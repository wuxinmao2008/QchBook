<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../page_styles.css"/>
</head>
<body>
    
<h4 class="sigil_not_in_toc">glBufferData</h4>
<p class="calibre1">创建和初始化一个缓冲区对象的数据存储。</p>
<h4 class="sigil_not_in_toc">C规范</h4>
<pre class="dai_ma_wu_xing_hao">
<code class="calibre12">void glBufferData(GLenum target,
　　　　　　GLsizeiptr size,
　　　　　　const GLvoid * data,
　　　　　　GLenum usage);</code>

</pre>
<h4 class="sigil_not_in_toc">参数</h4>
<p class="calibre1">target</p>
<p class="calibre1">指定目标缓冲区对象。符号常量必须是GL_ARRAY_BUFFER、GL_COPY_READ_BUFFER、GL_COPY_WRITE_BUFFER、GL_ELEMENT_ARRAY_BUFFER、GL_PIXEL_PACK_BUFFER、GL_PIXEL_UNPACK_BUFFER、GL_TEXTURE_BUFFER、GL_TRANSFORM_FEEDBACK_BUFFER或GL_UNIFORM_BUFFER。</p>
<p class="calibre1">size</p>
<p class="calibre1">指定缓冲区对象的新数据存储的大小，以byte为单位。</p>
<p class="calibre1">data</p>
<p class="calibre1">指定一个到将要被复制到数据存储以进行初始化的数据的指针，或者在没有数据要复制的情况下为NULL。</p>
<p class="calibre1">usage</p>
<p class="calibre1">指定数据存储的预期使用模式。符号常量必须是GL_STREAM_DRAW、GL_STREAM_READ、GL_STREAM_COPY、GL_STATIC_DRAW、GL_STATIC_READ、GL_STATIC_COPY、GL_DYNAMIC_DRAW、GL_DYNAMIC_READ或GL_DYNAMIC_COPY。</p>
<h4 class="sigil_not_in_toc">描述</h4>
<p class="calibre1">glBufferData 为当前绑定到target的缓冲区对象创建一个新的数据存储。以前存在的所有数据都会被删除。新的数据存储使用指定的byte形式的size（以字节为单位）和usage。如果data不为NULL，数据存储会使用来自这个指针的数据进行初始化。在它的初始状态下，新的数据存储没有被映射，它有一个NULL映射指针，而它的映射访问是GL_READ_WRITE。</p>
<p class="calibre1">usage 对GL实现来说是关于一个缓冲区对象的数据存储将如何被访问的一个提示。</p>
<p class="calibre1">它使得GL实现能够做出更智能的决定，这可能会对缓冲区对象性能产生极大的影响。不过，它不会限制数据存储的实际使用。usage能够分解成两个部分，首先是访问（包括修改和使用）频率，其次是访问的种类。访问频率可以是如下几种。</p>
<p class="calibre1">STREAM：数据存储内容将被改变一次，最多使用几次。</p>
<p class="calibre1">STATIC：数据存储内容将被改变一次，使用很多次。</p>
<p class="calibre1">DYNAMIC：数据存储内容将被改变多次，使用很多次。</p>
<p class="calibre1">访问种类可以是如下几种。</p>
<p class="calibre1">DRAW：数据存储内容由应用程序进行修改，并作为GL绘图和图像规范命令使用。</p>
<p class="calibre1">READ：数据存储内容由GL中的读取数据进行修改，并在被应用程序查询时用来返回这个数据。</p>
<p class="calibre1">COPY：数据存储内容由GL中的读取数据进行修改，并作为GL绘图和图像规范命令使用。</p>
<h4 class="sigil_not_in_toc">注意</h4>
<p class="calibre1">如果data为NULL，仍然会创建一个指定大小的数据存储，但是它的内容保留为未初始化和为定义的。</p>
<p class="calibre1">客户端程序必须按照客户端平台的要求（还有一个附加的基本要求，即在缓冲区中由NN组成的数据的偏移）排列数据元素。</p>
<h4 class="sigil_not_in_toc">错误</h4>
<p class="calibre1">如果tarGet不是一个可接受的缓冲区对象，则产生GL_INVALID_ENUM错误。</p>
<p class="calibre1">如果tarGet不是GL_STREAM_DRAW、GL_STREAM_READ、GL_STREAM_COPY、GL_STATIC_DRAW、GL_STATIC_READ、GL_STATIC_COPY、GL_DYNAMIC_DRAW、GL_DYNAMIC_READ或GL_DYNAMIC_COPY，则产生GL_INVALID_ENUM错误。</p>
<p class="calibre1">如果size为负值，则产生GL_INVALID_VALUE 错误。</p>
<p class="calibre1">如果保留的缓冲区对象名称0被绑定到 tarGet，则产生GL_INVALID_OPERATION错误。</p>
<p class="calibre1">如果GL不能用指定的size创建数据存储，则产生GL_OUT_OF_MEMORY错误。</p>
<h4 class="sigil_not_in_toc">相关Get函数</h4>
<p class="calibre1">glGetBufferSubData</p>
<p class="calibre1">glGetBufferParameter，其自变量为 GL_BUFFER_SIZE 或GL_BUFFER_USAGE。</p>
<h4 class="sigil_not_in_toc">另外查看</h4>
<p class="calibre1">glBindBuffer、glBufferSubData、glMapBuffer、glUnmapBuffer。</p>
</body>
</html>