<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../page_styles.css"/>
</head>
<body>
    
<h4 class="sigil_not_in_toc">glDrawElementsInstancedBaseVertex</h4>
<p class="calibre1">从数组数据渲染一组图元的多个实例，并进行逐元素偏置。</p>
<h4 class="sigil_not_in_toc">C规范</h4>
<pre class="dai_ma_wu_xing_hao">
<code class="calibre12">void glDrawElementsInstancedBaseVertex(GLenum mode,
　　　　　　GLsizei count,
　　　　　　GLenum type,
　　　　　　GLvoid * indices,
　　　　　　GLsizei primcount,
　　　　　　GLint basevertex);</code>

</pre>
<h4 class="sigil_not_in_toc">参数</h4>
<p class="calibre1">mode</p>
<p class="calibre1">指定将要渲染哪种类型的图元。符号常量GL_POINTS、GL_LINE_STRIP、GL_LINE_LOOP、GL_LINES、GL_TRIANGLE_STRIP、GL_TRIANGLE_FAN和GL_TRIANGLES都是可接受的。</p>
<p class="calibre1">count</p>
<p class="calibre1">指定将要被渲染的元素数量。</p>
<p class="calibre1">type</p>
<p class="calibre1">指定indices中的值的类型，必须是GL_UNSIGNED_BYTE、GL_UNSIGNED_SHORT和GL_UNSIGNED_INT中的一个。</p>
<p class="calibre1">indices</p>
<p class="calibre1">指定一个指向索引存储位置的指针。</p>
<p class="calibre1">primcount</p>
<p class="calibre1">指定应该进行绘制的索引几何图形的实例的数量。</p>
<p class="calibre1">basevertex</p>
<p class="calibre1">指定一个应该在从激活的顶点数组中选择元素时被添加到indices的每个元素的常量</p>
<h4 class="sigil_not_in_toc">描述</h4>
<p class="calibre1">glDrawElementsInstancedBaseVertex的行为与glDrawElementsInstanced相同，除了由相应绘制调用进行变换的第i个元素将会从每个激活的数组的indices[i] + basevertex元素中获取之外。如果结果得到的值大于type能够表示的最大值，那么计算就像上转换到32位无符号整数（在溢出条件下进行环绕）一样。如果得到的和为负，那么操作将为位定义的。</p>
<h4 class="sigil_not_in_toc">注意</h4>
<p class="calibre1">glDrawElementsInstancedBaseVertex只在3.2或更高版本的GL中能够支持。</p>
<h4 class="sigil_not_in_toc">错误</h4>
<p class="calibre1">如果mode不是一个可接受的值，则产生GL_INVALID_ENUM错误。</p>
<p class="calibre1">如果count或者primcount为负值，则产生GL_INVALID_VALUE 错误。</p>
<p class="calibre1">如果一个几何图形着色器被激活，并且mode与当前安装的程序对象中几何图形着色器的输入图元类型不兼容，那么将生成GL_INVALID_OPERATION错误。</p>
<p class="calibre1">如果非0缓冲区对象名称被绑定到一个激活的数组或这个元素数组，并且缓冲区对象的数据存储当前被映射，则产生GL_INVALID_OPERATION错误。</p>
<h4 class="sigil_not_in_toc">另外查看</h4>
<p class="calibre1">glDrawElements, glDrawRangeElements, glDrawRangeElementsBaseVertex, glDrawElementsInstanced, glDrawElementsInstancedBaseVertex</p>
<h4 class="sigil_not_in_toc">版权</h4>
<p class="calibre1">Copyright © 2010 Khronos Group。这些材料可以按照Open Publication License, v 1.0, 8 June 1999中规定的条款和条件进行发布。<a href="http://opencontent.org/openpub/">http://opencontent.org/openpub/</a>
 。</p>
</body>
</html>