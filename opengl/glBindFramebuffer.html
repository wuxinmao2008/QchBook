<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../page_styles.css"/>
</head>
<body>

<h4 class="sigil_not_in_toc">glBindFramebuffer</h4>
<p class="calibre1">将一个帧缓冲区绑定到一个帧缓冲区目标上。</p>
<h4 class="sigil_not_in_toc">C规范</h4>
<pre class="dai_ma_wu_xing_hao">
<code class="calibre12">void glBindFramebuffer(GLenum target,
　　　　　GLuint framebuffer);</code>

</pre>
<h4 class="sigil_not_in_toc">参数</h4>
<p class="calibre1">target</p>
<p class="calibre1">指定绑定操作的帧缓冲区目标。</p>
<p class="calibre1">framebuffer</p>
<p class="calibre1">指定将要进行绑定的帧缓冲区对象的名称。</p>
<h4 class="sigil_not_in_toc">描述</h4>
<p class="calibre1">glBindFramebuffer会将名称为framebuffer 的帧缓冲区对象绑定到target指定的帧缓冲区目标。target必须为GL_DRAW_FRAMEBUFFER、GL_READ_ FRAMEBUFFER或GL_FRAMEBUFFER。如果一个帧缓冲区被绑定到GL_DRAW_FRAMEBUFFER或GL_READ_FRAMEBUFFER上，那么在这两种情况下它将分别成为渲染或回读操作的目标，直到它被删除，或者其他帧缓冲区被绑定到相应的绑定点。调用target被设置为GL_FRAMEBUFFER的glBindFramebuffer，会将framebuffer绑定到读取缓冲区和绘制缓冲区。framebuffer是以前的一个glGenFramebuffers调用返回的帧缓冲区对象的名称，或者也可以设为0来解除已经存在的从一个帧缓冲区对象到target的绑定。</p>
<h4 class="sigil_not_in_toc">错误</h4>
<p class="calibre1">如果tarGet不是GL_DRAW_FRAMEBUFFER、GL_READ_FRAMEBUFFER或GL_FRAMEBUFFER，则产生GL_INVALID_ENUM错误。</p>
<p class="calibre1">如果framebuffer不是0或以前的一次调用所返回的帧缓冲区的名称，则产生GL_INVALID_OPERATION错误。</p>
<h4 class="sigil_not_in_toc">另外查看</h4>
<p class="calibre1">glGenFramebuffers、glDeleteFramebuffers、glFramebufferRenderbuffer、glFramebufferTexture、glFramebufferTexture1D、glFramebufferTexture2D、glFramebufferTexture3D、glFramebufferTextureFace、glFramebufferTextureLayer、glIsFramebuffer。</p>
</body>
</html>