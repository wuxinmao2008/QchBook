<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="内存管理" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/memory.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="概述: 在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有堆的管理由内部的 Python 内存管理器（Python memory manager） 保证。Python 内存管理器有不同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。 在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="概述: 在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有堆的管理由内部的 Python 内存管理器（Python memory manager） 保证。Python 内存管理器有不同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。 在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>内存管理</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/memory.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="memory-management">
<span id="memory"></span><h1>内存管理</h1>
<section id="overview">
<span id="memoryoverview"></span><h2>概述</h2>
<p>在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有堆的管理由内部的 <em>Python 内存管理器（Python memory manager）</em> 保证。Python 内存管理器有不同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。</p>
<p>在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空间来存储所有与 Python 相关的数据。在原始内存分配器的基础上，几个对象特定的分配器在同一堆上运行，并根据每种对象类型的特点实现不同的内存管理策略。例如，整数对象在堆内的管理方式不同于字符串、元组或字典，因为整数需要不同的存储需求和速度与空间的权衡。因此，Python 内存管理器将一些工作分配给对象特定分配器，但确保后者在私有堆的范围内运行。</p>
<p>Python 堆内存的管理是由解释器来执行，用户对它没有控制权，即使他们经常操作指向堆内内存块的对象指针，理解这一点十分重要。Python 对象和其他内部缓冲区的堆空间分配是由 Python 内存管理器按需通过本文档中列出的 Python/C API 函数进行的。</p>
<p id="index-0">为了避免内存破坏，扩展的作者永远不应该试图用 C 库函数导出的函数来对 Python 对象进行操作，这些函数包括： <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>。这将导致 C 分配器和 Python 内存管理器之间的混用，引发严重后果，这是由于它们实现了不同的算法，并在不同的堆上操作。但是，我们可以安全地使用 C 库分配器为单独的目的分配和释放内存块，如下例所示：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"> </span><span class="cm">/* for I/O */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="p">...</span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">involving</span><span class="w"> </span><span class="n">buf</span><span class="p">...</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/* malloc&#39;ed */</span>
<span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>在这个例子中，I/O 缓冲区的内存请求是由 C 库分配器处理的。Python 内存管理器只参与了分配作为结果返回的字节对象。</p>
<p>然而，在大多数情况下，都建议专门基于 Python 堆来分配内存，因为后者是由 Python 内存管理器控制的。 例如，当解释器使用 C 编写的新对象类型进行扩展时就必须这样做。 使用 Python 堆的另一个理由是需要能 <em>通知</em> Python 内存管理器有关扩展模块的内存需求。 即使所请求的内存全部只用于内部的、高度特定的目的，将所有的内存请求交给 Python 内存管理器能让解释器对其内存占用的整体情况有更准确的了解。 因此，在特定情况下，Python 内存管理器可能会触发或不触发适当的操作，如垃圾回收、内存压缩或其他的预防性操作。 请注意通过使用前面例子所演示的 C 库分配器，为 I/O 缓冲区分配的内存将完全不受 Python 内存管理器的控制。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>环境变量 <span class="target" id="index-11"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> 可被用来配置 Python 所使用的内存分配器。</p>
<p>环境变量 <span class="target" id="index-12"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONMALLOCSTATS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOCSTATS</span></code></a> 可以用来在每次创建和关闭新的 pymalloc 对象区域时打印 <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc  内存分配器</span></a> 的统计数据。</p>
</div>
</section>
<section id="allocator-domains">
<h2>分配器域</h2>
<p id="id1">所有分配函数都属于三个不同的“分配器域”之一（见 <a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocatorDomain</span></code></a>）。这些域代表了不同的分配策略，并为不同目的进行了优化。每个域如何分配内存和每个域调用哪些内部函数的具体细节被认为是实现细节，但是出于调试目的，可以在 <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">此处</span></a> 找到一张简化的表格。没有硬性要求将属于给定域的分配函数返回的内存，仅用于该域提示的目的（虽然这是推荐的做法）。例如，你可以将 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 返回的内存用于分配 Python 对象，或者将 <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> 返回的内存用作缓冲区。</p>
<p>三个分配域分别是：</p>
<ul class="simple">
<li><p>原始域：用于为通用内存缓冲区分配内存，分配*必须*转到系统分配器并且分配器可以在没有 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a> 的情况下运行。内存直接请求自系统。</p></li>
<li><p>&quot;Mem&quot; 域：用于为 Python 缓冲区和通用内存缓冲区分配内存，分配时必须持有 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。内存取自于 Python 私有堆。</p></li>
<li><p>对象域：用于分配属于 Python 对象的内存。内存取自于 Python 私有堆。</p></li>
</ul>
<p>当释放属于给定域的分配函数先前分配的内存时，必须使用对应的释放函数。例如，<a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> 来释放 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 分配的内存。</p>
</section>
<section id="raw-memory-interface">
<h2>原始内存接口</h2>
<p>以下函数集封装了系统分配器。这些函数是线程安全的，不需要持有 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">全局解释器锁</span></a>。</p>
<p><a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">默认原始内存分配器</span></a> 使用以下函数: <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>；当请求零个字节时则调用 <code class="docutils literal notranslate"><span class="pre">malloc(1)</span></code> (或 <code class="docutils literal notranslate"><span class="pre">calloc(1,</span> <span class="pre">1)</span></code>)。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawMalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawMalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>分配 <em>n</em> 个字节并返回一个指向所分配内存的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型指针，如果请求失败则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了 <code class="docutils literal notranslate"><span class="pre">PyMem_RawMalloc(1)</span></code> 一样。但是内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawCalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawCalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nelem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">elsize</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>分配 <em>nelem</em> 个元素，每个元素的大小为 <em>elsize</em> 个字节，并返回指向所分配的内存的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型指针，如果请求失败则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 内存会被初始化为零。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了 <code class="docutils literal notranslate"><span class="pre">PyMem_RawCalloc(1,</span> <span class="pre">1)</span></code> 一样。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawRealloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawRealloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 <em>p</em> 指向的内存块大小调整为 <em>n</em> 字节。以新旧内存块大小中的最小值为准，其中内容保持不变，</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，则相当于调用 <code class="docutils literal notranslate"><span class="pre">PyMem_RawMalloc(n)</span></code> ；如果 <em>n</em> 等于 0，则内存块大小会被调整，但不会被释放，返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a> 所返回的。</p>
<p>如果请求失败，<a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <em>p</em> 仍然是指向先前内存区域的有效指针。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawFree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawFree</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>释放 <em>p</em> 指向的内存块。 <em>p</em> 必须是之前调用 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a> 所返回的指针。否则，或在 <code class="docutils literal notranslate"><span class="pre">PyMem_RawFree(p)</span></code> 之前已经调用过的情况下，未定义的行为会发生。</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 那么什么操作也不会进行。</p>
</dd></dl>

</section>
<section id="memory-interface">
<span id="memoryinterface"></span><h2>内存接口</h2>
<p>以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内存。</p>
<p><a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">默认内存分配器</span></a> 使用了 <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc 内存分配器</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在使用这些函数时，必须持有 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">全局解释器锁（GIL）</span></a> 。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>现在默认的分配器是 pymalloc 而非系统的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 。</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Malloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Malloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>分配 <em>n</em> 个字节并返回一个指向所分配内存的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型指针，如果请求失败则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了 <code class="docutils literal notranslate"><span class="pre">PyMem_Malloc(1)</span></code> 一样。但是内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Calloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Calloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nelem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">elsize</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>分配 <em>nelem</em> 个元素，每个元素的大小为 <em>elsize</em> 个字节，并返回指向所分配的内存的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型指针，如果请求失败则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 内存会被初始化为零。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了 <code class="docutils literal notranslate"><span class="pre">PyMem_Calloc(1,</span> <span class="pre">1)</span></code> 一样。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Realloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Realloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>将 <em>p</em> 指向的内存块大小调整为 <em>n</em> 字节。以新旧内存块大小中的最小值为准，其中内容保持不变，</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，则相当于调用 <code class="docutils literal notranslate"><span class="pre">PyMem_Malloc(n)</span></code> ；如果 <em>n</em> 等于 0，则内存块大小会被调整，但不会被释放，返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a> 所返回的。</p>
<p>如果请求失败，<a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <em>p</em> 仍然是指向先前内存区域的有效指针。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>释放 <em>p</em> 指向的内存块。 <em>p</em> 必须是之前调用 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a> 所返回的指针。否则，或在 <code class="docutils literal notranslate"><span class="pre">PyMem_Free(p)</span></code> 之前已经调用过的情况下，未定义的行为会发生。</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 那么什么操作也不会进行。</p>
</dd></dl>

<p>以下面向类型的宏为方便而提供。 注意 <em>TYPE</em> 可以指任何 C 类型。</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PyMem_New">
<span class="sig-name descname"><span class="n"><span class="pre">PyMem_New</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TYPE</span></span>, <span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>与 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 相同，但会分配 <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> 字节的内存。 返回一个转换为 <code class="docutils literal notranslate"><span class="pre">TYPE*</span></code> 的指针。 内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyMem_Resize">
<span class="sig-name descname"><span class="n"><span class="pre">PyMem_Resize</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">TYPE</span></span>, <span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>与 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 类似，但内存块的大小被调整为 <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> 个字节。 返回一个转换为 <code class="docutils literal notranslate"><span class="pre">TYPE*</span></code> 的指针。 在返回时，<em>p</em> 将是一个指向新内存区域的指针，或者如果执行失败则为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>这是一个 C 预处理宏， <em>p</em> 总是被重新赋值。请保存 <em>p</em> 的原始值，以避免在处理错误时丢失内存。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Del</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>与 <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> 相同</p>
</dd></dl>

<p>此外，我们还提供了以下宏集用于直接调用 Python 内存分配器，而不涉及上面列出的 C API 函数。但是请注意，使用它们并不能保证跨 Python 版本的二进制兼容性，因此在扩展模块被弃用。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_MALLOC(size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_NEW(type,</span> <span class="pre">size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_REALLOC(ptr,</span> <span class="pre">size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_RESIZE(ptr,</span> <span class="pre">type,</span> <span class="pre">size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_FREE(ptr)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_DEL(ptr)</span></code></p></li>
</ul>
</section>
<section id="object-allocators">
<h2>对象分配器</h2>
<p>以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内存。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当通过 <a class="reference internal" href="#customize-memory-allocators"><span class="std std-ref">自定义内存分配器</span></a> 部分描述的方法拦截该域中的分配函数时，无法保证这些分配器返回的内存可以被成功地转换成 Python 对象。</p>
</div>
<p><a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">默认对象分配器</span></a> 使用 <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc 内存分配器</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在使用这些函数时，必须持有 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">全局解释器锁（GIL）</span></a> 。</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Malloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Malloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>分配 <em>n</em> 个字节并返回一个指向所分配内存的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型指针，如果请求失败则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了 <code class="docutils literal notranslate"><span class="pre">PyObject_Malloc(1)</span></code> 一样。但是内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Calloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Calloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nelem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">elsize</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>分配 <em>nelem</em> 个元素，每个元素的大小为 <em>elsize</em> 个字节，并返回指向所分配的内存的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型指针，如果请求失败则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 内存会被初始化为零。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了 <code class="docutils literal notranslate"><span class="pre">PyObject_Calloc(1,</span> <span class="pre">1)</span></code> 一样。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Realloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Realloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>将 <em>p</em> 指向的内存块大小调整为 <em>n</em> 字节。以新旧内存块大小中的最小值为准，其中内容保持不变，</p>
<p>如果*p*是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则相当于调用 <code class="docutils literal notranslate"><span class="pre">PyObject_Malloc(n)</span></code> ；如果 <em>n</em> 等于 0，则内存块大小会被调整，但不会被释放，返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a> 所返回的。</p>
<p>如果请求失败，<a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <em>p</em> 仍然是指向先前内存区域的有效指针。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>释放 <em>p</em> 指向的内存块。 <em>p</em> 必须是之前调用 <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a> 所返回的指针。否则，或在 <code class="docutils literal notranslate"><span class="pre">PyObject_Free(p)</span></code> 之前已经调用过的情况下，未定义行为会发生。</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 那么什么操作也不会进行。</p>
</dd></dl>

</section>
<section id="default-memory-allocators">
<span id="id2"></span><h2>默认内存分配器</h2>
<p>默认内存分配器：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>配置</p></th>
<th class="head"><p>名称</p></th>
<th class="head"><p>PyMem_RawMalloc</p></th>
<th class="head"><p>PyMem_Malloc</p></th>
<th class="head"><p>PyObject_Malloc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>发布版本</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;pymalloc&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>调试构建</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;pymalloc_debug&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code> + debug</p></td>
</tr>
<tr class="row-even"><td><p>没有 pymalloc 的发布版本</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;malloc&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>没有 pymalloc 的调试构建</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;malloc_debug&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
</tr>
</tbody>
</table>
<p>说明：</p>
<ul class="simple">
<li><p>名称：<span class="target" id="index-13"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> 环境变量的值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code>：来自 C 标准库的系统分配器，C 函数：<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>、<code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>、<code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code>：<a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc 内存分配器</span></a>.</p></li>
<li><p>&quot;+ debug&quot;: 附带 <a class="reference internal" href="#pymem-debug-hooks"><span class="std std-ref">Python 内存分配器的调试钩子</span></a>.</p></li>
<li><p>“调试构建”：<a class="reference internal" href="../using/configure.xhtml#debug-build"><span class="std std-ref">调试模式下的 Python 构建</span></a>。</p></li>
</ul>
</section>
<section id="customize-memory-allocators">
<span id="id3"></span><h2>自定义内存分配器</h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyMemAllocatorEx">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMemAllocatorEx</span></span></span><br /></dt>
<dd><p>用于描述内存块分配器的结构体。 该结构体下列字段:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>域</p></th>
<th class="head"><p>含意</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ctx</span></code></p></td>
<td><p>作为第一个参数传入的用户上下文</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">malloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p>分配一个内存块</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">calloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">nelem,</span> <span class="pre">size_t</span> <span class="pre">elsize)</span></code></p></td>
<td><p>分配一个初始化为 0 的内存块</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">realloc(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">new_size)</span></code></p></td>
<td><p>分配一个内存块或调整其大小</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></p></td>
<td><p>释放一个内存块</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocator</span></code> 结构被重命名为 <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocatorEx</span></code></a> 并新增了一个 <code class="docutils literal notranslate"><span class="pre">calloc</span></code> 字段。</p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.PyMemAllocatorDomain">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMemAllocatorDomain</span></span></span><br /></dt>
<dd><p>用来识别分配器域的枚举类。域有：</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PYMEM_DOMAIN_RAW">
<span class="sig-name descname"><span class="n"><span class="pre">PYMEM_DOMAIN_RAW</span></span></span><br /></dt>
<dd><p>函数</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PYMEM_DOMAIN_MEM">
<span class="sig-name descname"><span class="n"><span class="pre">PYMEM_DOMAIN_MEM</span></span></span><br /></dt>
<dd><p>函数</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>,</p></li>
<li><p><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a></p></li>
</ul>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PYMEM_DOMAIN_OBJ">
<span class="sig-name descname"><span class="n"><span class="pre">PYMEM_DOMAIN_OBJ</span></span></span><br /></dt>
<dd><p>函数</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a></p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_GetAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_GetAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><span class="n"><span class="pre">PyMemAllocatorDomain</span></span></a><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><span class="n"><span class="pre">PyMemAllocatorEx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>获取指定域的内存块分配器。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_SetAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_SetAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><span class="n"><span class="pre">PyMemAllocatorDomain</span></span></a><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><span class="n"><span class="pre">PyMemAllocatorEx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>设置指定域的内存块分配器。</p>
<p>当请求零字节时，新的分配器必须返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>对于 <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_RAW</span></code></a> 域，分配器必须是线程安全的：当分配器被调用时将不持有 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a>。</p>
<p>对于其余的域，分配器也必须是线程安全的：分配器可以在不共享 <code class="docutils literal notranslate"><span class="pre">GIL</span></code> 的不同解释器中被调用。</p>
<p>如果新的分配器不是钩子（不调用之前的分配器），必须调用 <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> 函数在新分配器上重新安装调试钩子。</p>
<p>另请参阅 <a class="reference internal" href="init_config.xhtml#c.PyPreConfig.allocator" title="PyPreConfig.allocator"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyPreConfig.allocator</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c-preinit"><span class="std std-ref">Preinitialize Python with PyPreConfig</span></a>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a> 没有以下合约:</p>
<ul class="simple">
<li><p>可以在 <a class="reference internal" href="init_config.xhtml#c.Py_PreInitialize" title="Py_PreInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_PreInitialize()</span></code></a> 之后 <a class="reference internal" href="init_config.xhtml#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> 之前调用它来安装自定义的内存分配器。 对于所安装的分配器除了域的规定以外没有任何其他限制（例如 Raw Domain 允许分配器在不持有 GIL 的情况下被调用）。 请参阅 <a class="reference internal" href="#id1"><span class="std std-ref">有关分配器域的章节</span></a> 来了解详情。</p></li>
<li><p>如果在 Python 已完成初始化之后（即 <a class="reference internal" href="init_config.xhtml#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> 被调用之后）被调用则自定义分配器 <strong>must</strong> 必须包装现有的分配器。 将现有分配器替换为任意的其他分配器是 <strong>不受支持的</strong>。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>所有分配器都必须是线程安全的。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_SetupDebugHooks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_SetupDebugHooks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>设置 <a class="reference internal" href="#pymem-debug-hooks"><span class="std std-ref">Python 内存分配器的调试钩子</span></a> 以检测内存错误。</p>
</dd></dl>

</section>
<section id="debug-hooks-on-the-python-memory-allocators">
<span id="pymem-debug-hooks"></span><h2>Python 内存分配器的调试钩子</h2>
<p>当 <a class="reference internal" href="../using/configure.xhtml#debug-build"><span class="std std-ref">Python 在调试模式下构建</span></a>，<a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> 函数在 <a class="reference internal" href="init_config.xhtml#c-preinit"><span class="std std-ref">Python 预初始化</span></a> 时被调用，以在 Python 内存分配器上设置调试钩子以检测内存错误。</p>
<p><span class="target" id="index-14"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> 环境变量可被用于在以发行模式下编译的 Python 上安装调试钩子（例如：<code class="docutils literal notranslate"><span class="pre">PYTHONMALLOC=debug</span></code>）。</p>
<p><a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> 函数可被用于在调用了 <a class="reference internal" href="#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a> 之后设置调试钩子。</p>
<p>这些调试钩子用特殊的、可辨认的位模式填充动态分配的内存块。新分配的内存用字节 <code class="docutils literal notranslate"><span class="pre">0xCD</span></code> （<code class="docutils literal notranslate"><span class="pre">PYMEM_CLEANBYTE</span></code> ）填充，释放的内存用字节 <code class="docutils literal notranslate"><span class="pre">0xDD</span></code> （<code class="docutils literal notranslate"><span class="pre">PYMEM_DEADBYTE</span></code> ）填充。内存块被填充了字节 <code class="docutils literal notranslate"><span class="pre">0xFD</span></code> （<code class="docutils literal notranslate"><span class="pre">PYMEM_FORBIDDENBYTE</span></code> ）的“禁止字节”包围。这些字节串不太可能是合法的地址、浮点数或ASCII字符串</p>
<p>运行时检查：</p>
<ul class="simple">
<li><p>检测对 API 的违反。例如：检测对 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 分配的内存块调用 <a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>。</p></li>
<li><p>检测缓冲区起始位置前的写入（缓冲区下溢）。</p></li>
<li><p>检测缓冲区终止位置后的写入（缓冲区溢出）。</p></li>
<li><p>检测当调用 <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (如: <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>) 和 <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (如: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>) 域的分配器函数时是否持有 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a>。</p></li>
</ul>
<p>在出错时，调试钩子使用 <a class="reference internal" href="../library/tracemalloc.xhtml#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> 模块来回溯内存块被分配的位置。只有当 <a class="reference internal" href="../library/tracemalloc.xhtml#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> 正在追踪 Python 内存分配，并且内存块被追踪时，才会显示回溯。</p>
<p>让 <em>S</em> = <code class="docutils literal notranslate"><span class="pre">sizeof(size_t)</span></code>。 将 <code class="docutils literal notranslate"><span class="pre">2*S</span></code> 个字节添加到每个被请求的 <em>N</em> 字节数据块的两端。 内存的布局像是这样，其中 p 代表由类似 malloc 或类似 realloc 的函数所返回的地址 (<code class="docutils literal notranslate"><span class="pre">p[i:j]</span></code> 表示从 <code class="docutils literal notranslate"><span class="pre">*(p+i)</span></code> 左侧开始到 <code class="docutils literal notranslate"><span class="pre">*(p+j)</span></code> 左侧止的字节数据切片；请注意对负索引号的处理与 Python 切片是不同的）:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">p[-2*S:-S]</span></code></dt><dd><p>最初所要求的字节数。 这是一个 size_t，为大端序（易于在内存转储中读取）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p[-S]</span></code></dt><dd><p>API 标识符（ASCII 字符）:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code> 表示 <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_RAW</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'m'</span></code> 表示 <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'o'</span></code> 表示 <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a>。</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p[-S+1:0]</span></code></dt><dd><p>PYMEM_FORBIDDENBYTE 的副本。 用于捕获下层的写入和读取。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p[0:N]</span></code></dt><dd><p>所请求的内存，用 PYMEM_CLEANBYTE 的副本填充，用于捕获对未初始化内存的引用。 当调用 realloc 之类的函数来请求更大的内存块时，额外新增的字节也会用 PYMEM_CLEANBYTE 来填充。 当调用 free 之类的函数时，这些字节会用 PYMEM_DEADBYTE 来重写，以捕获对已释放内存的引用。 当调用 realloc 之类的函数来请求更小的内存块时，多余的旧字节也会用 PYMEM_DEADBYTE 来填充。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p[N:N+S]</span></code></dt><dd><p>PYMEM_FORBIDDENBYTE 的副本。 用于捕获超限的写入和读取。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p[N+S:N+2*S]</span></code></dt><dd><p>仅当定义了 <code class="docutils literal notranslate"><span class="pre">PYMEM_DEBUG_SERIALNO</span></code> 宏时会被使用（默认情况下将不定义）。</p>
<p>一个序列号，每次调用 malloc 或 realloc 之类的函数时都会递增 1。 大端序的 <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code>。 如果之后检测到了“被破坏的内存”，此序列号提供了一个很好的手段用来在下次运行时设置中断点，以捕获该内存块被破坏的瞬间。 obmalloc.c 中的静态函数 bumpserialno() 是唯一会递增序列号的函数，它的存在让你可以轻松地设置这样的中断点。</p>
</dd>
</dl>
<p>一个 realloc 之类或 free 之类的函数会先检查两端的 PYMEM_FORBIDDENBYTE 字节是否完好。 如果它们被改变了，则会将诊断输出写入到 stderr，并且程序将通过 Py_FatalError() 中止。 另一种主要的失败模式是当程序读到某种特殊的比特模式并试图将其用作地址时触发内存错误。 如果你随即进入调试器并查看该对象，你很可能会看到它已完全被填充为 PYMEM_DEADBYTE (意味着已释放的内存被使用) 或 PYMEM_CLEANBYTE (意味着未初始货摊内存被使用)。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span><a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> 函数现在也能在使用发布模式编译的 Python 上工作。 当发生错误时，调试钩子现在会使用 <a class="reference internal" href="../library/tracemalloc.xhtml#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> 来获取已分配内存块的回溯信息。 调试钩子现在还会在 <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> 和 <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> 作用域的函数被调用时检查是否持有 GIL。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>字节模式 <code class="docutils literal notranslate"><span class="pre">0xCB</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_CLEANBYTE</span></code>)、 <code class="docutils literal notranslate"><span class="pre">0xDB</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_DEADBYTE</span></code>) 和 <code class="docutils literal notranslate"><span class="pre">0xFB</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_FORBIDDENBYTE</span></code>) 已被 <code class="docutils literal notranslate"><span class="pre">0xCD</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0xDD</span></code> 和 <code class="docutils literal notranslate"><span class="pre">0xFD</span></code> 替代以使用与 Windows CRT 调试 <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">free()</span></code> 相同的值。</p>
</div>
</section>
<section id="the-pymalloc-allocator">
<span id="pymalloc"></span><h2>pymalloc 分配器</h2>
<p>Python 有一个针对短生命周期的小对象（小于或等于 512 字节）进行了优化的 <em>pymalloc</em> 分配器。 它使用名为“arena”的内存映射，在 32 位平台上的固定大小为 256 KiB，在 64 位平台上的固定大小为 1 MiB。 对于大于 512 字节的分配，它会回退为 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 和 <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a>。</p>
<p><em>pymalloc</em> 是 <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (例如: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>) 和 <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (例如: <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>) 域的 <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">默认分配器</span></a>。</p>
<p>arena 分配器使用以下函数：</p>
<ul class="simple">
<li><p>Windows 上的 <code class="xref c c-func docutils literal notranslate"><span class="pre">VirtualAlloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">VirtualFree()</span></code>，</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">munmap()</span></code>，如果可用的话，</p></li>
<li><p>否则， <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 。</p></li>
</ul>
<p>如果 Python 配置了 <a class="reference internal" href="../using/configure.xhtml#cmdoption-without-pymalloc"><code class="xref std std-option docutils literal notranslate"><span class="pre">--without-pymalloc</span></code></a> 选项，那么此分配器将被禁用。也可以在运行时使用 <span class="target" id="index-15"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC`（例如：``PYTHONMALLOC=malloc`</span></code>）环境变量来禁用它。</p>
<section id="customize-pymalloc-arena-allocator">
<h3>自定义 pymalloc Arena 分配器</h3>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyObjectArenaAllocator">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObjectArenaAllocator</span></span></span><br /></dt>
<dd><p>用来描述一个 arena 分配器的结构体。这个结构体有三个字段：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>域</p></th>
<th class="head"><p>含意</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ctx</span></code></p></td>
<td><p>作为第一个参数传入的用户上下文</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">alloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p>分配一块 size 字节的区域</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p>释放一块区域</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_GetArenaAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_GetArenaAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator"><span class="n"><span class="pre">PyObjectArenaAllocator</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>获取 arena 分配器</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_SetArenaAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_SetArenaAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator"><span class="n"><span class="pre">PyObjectArenaAllocator</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>设置 arena 分配器</p>
</dd></dl>

</section>
</section>
<section id="tracemalloc-c-api">
<h2>tracemalloc C API</h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyTraceMalloc_Track">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTraceMalloc_Track</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>在 <a class="reference internal" href="../library/tracemalloc.xhtml#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> 模块中跟踪一个已分配的内存块。</p>
<p>成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，出错时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> (无法分配内存来保存跟踪信息)。 如果禁用了 tracemalloc 则返回 <code class="docutils literal notranslate"><span class="pre">-2</span></code>。</p>
<p>如果内存块已被跟踪，则更新现有跟踪信息。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyTraceMalloc_Untrack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTraceMalloc_Untrack</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>在 <a class="reference internal" href="../library/tracemalloc.xhtml#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> 模块中取消跟踪一个已分配的内存块。 如果内存块未被跟踪则不执行任何操作。</p>
<p>如果 tracemalloc 被禁用则返回 <code class="docutils literal notranslate"><span class="pre">-2</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

</section>
<section id="examples">
<span id="memoryexamples"></span><h2>例子</h2>
<p>以下是来自 <a class="reference internal" href="#memoryoverview"><span class="std std-ref">概述</span></a> 小节的示例，经过重写以使 I/O 缓冲区是通过使用第一个函数集从 Python 堆中分配的:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"> </span><span class="cm">/* for I/O */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/* allocated with PyMem_Malloc */</span>
<span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>使用面向类型函数集的相同代码:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"> </span><span class="cm">/* for I/O */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/* allocated with PyMem_New */</span>
<span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>请注意在以上两个示例中，缓冲区总是通过归属于相同集的函数来操纵的。 事实上，对于一个给定的内存块必须使用相同的内存 API 族，以便使得混合不同分配器的风险减至最低。 以下代码序列包含两处错误，其中一个被标记为 <em>fatal</em> 因为它混合了两种在不同堆上操作的不同分配器。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span><span class="w">  </span><span class="cm">/* Wrong -- should be PyMem_Free() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span><span class="w">       </span><span class="cm">/* Right -- allocated via malloc() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span><span class="w">       </span><span class="cm">/* Fatal -- should be PyMem_Del()  */</span>
</pre></div>
</div>
<p>除了用于处理来自 Python 堆的原始内存块的函数，Python 中的对象还通过 <a class="reference internal" href="allocation.xhtml#c.PyObject_New" title="PyObject_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_New</span></code></a>、<a class="reference internal" href="allocation.xhtml#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_NewVar</span></code></a> 和 <a class="reference internal" href="allocation.xhtml#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a> 进行分配和释放。</p>
<p>这些将在有关如何在 C 中定义和实现新对象类型的下一章中讲解。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>