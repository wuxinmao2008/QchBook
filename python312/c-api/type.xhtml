<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="类型对象" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/type.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="创建堆分配类型: 下列函数和结构体可被用来创建 堆类型 。" />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="创建堆分配类型: 下列函数和结构体可被用来创建 堆类型 。" />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>类型对象</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/type.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="type-objects">
<span id="typeobjects"></span><h1>类型对象</h1>
<dl class="c type" id="index-0">
<dt class="sig sig-object c" id="c.PyTypeObject">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTypeObject</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">受限 API</span></a> （作为不透明的结构体）.</em><p>对象的 C 结构用于描述 built-in 类型。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyType_Type">
<a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Type</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这是属于 type 对象的 type object，它在 Python 层面和 <a class="reference internal" href="../library/functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 是相同的对象。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_Check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Check</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">o</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果对象 <em>o</em> 是一个类型对象，包括派生自标准类型对象的类型实例则返回非零值。 在所有其它情况下都返回 0。 此函数将总是成功执行。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_CheckExact">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_CheckExact</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">o</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果对象 <em>o</em> 是一个类型对象，但不是标准类型对象的子类型则返回非零值。 在所有其它情况下都返回 0。 此函数将总是成功执行。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_ClearCache">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_ClearCache</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>清空内部查找缓存。 返回当前版本标签。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetFlags">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetFlags</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回 <em>type</em> 的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 成员。 此函数主要是配合 <code class="docutils literal notranslate"><span class="pre">Py_LIMITED_API</span></code> 使用；单独的旗标位会确保在各个 Python 发布版之间保持稳定，但对 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 本身的访问并不是 <a class="reference internal" href="stable.xhtml#limited-c-api"><span class="std std-ref">受限 API</span></a> 的一部分。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>返回类型现在是 <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">long</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetDict">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetDict</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>返回类型对象的内部命名空间，它在其他情况下只能通过只读代理 (<code class="docutils literal notranslate"><span class="pre">cls.__dict__</span></code>) 公开。 这可以代替直接访问 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> 的方式。 返回的字典必须当作是只读的。</p>
<p>该函数用于特定的嵌入和语言绑定场景，在这些场景下需要直接访问该字典而间接访问（例如通过代理或 <a class="reference internal" href="object.xhtml#c.PyObject_GetAttr" title="PyObject_GetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetAttr()</span></code></a> 访问）并不足够。</p>
<p>扩展模块在设置它们自己的类型时应当继续直接或间接地使用 <code class="docutils literal notranslate"><span class="pre">tp_dict</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_Modified">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Modified</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>使该类型及其所有子类型的内部查找缓存失效。 此函数必须在对该类型的属性或基类进行任何手动修改之后调用。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_AddWatcher">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_AddWatcher</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyType_WatchCallback" title="PyType_WatchCallback"><span class="n"><span class="pre">PyType_WatchCallback</span></span></a><span class="w"> </span><span class="n"><span class="pre">callback</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>注册 <em>callback</em> 作为类型监视器。 返回一个非负的整数 ID，它必须传给将来对 <a class="reference internal" href="#c.PyType_Watch" title="PyType_Watch"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Watch()</span></code></a> 的调用。 如果出错（例如没有足够的可用监视器 ID）,则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置一个异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_ClearWatcher">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_ClearWatcher</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">watcher_id</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>清除由 <em>watcher_id</em> (之前从 <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_AddWatcher()</span></code></a> 返回) 所标识的 watcher。 成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，出错时（例如 <em>watcher_id</em> 未被注册）返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p>扩展在调用 <code class="docutils literal notranslate"><span class="pre">PyType_ClearWatcher</span></code> 时绝不能使用不是之前调用 <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_AddWatcher()</span></code></a> 所返回的 <em>watcher_id</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_Watch">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Watch</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">watcher_id</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 <em>type</em> 标记为已监视。 每当 <a class="reference internal" href="#c.PyType_Modified" title="PyType_Modified"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Modified()</span></code></a> 报告 <em>type</em> 发生变化时 <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_AddWatcher()</span></code></a> 赋予 <em>watcher_id</em> 的回调将被调用。 （如果在 <em>type</em> 的一系列连续修改之间没有调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">_PyType_Lookup()</span></code>，则回调只能被调用一次；这是一个实现细节并可能发生变化）。</p>
<p>扩展在调用 <code class="docutils literal notranslate"><span class="pre">PyType_Watch</span></code> 时绝不能使用不是之前调用 <a class="reference internal" href="#c.PyType_AddWatcher" title="PyType_AddWatcher"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_AddWatcher()</span></code></a> 所返回的 <em>watcher_id</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.PyType_WatchCallback">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_WatchCallback</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><p>类型监视器回调函数的类型。</p>
<p>回调不可以修改 <em>type</em> 或是导致 <a class="reference internal" href="#c.PyType_Modified" title="PyType_Modified"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Modified()</span></code></a> 在 <em>type</em> 或其 MRO 中的任何类型上被调用；违反此规则可能导致无限递归。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_HasFeature">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_HasFeature</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">o</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">feature</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果类型对象 <em>o</em> 设置了特性 <em>feature</em> 则返回非零值。 类型特性是用单个比特位旗标来表示的。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_IS_GC">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_IS_GC</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">o</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果类型对象包括了对循环检测器的支持则返回真值；这将测试类型旗标 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_IsSubtype">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_IsSubtype</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>如果 <em>a</em> 是 <em>b</em> 的子类型则返回真值。</p>
<p>此函数只检查实际的子类型，这意味着 <a class="reference internal" href="../reference/datamodel.xhtml#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a> 不会在 <em>b</em> 上被调用。 请调用 <a class="reference internal" href="object.xhtml#c.PyObject_IsSubclass" title="PyObject_IsSubclass"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_IsSubclass()</span></code></a> 来执行与 <a class="reference internal" href="../library/functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 所做的相同检查。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GenericAlloc">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GenericAlloc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span>, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">nitems</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>类型对象的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_alloc</span></code></a> 槽位的通用处理器。 请使用 Python 的默认内存分配机制来分配一个新的实例并将其所有内容初始化为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GenericNew">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GenericNew</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kwds</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>类型对象的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 槽位的通用处理器。 请使用类型的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_alloc</span></code></a> 槽位来创建一个新的实例。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_Ready">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Ready</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>最终化一个类型对象。 这应当在所有类型对象上调用以完成它们的初始化。 此函数会负责从一个类型的基类添加被继承的槽位。 成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，或是在出错时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置一个异常。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果某些基类实现了 GC 协议并且所提供的类型的旗标中未包括 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>，则将自动从其父类实现 GC 协议。 相反地，如果被创建的类型的旗标中确实包含 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 则它 <strong>必须</strong> 自己实现 GC 协议，至少要实现 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 句柄。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetName">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.11 版起.</em><p>返回类型名称。 等同于获取类型的 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 属性。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetQualName">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetQualName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.11 版起.</em><p>返回类型的限定名称。 等同于获取类型的 <code class="docutils literal notranslate"><span class="pre">__qualname__</span></code> 属性。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetSlot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetSlot</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.4 版起.</em><p>返回存储在给定槽位中的函数指针。 如果结果为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则表示或者该槽位为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，或者该函数调用传入了无效的形参。 调用方通常要将结果指针转换到适当的函数类型。</p>
<p>请参阅 <a class="reference internal" href="#c.PyType_Slot.slot" title="PyType_Slot.slot"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyType_Slot.slot</span></code></a> 查看可用的 <em>slot</em> 参数值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><a class="reference internal" href="#c.PyType_GetSlot" title="PyType_GetSlot"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetSlot()</span></code></a> 现在可以接受所有类型。 在此之前，它被限制为 <a class="reference internal" href="typeobj.xhtml#heap-types"><span class="std std-ref">堆类型</span></a>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetModule">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetModule</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p>返回当使用 <a class="reference internal" href="#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a> 创建类型时关联到给定类型的模块对象。</p>
<p>如果没有关联到给定类型的模块，则设置 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a> 并返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>此函数通常被用于获取方法定义所在的模块。 请注意在这样的方法中，<code class="docutils literal notranslate"><span class="pre">PyType_GetModule(Py_TYPE(self))</span></code> 可能不会返回预期的结果。 <code class="docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code> 可以是目标类的一个 <em>子类</em>，而子类并不一定是在与其超类相同的模块中定义的。 请参阅 <a class="reference internal" href="structures.xhtml#c.PyCMethod" title="PyCMethod"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code></a> 了解如何获取方法定义所在的类。 请参阅 <a class="reference internal" href="#c.PyType_GetModuleByDef" title="PyType_GetModuleByDef"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleByDef()</span></code></a> 了解有关无法使用 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code> 的情况。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetModuleState">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetModuleState</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p>返回关联到给定类型的模块对象的状态。 这是一个在 <a class="reference internal" href="#c.PyType_GetModule" title="PyType_GetModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModule()</span></code></a> 的结果上调用 <a class="reference internal" href="module.xhtml#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> 的快捷方式。</p>
<p>如果没有关联到给定类型的模块，则设置 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a> 并返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>如果 <em>type</em> 有关联的模块但其状态为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 且不设置异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_GetModuleByDef">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_GetModuleByDef</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="module.xhtml#c.PyModuleDef" title="PyModuleDef"><span class="n"><span class="pre">PyModuleDef</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">def</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>找到所属模块基于给定的 <a class="reference internal" href="module.xhtml#c.PyModuleDef" title="PyModuleDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyModuleDef</span></code></a> <em>def</em> 创建的第一个上级类，并返回该模块。</p>
<p>如果未找到模块，则会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a> 并返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>此函数预期会与 <a class="reference internal" href="module.xhtml#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> 一起使用以便从槽位方法 (如 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 或 <a class="reference internal" href="typeobj.xhtml#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a>) 及其他定义方法的类无法使用 <a class="reference internal" href="structures.xhtml#c.PyCMethod" title="PyCMethod"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code></a> 调用惯例来传递的场合获取模块状态。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyUnstable_Type_AssignVersionTag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyUnstable_Type_AssignVersionTag</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><div class="unstable-c-api warning admonition">
<em>这是 <a class="reference internal" href="stable.xhtml#unstable-c-api"><span class="std std-ref">不稳定 API</span></a>。它可在次发布版中不经警告地改变。</em></div>
<p>尝试为给定的类型设置一个版本标签。</p>
<p>如果类型已有合法的版本标签或已设置了新的版本标签则返回 1，或者如果无法设置新的标签则返回 0。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<section id="creating-heap-allocated-types">
<h2>创建堆分配类型</h2>
<p>下列函数和结构体可被用来创建 <a class="reference internal" href="typeobj.xhtml#heap-types"><span class="std std-ref">堆类型</span></a>。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_FromMetaclass">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_FromMetaclass</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">metaclass</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span>, <a class="reference internal" href="#c.PyType_Spec" title="PyType_Spec"><span class="n"><span class="pre">PyType_Spec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">spec</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bases</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.12 版起.</em><p>根据 <em>spec</em> (参见 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code></a>) 创建并返回一个 <a class="reference internal" href="typeobj.xhtml#heap-types"><span class="std std-ref">堆类型</span></a>。</p>
<p>元类 <em>metaclass</em> 用于构建结果类型对象。 当 <em>metaclass</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时，元类将派生自 <em>bases</em> (或者如果 <em>bases</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则派生自 <em>Py_tp_base[s]</em> 槽位，见下文)。</p>
<p>不支持重写 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 的元类，除非 <code class="docutils literal notranslate"><span class="pre">tp_new</span></code> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 （为了向下兼容，其他 <code class="docutils literal notranslate"><span class="pre">PyType_From*</span></code> 函数允许这样的元类。 它们将忽略 <code class="docutils literal notranslate"><span class="pre">tp_new</span></code>，可能导致不完整的初始化。 这样的元类已被弃用并在 Python 3.14+ 中停止支持。）</p>
<p><em>bases</em> 参数可被用来指定基类；它可以是单个类或由多个类组成的元组。 如果 <em>bases</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则会改用 <em>Py_tp_bases</em> 槽位。 如果该槽位也为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则会改用 <em>Py_tp_base</em> 槽位。 如果该槽位同样为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则新类型将派生自 <a class="reference internal" href="../library/functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>。</p>
<p><em>module</em> 参数可被用来记录新类定义所在的模块。 它必须是一个模块对象或为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 如果不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则该模块会被关联到新类型并且可在之后通过 <a class="reference internal" href="#c.PyType_GetModule" title="PyType_GetModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModule()</span></code></a> 来获取。 这个关联模块不可被子类继承；它必须为每个类单独指定。</p>
<p>此函数会在新类型上调用 <a class="reference internal" href="#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>。</p>
<p>请注意此函数 <em>不能</em> 完全匹配调用 <a class="reference internal" href="../library/functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type()</span></code></a> 或使用 <a class="reference internal" href="../reference/compound_stmts.xhtml#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 语句的行为。 对于用户提供的类型或元类，推荐 <a class="reference internal" href="call.xhtml#capi-call"><span class="std std-ref">调用</span></a> <a class="reference internal" href="../library/functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> (或元类) 而不是 <code class="docutils literal notranslate"><span class="pre">PyType_From*</span></code> 函数。 特别地:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 不会在新类上被调用 (它必须被设为 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>)。</p></li>
<li><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 不会在新类上被调用。</p></li>
<li><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> 不会在任何基类上调用。</p></li>
<li><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> 不会在新的描述器上调用。</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_FromModuleAndSpec">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_FromModuleAndSpec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span>, <a class="reference internal" href="#c.PyType_Spec" title="PyType_Spec"><span class="n"><span class="pre">PyType_Spec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">spec</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bases</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p>等价于 <code class="docutils literal notranslate"><span class="pre">PyType_FromMetaclass(NULL,</span> <span class="pre">module,</span> <span class="pre">spec,</span> <span class="pre">bases)</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>此函数现在接受一个单独类作为 <em>bases</em> 参数并接受 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">tp_doc</span></code> 槽位。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该函数现在可以找到并使用与所提供的基类相对应的元类。 在此之前，只会返回 <a class="reference internal" href="../library/functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 实例。</p>
<p>元类的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 将被 <em>忽略</em>。 这可能导致不完整的初始化。 创建元类重写 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 的类的做法已被弃用并且在 Python 3.14+ 中将不再被允许。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_FromSpecWithBases">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_FromSpecWithBases</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyType_Spec" title="PyType_Spec"><span class="n"><span class="pre">PyType_Spec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">spec</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bases</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.3 版起.</em><p>等价于 <code class="docutils literal notranslate"><span class="pre">PyType_FromMetaclass(NULL,</span> <span class="pre">NULL,</span> <span class="pre">spec,</span> <span class="pre">bases)</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该函数现在可以找到并使用与所提供的基类相对应的元类。 在此之前，只会返回 <a class="reference internal" href="../library/functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 实例。</p>
<p>元类的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 将被 <em>忽略</em>。 这可能导致不完整的初始化。 创建元类重写 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 的类的做法已被弃用并且在 Python 3.14+ 中将不再被允许。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyType_FromSpec">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyType_FromSpec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyType_Spec" title="PyType_Spec"><span class="n"><span class="pre">PyType_Spec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">spec</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>等价于 <code class="docutils literal notranslate"><span class="pre">PyType_FromMetaclass(NULL,</span> <span class="pre">NULL,</span> <span class="pre">spec,</span> <span class="pre">NULL)</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该函数现在可以找到并使用与 <em>Py_tp_base[s]</em> 槽位中提供的基类相对应的元类。 在此之前，只会返回 <a class="reference internal" href="../library/functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 实例。</p>
<p>元类的 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 将被 <em>忽略</em>。 这可能导致不完整的初始化。 创建元类重写 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 的类的做法已被弃用并且在 Python 3.14+ 中将不再被允许。</p>
</div>
</dd></dl>

<!-- Keep old URL fragments working (see gh-97908) -->
<span id='c.PyType_Spec.PyType_Spec.name'></span>
<span id='c.PyType_Spec.PyType_Spec.basicsize'></span>
<span id='c.PyType_Spec.PyType_Spec.itemsize'></span>
<span id='c.PyType_Spec.PyType_Spec.flags'></span>
<span id='c.PyType_Spec.PyType_Spec.slots'></span><dl class="c type">
<dt class="sig sig-object c" id="c.PyType_Spec">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Spec</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> （包括所有成员）.</em><p>定义一个类型的行为的结构体。</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Spec.name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">name</span></span></span><br /></dt>
<dd><p>类型的名称，用来设置 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_name</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Spec.basicsize">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">basicsize</span></span></span><br /></dt>
<dd><p>如果为正数，则以字节为单位指定实例的大小。 它用于设置 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_basicsize</span></code></a>。</p>
<p>如果为零，则指定应当继承 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>。</p>
<p>如果为负数，则以其绝对值指定该类的实例在超类的 <em>基础之上</em> 还需要多少空间。 使用 <a class="reference internal" href="object.xhtml#c.PyObject_GetTypeData" title="PyObject_GetTypeData"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetTypeData()</span></code></a> 来获取通过此方式保留的子类专属内存的指针。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>在之前版本中，此字段不能为负数。</p>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Spec.itemsize">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">itemsize</span></span></span><br /></dt>
<dd><p>可变大小类型中一个元素的大小，以字节为单位。 用于设置 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_itemsize</span></code></a>。 注意事项请参阅 <code class="docutils literal notranslate"><span class="pre">tp_itemsize</span></code> 文档。</p>
<p>如果为零，则会继承 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>。 扩展任意可变大小的类是很危险的，因为某些类型使用固定偏移量来标识可变大小的内存，这样就会与子类使用的固定大小的内存相重叠。 为了防止出错，只有在以下情况下才可以继承 <code class="docutils literal notranslate"><span class="pre">itemsize</span></code>:</p>
<ul class="simple">
<li><p>基类不是可变大小的 (即其 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>)。</p></li>
<li><p>所请求的 <a class="reference internal" href="#c.PyType_Spec.basicsize" title="PyType_Spec.basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyType_Spec.basicsize</span></code></a> 为正值，表明基类的内存布局是已知的。</p></li>
<li><p>所请求的 <a class="reference internal" href="#c.PyType_Spec.basicsize" title="PyType_Spec.basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyType_Spec.basicsize</span></code></a> 为零，表明子类不会直接访问实例的内存。</p></li>
<li><p>具有 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_ITEMS_AT_END" title="Py_TPFLAGS_ITEMS_AT_END"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_ITEMS_AT_END</span></code></a> 旗标。</p></li>
</ul>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Spec.flags">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><br /></dt>
<dd><p>类型旗标，用来设置 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_flags</span></code></a>。</p>
<p>如果未设置 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code> 旗标，则 <a class="reference internal" href="#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases()</span></code></a> 会自动设置它。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Spec.slots">
<a class="reference internal" href="#c.PyType_Slot" title="PyType_Slot"><span class="n"><span class="pre">PyType_Slot</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">slots</span></span></span><br /></dt>
<dd><p><a class="reference internal" href="#c.PyType_Slot" title="PyType_Slot"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Slot</span></code></a> 结构体的数组。 以特殊槽位值 <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">NULL}</span></code> 来结束。</p>
<p>每个槽位 ID 应当只被指定一次。</p>
</dd></dl>

</dd></dl>

<!-- Keep old URL fragments working (see gh-97908) -->
<span id='c.PyType_Slot.PyType_Slot.slot'></span>
<span id='c.PyType_Slot.PyType_Slot.pfunc'></span><dl class="c type">
<dt class="sig sig-object c" id="c.PyType_Slot">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyType_Slot</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> （包括所有成员）.</em><p>定义一个类型的可选功能的结构体，包含一个槽位 ID 和一个值指针。</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Slot.slot">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">slot</span></span></span><br /></dt>
<dd><blockquote>
<div><p>槽位 ID。</p>
<p>槽位 ID 的类名像是结构体 <a class="reference internal" href="#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>, <a class="reference internal" href="typeobj.xhtml#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a>, <a class="reference internal" href="typeobj.xhtml#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PySequenceMethods</span></code></a>, <a class="reference internal" href="typeobj.xhtml#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMappingMethods</span></code></a> 和 <a class="reference internal" href="typeobj.xhtml#c.PyAsyncMethods" title="PyAsyncMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyAsyncMethods</span></code></a> 的字段名附加一个 <code class="docutils literal notranslate"><span class="pre">Py_</span></code> 前缀。 举例来说，使用:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Py_tp_dealloc</span></code> 设置 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_dealloc</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_nb_add</span></code> 设置 <a class="reference internal" href="typeobj.xhtml#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyNumberMethods.nb_add</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_sq_length</span></code> 设置 <a class="reference internal" href="typeobj.xhtml#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">PySequenceMethods.sq_length</span></code></a></p></li>
</ul>
<p>下列 “offset” 字段不可使用 <a class="reference internal" href="#c.PyType_Slot" title="PyType_Slot"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Slot</span></code></a> 来设置:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> (如果可能请改用 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_WEAKREF</span></code></a>)</p></li>
<li><p><a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> (如果可能请改用 <a class="reference internal" href="typeobj.xhtml#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_DICT</span></code></a>)</p></li>
<li><p><a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a> (请使用 <a class="reference internal" href="structures.xhtml#pymemberdef-offsets"><span class="std std-ref">PyMemberDef</span></a> 中的 <code class="docutils literal notranslate"><span class="pre">&quot;__vectorcalloffset__&quot;</span></code>)</p></li>
</ul>
<p>如果无法转为 <code class="docutils literal notranslate"><span class="pre">MANAGED</span></code> 旗标 (例如，对于 vectorcall 或是为了支持早于 Python 3.12 的版本)，请在 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal notranslate"><span class="pre">Py_tp_members</span></code></a> 中指定 offset。 详情参见 <a class="reference internal" href="structures.xhtml#pymemberdef-offsets"><span class="std std-ref">PyMemberDef documentation</span></a>。</p>
</div></blockquote>
<p>以下字段在创建堆类型时完全不可设置:</p>
<ul class="simple">
<li><p><a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_vectorcall" title="PyTypeObject.tp_vectorcall"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall</span></code></a> (请使用 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 和/或 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>)</p></li>
<li><p>内部字段: <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>, <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_mro</span></code></a>, <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_cache</span></code></a>, <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_subclasses</span></code></a> 和 <a class="reference internal" href="typeobj.xhtml#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a>。</p></li>
</ul>
<p>在某些平台上设置 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_tp_bases</span></code> 或 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_tp_base</span></code> 可能会有问题。 为了避免问题，请改用 <a class="reference internal" href="#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases()</span></code></a> 的 <em>bases</em> 参数。</p>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span><a class="reference internal" href="typeobj.xhtml#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBufferProcs</span></code></a> 中的槽位可能会在不受限 API 中被设置。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>现在 <a class="reference internal" href="typeobj.xhtml#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_getbuffer</span></code></a> 和 <a class="reference internal" href="typeobj.xhtml#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code></a> 将在 <a class="reference internal" href="stable.xhtml#limited-c-api"><span class="std std-ref">受限 API</span></a> 中可用。</p>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyType_Slot.pfunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pfunc</span></span></span><br /></dt>
<dd><p>该槽位的预期值。 在大多数情况下，这将是一个指向函数的指针。</p>
<p><code class="docutils literal notranslate"><span class="pre">Py_tp_doc</span></code> 以外的槽位均不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>