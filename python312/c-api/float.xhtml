<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="浮点数对象" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/float.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="打包与解包函数: 打包与解包函数提供了独立于平台的高效方式来将浮点数值存储为字节串。 Pack 例程根据 C double 产生字节串，而 Unpack 例程根据这样的字节串产生 C double 。 后缀 (2, 4 or 8) 指明字节串中的字节数。 在明显使用 IEEE 754 格式的平台上这些函数是通过拷贝比特位来实现的。 在其他平台上，2 字节格式与 IEEE 754 binary..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="打包与解包函数: 打包与解包函数提供了独立于平台的高效方式来将浮点数值存储为字节串。 Pack 例程根据 C double 产生字节串，而 Unpack 例程根据这样的字节串产生 C double 。 后缀 (2, 4 or 8) 指明字节串中的字节数。 在明显使用 IEEE 754 格式的平台上这些函数是通过拷贝比特位来实现的。 在其他平台上，2 字节格式与 IEEE 754 binary..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>浮点数对象</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/float.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="floating-point-objects">
<span id="floatobjects"></span><h1>浮点数对象</h1>
<dl class="c type" id="index-0">
<dt class="sig sig-object c" id="c.PyFloatObject">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloatObject</span></span></span><br /></dt>
<dd><p>这个C类型 <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 的子类型代表一个Python浮点数对象。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyFloat_Type">
<a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Type</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这是个属于C类型 <a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 的代表Python浮点类型的实例。在Python层面的类型 <a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 是同一个对象。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Check</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果它的参数是一个 <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFloatObject</span></code></a> 或者 <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFloatObject</span></code></a> 的子类型则返回真值。 此函数总是会成功执行。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_CheckExact">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_CheckExact</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果它的参数是一个 <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFloatObject</span></code></a> 但不是 <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFloatObject</span></code></a> 的子类型则返回真值。 此函数总是会成功执行。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_FromString">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_FromString</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>根据字符串 <em>str</em> 的值创建一个 <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFloatObject</span></code></a>，失败时返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_FromDouble">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_FromDouble</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>根据 <em>v</em> 创建一个 <a class="reference internal" href="#c.PyFloatObject" title="PyFloatObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFloatObject</span></code></a> 对象，失败时返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_AsDouble">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_AsDouble</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pyfloat</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回 <em>pyfloat</em> 的内容的 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 表示形式。 如果 <em>pyfloat</em> 不是一个 Python 浮点数对象但是具有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 方法，则会先调用此方法来将 <em>pyfloat</em> 转换为浮点数。 如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code> 未定义则将回退至 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>。 此方法在失败时将返回 <code class="docutils literal notranslate"><span class="pre">-1.0</span></code>，因此开发者应当调用 <a class="reference internal" href="exceptions.xhtml#c.PyErr_Occurred" title="PyErr_Occurred"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code></a> 来检测错误。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>如果可能将使用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_AS_DOUBLE">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_AS_DOUBLE</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pyfloat</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>返回 <em>pyfloat</em> 的 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 表示形式，但不带错误检测。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_GetInfo">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_GetInfo</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回一个 structseq 实例，其中包含有关 float 的精度、最小值和最大值的信息。 它是头文件 <code class="file docutils literal notranslate"><span class="pre">float.h</span></code> 的一个简单包装。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_GetMax">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_GetMax</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 形式的最大可表示有限浮点数 <em>DBL_MAX</em>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_GetMin">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_GetMin</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 形式的最小正规化正浮点数 <em>DBL_MIN</em>。</p>
</dd></dl>

<section id="pack-and-unpack-functions">
<h2>打包与解包函数</h2>
<p>打包与解包函数提供了独立于平台的高效方式来将浮点数值存储为字节串。 Pack 例程根据 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 产生字节串，而 Unpack 例程根据这样的字节串产生 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>。 后缀 (2, 4 or 8) 指明字节串中的字节数。</p>
<p>在明显使用 IEEE 754 格式的平台上这些函数是通过拷贝比特位来实现的。 在其他平台上，2 字节格式与 IEEE 754 binary16 半精度格式相同，4 字节格式 (32 位) 与 IEEE 754 binary32 单精度格式相同，而 8 字节格式则与 IEEE 754 双精度格式相同，不过 INF 和 NaN (如果平台存在这两种值) 未得到正确处理，而试图对包含 IEEE INF 或 NaN 的字节串执行解包将会引发一个异常。</p>
<p>在具有比 IEEE 754 所支持的更高精度，或更大动态范围的非 IEEE 平台上，不是所有的值都能被打包；在具有更低精度，或更小动态范围的非 IEEE 平台上，则不是所有的值都能被解包。 在这种情况下发生的事情有一部分将是偶然的（无奈）。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<section id="pack-functions">
<h3>打包函数</h3>
<p>打包例程会写入 2, 4 或 8 个字节，从 <em>p</em> 开始。 <em>le</em> 是一个 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 参数，如果你想要字节串为小端序格式 (指数部分放在后面，位于 <code class="docutils literal notranslate"><span class="pre">p+1</span></code>, <code class="docutils literal notranslate"><span class="pre">p+3</span></code> 或 <code class="docutils literal notranslate"><span class="pre">p+6</span></code> <code class="docutils literal notranslate"><span class="pre">p+7</span></code>) 则其应为非零值，如果你想要大端序格式 (指数部分放在前面，位于 <em>p</em>) 则其应为零。 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_BIG_ENDIAN</span></code> 常量可被用于使用本机端序：在大端序处理器上等于 <code class="docutils literal notranslate"><span class="pre">1</span></code>，在小端序处理器上则等于 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<p>返回值: 如果一切正常则为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，如果出错则为 <code class="docutils literal notranslate"><span class="pre">-1</span></code> (并会设置一个异常，最大可能为 <a class="reference internal" href="../library/exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>)。</p>
<p>在非 IEEE 平台上存在两个问题:</p>
<ul class="simple">
<li><p>如果 <em>x</em> 为 NaN 或无穷大则此函数的行为是未定义的。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-0.0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">+0.0</span></code> 将产生相同的字节串。</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Pack2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Pack2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">le</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 C double 打包为 IEEE 754 binary16 半精度格式。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Pack4">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Pack4</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">le</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 C double 打包为 IEEE 754 binary32 单精度格式。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Pack8">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Pack8</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">le</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 C double 打包为 IEEE 754 binary64 双精度格式。</p>
</dd></dl>

</section>
<section id="unpack-functions">
<h3>解包函数</h3>
<p>解包例程会读取 2, 4 或 8 个字节，从 <em>p</em> 开始。 <em>le</em> 是一个 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 参数，如果字节串为小端序格式 (指数部门放在后面，位于 <code class="docutils literal notranslate"><span class="pre">p+1</span></code>, <code class="docutils literal notranslate"><span class="pre">p+3</span></code> 或 <code class="docutils literal notranslate"><span class="pre">p+6</span></code> 和 <code class="docutils literal notranslate"><span class="pre">p+7</span></code>) 则其应为非零值，如果为大端序格式 (指数部分放在前面，位于 <em>p</em>) 则其应为零。 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_BIG_ENDIAN</span></code> 常量可被用于使用本机端序：在大端序处理器上等于 <code class="docutils literal notranslate"><span class="pre">1</span></code>，在小端序处理器上则等于 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<p>返回值: 解包后的 double。 出错时，返回值为 <code class="docutils literal notranslate"><span class="pre">-1.0</span></code> 且 <a class="reference internal" href="exceptions.xhtml#c.PyErr_Occurred" title="PyErr_Occurred"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code></a> 为真值 (并且会设置一个异常，最大可能为 <a class="reference internal" href="../library/exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>)。</p>
<p>请注意在非 IEEE 平台上此函数将拒绝解包表示 NaN 或无穷大的字节串。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Unpack2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Unpack2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">le</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 IEEE 754 binary16 半精度格式解包为 C double。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Unpack4">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Unpack4</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">le</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 IEEE 754 binary32 单精度格式解包为 C double。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyFloat_Unpack8">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyFloat_Unpack8</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">le</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将 IEEE 754 binary64 双精度格式解包为 C double。</p>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>