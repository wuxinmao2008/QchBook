<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="初始化，终结和线程" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/init.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="请参阅 Python 初始化配置 。 在Python初始化之前: 在一个植入了 Python 的应用程序中， Py_Initialize() 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 全局配置变量 。 在初始化Python之前，可以安全地调用以下函数： 配置函数：- PyImport_AppendInittab(), PyImport_ExtendI..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="请参阅 Python 初始化配置 。 在Python初始化之前: 在一个植入了 Python 的应用程序中， Py_Initialize() 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 全局配置变量 。 在初始化Python之前，可以安全地调用以下函数： 配置函数：- PyImport_AppendInittab(), PyImport_ExtendI..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>初始化，终结和线程</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/init.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="initialization-finalization-and-threads">
<span id="initialization"></span><h1>初始化，终结和线程</h1>
<p>请参阅 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a> 。</p>
<section id="before-python-initialization">
<span id="pre-init-safe"></span><h2>在Python初始化之前</h2>
<p>在一个植入了 Python 的应用程序中，<a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 <a class="reference internal" href="#global-conf-vars"><span class="std std-ref">全局配置变量</span></a>。</p>
<p>在初始化Python之前，可以安全地调用以下函数：</p>
<ul class="simple">
<li><p>配置函数：</p>
<ul>
<li><p><a class="reference internal" href="import.xhtml#c.PyImport_AppendInittab" title="PyImport_AppendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_AppendInittab()</span></code></a></p></li>
<li><p><a class="reference internal" href="import.xhtml#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExtendInittab()</span></code></a></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInitFrozenExtensions()</span></code></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyObject_SetArenaAllocator" title="PyObject_SetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetArenaAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetPath" title="Py_SetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPath()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetStandardStreamEncoding" title="Py_SetStandardStreamEncoding"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetStandardStreamEncoding()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.xhtml#c.PySys_AddWarnOption" title="PySys_AddWarnOption"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddWarnOption()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.xhtml#c.PySys_AddXOption" title="PySys_AddXOption"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddXOption()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.xhtml#c.PySys_ResetWarnOptions" title="PySys_ResetWarnOptions"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_ResetWarnOptions()</span></code></a></p></li>
</ul>
</li>
<li><p>信息函数：</p>
<ul>
<li><p><a class="reference internal" href="#c.Py_IsInitialized" title="Py_IsInitialized"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsInitialized()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_GetAllocator" title="PyMem_GetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_GetAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyObject_GetArenaAllocator" title="PyObject_GetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetArenaAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetCompiler" title="Py_GetCompiler"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCompiler()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetCopyright" title="Py_GetCopyright"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCopyright()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetPlatform" title="Py_GetPlatform"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPlatform()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetVersion" title="Py_GetVersion"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetVersion()</span></code></a></p></li>
</ul>
</li>
<li><p>工具</p>
<ul>
<li><p><a class="reference internal" href="sys.xhtml#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a></p></li>
</ul>
</li>
<li><p>内存分配器：</p>
<ul>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.xhtml#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>以下函数 <strong>不应该</strong> 在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>: <a class="reference internal" href="sys.xhtml#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a>, <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPrefix" title="Py_GetPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetExecPrefix" title="Py_GetExecPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetExecPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPythonHome" title="Py_GetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPythonHome()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramName" title="Py_GetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramName()</span></code></a> 和 <a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a> 前调用。</p>
</div>
</section>
<section id="global-configuration-variables">
<span id="global-conf-vars"></span><h2>全局配置变量</h2>
<p>Python 有负责控制全局配置中不同特性和选项的变量。这些标志默认被 <a class="reference internal" href="../using/cmdline.xhtml#using-on-interface-options"><span class="std std-ref">命令行选项</span></a>。</p>
<p>当一个选项设置一个旗标时，该旗标的值将是设置选项的次数。 例如，<code class="docutils literal notranslate"><span class="pre">-b</span></code> 会将 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a> 设为 1 而 <code class="docutils literal notranslate"><span class="pre">-bb</span></code> 会将 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a> 设为 2.</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.Py_BytesWarningFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_BytesWarningFlag</span></span></span><br /></dt>
<dd><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.bytes_warning" title="PyConfig.bytes_warning"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.bytes_warning</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>当将 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 与 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 比较或者将 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 与 <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 比较时发出警告。 如果大于等于 <code class="docutils literal notranslate"><span class="pre">2</span></code> 则报错。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 选项设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_DebugFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_DebugFlag</span></span></span><br /></dt>
<dd><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.parser_debug" title="PyConfig.parser_debug"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.parser_debug</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>开启解析器调试输出（限专家使用，依赖于编译选项）。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-d"><code class="xref std std-option docutils literal notranslate"><span class="pre">-d</span></code></a> 选项和 <span class="target" id="index-72"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONDEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDEBUG</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_DontWriteBytecodeFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_DontWriteBytecodeFlag</span></span></span><br /></dt>
<dd><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.write_bytecode" title="PyConfig.write_bytecode"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.write_bytecode</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>如果设置为非零, Python 不会在导入源代码时尝试写入 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-B"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> 选项和 <span class="target" id="index-73"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_FrozenFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_FrozenFlag</span></span></span><br /></dt>
<dd><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.pathconfig_warnings" title="PyConfig.pathconfig_warnings"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.pathconfig_warnings</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>当在 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a> 中计算模块搜索路径时屏蔽错误消息。</p>
<p>由 <code class="docutils literal notranslate"><span class="pre">_freeze_importlib</span></code> 和 <code class="docutils literal notranslate"><span class="pre">frozenmain</span></code> 程序使用的私有旗标。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_HashRandomizationFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_HashRandomizationFlag</span></span></span><br /></dt>
<dd><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.hash_seed" title="PyConfig.hash_seed"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.hash_seed</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c.PyConfig.use_hash_seed" title="PyConfig.use_hash_seed"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.use_hash_seed</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>如果 <span class="target" id="index-74"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 环境变量被设为非空字符串则设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p>如果该旗标为非零值，则读取 <span class="target" id="index-75"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 环境变量来初始化加密哈希种子。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_IgnoreEnvironmentFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IgnoreEnvironmentFlag</span></span></span><br /></dt>
<dd><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.use_environment" title="PyConfig.use_environment"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.use_environment</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>忽略所有 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON*</span></code> 环境变量，例如可能设置的 <span class="target" id="index-76"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 和 <span class="target" id="index-77"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a>。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-E"><code class="xref std std-option docutils literal notranslate"><span class="pre">-E</span></code></a>  和 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 选项设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_InspectFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InspectFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为采用设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.inspect" title="PyConfig.inspect"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.inspect</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>当将脚本作为第一个参数传入或是使用了 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 选项时，则会在执行该脚本或命令后进入交互模式，即使在 <a class="reference internal" href="../library/sys.xhtml#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> 并非一个终端时也是如此。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项和 <span class="target" id="index-78"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_InteractiveFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InteractiveFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为采用设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.interactive" title="PyConfig.interactive"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.interactive</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_IsolatedFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IsolatedFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.isolated" title="PyConfig.isolated"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.isolated</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>以隔离模式运行 Python. 在隔离模式下 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 将不包含脚本的目录或用户的 site-packages 目录。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 选项设置。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_LegacyWindowsFSEncodingFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_LegacyWindowsFSEncodingFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyPreConfig.legacy_windows_fs_encoding" title="PyPreConfig.legacy_windows_fs_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyPreConfig.legacy_windows_fs_encoding</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>如果该旗标为非零值，则使用 <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> 编码和``replace`` 错误处理器，而不是 UTF-8 编码和 <code class="docutils literal notranslate"><span class="pre">surrogatepass</span></code> 错误处理器作用 <a class="reference internal" href="../glossary.xhtml#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>。</p>
<p>如果 <span class="target" id="index-79"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONLEGACYWINDOWSFSENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSFSENCODING</span></code></a> 环境变量被设为非空字符串则设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p>更多详情请参阅 <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0529/"><strong>PEP 529</strong></a><span class="link-target"> [https://peps.python.org/pep-0529/]</span>。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="../library/intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: Windows。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_LegacyWindowsStdioFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_LegacyWindowsStdioFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.legacy_windows_stdio" title="PyConfig.legacy_windows_stdio"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.legacy_windows_stdio</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>如果该旗标为非零值，则会使用 <a class="reference internal" href="../library/io.xhtml#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a> 而不是 <code class="xref py py-class docutils literal notranslate"><span class="pre">io._WindowsConsoleIO</span></code> 作为 <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 标准流。</p>
<p>如果 <span class="target" id="index-81"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONLEGACYWINDOWSSTDIO"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSSTDIO</span></code></a> 环境变量被设为非空字符串则设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p>有关更多详细信息，请参阅 <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0528/"><strong>PEP 528</strong></a><span class="link-target"> [https://peps.python.org/pep-0528/]</span>。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="../library/intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: Windows。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_NoSiteFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_NoSiteFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.site_import" title="PyConfig.site_import"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.site_import</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>禁用 <a class="reference internal" href="../library/site.xhtml#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 的导入及其所附带的基于站点对 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 的操作。 如果 <a class="reference internal" href="../library/site.xhtml#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 会在稍后被显式地导入也会禁用这些操作 (如果你希望触发它们则应调用 <a class="reference internal" href="../library/site.xhtml#site.main" title="site.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">site.main()</span></code></a>)。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-S"><code class="xref std std-option docutils literal notranslate"><span class="pre">-S</span></code></a> 选项设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_NoUserSiteDirectory">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_NoUserSiteDirectory</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.user_site_directory" title="PyConfig.user_site_directory"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.user_site_directory</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>不要将 <a class="reference internal" href="../library/site.xhtml#site.USER_SITE" title="site.USER_SITE"><code class="xref py py-data docutils literal notranslate"><span class="pre">用户</span> <span class="pre">site-packages</span> <span class="pre">目录</span></code></a> 添加到 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a> 和 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 选项以及 <span class="target" id="index-83"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONNOUSERSITE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNOUSERSITE</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_OptimizeFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_OptimizeFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为 <a class="reference internal" href="init_config.xhtml#c.PyConfig.optimization_level" title="PyConfig.optimization_level"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.optimization_level</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项和 <span class="target" id="index-84"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONOPTIMIZE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONOPTIMIZE</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_QuietFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_QuietFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.quiet" title="PyConfig.quiet"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.quiet</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>即使在交互模式下也不显示版权和版本信息。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-q"><code class="xref std std-option docutils literal notranslate"><span class="pre">-q</span></code></a> 选项设置。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_UnbufferedStdioFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_UnbufferedStdioFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.buffered_stdio" title="PyConfig.buffered_stdio"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.buffered_stdio</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>强制 stdout 和 stderr 流不带缓冲。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-u"><code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code></a> 选项和 <span class="target" id="index-85"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONUNBUFFERED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONUNBUFFERED</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_VerboseFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_VerboseFlag</span></span></span><br /></dt>
<dd><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.verbose" title="PyConfig.verbose"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.verbose</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>每次初始化模块时打印一条消息，显示加载模块的位置（文件名或内置模块）。 如果大于或等于 <code class="docutils literal notranslate"><span class="pre">2</span></code>，则为搜索模块时检查的每个文件打印一条消息。 此外还会在退出时提供模块清理信息。</p>
<p>由 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-v"><code class="xref std std-option docutils literal notranslate"><span class="pre">-v</span></code></a> 选项和 <span class="target" id="index-86"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONVERBOSE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONVERBOSE</span></code></a> 环境变量设置。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</dd></dl>

</section>
<section id="initializing-and-finalizing-the-interpreter">
<h2>初始化和最终化解释器</h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_Initialize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_Initialize</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-15">初始化 Python 解释器。 在嵌入 Python 的应用程序中，它应当在使用任何其他 Python/C API 函数之前被调用；请参阅 <a class="reference internal" href="#pre-init-safe"><span class="std std-ref">在 Python 初始化之前</span></a> 了解少数的例外情况。</p>
<p>这将初始化已加载模块表 (<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>)，并创建基本模块 <a class="reference internal" href="../library/builtins.xhtml#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>、<a class="reference internal" href="../library/__main__.xhtml#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 和 <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>。 它还会初始化模块搜索路径 (<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>)。 它不会设置 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>；如有需要请使用 <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a>。 当第二次调用时 (在未事先调用 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 的情况下) 将不会执行任何操作。 它没有返回值；如果初始化失败则会发生致命错误。</p>
<p>使用 <a class="reference internal" href="init_config.xhtml#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> 函数自定义 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Windows 上，将控制台模式从 <code class="docutils literal notranslate"><span class="pre">O_TEXT</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">O_BINARY</span></code>，这还将影响使用 C 运行时的非 Python 的控制台使用。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_InitializeEx">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InitializeEx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">initsigs</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>如果 <em>initsigs</em> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则该函数的工作方式与 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 类似。 如果 <em>initsigs</em> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，它将跳过信号处理器的初始化注册，这在嵌入 Python 时可能会很有用处。</p>
<p>使用 <a class="reference internal" href="init_config.xhtml#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> 函数自定义 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_IsInitialized">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IsInitialized</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>如果 Python 解释器已初始化，则返回真值（非零）；否则返回假值（零）。 在调用 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 之后，此函数将返回假值直到 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 再次被调用。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_FinalizeEx">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_FinalizeEx</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.6 版起.</em><p>撤销 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 所做的所有初始化操作和后续对 Python/C API 函数的使用，并销毁自上次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 以来创建但尚未销毁的所有子解释器（参见下文 <a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a> 一节)。 在理想情况下，这会释放 Python 解释器分配的所有内存。 当第二次调用时（在未再次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 的情况下），这将不执行任何操作。 正常情况下返回值是 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 如果在最终化（刷新缓冲数据）过程中出现错误，则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p>提供此函数的原因有很多。嵌入应用程序可能希望重新启动Python，而不必重新启动应用程序本身。从动态可加载库（或DLL）加载Python解释器的应用程序可能希望在卸载DLL之前释放Python分配的所有内存。在搜索应用程序内存泄漏的过程中，开发人员可能希望在退出应用程序之前释放Python分配的所有内存。</p>
<p><strong>程序问题和注意事项:</strong> 模块和模块中对象的销毁是按随机顺序进行的；这可能导致依赖于其他对象（甚至函数）或模块的析构器（即 <a class="reference internal" href="../reference/datamodel.xhtml#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 方法）出错。 Python 所加载的动态加载扩展模块不会被卸载。 Python 解释器所分配的少量内存可能不会被释放（如果发现内存泄漏，请报告问题）。 对象间循环引用所占用的内存不会被释放。 扩展模块所分配的某些内存可能不会被释放。 如果某些扩展的初始化例程被调用多次它们可能无法正常工作；如果应用程序多次调用了 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 和 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 就可能发生这种情况。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="../library/sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">cpython._PySys_ClearAuditHooks</span></code>，不附带任何参数。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_Finalize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_Finalize</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这是一个不考虑返回值的 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 的向下兼容版本。</p>
</dd></dl>

</section>
<section id="process-wide-parameters">
<h2>进程级参数</h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_SetStandardStreamEncoding">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_SetStandardStreamEncoding</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">encoding</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">errors</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p id="index-16">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.stdio_encoding" title="PyConfig.stdio_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.stdio_encoding</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c.PyConfig.stdio_errors" title="PyConfig.stdio_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.stdio_errors</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>如果要调用该函数，应当在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前调用。 它指定了标准 IO 使用的编码格式和错误处理方式，其含义与 <a class="reference internal" href="../library/stdtypes.xhtml#str.encode" title="str.encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 中的相同。</p>
<p>它覆盖了 <span class="target" id="index-87"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 的值，并允许嵌入代码以便在环境变量不起作用时控制 IO 编码格式。</p>
<p><em>encoding</em> 和/或 <em>errors</em> 可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 以使用 <span class="target" id="index-88"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 和/或默认值（取决于其他设置）。</p>
<p>请注意无论是否有此设置（或任何其他设置），<a class="reference internal" href="../library/sys.xhtml#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 都会使用 &quot;backslashreplace&quot; 错误处理器。</p>
<p>如果调用了 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>，则需要再次调用该函数以便影响对 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 的后续调用。</p>
<p>成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，出错时返回非零值（例如在解释器已被初始化后再调用）。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_SetProgramName">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_SetProgramName</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-19">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.program_name" title="PyConfig.program_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.program_name</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>如果要调用该函数，应当在首次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前调用它。 它将告诉解释器程序的 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 函数的 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 参数的值（转换为宽字符）。 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a> 和下面的某些其他函数会使用它在相对于解释器的位置上查找可执行文件的 Python 运行时库。 默认值是 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>。 参数应当指向静态存储中的一个以零值结束的宽字符串，其内容在程序执行期间不会发生改变。 Python 解释器中的任何代码都不会改变该存储的内容。</p>
<p>使用 <a class="reference internal" href="sys.xhtml#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 对字节串进行解码以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> 字符串。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetProgramName">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetProgramName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-20">返回用 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 设置的程序名称，或默认的名称。 返回的字符串指向静态存储；调用者不应修改其值。</p>
<p>此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPrefix">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPrefix</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回针对已安装的独立于平台文件的 <em>prefix</em>。 这是通过基于使用 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 设置的程序名称和某些环境变量所派生的一系列复杂规则获得的；举例来说，如果程序名称为 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>，则 prefix 为 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>。 返回的字符串将指向静态存储；调用方不应修改其值。 这对应于最高层级 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code> 中的 <strong class="makevar">prefix</strong> 变量以及在编译时传给 <strong class="program">configure</strong> 脚本的 <a class="reference internal" href="../using/configure.xhtml#cmdoption-prefix"><code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code></a> 参数。 该值将以 <code class="docutils literal notranslate"><span class="pre">sys.prefix</span></code> 的名称供 Python 代码使用。 它仅适用于 Unix。 另请参见下一个函数。</p>
<p>此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetExecPrefix">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetExecPrefix</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回针对已安装的 <em>依赖于</em> 平台文件的 <em>exec-prefix</em>。 这是通过基于使用 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 设置的程序名称和某些环境变量所派生的一系列复杂规则获得的；举例来说，如果程序名称为 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>，则 exec-prefix 为 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>。 返回的字符串将指向静态存储；调用方不应修改其值。 这对应于最高层级 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code> 中的 <strong class="makevar">exec_prefix</strong> 变量以及在编译时传给 <strong class="program">configure</strong> 脚本的 <code class="docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 参数。 该值将以 <code class="docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code> 的名称供 Python 代码使用。 它仅适用于 Unix。</p>
<p>背景：当依赖于平台的文件（如可执行文件和共享库）是安装于不同的目录树中的时候 exec-prefix 将会不同于 prefix。 在典型的安装中，依赖于平台的文件可能安装于 the <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code> 子目录树而独立于平台的文件可能安装于 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>。</p>
<p>总而言之，平台是一组硬件和软件资源的组合，例如所有运行 Solaris 2.x 操作系统的 Sparc 机器会被视为相同平台，但运行 Solaris 2.x 的 Intel 机器是另一种平台，而运行 Linux 的 Intel 机器又是另一种平台。 相同操作系统的不同主要发布版通常也会构成不同的平台。 非 Unix 操作系统的情况又有所不同；这类系统上的安装策略差别巨大因此 prefix 和 exec-prefix 是没有意义的，并将被设为空字符串。 请注意已编译的 Python 字节码是独立于平台的（但并不独立于它们编译时所使用的 Python 版本！）</p>
<p>系统管理员知道如何配置 <strong class="program">mount</strong> 或 <strong class="program">automount</strong> 程序以在平台间共享 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code> 而让 <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code> 成为针对不同平台的不同文件系统。</p>
<p>此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetProgramFullPath">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetProgramFullPath</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-21">返回 Python 可执行文件的完整程序名称；这是作为根据程序名称（由上述 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 设置）派生默认模块搜索路径的附带影响计算得出的。 返回的字符串将指向静态存储；调用方不应修改其值。 该值将以 <code class="docutils literal notranslate"><span class="pre">sys.executable</span></code> 的名称供 Python 代码使用。</p>
<p>此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPath">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPath</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-22">返回默认模块搜索路径；这是根据程序名称（由上述 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 设置）和某些环境变量计算得出的。 返回的字符串由一系列由依赖于平台的分隔符分开的目录名称组成。 分隔符在 Unix 和 macOS 上为 <code class="docutils literal notranslate"><span class="pre">':'</span></code> 而在 Windows 上为 <code class="docutils literal notranslate"><span class="pre">';'</span></code>。 返回的字符串将指向静态存储；调用方不应修改其值。 列表 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 将在解释器启动时使用该值来初始化；它可以在随后被修改（并且通常都会被修改）以变更加载模块的搜索路径。</p>
<p>此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_SetPath">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_SetPath</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">wchar_t</span></span><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p id="index-23">此 API 被保留用于向下兼容：应当改为采用设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.module_search_paths" title="PyConfig.module_search_paths"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c.PyConfig.module_search_paths_set" title="PyConfig.module_search_paths_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths_set</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>设置默认的模块搜索路径。 如果此函数在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，则 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a> 将不会尝试计算默认的搜索路径而是改用已提供的路径。 这适用于由一个完全知晓所有模块的位置的应用程序来嵌入 Python 的情况。 路径组件应当由平台专属的分隔符来分隔，在 Unix 和 macOS 上是 <code class="docutils literal notranslate"><span class="pre">':'</span></code> 而在 Windows 上则是 <code class="docutils literal notranslate"><span class="pre">';'</span></code>。</p>
<p>这也将导致 <a class="reference internal" href="../library/sys.xhtml#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a> 被设为程序的完整路径 (参见 <a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>) 而 <a class="reference internal" href="../library/sys.xhtml#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.prefix</span></code></a> 和 <a class="reference internal" href="../library/sys.xhtml#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code></a> 变为空值。 如果在调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之后有需要则应由调用方来修改它们。</p>
<p>使用 <a class="reference internal" href="sys.xhtml#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 来解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_</span><span class="p">*</span></span> 字符串。</p>
<p>路径参数会在内部被复制，使调用方可以在调用结束后释放它。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>现在 <a class="reference internal" href="../library/sys.xhtml#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a> 将使用程序的完整路径，而不是程序文件名。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetVersion">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetVersion</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回 Python 解释器的版本。 这将为如下形式的字符串</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) </span><span class="se">\n</span><span class="s">[GCC 4.2.3]&quot;</span>
</pre></div>
</div>
<p id="index-24">第一个单词（到第一个空格符为止）是当前的 Python 版本；前面的字符是以点号分隔的主要和次要版本号。 返回的字符串将指向静态存储；调用方不应修改其值。 该值将以 <a class="reference internal" href="../library/sys.xhtml#sys.version" title="sys.version"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version</span></code></a> 的名称供 Python 代码使用。</p>
<p>另请参阅 <a class="reference internal" href="apiabiversion.xhtml#c.Py_Version" title="Py_Version"><code class="xref c c-var docutils literal notranslate"><span class="pre">Py_Version</span></code></a> 常量。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPlatform">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPlatform</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-25">返回当前平台的平台标识符。 在 Unix 上，这将以操作系统的“官方”名称为基础，转换为小写形式，再加上主版本号；例如，对于 Solaris 2.x，或称 SunOS 5.x，该值将为 <code class="docutils literal notranslate"><span class="pre">'sunos5'</span></code>。 在 macOS 上，它将为 <code class="docutils literal notranslate"><span class="pre">'darwin'</span></code>。 在 Windows 上它将为 <code class="docutils literal notranslate"><span class="pre">'win'</span></code>。 返回的字符串指向静态存储；调用方不应修改其值。 Python 代码可通过 <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> 获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetCopyright">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetCopyright</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回当前 Python 版本的官方版权字符串，例如</p>
<p><code class="docutils literal notranslate"><span class="pre">'Copyright</span> <span class="pre">1991-1995</span> <span class="pre">Stichting</span> <span class="pre">Mathematisch</span> <span class="pre">Centrum,</span> <span class="pre">Amsterdam'</span></code></p>
<p id="index-26">返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可通过 <code class="docutils literal notranslate"><span class="pre">sys.copyright</span></code> 获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetCompiler">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetCompiler</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回用于编译当前 Python 版本的编译器指令，为带方括号的形式，例如:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;[GCC 2.7.2.2]&quot;</span>
</pre></div>
</div>
<p id="index-27">返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 <code class="docutils literal notranslate"><span class="pre">sys.version</span></code> 中获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetBuildInfo">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetBuildInfo</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回有关当前Python解释器实例的序列号和构建日期和时间的信息，例如：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;#67, Aug  1 1997, 22:34:28&quot;</span>
</pre></div>
</div>
<p id="index-28">返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 <code class="docutils literal notranslate"><span class="pre">sys.version</span></code> 中获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PySys_SetArgvEx">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PySys_SetArgvEx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">argc</span></span>, <span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argv</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">updatepath</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-29">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a>, <a class="reference internal" href="init_config.xhtml#c.PyConfig.parse_argv" title="PyConfig.parse_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.parse_argv</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c.PyConfig.safe_path" title="PyConfig.safe_path"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.safe_path</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>根据 <em>argc</em> 和 <em>argv</em> 设置 <a class="reference internal" href="../library/sys.xhtml#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>。 这些形参与传给程序的 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 函数的类似，区别在于第一项应当指向要执行的脚本文件而不是 Python 解释器对应的可执行文件。 如果没有要运行的脚本，则 <em>argv</em> 中的第一项可以为空字符串。 如果此函数无法初始化 <a class="reference internal" href="../library/sys.xhtml#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>，则将使用 <a class="reference internal" href="sys.xhtml#c.Py_FatalError" title="Py_FatalError"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FatalError()</span></code></a> 发出严重情况信号。</p>
<p>如果 <em>updatepath</em> 为零，此函数将完成操作。 如果 <em>updatepath</em> 为非零值，则此函数还将根据以下算法修改 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>:</p>
<ul class="simple">
<li><p>如果在 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 中传入一个现有脚本，则脚本所在目录的绝对路径将被添加到 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 的开头。</p></li>
<li><p>在其他情况下 (也就是说，如果 <em>argc</em> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 未指向现有文件名)，则将在 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 的开头添加一个空字符串，这等价于添加当前工作目录 (<code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code>)。</p></li>
</ul>
<p>使用 <a class="reference internal" href="sys.xhtml#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 来解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_</span><span class="p">*</span></span> 字符串。</p>
<p>另请参阅 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a> 的 <a class="reference internal" href="init_config.xhtml#c.PyConfig.orig_argv" title="PyConfig.orig_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.orig_argv</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a> 成员。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>建议在出于执行单个脚本以外的目的嵌入 Python 解释器的应用传入 <code class="docutils literal notranslate"><span class="pre">0</span></code> 作为 <em>updatepath</em>，并在需要时更新 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 本身。 参见 <a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983">CVE-2008-5983</a><span class="link-target"> [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983]</span>。</p>
<p>在 3.1.3 之前的版本中，你可以通过在调用 <a class="reference internal" href="#c.PySys_SetArgv" title="PySys_SetArgv"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code></a> 之后手动弹出第一个 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 元素，例如使用:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;import sys; sys.path.pop(0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PySys_SetArgv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PySys_SetArgv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">argc</span></span>, <span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argv</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a> 并改用 <a class="reference internal" href="init_config.xhtml#c.PyConfig.parse_argv" title="PyConfig.parse_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.parse_argv</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>此函数相当于 <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a> 设置了 <em>updatepath</em> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 除非 <strong class="program">python</strong> 解释器启动时附带了 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>。</p>
<p>使用 <a class="reference internal" href="sys.xhtml#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 来解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_</span><span class="p">*</span></span> 字符串。</p>
<p>另请参阅 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a> 的 <a class="reference internal" href="init_config.xhtml#c.PyConfig.orig_argv" title="PyConfig.orig_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.orig_argv</span></code></a> 和 <a class="reference internal" href="init_config.xhtml#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a> 成员。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span><em>updatepath</em> 值依赖于 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_SetPythonHome">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_SetPythonHome</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">home</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.xhtml#c.PyConfig.home" title="PyConfig.home"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.home</span></code></a>，参见 <a class="reference internal" href="init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p>设置默认的 &quot;home&quot; 目录，也就是标准 Python 库所在的位置。 请参阅 <span class="target" id="index-89"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 了解该参数字符串的含义。</p>
<p>此参数应当指向静态存储中一个以零值结束的字符串，其内容在程序执行期间将保持不变。 Python 解释器中的代码绝不会修改此存储中的内容。</p>
<p>使用 <a class="reference internal" href="sys.xhtml#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 来解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_</span><span class="p">*</span></span> 字符串。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPythonHome">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPythonHome</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回默认的 &quot;home&quot;，就是由之前对 <a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a> 的调用所设置的值，或者在设置了 <span class="target" id="index-90"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 环境变量的情况下该环境变量的值。</p>
<p>此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

</section>
<section id="thread-state-and-the-global-interpreter-lock">
<span id="threads"></span><h2>线程状态和全局解释器锁</h2>
<p id="index-32">Python 解释器不是完全线程安全的。 为了支持多线程的 Python 程序，设置了一个全局锁，称为 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> 或 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>，当前线程必须在持有它之后才能安全地访问 Python 对象。 如果没有这个锁，即使最简单的操作也可能在多线程的程序中导致问题：例如，当两个线程同时增加相同对象的引用计数时，引用计数可能最终只增加了一次而不是两次。</p>
<p id="index-33">因此，规则要求只有获得 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a> 的线程才能在 Python对象上执行操作或调用 Python/C API 函数。 为了模拟并发执行，解释器会定期尝试切换线程 (参见 <a class="reference internal" href="../library/sys.xhtml#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>)。 锁也会在读写文件等可能造成阻塞的 I/O 操作时释放，以便其他 Python 线程可以同时运行。</p>
<p id="index-34">Python 解释器会在一个名为 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 的数据结构体中保存一些线程专属的记录信息。 还有一个全局变量指向当前的 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a>: 它可以使用 <a class="reference internal" href="#c.PyThreadState_Get" title="PyThreadState_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a> 来获取。</p>
<section id="releasing-the-gil-from-extension-code">
<h3>从扩展扩展代码中释放 GIL</h3>
<p>大多数操作 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a> 的扩展代码具有以下简单结构：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Save</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variable</span><span class="p">.</span>
<span class="n">Release</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">global</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span>
<span class="p">...</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">blocking</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="p">...</span>
<span class="n">Reacquire</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">global</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span>
<span class="n">Restore</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variable</span><span class="p">.</span>
</pre></div>
</div>
<p>这是如此常用因此增加了一对宏来简化它:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="p">...</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">blocking</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="p">...</span>
<span class="n">Py_END_ALLOW_THREADS</span>
</pre></div>
</div>
<p id="index-35"><a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 宏将打开一个新块并声明一个隐藏的局部变量；<a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 宏将关闭这个块。</p>
<p>上面的代码块可扩展为下面的代码:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">_save</span><span class="p">;</span>

<span class="n">_save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyEval_SaveThread</span><span class="p">();</span>
<span class="p">...</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">blocking</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="p">...</span>
<span class="n">PyEval_RestoreThread</span><span class="p">(</span><span class="n">_save</span><span class="p">);</span>
</pre></div>
</div>
<p id="index-36">这些函数的工作原理如下：全局解释器锁被用来保护指向当前线程状态的指针。 当释放锁并保存线程状态时，必须在锁被释放之前获取当前线程状态指针 （因为另一个线程可以立即获取锁并将自己的线程状态存储到全局变量中）。 相应地，当获取锁并恢复线程状态时，必须在存储线程状态指针之前先获取锁。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>调用系统 I/O 函数是释放 GIL 的最常见用例，但它在调用不需要访问 Python 对象的长期运行计算，比如针对内存缓冲区进行操作的压缩或加密函数之前也很有用。 举例来说，在对数据执行压缩或哈希操作时标准 <a class="reference internal" href="../library/zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 和 <a class="reference internal" href="../library/hashlib.xhtml#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块就会释放 GIL。</p>
</div>
</section>
<section id="non-python-created-threads">
<span id="gilstate"></span><h3>非Python创建的线程</h3>
<p>当使用专门的 Python API（如 <a class="reference internal" href="../library/threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块）创建线程时，会自动关联一个线程状态因而上面显示的代码是正确的。 但是，如果线程是用 C 创建的（例如由具有自己的线程管理的第三方库创建），它们就不持有 GIL 也没有对应的线程状态结构体。</p>
<p>如果你需要从这些线程调用 Python 代码（这通常会是上述第三方库所提供的回调 API 的一部分），你必须首先通过创建线程状态数据结构体向解释器注册这些线程，然后获取 GIL，最后存储它们的线程状态指针，这样你才能开始使用 Python/C API。 完成以上步骤后，你应当重置线程状态指针，释放 GIL，最后释放线程状态数据结构体。</p>
<p><a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 函数会自动完成上述的所有操作。 从 C 线程调用到 Python 的典型方式如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyGILState_STATE</span><span class="w"> </span><span class="n">gstate</span><span class="p">;</span>
<span class="n">gstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyGILState_Ensure</span><span class="p">();</span>

<span class="cm">/* Perform Python actions here. */</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CallSomeFunction</span><span class="p">();</span>
<span class="cm">/* evaluate result or handle exception */</span>

<span class="cm">/* Release the thread. No Python API allowed beyond this point. */</span>
<span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
</pre></div>
</div>
<p>请注意 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> 函数会假定只有一个全局解释器（由 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 自动创建）。 Python 支持创建额外的解释器（使用 <a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a> 创建），但不支持混合使用多个解释器和 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API。</p>
</section>
<section id="cautions-about-fork">
<span id="fork-and-threads"></span><h3>有关 fork() 的注意事项</h3>
<p>有关线程的另一个需要注意的重要问题是它们在面对 C <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 调用时的行为。 在大多数支持 <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 的系统中，当一个进程执行 fork 之后将只有发出 fork 的线程存在。 这对需要如何处理锁以及CPython 的运行时内所有的存储状态都会有实质性的影响。</p>
<p>只保留“当前”线程这一事实意味着任何由其他线程所持有的锁永远不会被释放。 Python 通过在 fork 之前获取内部使用的锁，并随后释放它们的方式为 <a class="reference internal" href="../library/os.xhtml#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 解决了这个问题。 此外，它还会重置子进程中的任何 <a class="reference internal" href="../library/threading.xhtml#lock-objects"><span class="std std-ref">锁对象</span></a>。 在扩展或嵌入 Python 时，没有办法通知 Python 在 fork 之前或之后需要获取或重置的附加（非 Python）锁。 需要使用 OS 工具例如 <code class="xref c c-func docutils literal notranslate"><span class="pre">pthread_atfork()</span></code> 来完成同样的事情。 此外，在扩展或嵌入 Python 时，直接调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 而不是通过 <a class="reference internal" href="../library/os.xhtml#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> (并返回到或调用至 Python 中) 调用可能会导致某个被  fork 之后失效的线程所持有的 Python 内部锁发生死锁。 <a class="reference internal" href="sys.xhtml#c.PyOS_AfterFork_Child" title="PyOS_AfterFork_Child"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_AfterFork_Child()</span></code></a> 会尝试重置必要的锁，但并不总是能够做到。</p>
<p>所有其他线程都将结束这一事实也意味着 CPython 的运行时状态必须妥善清理，<a class="reference internal" href="../library/os.xhtml#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 就是这样做的。 这意味着最终化归属于当前解释器的所有其他 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 对象以及所有其他 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 对象。 由于这一点以及 <a class="reference internal" href="#sub-interpreter-support"><span class="std std-ref">&quot;main&quot; 解释器</span></a> 的特殊性质，<code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 应当只在该解释器 的 &quot;main&quot; 线程中被调用，而 CPython 全局运行时最初就是在该线程中初始化的。 只有当 <code class="xref c c-func docutils literal notranslate"><span class="pre">exec()</span></code> 将随后立即被调用的情况是唯一的例外。</p>
</section>
<section id="high-level-api">
<h3>高阶 API</h3>
<p>这些是在编写 C 扩展代码或在嵌入 Python 解释器时最常用的类型和函数：</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyInterpreterState">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">受限 API</span></a> （作为不透明的结构体）.</em><p>该数据结构代表多个合作线程所共享的状态。 属于同一解释器的线程将共享其模块管理以及其他一些内部条目。 该结构体中不包含公有成员。</p>
<p>最初归属于不同解释器的线程不会共享任何东西，但进程状态如可用内存、打开的文件描述符等等除外。 全局解释器锁也会被所有线程共享，无论它们归属于哪个解释器。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.PyThreadState">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">受限 API</span></a> （作为不透明的结构体）.</em><p>该数据结构代表单个线程的状态。 唯一的公有数据成员为：</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyThreadState.interp">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">interp</span></span></span><br /></dt>
<dd><p>该线程的解释器状态。</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_InitThreads">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_InitThreads</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-37">不执行任何操作的已弃用函数。</p>
<p>在 Python 3.6 及更老的版本中，此函数会在 GIL 不存在时创建它。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>此函数现在不执行任何操作。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>该函数现在由 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 调用，因此你无需再自行调用它。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>此函数已不再被允许在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前调用。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用.</span></p>
</div>
<span class="target" id="index-38"></span></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_ThreadsInitialized">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_ThreadsInitialized</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>如果 <a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a> 已经被调用则返回非零值。 此函数可在不持有 GIL 的情况下被调用，因而可被用来避免在单线程运行时对加锁 API 的调用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>现在 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a> 将由 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 来初始化。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SaveThread">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SaveThread</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>释放全局解释器锁  (如果已创建) 并将线程状态重置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，返回之前的线程状态 (不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)。 如果锁已被创建，则当前线程必须已获取到它。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_RestoreThread">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_RestoreThread</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>获取全局解释器锁 (如果已创建) 并将线程状态设为 <em>tstate</em>，它必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 如果锁已被创建，则当前线程必须尚未获取它，否则将发生死锁。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当运行时正在最终化时从某个线程调用此函数将终结该线程，即使线程不是由 Python 创建的。 你可以在调用此函数之前使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> 或 <a class="reference internal" href="../library/sys.xhtml#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> 来检查解释器是否还处于最终化过程中以避免不必要的终结。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Get">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Get</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回当前线程状态。 全局解释器锁必须被持有。 在当前状态为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时，这将发出一个致命错误  (这样调用方将无须检查是否为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Swap">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Swap</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>交换当前线程状态与由参数 <em>tstate</em> (可能为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>) 给出的线程状态。 全局解释器锁必须被持有且未被释放。</p>
</dd></dl>

<p>下列函数使用线程级本地存储，并且不能兼容子解释器：</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_Ensure">
<span class="n"><span class="pre">PyGILState_STATE</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_Ensure</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>确保当前线程已准备好调用 Python C API 而不管 Python 或全局解释器锁的当前状态如何。 只要每次调用都与 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 的调用相匹配就可以通过线程调用此函数任意多次。 一般来说，只要线程状态恢复到 Release() 之前的状态就可以在 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 调用之间使用其他与线程相关的 API。 例如，可以正常使用 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 和 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 宏。</p>
<p>返回值是一个当 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 被调用时的线程状态的不透明“句柄”，并且必须被传递给 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 以确保 Python 处于相同状态。 虽然允许递归调用，但这些句柄 <em>不能</em> 被共享 —— 每次对 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 的单独调用都必须保存其对 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 的调用的句柄。</p>
<p>当该函数返回时，当前线程将持有 GIL 并能够调用任意 Python 代码。 执行失败将导致致命级错误。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当运行时正在最终化时从某个线程调用此函数将终结该线程，即使线程不是由 Python 创建的。 你可以在调用此函数之前使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> 或 <a class="reference internal" href="../library/sys.xhtml#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> 来检查解释器是否还处于最终化过程中以避免不必要的终结。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_Release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_Release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">PyGILState_STATE</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>释放之前获取的任何资源。 在此调用之后，Python 的状态将与其在对相应 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 调用之前的一样（但是通常此状态对调用方来说将是未知的，对 GILState API 的使用也是如此）。</p>
<p>对 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 的每次调用都必须与在同一线程上对 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 的调用相匹配。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_GetThisThreadState">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_GetThisThreadState</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>获取此线程的当前线程状态。 如果当前线程上没有使用过 GILState API 则可以返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 请注意主线程总是会有这样一个线程状态，即使没有在主线程上执行过自动线程状态调用。 这主要是一个辅助/诊断函数。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_Check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_Check</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>如果当前线程持有 GIL 则返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> 否则返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 此函数可以随时从任何线程调用。 只有当它的 Python 线程状态已经初始化并且当前持有 GIL 时它才会返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>。 这主要是一个辅助/诊断函数。 例如在回调上下文或内存分配函数中会很有用处，当知道 GIL 被锁定时可以允许调用方执行敏感的操作或是在其他情况下做出不同的行为。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<p>以下的宏被使用时通常不带末尾分号；请在 Python 源代码发布包中查看示例用法。</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BEGIN_ALLOW_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>此宏会扩展为 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">PyThreadState</span> <span class="pre">*_save;</span> <span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code>。 请注意它包含一个开头花括号；它必须与后面的 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 宏匹配。 有关此宏的进一步讨论请参阅上文。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_END_ALLOW_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_END_ALLOW_THREADS</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>此宏扩展为 <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span> <span class="pre">}</span></code>。 注意它包含一个右花括号；它必须与之前的 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 宏匹配。 请参阅上文以进一步讨论此宏。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BLOCK_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BLOCK_THREADS</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这个宏扩展为 <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span></code>: 它等价于没有关闭花括号的 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a>。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_UNBLOCK_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_UNBLOCK_THREADS</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这个宏扩展为 <code class="docutils literal notranslate"><span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code>: 它等价于没有开始花括号和变量声明的 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a>。</p>
</dd></dl>

</section>
<section id="low-level-api">
<h3>底层级 API</h3>
<p>下列所有函数都必须在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之后被调用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 现在会初始化 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_New">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_New</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>创建一个新的解释器状态对象。 不需要持有全局解释器锁，但如果有必要序列化对此函数的调用则可能会持有。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="../library/sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_New</span></code>，不附带任何参数。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>重置解释器状态对象中的所有信息。 必须持有全局解释器锁。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="../library/sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_Clear</span></code>，不附带任何参数。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>销毁解释器状态对象。 不需要持有全局解释器锁。 解释器状态必须使用之前对 <a class="reference internal" href="#c.PyInterpreterState_Clear" title="PyInterpreterState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Clear()</span></code></a> 的调用来重置。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_New">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_New</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>创建属于给定解释器对象的新线程状态对象。全局解释器锁不需要保持，但如果需要序列化对此函数的调用，则可以保持。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>重置线程状态对象中的所有信息。 必须持有全局解释器锁。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>此函数现在会调用 <code class="xref c c-member docutils literal notranslate"><span class="pre">PyThreadState.on_delete</span></code> 回调。 在之前版本中，此操作是发生在 <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a> 中的。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>销毁线程状态对象。 不需要持有全局解释器锁。 线程状态必须使用之前对 <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a> 的调用来重置。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_DeleteCurrent">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_DeleteCurrent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>销毁当前线程状态并释放全局解释器锁。 与 <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a> 类似，不需要持有全局解释器锁。 线程状态必须已使用之前对 <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a> 调用来重置。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetFrame">
<a class="reference internal" href="frame.xhtml#c.PyFrameObject" title="PyFrameObject"><span class="n"><span class="pre">PyFrameObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetFrame</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p>获取 Python 线程状态 <em>tstate</em> 的当前帧。</p>
<p>返回一个 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">strong reference</span></a>。 如果没有当前执行的帧则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>另请参阅 <a class="reference internal" href="reflection.xhtml#c.PyEval_GetFrame" title="PyEval_GetFrame"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_GetFrame()</span></code></a>。</p>
<p><em>tstate</em> 必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetID">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetID</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p>获取 Python 线程状态 <em>tstate</em> 的唯一线程状态标识符。</p>
<p><em>tstate</em> 必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetInterpreter">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetInterpreter</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p>获取 Python 线程状态 <em>tstate</em> 对应的解释器。</p>
<p><em>tstate</em> 必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_EnterTracing">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_EnterTracing</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>暂停 Python 线程状态 <em>tstate</em> 中的追踪和性能分析。</p>
<p>使用 <a class="reference internal" href="#c.PyThreadState_LeaveTracing" title="PyThreadState_LeaveTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_LeaveTracing()</span></code></a> 函数来恢复它们。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_LeaveTracing">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_LeaveTracing</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>恢复 Python 线程状态 <em>tstate</em> 中被 <a class="reference internal" href="#c.PyThreadState_EnterTracing" title="PyThreadState_EnterTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_EnterTracing()</span></code></a> 函数暂停的追踪和性能分析。</p>
<p>另请参阅 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 和 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Get">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.9 版起.</em><p>获取当前解释器。</p>
<p>如果不存在当前 Python 线程状态或不存在当前解释器则将发出致命级错误信号。 它无法返回 NULL。</p>
<p>调用时必须携带GIL。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_GetID">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_GetID</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>返回解释器的唯一 ID。 如果执行过程中发生任何错误则将返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置错误。</p>
<p>调用时必须携带GIL。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_GetDict">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_GetDict</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.8 版起.</em><p>返回一个存储解释器专属数据的字典。 如果此函数返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则没有任何异常被引发并且调用方应当将解释器专属字典视为不可用。</p>
<p>这不是 <a class="reference internal" href="module.xhtml#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> 的替代，扩展仍应使用它来存储解释器专属的状态信息。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c._PyFrameEvalFunction">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_PyFrameEvalFunction</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="frame.xhtml#c._PyInterpreterFrame" title="_PyInterpreterFrame"><span class="n"><span class="pre">_PyInterpreterFrame</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">throwflag</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><p>帧评估函数的类型</p>
<p><em>throwflag</em> 形参将由生成器的 <code class="docutils literal notranslate"><span class="pre">throw()</span></code> 方法来使用：如为非零值，则处理当前异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>此函数现在可接受一个 <em>tstate</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><em>frame</em> 形参由 <code class="docutils literal notranslate"><span class="pre">PyFrameObject*</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">_PyInterpreterFrame*</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._PyInterpreterState_GetEvalFrameFunc">
<a class="reference internal" href="#c._PyFrameEvalFunction" title="_PyFrameEvalFunction"><span class="n"><span class="pre">_PyFrameEvalFunction</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_PyInterpreterState_GetEvalFrameFunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>获取帧评估函数。</p>
<p>请参阅 <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0523/"><strong>PEP 523</strong></a><span class="link-target"> [https://peps.python.org/pep-0523/]</span> &quot;Adding a frame evaluation API to CPython&quot;。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._PyInterpreterState_SetEvalFrameFunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_PyInterpreterState_SetEvalFrameFunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span>, <a class="reference internal" href="#c._PyFrameEvalFunction" title="_PyFrameEvalFunction"><span class="n"><span class="pre">_PyFrameEvalFunction</span></span></a><span class="w"> </span><span class="n"><span class="pre">eval_frame</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>设置帧评估函数。</p>
<p>请参阅 <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0523/"><strong>PEP 523</strong></a><span class="link-target"> [https://peps.python.org/pep-0523/]</span> &quot;Adding a frame evaluation API to CPython&quot;。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetDict">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetDict</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_borrowed_ref">返回值：借入的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回一个扩展可以在其中存储线程专属状态信息的字典。 每个扩展都应当使用一个独有的键用来在该字典中存储状态。 在没有可用的当前线程状态时也可以调用此函数。 如果此函数返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则还没有任何异常被引发并且调用方应当假定没有可用的当前线程状态。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_SetAsyncExc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_SetAsyncExc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exc</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>在一个线程中异步地引发异常。 <em>id</em> 参数是目标线程的线程 id；<em>exc</em> 是要引发的异常对象。 该函数不会窃取任何对 <em>exc</em> 的引用。 为防止随意滥用，你必须编写你自己的 C 扩展来调用它。 调用时必须持有 GIL。 返回已修改的线程状态数量；该值通常为一，但如果未找到线程 id 则会返回 0。 如果 <em>exc</em> 为``NULL``，则会清除线程的待处理异常（如果存在）。 这将不会引发异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><em>id</em> 形参的类型已从 <span class="c-expr sig sig-inline c"><span class="kt">long</span></span> 变为 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_AcquireThread">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_AcquireThread</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>获取全局解释器锁并将当前线程状态设为 <em>tstate</em>，它必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 锁必须在此之前已被创建。 如果该线程已获取锁，则会发生死锁。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当运行时正在最终化时从某个线程调用此函数将终结该线程，即使线程不是由 Python 创建的。 你可以在调用此函数之前使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> 或 <a class="reference internal" href="../library/sys.xhtml#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> 来检查解释器是否还处于最终化过程中以避免不必要的终结。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>已被更新为与 <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>, <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 保持一致，如果在解释器正在最终化时被调用则会终结当前线程。</p>
</div>
<p><a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a> 是一个始终可用的（即使线程尚未初始化）更高层级函数。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_ReleaseThread">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_ReleaseThread</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>将当前线程状态重置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并释放全局解释器锁。 在此之前锁必须已被创建并且必须由当前的线程所持有。 <em>tstate</em> 参数必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，该参数仅被用于检查它是否代表当前线程状态 --- 如果不是，则会报告一个致命级错误。</p>
<p><a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a> 是一个始终可用的（即使线程尚未初始化）更高层级函数。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_AcquireLock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_AcquireLock</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>获取全局解释器锁。锁必须在此之前已被创建。 如果该线程已经拥有锁，则会出现死锁。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.2 版本弃用: </span>此函数不会更新当前线程状态。 请改用 <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a> 或 <a class="reference internal" href="#c.PyEval_AcquireThread" title="PyEval_AcquireThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_AcquireThread()</span></code></a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当运行时正在最终化时从某个线程调用此函数将终结该线程，即使线程不是由 Python 创建的。 你可以在调用此函数之前使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> 或 <a class="reference internal" href="../library/sys.xhtml#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> 来检查解释器是否还处于最终化过程中以避免不必要的终结。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>已被更新为与 <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>, <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 保持一致，如果在解释器正在最终化时被调用则会终结当前线程。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_ReleaseLock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_ReleaseLock</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>释放全局解释器锁。 锁必须在此之前已被创建。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.2 版本弃用: </span>此函数不会更新当前线程状态。 请改用 <a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a> 或 <a class="reference internal" href="#c.PyEval_ReleaseThread" title="PyEval_ReleaseThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_ReleaseThread()</span></code></a>。</p>
</div>
</dd></dl>

</section>
</section>
<section id="sub-interpreter-support">
<span id="id1"></span><h2>子解释器支持</h2>
<p>虽然在大多数用例中，你都只会嵌入一个单独的 Python 解释器，但某些场景需要你在同一个进程甚至同一个线程中创建多个独立的解释器。 子解释器让你能够做到这一点。</p>
<p>“主”解释器是在运行时初始化时创建的第一个解释器。 它通常是一个进程中唯一的 Python 解释器。 与子解释器不同，主解释器具有唯一的进程全局责任比如信号处理等。 它还负责在运行时初始化期间的执行并且通常还是运行时最终化期间的活动解释器。 <a class="reference internal" href="#c.PyInterpreterState_Main" title="PyInterpreterState_Main"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Main()</span></code></a> 函数将返回一个指向其状态的指针。</p>
<p>你可以使用 <a class="reference internal" href="#c.PyThreadState_Swap" title="PyThreadState_Swap"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a> 函数在子解释器之间进行切换。 你可以使用下列函数来创建和销毁它们：</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyInterpreterConfig">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig</span></span></span><br /></dt>
<dd><p>包含用于配置子解释器的大部分形参的结构体。 其值仅在 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a> 中被使用而绝不会被运行时所修改。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p>结构体字段:</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.use_main_obmalloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">use_main_obmalloc</span></span></span><br /></dt>
<dd><p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则子解释器将使用自己的“对象”分配器状态。 否则它将使用（共享）主解释器的状态。</p>
<p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则 <a class="reference internal" href="#c.PyInterpreterConfig.check_multi_interp_extensions" title="PyInterpreterConfig.check_multi_interp_extensions"><code class="xref c c-member docutils literal notranslate"><span class="pre">check_multi_interp_extensions</span></code></a> 必须为 <code class="docutils literal notranslate"><span class="pre">1</span></code> (非零值)。 如果该值为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则 <a class="reference internal" href="#c.PyInterpreterConfig.gil" title="PyInterpreterConfig.gil"><code class="xref c c-member docutils literal notranslate"><span class="pre">gil</span></code></a> 不可为 <a class="reference internal" href="#c.PyInterpreterConfig_OWN_GIL" title="PyInterpreterConfig_OWN_GIL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyInterpreterConfig_OWN_GIL</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_fork">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_fork</span></span></span><br /></dt>
<dd><p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则运行时将不支持在当前激活了子解释器的任何线程中 fork 进程。 否则 fork 将不受限制。</p>
<p>请注意当 fork 被禁止时 <a class="reference internal" href="../library/subprocess.xhtml#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块将仍然可用。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_exec">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_exec</span></span></span><br /></dt>
<dd><p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则运行时将不支持在当前激活了子解释器的任何线程中通过 exec (例如 <a class="reference internal" href="../library/os.xhtml#os.execv" title="os.execv"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.execv()</span></code></a>) 替换当前进程。 否则 exec 将不受限制。</p>
<p>请注意当 exec 被禁止时 <a class="reference internal" href="../library/subprocess.xhtml#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块将仍然可用。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_threads">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_threads</span></span></span><br /></dt>
<dd><p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则子解释器的 <a class="reference internal" href="../library/threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块将不会创建线程。 否则线程将被允许。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_daemon_threads">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_daemon_threads</span></span></span><br /></dt>
<dd><p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则子解释器的 <a class="reference internal" href="../library/threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块将不会创建守护线程。 否则将允许守护线程（只要 <a class="reference internal" href="#c.PyInterpreterConfig.allow_threads" title="PyInterpreterConfig.allow_threads"><code class="xref c c-member docutils literal notranslate"><span class="pre">allow_threads</span></code></a> 是非零值）。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.check_multi_interp_extensions">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">check_multi_interp_extensions</span></span></span><br /></dt>
<dd><p>如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则所有扩展模块均可在当前子解释器被激活的任何线程中被导入，包括旧式的 (单阶段初始化) 模块。 否则将只有多阶段初始化扩展模块 (参见 <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a><span class="link-target"> [https://peps.python.org/pep-0489/]</span>) 可以被导入。 (另请参阅 <a class="reference internal" href="module.xhtml#c.Py_mod_multiple_interpreters" title="Py_mod_multiple_interpreters"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_mod_multiple_interpreters</span></code></a>。)</p>
<p>如果 <a class="reference internal" href="#c.PyInterpreterConfig.use_main_obmalloc" title="PyInterpreterConfig.use_main_obmalloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">use_main_obmalloc</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则该值必须为 <code class="docutils literal notranslate"><span class="pre">1</span></code> (非零值)。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.gil">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gil</span></span></span><br /></dt>
<dd><p>这将确定针对子解释器的 GIL 操作方式。 它可以是以下的几种之一：</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PyInterpreterConfig_DEFAULT_GIL">
<span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig_DEFAULT_GIL</span></span></span><br /></dt>
<dd><p>使用默认选择 (<a class="reference internal" href="#c.PyInterpreterConfig_SHARED_GIL" title="PyInterpreterConfig_SHARED_GIL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyInterpreterConfig_SHARED_GIL</span></code></a>)。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyInterpreterConfig_SHARED_GIL">
<span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig_SHARED_GIL</span></span></span><br /></dt>
<dd><p>使用（共享）主解释器的 GIL。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyInterpreterConfig_OWN_GIL">
<span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig_OWN_GIL</span></span></span><br /></dt>
<dd><p>使用子解释器自己的 GIL。</p>
</dd></dl>

<p>如果该值为 <a class="reference internal" href="#c.PyInterpreterConfig_OWN_GIL" title="PyInterpreterConfig_OWN_GIL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyInterpreterConfig_OWN_GIL</span></code></a> 则 <a class="reference internal" href="#c.PyInterpreterConfig.use_main_obmalloc" title="PyInterpreterConfig.use_main_obmalloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyInterpreterConfig.use_main_obmalloc</span></code></a> 必须为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_NewInterpreterFromConfig">
<a class="reference internal" href="init_config.xhtml#c.PyStatus" title="PyStatus"><span class="n"><span class="pre">PyStatus</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_NewInterpreterFromConfig</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate_p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.PyInterpreterConfig" title="PyInterpreterConfig"><span class="n"><span class="pre">PyInterpreterConfig</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p id="index-42">新建一个子解释器。 这是一个 (几乎) 完全隔离的 Python 代码执行环境。 特别需要注意，新的子解释器具有全部已导入模块的隔离的、独立的版本，包括基本模块 <a class="reference internal" href="../library/builtins.xhtml#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.xhtml#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 和 <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 等。 已加载模块表 (<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>) 和模块搜索路径 (<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>) 也是隔离的。 新环境没有 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code> 变量。 它具有新的标准 I/O 流文件对象 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> (不过这些对象都指向相同的底层文件描述符)。</p>
<p>给定的 <em>config</em> 控制着初始化解释器所使用的选项。</p>
<p>成功后，<em>tstate_p</em> 将被设为新的子解释器中创建的第一个线程状态。该线程状态是在当前线程状态中创建的。 请注意并没有真实的线程被创建；请参阅下文有关线程状态的讨论。 如果创建新的解释器没有成功，则 <em>tstate_p</em> 将被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；不会设置任何异常因为异常状态是存储在当前的线程状态中而当前线程状态并不一定存在。</p>
<p>与所有其他 Python/C API 函数一样，在调用此函数之前必须先持有全局解释器锁并且在其返回时仍继续持有。 同样地在进入函数时也必须设置当前线程状态。 执行成功后，返回的线程状态将被设为当前线程状态。 如果创建的子解释器具有自己的 GIL 那么调用方解释器的 GIL 将被释放。 当此函数返回时，新的解释器的 GIL 将由当前线程持有而之前的解释器的 GIL 在此将保持释放状态。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p>子解释器在彼此相互隔离，并让特定功能受限的情况下是最有效率的:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyInterpreterConfig</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">use_main_obmalloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_fork</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_exec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_daemon_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">check_multi_interp_extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">gil</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterConfig_OWN_GIL</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">tstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_NewInterpreterFromConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
</pre></div>
</div>
<p>请注意该配置只会被短暂使用而不会被修改。 在初始化期间配置的值会被转换成各种 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 值。 配置的只读副本可以被内部存储于 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 中。</p>
<p id="index-43">扩展模块将以如下方式在（子）解释器之间共享：</p>
<ul>
<li><p>对于使用多阶段初始化的模块 ，例如 <a class="reference internal" href="module.xhtml#c.PyModule_FromDefAndSpec" title="PyModule_FromDefAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec()</span></code></a>，将为每个解释器创建并初始化一个单独的模块对象。 只有 C 层级的静态和全局变量能在这些模块 对象之间共享。</p></li>
<li><p>对于使用单阶段初始化的模块，例如 <a class="reference internal" href="module.xhtml#c.PyModule_Create" title="PyModule_Create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_Create()</span></code></a>，当特定扩展被首次导入时，它将被正常初始化，并会保存其模块字典的一个 (浅) 拷贝。 当同一扩展被另一个 (子) 解释器导入时，将初始化一个新模块并填充该拷贝的内容；扩展的 <code class="docutils literal notranslate"><span class="pre">init</span></code> 函数不会被调用。 因此模块字典中的对象最终会被 (子) 解释器所共享，这可能会导致预期之外的行为  (参见下文的 <a class="reference internal" href="#bugs-and-caveats">Bugs and caveats</a>)。</p>
<p>请注意这不同于在调用 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 和 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 完全重新初始化解释器之后导入扩展时所发生的情况；对于那种情况，扩展的 <code class="docutils literal notranslate"><span class="pre">initmodule</span></code> 函数 <em>会被</em> 再次调用。 与多阶段初始化一样，这意味着只有 C 层级的静态和全局变量能在这些模块之间共享。</p>
</li>
</ul>
<span class="target" id="index-44"></span></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_NewInterpreter">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_NewInterpreter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-45">新建一个子解释器。 这在本质上只是针对 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a> 的包装器，其配置保留了现有的行为。 结果是一个未隔离的子解释器，它会共享主解释器的 GIL，允许 fork/exec，允许守护线程，也允许单阶段初始化模块。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_EndInterpreter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_EndInterpreter</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p id="index-46">销毁由给定的线程状态所代表的（子）解释器。 给定的线程状态必须为当前的线程状态。 请参阅下文中关于线程状态的讨论。 当调用返回时，当前的线程状态将为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 与此解释器相关联的所有线程状态都会被销毁。 在调用此函数之前必须持有目标解释器所使用的全局解释器锁。 当其返回时将不再持有 GIL。</p>
<p><a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 将销毁所有在当前时间点上尚未被明确销毁的子解释器。</p>
</dd></dl>

<section id="a-per-interpreter-gil">
<h3>解释器级 GIL</h3>
<p>使用 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a> 你将可以创建一个与其他解释器完全隔离的子解释器，包括具有自己的 GIL。 这种隔离带来的最大好处在于这样的解释器执行 Python 代码时不会被其他解释器所阻塞或者阻塞任何其他解释器。 因此在运行 Python 代码时单个 Python 进程可以真正地利用多个 CPU 核心。 这种隔离还能鼓励开发者采取不同于仅使用线程的并发方式。 (参见 <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0554/"><strong>PEP 554</strong></a><span class="link-target"> [https://peps.python.org/pep-0554/]</span>)。</p>
<p>使用隔离的解释器要求谨慎地保持隔离状态。 尤其是意味着不要在未确保线程安全的情况下共享任何对象 或可变的状态。 由于引用计数的存在即使是在其他情况下不可变的对象 (例如 <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">5)</span></code>) 通常也不可被共享。 针对此问题的一种简单但效率较低的解决方式是在使用某些状态 (或对象) 时总是使用一个全局锁。 或者，对于实际上不可变的对象 (如整数或字符串) 可以通过将其设为 &quot;永久&quot; 对象而无视其引用计数来确保其安全。 事实上，对于内置单例、小整数和其他一些内置对象都是这样做的。</p>
<p>如果你能保持隔离状态那么你将能获得真正的多核计算能力而不会遇到自由线程所带来的复杂性。 如果未能保持隔离状态那么你将面对自由线程所带来的全部后果，包括线程竞争和难以调试的崩溃。</p>
<p>除此之外，使用多个相互隔离的解释器的一个主要挑战是如何在它们之间安全 (不破坏隔离状态)、高效地进行通信。 运行时和标准库还没有为此提供任何标准方式。 未来的标准库模块将会帮助减少保持隔离状态所需的工作量并为解释器之间的数据通信（和共享）公开有效的工具。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</section>
<section id="bugs-and-caveats">
<h3>错误和警告</h3>
<p>由于子解释器 (以及主解释器) 都是同一个进程的组成部分，它们之间的隔离状态并非完美 --- 举例来说，使用低层级的文件操作如 <a class="reference internal" href="../library/os.xhtml#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a> 时它们可能 (无意或恶意地) 影响它们各自打开的文件。 由于 (子) 解释器之间共享扩展的方式，某些扩展可能无法正常工作；在使用单阶段初始化或者 (静态) 全局变量时尤其如此。 在一个子解释器中创建的对象有可能被插入到另一个 (子) 解释器的命名空间中；这种情况应当尽可能地避免。</p>
<p>应当特别注意避免在子解释器之间共享用户自定义的函数、方法、实例或类，因为由这些对象执行的导入 操作可能会影响错误的已加载模块的 (子) 解释器的字典。 同样重要的一点是应当避免共享可被上述对象访问的对象 。</p>
<p>还要注意的一点是将此功能与 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API 结合使用是很微妙的，因为这些 API 会假定 Python线程状态与操作系统级线程之间存在双向投影关系，而子解释器的存在打破了这一假定。 强烈建议你不要在一对互相匹配的 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 调用之间切换子解释器。 此外，使用这些 API 以允许从非 Python 创建的线程调用 Python 代码的扩展 (如 <a class="reference internal" href="../library/ctypes.xhtml#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>) 在使用子解释器时很可能会出现问题。</p>
</section>
</section>
<section id="asynchronous-notifications">
<h2>异步通知</h2>
<p>提供了一种向主解释器线程发送异步通知的机制。 这些通知将采用函数指针和空指针参数的形式。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_AddPendingCall">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_AddPendingCall</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>将一个函数加入从主解释器线程调用的计划任务。 成功时，将返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 并将 <em>func</em> 加入要被主线程调用的等待队列。 失败时，将返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 但不会设置任何异常。</p>
<p>当成功加入队列后，<em>func</em> 将 <em>最终</em> 附带参数 <em>arg</em> 被主解释器线程调用。 对于正常运行的 Python 代码来说它将被异步地调用，但要同时满足以下两个条件：</p>
<ul class="simple">
<li><p>位于 <a class="reference internal" href="../glossary.xhtml#term-bytecode"><span class="xref std std-term">bytecode</span></a> 的边界上；</p></li>
<li><p>主线程持有 <a class="reference internal" href="../glossary.xhtml#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> (因此 <em>func</em> 可以使用完整的 C API)。</p></li>
</ul>
<p><em>func</em> 必须在成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，或在失败时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置一个异常集合。 <em>func</em> 不会被中断来递归地执行另一个异步通知，但如果全局解释器锁被释放则它仍可被中断以切换线程。</p>
<p>此函数的运行不需要当前线程状态，也不需要全局解释器锁。</p>
<p>要在子解释器中调用函数，调用方必须持有 GIL。 否则，函数 <em>func</em> 可能会被安排给错误的解释器来调用。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>这是一个低层级函数，只在非常特殊的情况下有用。 不能保证 <em>func</em> 会尽快被调用。 如果主线程忙于执行某个系统调用，<em>func</em> 将不会在系统调用返回之前被调用。 此函数 通常 <strong>不适合</strong> 从任意 C 线程调用 Python 代码。 作为替代，请使用 <a class="reference internal" href="#gilstate"><span class="std std-ref">PyGILStateAPI</span></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>如果此函数在子解释器中被调用，则函数 <em>func</em> 将被安排在子解释器中调用，而不是在主解释器中调用。现在每个子解释器都有自己的计划调用列表。</p>
</div>
</dd></dl>

</section>
<section id="profiling-and-tracing">
<span id="profiling"></span><h2>分析和跟踪</h2>
<p>Python 解释器为附加的性能分析和执行跟踪工具提供了一些低层级的支持。 它们可被用于性能分析、调试和覆盖分析工具。</p>
<p>这个 C 接口允许性能分析或跟踪代码避免调用 Python 层级的可调用对象带来的开销，它能直接执行 C 函数调用。 此工具的基本属性没有变化；这个接口允许针对每个线程安装跟踪函数，并且向跟踪函数报告的基本事件与之前版本中向 Python 层级跟踪函数报告的事件相同。</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.Py_tracefunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_tracefunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="frame.xhtml#c.PyFrameObject" title="PyFrameObject"><span class="n"><span class="pre">PyFrameObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">what</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><p>使用 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 和 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 注册的跟踪函数的类型。 第一个形参是作为 <em>obj</em> 传递给注册函数的对象，<em>frame</em> 是与事件相关的帧对象，<em>what</em> 是常量 <a class="reference internal" href="#c.PyTrace_CALL" title="PyTrace_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code></a>, <a class="reference internal" href="#c.PyTrace_EXCEPTION" title="PyTrace_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></a>, <a class="reference internal" href="#c.PyTrace_LINE" title="PyTrace_LINE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></a>, <a class="reference internal" href="#c.PyTrace_RETURN" title="PyTrace_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code></a>, <a class="reference internal" href="#c.PyTrace_C_CALL" title="PyTrace_C_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></a>, <a class="reference internal" href="#c.PyTrace_C_EXCEPTION" title="PyTrace_C_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></a>, <a class="reference internal" href="#c.PyTrace_C_RETURN" title="PyTrace_C_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></a> 或 <a class="reference internal" href="#c.PyTrace_OPCODE" title="PyTrace_OPCODE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></a> 中的一个，而 <em>arg</em> 将依赖于 <em>what</em> 的值：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><em>what</em> 的值</p></th>
<th class="head"><p><em>arg</em> 的含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTrace_CALL" title="PyTrace_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code></a></p></td>
<td><p>总是 <a class="reference internal" href="none.xhtml#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTrace_EXCEPTION" title="PyTrace_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的异常信息。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTrace_LINE" title="PyTrace_LINE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></a></p></td>
<td><p>总是 <a class="reference internal" href="none.xhtml#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTrace_RETURN" title="PyTrace_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code></a></p></td>
<td><p>返回给调用方的值，或者如果是由异常导致的则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTrace_C_CALL" title="PyTrace_C_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></a></p></td>
<td><p>正在调用函数对象。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTrace_C_EXCEPTION" title="PyTrace_C_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></a></p></td>
<td><p>正在调用函数对象。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTrace_C_RETURN" title="PyTrace_C_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></a></p></td>
<td><p>正在调用函数对象。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTrace_OPCODE" title="PyTrace_OPCODE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></a></p></td>
<td><p>总是 <a class="reference internal" href="none.xhtml#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_CALL">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_CALL</span></span></span><br /></dt>
<dd><p>当对一个函数或方法的新调用被报告，或是向一个生成器增加新条目时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。 请注意针对生成器函数的迭代器的创建情况不会被报告因为在相应的帧中没有向 Python字节码转移控制权。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_EXCEPTION">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_EXCEPTION</span></span></span><br /></dt>
<dd><p>当一个异常被引发时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。 在处理完任何字节码之后将附带 <em>what</em> 的值调用回调函数，在此之后该异常将会被设置在正在执行的帧中。 这样做的效果是当异常传播导致 Python 栈展开时，被调用的回调函数将随异常传播返回到每个帧。 只有跟踪函数才会接收到这些事件；性能分析器并不需要它们。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_LINE">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_LINE</span></span></span><br /></dt>
<dd><p>当一个行编号事件被报告时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数 (但不会传给性能分析函数) 的 <em>what</em> 形参的值。 它可以通过将 <a class="reference internal" href="../reference/datamodel.xhtml#frame.f_trace_lines" title="frame.f_trace_lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code></a> 设为 <em>0</em> 在某个帧中被禁用。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_RETURN">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_RETURN</span></span></span><br /></dt>
<dd><p>当一个调用即将返回时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_C_CALL">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_C_CALL</span></span></span><br /></dt>
<dd><p>当一个 C 函数即将被调用时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_C_EXCEPTION">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_C_EXCEPTION</span></span></span><br /></dt>
<dd><p>当一个 C 函数引发异常时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_C_RETURN">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_C_RETURN</span></span></span><br /></dt>
<dd><p>当一个 C 函数返回时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_OPCODE">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_OPCODE</span></span></span><br /></dt>
<dd><p>当一个新操作码即将被执行时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数 (但不会传给性能分析函数) 的 <em>what</em> 形参的值。 在默认情况下此事件不会被发送：它必须通过在某个帧上将 <a class="reference internal" href="../reference/datamodel.xhtml#frame.f_trace_opcodes" title="frame.f_trace_opcodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code></a> 设为 <em>1</em> 来显式地请求。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetProfile">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetProfile</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将性能分析器函数设为 <em>func</em>。 <em>obj</em> 形参将作为第一个形参传给该函数，它可以是任意 Python 对象或为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 如果性能分析函数需要维护状态，则为每个线程的 <em>obj</em> 使用不同的值将提供一个方便而线程安全的存储位置。 这个性能分析函数将针对除 <a class="reference internal" href="#c.PyTrace_LINE" title="PyTrace_LINE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></a> <a class="reference internal" href="#c.PyTrace_OPCODE" title="PyTrace_OPCODE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></a> 和 <a class="reference internal" href="#c.PyTrace_EXCEPTION" title="PyTrace_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></a> 以外的所有被监控事件进行调用。</p>
<p>另请参阅 <a class="reference internal" href="../library/sys.xhtml#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setprofile()</span></code></a> 函数。</p>
<p>调用方必须持有 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetProfileAllThreads">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetProfileAllThreads</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>类似于 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 但会在属于当前解释器的所有在运行线程中设置性能分析函数而不是仅在当前线程上设置。</p>
<p>调用方必须持有 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
<p>与 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 一样，该函数会忽略任何被引发的异常同时在所有线程中设置性能分析函数。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetTrace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetTrace</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>将跟踪函数设为 <em>func</em>。 这类似于 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a>，区别在于跟踪函数会接收行编号事件和操作码级事件，但不会接收与被调用的 C 函数对象相关的任何事件。 使用 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 注册的任何跟踪函数将不会接收 <a class="reference internal" href="#c.PyTrace_C_CALL" title="PyTrace_C_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></a>、<a class="reference internal" href="#c.PyTrace_C_EXCEPTION" title="PyTrace_C_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></a> 或 <a class="reference internal" href="#c.PyTrace_C_RETURN" title="PyTrace_C_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></a> 作为 <em>what</em> 形参的值。</p>
<p>另请参阅 <a class="reference internal" href="../library/sys.xhtml#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.settrace()</span></code></a> 函数。</p>
<p>调用方必须持有 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetTraceAllThreads">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetTraceAllThreads</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>类似于 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 但会在属于当前解释器的所有在运行线程中设置跟踪函数而不是仅在当前线程上设置。</p>
<p>调用方必须持有 <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
<p>与 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 一样，该函数会忽略任何被引发的异常同时在所有线程中设置跟踪函数。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</section>
<section id="advanced-debugger-support">
<span id="advanced-debugging"></span><h2>高级调试器支持</h2>
<p>这些函数仅供高级调试工具使用。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Head">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Head</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>将解释器状态对象返回到由所有此类对象组成的列表的开头。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Main">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Main</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>返回主解释器状态对象。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Next">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Next</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>从由解释器状态对象组成的列表中返回 <em>interp</em> 之后的下一项。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_ThreadHead">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_ThreadHead</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>在由与解释器 <em>interp</em> 相关联的线程组成的列表中返回指向第一个 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 对象的指针。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Next">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Next</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>从由属于同一个 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 对象的线程状态对象组成的列表中返回 <em>tstate</em> 之后的下一项。</p>
</dd></dl>

</section>
<section id="thread-local-storage-support">
<span id="thread-local-storage"></span><h2>线程本地存储支持</h2>
<p>Python 解释器提供也对线程本地存储 (TLS) 的低层级支持，它对下层的原生 TLS 实现进行了包装以支持 Python 层级的线程本地存储 API (<a class="reference internal" href="../library/threading.xhtml#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a>)。 CPython 的 C 层级 API 与 pthreads 和 Windows 所提供的类似：使用一个线程键和函数来为每个线程关联一个 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值。</p>
<p>当调用这些函数时 <em>无须</em> 持有 GIL；它们会提供自己的锁机制。</p>
<p>请注意 <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code> 并不包括 TLS API 的声明，你需要包括 <code class="file docutils literal notranslate"><span class="pre">pythread.h</span></code> 来使用线程本地存储。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这些 API 函数都不会为 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 的值处理内存管理问题。 你需要自己分配和释放它们。 如果 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值碰巧为 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>，这些函数也不会对它们执行引用计数操作。</p>
</div>
<section id="thread-specific-storage-tss-api">
<span id="thread-specific-storage-api"></span><h3>线程专属存储 (TSS) API</h3>
<p>引入 TSSAPI 是为了取代 CPython 解释器中现有 TLS API 的使用。 该 API 使用一个新类型 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 而不是 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 来表示线程键。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>&quot;A New C-API for Thread-Local Storage in CPython&quot; (<span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0539/"><strong>PEP 539</strong></a><span class="link-target"> [https://peps.python.org/pep-0539/]</span>)</p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.Py_tss_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_tss_t</span></span></span><br /></dt>
<dd><p>该数据结构表示线程键的状态，其定义可能依赖于下层的 TLS 实现，并且它有一个表示键初始化状态的内部字段。 该结构体中不存在公有成员。</p>
<p>当未定义 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">Py_LIMITED_API</span></a> 时，允许由 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> 执行此类型的静态分配。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_tss_NEEDS_INIT">
<span class="sig-name descname"><span class="n"><span class="pre">Py_tss_NEEDS_INIT</span></span></span><br /></dt>
<dd><p>这个宏将扩展为 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 变量的初始化器。 请注意这个宏不会用 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">Py_LIMITED_API</span></a> 来定义。</p>
</dd></dl>

<section id="dynamic-allocation">
<h4>动态分配</h4>
<p><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 的动态分配，在使用 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">Py_LIMITED_API</span></a> 编译的扩展模块中是必须的，在这些模块由于此类型的实现在编译时是不透明的因此它不可能静态分配。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_alloc">
<a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_alloc</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>返回一个与使用 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> 初始化的值的状态相同的值，或者当动态分配失败时则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>在首次调用 <a class="reference internal" href="#c.PyThread_tss_delete" title="PyThread_tss_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_delete()</span></code></a> 以确保任何相关联的线程局部变量已被撤销赋值之后释放由 <a class="reference internal" href="#c.PyThread_tss_alloc" title="PyThread_tss_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_alloc()</span></code></a> 所分配的给定的 <em>key</em>。 如果 <em>key</em> 参数为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则这将无任何操作。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>被释放的 key 将变成一个悬空指针。 你应当将 key 重置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

</section>
<section id="methods">
<h4>方法</h4>
<p>这些函数的形参 <em>key</em> 不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 并且，如果给定的 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 还未被 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a> 初始化则 <a class="reference internal" href="#c.PyThread_tss_set" title="PyThread_tss_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_set()</span></code></a> 和 <a class="reference internal" href="#c.PyThread_tss_get" title="PyThread_tss_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_get()</span></code></a> 的行为将是未定义的。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_is_created">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_is_created</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>如果给定的 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 已通过has been initialized by <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a> 被初始化则返回一个非零值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_create</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>当成功初始化一个 TSS 键时将返回零值。 如果 <em>key</em> 参数所指向的值未被 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> 初始化则其行为是未定义的。 此函数可在相同的键上重复调用 -- 在已初始化的键上调用它将不执行任何操作并立即成功返回。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>销毁一个 TSS 键以便在所有线程中遗忘与该键相关联的值，并将该键的初始化状态改为未初始化的。 已销毁的键可以通过 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a> 再次被初始化。 此函数可以在同一个键上重复调用 -- 但在一个已被销毁的键上调用将是无效的。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_set">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>返回零值来表示成功将一个 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值与当前线程中的 TSS 键相关联。 每个线程都有一个从键到 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值的独立映射。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_get</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p>返回当前线程中与一个 TSS 键相关联的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值。 如果当前线程中没有与该键相关联的值则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

</section>
</section>
<section id="thread-local-storage-tls-api">
<span id="thread-local-storage-api"></span><h3>线程本地存储 (TLS) API</h3>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.7 版本弃用: </span>此 API 已被 <a class="reference internal" href="#thread-specific-storage-api"><span class="std std-ref">线程专属存储 (TSS) API</span></a> 所取代。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这个 API 版本不支持原生 TLS 键采用无法被安全转换为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的的定义方式的平台。 在这样的平台上，<a class="reference internal" href="#c.PyThread_create_key" title="PyThread_create_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_create_key()</span></code></a> 将立即返回一个失败状态，并且其他 TLS 函数在这样的平台上也都无效。</p>
</div>
<p>由于上面提到的兼容性问题，不应在新代码中使用此版本的API。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_create_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_create_key</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_delete_key">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_delete_key</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_set_key_value">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_set_key_value</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_get_key_value">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_get_key_value</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_delete_key_value">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_delete_key_value</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_ReInitTLS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_ReInitTLS</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>