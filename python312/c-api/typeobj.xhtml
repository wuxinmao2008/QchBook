<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="类型对象" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/typeobj.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Python 对象系统中最重要的一个结构体也许是定义新类型的结构体: PyTypeObject 结构体。 类型对象可以使用任何 PyObject_* 或 PyType_* 函数来处理，但并未提供大多数 Python 应用程序会感兴趣的东西。 这些对象是对象行为的基础，所以它们对解释器本身及任何实现新类型的扩展模块都非常重要。 与大多数标准类型相比，类型对象相当大。这么大的原因是每个类型对象存..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Python 对象系统中最重要的一个结构体也许是定义新类型的结构体: PyTypeObject 结构体。 类型对象可以使用任何 PyObject_* 或 PyType_* 函数来处理，但并未提供大多数 Python 应用程序会感兴趣的东西。 这些对象是对象行为的基础，所以它们对解释器本身及任何实现新类型的扩展模块都非常重要。 与大多数标准类型相比，类型对象相当大。这么大的原因是每个类型对象存..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>类型对象</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/typeobj.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="type-objects">
<span id="type-structs"></span><h1>类型对象</h1>
<p>Python 对象系统中最重要的一个结构体也许是定义新类型的结构体: <a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 结构体。 类型对象可以使用任何 <code class="docutils literal notranslate"><span class="pre">PyObject_*</span></code> 或 <code class="docutils literal notranslate"><span class="pre">PyType_*</span></code> 函数来处理，但并未提供大多数 Python 应用程序会感兴趣的东西。 这些对象是对象行为的基础，所以它们对解释器本身及任何实现新类型的扩展模块都非常重要。</p>
<p>与大多数标准类型相比，类型对象相当大。这么大的原因是每个类型对象存储了大量的值，大部分是C函数指针，每个指针实现了类型功能的一小部分。本节将详细描述类型对象的字段。这些字段将按照它们在结构中出现的顺序进行描述。</p>
<p>除了下面的快速参考， <a class="reference internal" href="#typedef-examples"><span class="std std-ref">例子</span></a> 小节提供了快速了解 <a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 的含义和用法的例子。</p>
<section id="quick-reference">
<h2>快速参考</h2>
<section id="tp-slots">
<span id="tp-slots-table"></span><h3>&quot;tp_方法槽&quot;</h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 31.0%" />
<col style="width: 31.0%" />
<col style="width: 31.0%" />
<col style="width: 1.7%" />
<col style="width: 1.7%" />
<col style="width: 1.7%" />
<col style="width: 1.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>PyTypeObject 槽 <a class="footnote-reference brackets" href="#slots" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></th>
<th class="head" rowspan="2"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">Type</span></a></p></th>
<th class="head" rowspan="2"><p>特殊方法/属性</p></th>
<th class="head" colspan="4"><p>信息 <a class="footnote-reference brackets" href="#cols" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></th>
</tr>
<tr class="row-even"><th class="head"><p>O</p></th>
<th class="head"><p>T</p></th>
<th class="head"><p>D</p></th>
<th class="head"><p>I</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>&lt;R&gt; <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a></p></td>
<td><p>const char *</p></td>
<td><p>__name__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a></p></td>
<td><p><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a></p></td>
<td><p><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a></p></td>
<td><p><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrfunc</span></code></a></p></td>
<td><p>__getattribute__,
__getattr__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrfunc</span></code></a></p></td>
<td><p>__setattr__,
__delattr__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_async</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyAsyncMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_repr</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p>__repr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PySequenceMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMappingMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">子方法槽（方法域）</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">hashfunc</span></code></a></p></td>
<td><p>__hash__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__call__</p></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_str</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p>__str__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrofunc</span></code></a></p></td>
<td><p>__getattribute__,
__getattr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrofunc</span></code></a></p></td>
<td><p>__setattr__,
__delattr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBufferProcs</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a></p></td>
<td><p>unsigned long</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_doc</span></code></a></p></td>
<td><p>const char *</p></td>
<td><p>__doc__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.xhtml#c.traverseproc" title="traverseproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">traverseproc</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">richcmpfunc</span></code></a></p></td>
<td><p>__lt__,
__le__,
__eq__,
__ne__,
__gt__,
__ge__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a>)</p></td>
<td><p><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getiterfunc</span></code></a></p></td>
<td><p>__iter__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">iternextfunc</span></code></a></p></td>
<td><p>__next__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_methods</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> []</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_members</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> []</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getset</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> []</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a></p></td>
<td><p><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> *</p></td>
<td><p>__base__</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__dict__</p></td>
<td></td>
<td></td>
<td><p>?</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrgetfunc</span></code></a></p></td>
<td><p>__get__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_set</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrsetfunc</span></code></a></p></td>
<td><p>__set__,
__delete__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>)</p></td>
<td><p><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.initproc" title="initproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">initproc</span></code></a></p></td>
<td><p>__init__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_alloc</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">allocfunc</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">newfunc</span></code></a></p></td>
<td><p>__new__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">freefunc</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_is_gc" title="PyTypeObject.tp_is_gc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_is_gc</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_bases" title="PyTypeObject.tp_bases"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_bases</span></code></a>&gt;</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__bases__</p></td>
<td></td>
<td></td>
<td><p>~</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_mro</span></code></a>&gt;</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__mro__</p></td>
<td></td>
<td></td>
<td><p>~</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_cache</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_subclasses</span></code></a>]</p></td>
<td><p>void *</p></td>
<td><p>__subclasses__</p></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_del" title="PyTypeObject.tp_del"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_del</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_version_tag" title="PyTypeObject.tp_version_tag"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_version_tag</span></code></a>]</p></td>
<td><p>unsigned int</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td><p>__del__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall" title="PyTypeObject.tp_vectorcall"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall</span></code></a></p></td>
<td><p><a class="reference internal" href="call.xhtml#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_watched" title="PyTypeObject.tp_watched"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_watched</span></code></a>]</p></td>
<td><p>unsigned char</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="slots" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><strong>（）</strong>：括号中的插槽名称表示（实际上）已弃用。</p>
<p><strong>&lt;&gt;</strong>: 尖括号内的名称在初始时应设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并被视为是只读的。</p>
<p><strong>[]</strong>: 方括号内的名称仅供内部使用。</p>
<p><strong>&lt;R&gt;</strong> (作为前缀) 表示字段是必需的 (不能是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)。</p>
</aside>
<aside class="footnote brackets" id="cols" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>列：</p>
<p><strong>&quot;O&quot;</strong>:  在 <code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 上设置</p>
<p><strong>&quot;T&quot;</strong>:  在 <a class="reference internal" href="type.xhtml#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> 上设置</p>
<p><strong>&quot;D&quot;</strong>: 默认设置(如果方法槽被设置为NULL)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X - PyType_Ready sets this value if it is NULL
~ - PyType_Ready always sets this value (it should be NULL)
? - PyType_Ready may set this value depending on other slots

Also see the inheritance column (&quot;I&quot;).
</pre></div>
</div>
<p><strong>&quot;I&quot;</strong>: 继承</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X - type slot is inherited via *PyType_Ready* if defined with a *NULL* value
% - the slots of the sub-struct are inherited individually
G - inherited, but only in combination with other slots; see the slot&#39;s description
? - it&#39;s complicated; see the slot&#39;s description
</pre></div>
</div>
<p>注意，有些方法槽是通过普通属性查找链有效继承的。</p>
</aside>
</aside>
</section>
<section id="sub-slots">
<span id="id3"></span><h3>子方法槽（方法域）</h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 47.3%" />
<col style="width: 30.9%" />
<col style="width: 21.8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法槽</p></th>
<th class="head"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">Type</span></a></p></th>
<th class="head"><p>特殊方法</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_await" title="PyAsyncMethods.am_await"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_await</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__await__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_aiter" title="PyAsyncMethods.am_aiter"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_aiter</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__aiter__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_anext" title="PyAsyncMethods.am_anext"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_anext</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__anext__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_send" title="PyAsyncMethods.am_send"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_send</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.sendfunc" title="sendfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">sendfunc</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td colspan="3"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__add__
__radd__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_add</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iadd__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_subtract" title="PyNumberMethods.nb_subtract"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_subtract</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__sub__
__rsub__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_subtract" title="PyNumberMethods.nb_inplace_subtract"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_subtract</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__isub__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mul__
__rmul__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__imul__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_remainder" title="PyNumberMethods.nb_remainder"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_remainder</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mod__
__rmod__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_remainder" title="PyNumberMethods.nb_inplace_remainder"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_remainder</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__imod__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_divmod" title="PyNumberMethods.nb_divmod"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_divmod</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__divmod__
__rdivmod__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_power" title="PyNumberMethods.nb_power"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_power</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__pow__
__rpow__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_power" title="PyNumberMethods.nb_inplace_power"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_power</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__ipow__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_negative" title="PyNumberMethods.nb_negative"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_negative</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__neg__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_positive" title="PyNumberMethods.nb_positive"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_positive</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__pos__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_absolute" title="PyNumberMethods.nb_absolute"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_absolute</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__abs__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_bool" title="PyNumberMethods.nb_bool"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_bool</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td><p>__bool__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_invert" title="PyNumberMethods.nb_invert"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_invert</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__invert__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_lshift" title="PyNumberMethods.nb_lshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_lshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__lshift__
__rlshift__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_lshift" title="PyNumberMethods.nb_inplace_lshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_lshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__ilshift__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_rshift" title="PyNumberMethods.nb_rshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_rshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__rshift__
__rrshift__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_rshift" title="PyNumberMethods.nb_inplace_rshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_rshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__irshift__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_and" title="PyNumberMethods.nb_and"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_and</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__and__
__rand__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_and" title="PyNumberMethods.nb_inplace_and"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_and</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iand__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_xor" title="PyNumberMethods.nb_xor"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_xor</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__xor__
__rxor__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_xor" title="PyNumberMethods.nb_inplace_xor"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_xor</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__ixor__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_or" title="PyNumberMethods.nb_or"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_or</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__or__
__ror__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_or" title="PyNumberMethods.nb_inplace_or"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_or</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__ior__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_int" title="PyNumberMethods.nb_int"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_int</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__int__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_reserved" title="PyNumberMethods.nb_reserved"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_reserved</span></code></a></p></td>
<td><p>void *</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_float" title="PyNumberMethods.nb_float"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_float</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__float__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_floor_divide" title="PyNumberMethods.nb_floor_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_floor_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__floordiv__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_floor_divide" title="PyNumberMethods.nb_inplace_floor_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_floor_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__ifloordiv__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_true_divide" title="PyNumberMethods.nb_true_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_true_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__truediv__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_true_divide" title="PyNumberMethods.nb_inplace_true_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_true_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__itruediv__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_index" title="PyNumberMethods.nb_index"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_index</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__index__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_matrix_multiply" title="PyNumberMethods.nb_matrix_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_matrix_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__matmul__
__rmatmul__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_matrix_multiply" title="PyNumberMethods.nb_inplace_matrix_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_matrix_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__imatmul__</p></td>
</tr>
<tr class="row-odd"><td colspan="3"></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_length" title="PyMappingMethods.mp_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_length</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p>__len__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_subscript</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__getitem__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_ass_subscript</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjargproc</span></code></a></p></td>
<td><p>__setitem__,
__delitem__</p></td>
</tr>
<tr class="row-odd"><td colspan="3"></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_length</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p>__len__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_concat" title="PySequenceMethods.sq_concat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_concat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__add__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_repeat" title="PySequenceMethods.sq_repeat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_repeat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__mul__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__getitem__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_ass_item</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeobjargproc</span></code></a></p></td>
<td><p>__setitem__
__delitem__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_contains" title="PySequenceMethods.sq_contains"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_contains</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjproc</span></code></a></p></td>
<td><p>__contains__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_concat" title="PySequenceMethods.sq_inplace_concat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_inplace_concat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iadd__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_repeat" title="PySequenceMethods.sq_inplace_repeat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_inplace_repeat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__imul__</p></td>
</tr>
<tr class="row-even"><td colspan="3"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_getbuffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code class="xref c c-func docutils literal notranslate"><span class="pre">getbufferproc()</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code class="xref c c-func docutils literal notranslate"><span class="pre">releasebufferproc()</span></code></a></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="slot-typedefs">
<span id="slot-typedefs-table"></span><h3>槽位 typedef</h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>typedef</p></th>
<th class="head"><p>参数类型</p></th>
<th class="head"><p>返回类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">allocfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>void</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">freefunc</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>void</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gcsupport.xhtml#c.traverseproc" title="traverseproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">traverseproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="gcsupport.xhtml#c.visitproc" title="visitproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">visitproc</span></code></a></div>
<div class="line">void *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">newfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.initproc" title="initproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">initproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">const char *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">const char *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrofunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrofunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrgetfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrsetfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">hashfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>Py_hash_t</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">richcmpfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">int</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getiterfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">iternextfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getbufferproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> *</div>
<div class="line">int</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">releasebufferproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> *</div>
</div>
</td>
<td><p>void</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></div>
</div>
</td>
<td><p><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeobjargproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a></div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjargproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
<p>请参阅 <a class="reference internal" href="#id6"><span class="std std-ref">槽位类型 typedef</span></a> 里有更多详细信息。</p>
</section>
</section>
<section id="pytypeobject-definition">
<h2>PyTypeObject 定义</h2>
<p><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 的结构定义可以在 <code class="file docutils literal notranslate"><span class="pre">Include/object.h</span></code> 中找到。 为了方便参考，此处复述了其中的定义:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_typeobject</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_VAR_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tp_name</span><span class="p">;</span><span class="w"> </span><span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_basicsize</span><span class="p">,</span><span class="w"> </span><span class="n">tp_itemsize</span><span class="p">;</span><span class="w"> </span><span class="cm">/* For allocation */</span>

<span class="w">    </span><span class="cm">/* Methods to implement standard operations */</span>

<span class="w">    </span><span class="n">destructor</span><span class="w"> </span><span class="n">tp_dealloc</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_vectorcall_offset</span><span class="p">;</span>
<span class="w">    </span><span class="n">getattrfunc</span><span class="w"> </span><span class="n">tp_getattr</span><span class="p">;</span>
<span class="w">    </span><span class="n">setattrfunc</span><span class="w"> </span><span class="n">tp_setattr</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyAsyncMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_async</span><span class="p">;</span><span class="w"> </span><span class="cm">/* formerly known as tp_compare (Python 2)</span>
<span class="cm">                                    or tp_reserved (Python 3) */</span>
<span class="w">    </span><span class="n">reprfunc</span><span class="w"> </span><span class="n">tp_repr</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Method suites for standard classes */</span>

<span class="w">    </span><span class="n">PyNumberMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
<span class="w">    </span><span class="n">PySequenceMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyMappingMethods</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* More standard operations (here for binary compatibility) */</span>

<span class="w">    </span><span class="n">hashfunc</span><span class="w"> </span><span class="n">tp_hash</span><span class="p">;</span>
<span class="w">    </span><span class="n">ternaryfunc</span><span class="w"> </span><span class="n">tp_call</span><span class="p">;</span>
<span class="w">    </span><span class="n">reprfunc</span><span class="w"> </span><span class="n">tp_str</span><span class="p">;</span>
<span class="w">    </span><span class="n">getattrofunc</span><span class="w"> </span><span class="n">tp_getattro</span><span class="p">;</span>
<span class="w">    </span><span class="n">setattrofunc</span><span class="w"> </span><span class="n">tp_setattro</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Functions to access object as input/output buffer */</span>
<span class="w">    </span><span class="n">PyBufferProcs</span><span class="w"> </span><span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Flags to define presence of optional/expanded features */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tp_flags</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Documentation string */</span>

<span class="w">    </span><span class="cm">/* Assigned meaning in release 2.0 */</span>
<span class="w">    </span><span class="cm">/* call function for all accessible objects */</span>
<span class="w">    </span><span class="n">traverseproc</span><span class="w"> </span><span class="n">tp_traverse</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* delete references to contained objects */</span>
<span class="w">    </span><span class="n">inquiry</span><span class="w"> </span><span class="n">tp_clear</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Assigned meaning in release 2.1 */</span>
<span class="w">    </span><span class="cm">/* rich comparisons */</span>
<span class="w">    </span><span class="n">richcmpfunc</span><span class="w"> </span><span class="n">tp_richcompare</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* weak reference enabler */</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_weaklistoffset</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Iterators */</span>
<span class="w">    </span><span class="n">getiterfunc</span><span class="w"> </span><span class="n">tp_iter</span><span class="p">;</span>
<span class="w">    </span><span class="n">iternextfunc</span><span class="w"> </span><span class="n">tp_iternext</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Attribute descriptor and subclassing stuff */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyMethodDef</span><span class="w"> </span><span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyMemberDef</span><span class="w"> </span><span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyGetSetDef</span><span class="w"> </span><span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Strong reference on a heap type, borrowed reference on a static type</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">_typeobject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
<span class="w">    </span><span class="n">descrgetfunc</span><span class="w"> </span><span class="n">tp_descr_get</span><span class="p">;</span>
<span class="w">    </span><span class="n">descrsetfunc</span><span class="w"> </span><span class="n">tp_descr_set</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">tp_dictoffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">initproc</span><span class="w"> </span><span class="n">tp_init</span><span class="p">;</span>
<span class="w">    </span><span class="n">allocfunc</span><span class="w"> </span><span class="n">tp_alloc</span><span class="p">;</span>
<span class="w">    </span><span class="n">newfunc</span><span class="w"> </span><span class="n">tp_new</span><span class="p">;</span>
<span class="w">    </span><span class="n">freefunc</span><span class="w"> </span><span class="n">tp_free</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Low-level free-memory routine */</span>
<span class="w">    </span><span class="n">inquiry</span><span class="w"> </span><span class="n">tp_is_gc</span><span class="p">;</span><span class="w"> </span><span class="cm">/* For PyObject_IS_GC */</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span><span class="w"> </span><span class="cm">/* method resolution order */</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>
<span class="w">    </span><span class="n">destructor</span><span class="w"> </span><span class="n">tp_del</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Type attribute cache version tag. Added in version 2.6 */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tp_version_tag</span><span class="p">;</span>

<span class="w">    </span><span class="n">destructor</span><span class="w"> </span><span class="n">tp_finalize</span><span class="p">;</span>
<span class="w">    </span><span class="n">vectorcallfunc</span><span class="w"> </span><span class="n">tp_vectorcall</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* bitset of which type-watchers care about this type */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">tp_watched</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="pyobject-slots">
<h2>PyObject 槽位</h2>
<p>类型对象结构体扩展了 <a class="reference internal" href="structures.xhtml#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyVarObject</span></code></a> 结构体。 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段用于动态类型（由 <code class="xref c c-func docutils literal notranslate"><span class="pre">type_new()</span></code> 创建，通常由 class 语句调用）。 请注意 <a class="reference internal" href="type.xhtml#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> （元类型）会初始化 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>，这意味着它的实例（即类型对象） <em>必须</em> 具有 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段。</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyObject.ob_refcnt">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">ob_refcnt</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这是类型对象的引用计数，由 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 宏初始化为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。 请注意对于 <a class="reference internal" href="#static-types"><span class="std std-ref">静态分配的类型对象</span></a>，类型的实例（其 <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_type</span></code></a> 指向该类型的对象） <em>不会被</em> 计入引用。 但对于 <a class="reference internal" href="#heap-types"><span class="std std-ref">动态分配的类型对象</span></a>，实例 <em>会被</em> 计入引用。</p>
<p><strong>继承：</strong></p>
<p>子类型不继承此字段。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyObject.ob_type">
<a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">ob_type</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>这是类型的类型，换句话说就是元类型，它由宏 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 的参数来做初始化，它的值一般情况下是 <code class="docutils literal notranslate"><span class="pre">&amp;PyType_Type</span></code> 。可是为了使动态可载入扩展模块至少在Windows上可用，编译器会报错这是一个不可用的初始化。因此按照惯例传递 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 给宏 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 并且在模块的初始化函数开始时候其他任何操作之前初始化这个字段。典型做法是这样的：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Foo_Type</span><span class="p">.</span><span class="n">ob_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>这应当在创建类型的任何实例之前完成。 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 会检查 <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_type</span></code></a> 是否为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，如果是，则将其初始化为基类的 <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_type</span></code></a> 字段。 如果该字段为非零值则 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 将不会更改它。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyObject._ob_next">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">_ob_next</span></span></span><br /></dt>
<dt class="sig sig-object c" id="c.PyObject._ob_prev">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">_ob_prev</span></span></span><br /></dt>
<dd><p>These fields are only present when the macro <code class="docutils literal notranslate"><span class="pre">Py_TRACE_REFS</span></code> is defined
(see the <a class="reference internal" href="../using/configure.xhtml#cmdoption-with-trace-refs"><code class="xref std std-option docutils literal notranslate"><span class="pre">configure</span> <span class="pre">--with-trace-refs</span> <span class="pre">option</span></code></a>).</p>
<p>Their initialization to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is taken care of by the
<code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> macro.  For <a class="reference internal" href="#static-types"><span class="std std-ref">statically allocated objects</span></a>, these fields always remain <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  For <a class="reference internal" href="#heap-types"><span class="std std-ref">dynamically
allocated objects</span></a>, these two fields are used to link the
object into a doubly linked list of <em>all</em> live objects on the heap.</p>
<p>This could be used for various debugging purposes; currently the only uses
are the <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getobjects()</span></code> function and to print the objects that are
still alive at the end of a run when the environment variable
<span class="target" id="index-0"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONDUMPREFS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDUMPREFS</span></code></a> is set.</p>
<p><strong>继承：</strong></p>
<p>These fields are not inherited by subtypes.</p>
</dd></dl>

</section>
<section id="pyvarobject-slots">
<h2>PyVarObject 槽位</h2>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyVarObject.ob_size">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="structures.xhtml#c.PyVarObject" title="PyVarObject"><span class="n"><span class="pre">PyVarObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">ob_size</span></span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>对于 <a class="reference internal" href="#static-types"><span class="std std-ref">静态分配的内存对象</span></a>，它应该初始化为 0。对于 <a class="reference internal" href="#heap-types"><span class="std std-ref">动态分配的类型对象</span></a>，该字段具有特殊的内部含义。</p>
<p><strong>继承：</strong></p>
<p>子类型不继承此字段。</p>
</dd></dl>

</section>
<section id="pytypeobject-slots">
<h2>PyTypeObject 槽</h2>
<p>每个槽位都有一个小节来描述继承关系。 如果 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 可以在字段被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时设置一个值那么还会有一个“默认”小节。 （请注意在 <code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 和 <a class="reference internal" href="type.xhtml#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> 上设置的许多字段实际上就是默认值。）</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_name</span></span></span><br /></dt>
<dd><p>指向包含类型名称的以 NUL 结尾的字符串的指针。 对于可作为模块全局访问的类型，该字符串应为模块全名，后面跟一个点号，然后再加类型名称；对于内置类型，它应当只是类型名称。 如果模块是包的子模块，则包的全名将是模块的全名的一部分。 例如，在包 <code class="xref py py-mod docutils literal notranslate"><span class="pre">P</span></code> 的子包 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Q</span></code> 中的模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code> 中定义的名为 <code class="xref py py-class docutils literal notranslate"><span class="pre">T</span></code> 的类型应当具有 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a> 初始化器 <code class="docutils literal notranslate"><span class="pre">&quot;P.Q.M.T&quot;</span></code>。</p>
<p>对于 <a class="reference internal" href="#heap-types"><span class="std std-ref">动态分配的类型对象</span></a>，这应为类型名称，而模块名称将作为 <code class="docutils literal notranslate"><span class="pre">'__module__'</span></code> 键的值显式地保存在类型字典中。</p>
<p>对于 <a class="reference internal" href="#static-types"><span class="std std-ref">静态分配的类型对象</span></a>，<em>tp_name</em> 字段应当包含一个点号。 最后一个点号之前的所有内容都可作为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 属性访问，而最后一个点号之后的所有内容都可作为 <a class="reference internal" href="../library/stdtypes.xhtml#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性访问。</p>
<p>如果不存在点号，则整个 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a> 字段将作为 <a class="reference internal" href="../library/stdtypes.xhtml#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性访问，而 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 属性则将是未定义的（除非在字典中显式地设置，如上文所述）。 这意味着你的类型将无法执行 pickle。 此外，用 pydoc 创建的模块文档中也不会列出该类型。</p>
<p>该字段不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 它是 <a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyTypeObject()</span></code></a> 中唯一的必填字段（除了潜在的 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 以外）。</p>
<p><strong>继承：</strong></p>
<p>子类型不继承此字段。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_basicsize">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_basicsize</span></span></span><br /></dt>
<dt class="sig sig-object c" id="c.PyTypeObject.tp_itemsize">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_itemsize</span></span></span><br /></dt>
<dd><p>通过这些字段可以计算出该类型实例以字节为单位的大小。</p>
<p>存在两种类型：具有固定长度实例的类型其 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 字段为零；具有可变长度实例的类型其 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 字段不为零。 对于具有固定长度实例的类型，所有实例的大小都相同，具体大小由 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 给出。</p>
<p>对于具有可变长度实例的类型，实例必须有一个 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段，实例大小为 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 加上 N 乘以 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>，其中 N 是对象的“长度”。 N 的值通常存储在实例的 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段中。 但也有例外：举例来说，整数类型使用负的 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 来表示负数，N 在这里就是 <code class="docutils literal notranslate"><span class="pre">abs(ob_size)</span></code>。 此外，在实例布局中存在 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段并不意味着实例结构是可变长度的（例如，列表类型的结构体有固定长度的实例，但这些实例却包含一个有意义的 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段）。</p>
<p>基本大小包括由宏 <a class="reference internal" href="structures.xhtml#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a> 或 <a class="reference internal" href="structures.xhtml#c.PyObject_VAR_HEAD" title="PyObject_VAR_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_VAR_HEAD</span></code></a> （以用于声明实例结构的宏为准）声明的实例中的字段，如果存在 <a class="reference internal" href="#c.PyObject._ob_prev" title="PyObject._ob_prev"><code class="xref c c-member docutils literal notranslate"><span class="pre">_ob_prev</span></code></a> 和 <a class="reference internal" href="#c.PyObject._ob_next" title="PyObject._ob_next"><code class="xref c c-member docutils literal notranslate"><span class="pre">_ob_next</span></code></a> 字段则将相应地包括这些字段。 这意味着为 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 获取初始化器的唯一正确方式是在用于声明实例布局的结构上使用 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 操作符。 基本大小不包括 GC 标头的大小。</p>
<p>关于对齐的说明：如果变量条目需要特定的对齐，则应通过 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 的值来处理。 例如：假设某个类型实现了一个 <code class="docutils literal notranslate"><span class="pre">double</span></code> 数组。 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 就是 <code class="docutils literal notranslate"><span class="pre">sizeof(double)</span></code>。 程序员有责任确保 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 是 <code class="docutils literal notranslate"><span class="pre">sizeof(double)</span></code> 的倍数（假设这是 <code class="docutils literal notranslate"><span class="pre">double</span></code> 的对齐要求）。</p>
<p>对于任何具有可变长度实例的类型，该字段不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p><strong>继承：</strong></p>
<p>这些字段将由子类分别继承。 如果基本类型有一个非零的 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>，那么在子类型中将 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 设置为不同的非零值通常是不安全的（不过这取决于该基本类型的具体实现）。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_dealloc">
<a class="reference internal" href="#c.destructor" title="destructor"><span class="n"><span class="pre">destructor</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_dealloc</span></span></span><br /></dt>
<dd><p>指向实例析构函数的指针。除非保证类型的实例永远不会被释放（就像单例对象 <code class="docutils literal notranslate"><span class="pre">None</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 那样），否则必须定义这个函数。函数声明如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tp_dealloc</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>当新引用计数为零时，<a class="reference internal" href="refcounting.xhtml#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> 和 <a class="reference internal" href="refcounting.xhtml#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_XDECREF()</span></code></a> 宏会调用析构函数。 此时，实例仍然存在，但已没有了对它的引用。 析构函数应当释放该实例拥有的所有引用，释放实例拥有的所有内存缓冲区（使用与分配缓冲区时所用分配函数相对应的释放函数），并调用类型的 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a> 函数。 如果该类型不可子类型化（未设置 <a class="reference internal" href="#c.Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_BASETYPE</span></code></a> 旗标位），则允许直接调用对象的释放器而不必通过 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a>。 对象的释放器应为分配实例时所使用的释放器；如果实例是使用 <a class="reference internal" href="allocation.xhtml#c.PyObject_New" title="PyObject_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_New</span></code></a> 或 <a class="reference internal" href="allocation.xhtml#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_NewVar</span></code></a> 分配的，则释放器通常为 <a class="reference internal" href="allocation.xhtml#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>；如果实例是使用 <a class="reference internal" href="gcsupport.xhtml#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_GC_New</span></code></a> 或 <a class="reference internal" href="gcsupport.xhtml#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_GC_NewVar</span></code></a> 分配的，则释放器通常为 <a class="reference internal" href="gcsupport.xhtml#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a>。</p>
<p>如果该类型支持垃圾回收（设置了 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位），则析构器应在清除任何成员字段之前调用 <a class="reference internal" href="gcsupport.xhtml#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_UnTrack()</span></code></a>。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo_dealloc</span><span class="p">(</span><span class="n">foo_object</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后，如果该类型是堆分配的 (<a class="reference internal" href="#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code></a>)，则在调用类型释放器后，释放器应释放对其类型对象的所有引用 (通过 <a class="reference internal" href="refcounting.xhtml#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a>)。 为了避免悬空指针，建议的实现方式如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo_dealloc</span><span class="p">(</span><span class="n">foo_object</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">tp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// free references and buffers here</span>
<span class="w">    </span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_vectorcall_offset">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_vectorcall_offset</span></span></span><br /></dt>
<dd><p>一个相对使用 <a class="reference internal" href="call.xhtml#vectorcall"><span class="std std-ref">vectorcall 协议</span></a> 实现调用对象的实例级函数的可选的偏移量，这是一种比简单的 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> 更有效的替代选择。</p>
<p>该字段仅在设置了 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 旗标时使用。 在此情况下，它必须为一个包含 <a class="reference internal" href="call.xhtml#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a> 指针实例中的偏移量的正整数。</p>
<p><em>vectorcallfunc</em> 指针可能为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在这种情况下实例的行为就像 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 没有被设置一样：调用实例操作会回退至 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>。</p>
<p>任何设置了 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code> 的类也必须设置 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> 并确保其行为与 <em>vectorcallfunc</em> 函数一致。 这可以通过将 <em>tp_call</em> 设为 <a class="reference internal" href="call.xhtml#c.PyVectorcall_Call" title="PyVectorcall_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyVectorcall_Call()</span></code></a> 来实现。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>在 3.8 版之前，这个槽位被命名为 <code class="docutils literal notranslate"><span class="pre">tp_print</span></code>。 在 Python 2.x 中，它被用于打印到文件。 在 Python 3.0 至 3.7 中，它没有被使用。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>在 3.12 版之前，不推荐 <a class="reference internal" href="#heap-types"><span class="std std-ref">可变堆类型</span></a> 实现 vectorcall 协议。 当用户在 Python 代码中设置 <a class="reference internal" href="../reference/datamodel.xhtml#object.__call__" title="object.__call__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__call__</span></code></a> 时，只有 <em>tp_call</em> 会被更新，很可能使它与 vectorcall 函数不一致。 自 3.12 起，设置 <code class="docutils literal notranslate"><span class="pre">__call__</span></code> 将通过清除 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 旗标来禁用 vectorcall 优化。</p>
</div>
<p><strong>继承：</strong></p>
<p>该字段总是会被继承。 但是，<a class="reference internal" href="#c.Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 旗标并不总是会被继承。 如果它未被设置，则子类不会使用 <a class="reference internal" href="call.xhtml#vectorcall"><span class="std std-ref">vectorcall</span></a>，除非显式地调用了 <a class="reference internal" href="call.xhtml#c.PyVectorcall_Call" title="PyVectorcall_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyVectorcall_Call()</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_getattr">
<a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><span class="n"><span class="pre">getattrfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_getattr</span></span></span><br /></dt>
<dd><p>一个指向获取属性字符串函数的可选指针。</p>
<p>该字段已弃用。当它被定义时，应该和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a></p>
<p>该字段会被子类和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 所继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时该子类型将从它的基类型同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_setattr">
<a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><span class="n"><span class="pre">setattrfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_setattr</span></span></span><br /></dt>
<dd><p>一个指向函数以便设置和删除属性的可选指针。</p>
<p>该字段已弃用。当它被定义时，应该和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 指向同一个函数，但接受一个C字符串参数表示属性名，而不是Python字符串对象。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a></p>
<p>该字段会被子类型和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 所继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时该子类型将同时从它的基类型继承 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_as_async">
<a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><span class="n"><span class="pre">PyAsyncMethods</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_as_async</span></span></span><br /></dt>
<dd><p>指向一个包含仅与在 C 层级上实现 <a class="reference internal" href="../glossary.xhtml#term-awaitable"><span class="xref std std-term">awaitable</span></a> 和 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 协议的对象相关联的字段的附加结构体。 请参阅 <a class="reference internal" href="#async-structs"><span class="std std-ref">异步对象结构体</span></a> 了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span>在之前被称为 <code class="docutils literal notranslate"><span class="pre">tp_compare</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tp_reserved</span></code>。</p>
</div>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_async</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_repr">
<a class="reference internal" href="#c.reprfunc" title="reprfunc"><span class="n"><span class="pre">reprfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_repr</span></span></span><br /></dt>
<dd><p id="index-1">一个实现了内置函数 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 的函数的可选指针。</p>
<p>该签名与 <a class="reference internal" href="object.xhtml#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_repr</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>该函数必须返回一个字符串或 Unicode 对象。 在理想情况下，该函数应当返回一个字符串，当将其传给 <a class="reference internal" href="../library/functions.xhtml#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 时，只要有合适的环境，就会返回一个具有相同值的对象。 如果这不可行，则它应当返回一个以 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> 开头并以 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> 结尾的可被用来推断出对象的类型和值的字符串。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>如果未设置该字段，则返回 <code class="docutils literal notranslate"><span class="pre">&lt;%s</span> <span class="pre">object</span> <span class="pre">at</span> <span class="pre">%p&gt;</span></code> 形式的字符串，其中 <code class="docutils literal notranslate"><span class="pre">%s</span></code> 将替换为类型名称，<code class="docutils literal notranslate"><span class="pre">%p</span></code> 将替换为对象的内存地址。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_as_number">
<a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_as_number</span></span></span><br /></dt>
<dd><p>指向一个附加结构体的指针，其中包含只与执行数字协议的对象相关的字段。 这些字段的文档参见 <a class="reference internal" href="#number-structs"><span class="std std-ref">数字对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_as_sequence">
<a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_as_sequence</span></span></span><br /></dt>
<dd><p>指向一个附加结构体的指针，其中包含只与执行序列协议的对象相关的字段。 这些字段的文档见 <a class="reference internal" href="#sequence-structs"><span class="std std-ref">序列对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_as_mapping">
<a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><span class="n"><span class="pre">PyMappingMethods</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_as_mapping</span></span></span><br /></dt>
<dd><p>指向一个附加结构体的指针，其中包含只与执行映射协议的对象相关的字段。 这些字段的文档见 <a class="reference internal" href="#mapping-structs"><span class="std std-ref">映射对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a> 字段不会继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_hash">
<a class="reference internal" href="#c.hashfunc" title="hashfunc"><span class="n"><span class="pre">hashfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_hash</span></span></span><br /></dt>
<dd><p id="index-2">一个指向实现了内置函数 <a class="reference internal" href="../library/functions.xhtml#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 的函数的可选指针。</p>
<p>其签名与 <a class="reference internal" href="object.xhtml#c.PyObject_Hash" title="PyObject_Hash"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Hash()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_hash_t</span><span class="w"> </span><span class="nf">tp_hash</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-1</span></code> 不应作为正常返回值被返回；当计算哈希值过程中发生错误时，函数应设置一个异常并返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p>当该字段（<em>和</em> <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>）都未设置，尝试对该对象取哈希会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。这与将其设为 <a class="reference internal" href="object.xhtml#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a> 相同。</p>
<p>此字段可被显式设为 <a class="reference internal" href="object.xhtml#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a> 以阻止从父类型继承哈希方法。在 Python 层面这被解释为 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 的等价物，使得 <code class="docutils literal notranslate"><span class="pre">isinstance(o,</span> <span class="pre">collections.Hashable)</span></code> 正确返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>.。请注意反过来也是如此：在 Python 层面设置一个类的 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 会使得 <code class="docutils literal notranslate"><span class="pre">tp_hash</span></code> 槽位被设置为 <a class="reference internal" href="object.xhtml#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a></p>
<p>该字段会被子类型同 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_call">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><span class="n"><span class="pre">ternaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_call</span></span></span><br /></dt>
<dd><p>一个可选的实现对象调用的指向函数的指针。 如果对象不是可调用对象则该值应为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 其签名与 <a class="reference internal" href="call.xhtml#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_call</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwargs</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_str">
<a class="reference internal" href="#c.reprfunc" title="reprfunc"><span class="n"><span class="pre">reprfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_str</span></span></span><br /></dt>
<dd><p>一个可选的实现内置 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 操作的函数的指针。 （请注意 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 现在是一个类型，<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 是调用该类型的构造器。 该构造器将调用 <a class="reference internal" href="object.xhtml#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 执行实际操作，而 <a class="reference internal" href="object.xhtml#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 将调用该处理器。）</p>
<p>其签名与 <a class="reference internal" href="object.xhtml#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_str</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>该函数必须返回一个字符串或 Unicode 对象。 它应当是一个“友好”的对象字符串表示形式，因为这就是要在 <a class="reference internal" href="../library/functions.xhtml#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 函数中与其他内容一起使用的表示形式。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>当未设置该字段时，将调用 <a class="reference internal" href="object.xhtml#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a> 来返回一个字符串表示形式。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_getattro">
<a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><span class="n"><span class="pre">getattrofunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_getattro</span></span></span><br /></dt>
<dd><p>一个指向获取属性字符串函数的可选指针。</p>
<p>其签名与 <a class="reference internal" href="object.xhtml#c.PyObject_GetAttr" title="PyObject_GetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetAttr()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_getattro</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</pre></div>
</div>
<p>可以方便地将该字段设为 <a class="reference internal" href="object.xhtml#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>，它实现了查找对象属性的通常方式。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a></p>
<p>该字段会被子类同 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 使用 <a class="reference internal" href="object.xhtml#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_setattro">
<a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><span class="n"><span class="pre">setattrofunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_setattro</span></span></span><br /></dt>
<dd><p>一个指向函数以便设置和删除属性的可选指针。</p>
<p>其签名与 <a class="reference internal" href="object.xhtml#c.PyObject_SetAttr" title="PyObject_SetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetAttr()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_setattro</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>此外，还必须支持将 <em>value</em> 设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 来删除属性。 通常可以方便地将该字段设为 <a class="reference internal" href="object.xhtml#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code></a>，它实现了设备对象属性的通常方式。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a></p>
<p>该字段会被子类型同 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 使用 <a class="reference internal" href="object.xhtml#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_as_buffer">
<a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><span class="n"><span class="pre">PyBufferProcs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_as_buffer</span></span></span><br /></dt>
<dd><p>指向一个包含只与实现缓冲区接口的对象相关的字段的附加结构体的指针。 这些字段的文档参见 <a class="reference internal" href="#buffer-structs"><span class="std std-ref">缓冲区对象结构体</span></a>。</p>
<p><strong>继承：</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a> 字段不会被继承，但所包含的字段会被单独继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_flags">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_flags</span></span></span><br /></dt>
<dd><p>该字段是针对多个旗标的位掩码。 某些旗标指明用于特定场景的变化语义；另一些旗标则用于指明类型对象（或通过 <a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a> 引用的扩展结构体）中的特定字段，它们在历史上并不总是有效；如果这样的旗标位是清晰的，则它所保护的类型字段必须不可被访问并且必须被视为具有零或 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值。</p>
<p><strong>继承：</strong></p>
<p>这个字段的继承很复杂。 大多数旗标位都是单独继承的，也就是说，如果基类型设置了一个旗标位，则子类型将继承该旗标位。 从属于扩展结构体的旗标位仅在扩展结构体被继承时才会被继承，也就是说，基类型的旗标位值会与指向扩展结构体的指针一起被拷贝到子类型中。 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位会与 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 字段一起被继承，也就是说，如果 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位在子类型中被清空并且子类型中的 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 字段存在并具有 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值。 .. XXX 那么大多数旗标位 <em>真的</em> 都是单独继承的吗？</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 使用 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_DEFAULT</span> <span class="pre">|</span> <span class="pre">Py_TPFLAGS_BASETYPE</span></code>。</p>
<p><strong>位掩码:</strong></p>
<p>目前定义了以下位掩码；可以使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> 运算符对它们进行 OR 运算以形成 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 字段的值。 宏 <a class="reference internal" href="type.xhtml#c.PyType_HasFeature" title="PyType_HasFeature"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_HasFeature()</span></code></a> 接受一个类型和一个旗标值 <em>tp</em> 和 <em>f</em>，并检查 <code class="docutils literal notranslate"><span class="pre">tp-&gt;tp_flags</span> <span class="pre">&amp;</span> <span class="pre">f</span></code> 是否为非零值。</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_HEAPTYPE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></span></span><br /></dt>
<dd><p>当类型对象本身在堆上被分配时会设置这个比特位，例如，使用 <a class="reference internal" href="type.xhtml#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a> 动态创建的类型。 在此情况下，其实例的 <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_type</span></code></a> 字段会被视为指向该类型的引用，而类型对象将在一个新实例被创建时执行 INCREF，并在实例被销毁时执行 DECREF（这不会应用于子类型的实例；只有实例的 ob_type 所引用的类型会执行 INCREF 和 DECREF）。 堆类型应当也 <a class="reference internal" href="gcsupport.xhtml#supporting-cycle-detection"><span class="std std-ref">支持垃圾回收</span></a> 因为它们会形成对它们自己的模块对象的循环引用。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_BASETYPE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_BASETYPE</span></span></span><br /></dt>
<dd><p>当此类型可被用作另一个类型的基类型时该比特位将被设置。 如果该比特位被清除，则此类型将无法被子类型化（类似于 Java 中的 &quot;final&quot; 类）。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_READY">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_READY</span></span></span><br /></dt>
<dd><p>当此类型对象通过 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 被完全实例化时该比特位将被设置。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_READYING">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_READYING</span></span></span><br /></dt>
<dd><p>当 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 处在初始化此类型对象过程中时该比特位将被设置。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_HAVE_GC">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_HAVE_GC</span></span></span><br /></dt>
<dd><p>当对象支持垃圾回收时会设置这个旗标位。 如果设置了这个位，则实例必须使用 <a class="reference internal" href="gcsupport.xhtml#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_GC_New</span></code></a> 来创建并使用 <a class="reference internal" href="gcsupport.xhtml#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> 来销毁。 更多信息参见 <a class="reference internal" href="gcsupport.xhtml#supporting-cycle-detection"><span class="std std-ref">使对象类型支持循环垃圾回收</span></a>。 这个位还会假定类型对象中存在 GC 相关字段 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a></p>
<p><a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位会与 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 字段一起被继承，也就是说，如果 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位在子类型中被清空并且子类型中的 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 字段存在并具有 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值的话。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_DEFAULT">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_DEFAULT</span></span></span><br /></dt>
<dd><p>这是一个从属于类型对象及其扩展结构体的存在的所有位的位掩码。 目前，它包括以下的位: <code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_STACKLESS_EXTENSION</span></code>。</p>
<p><strong>继承：</strong></p>
<p>？？？</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_METHOD_DESCRIPTOR">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_METHOD_DESCRIPTOR</span></span></span><br /></dt>
<dd><p>这个位指明对象的行为类似于未绑定方法。</p>
<p>如果为 <code class="docutils literal notranslate"><span class="pre">type(meth)</span></code> 设置了该旗标，那么：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">meth.__get__(obj,</span> <span class="pre">cls)(*args,</span> <span class="pre">**kwds)</span></code> (其中 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 不为 None) 必须等价于 <code class="docutils literal notranslate"><span class="pre">meth(obj,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meth.__get__(None,</span> <span class="pre">cls)(*args,</span> <span class="pre">**kwds)</span></code> 必须等价于 <code class="docutils literal notranslate"><span class="pre">meth(*args,</span> <span class="pre">**kwds)</span></code>。</p></li>
</ul>
<p>此旗标为 <code class="docutils literal notranslate"><span class="pre">obj.meth()</span></code> 这样的典型方法调用启用优化：它将避免为 <code class="docutils literal notranslate"><span class="pre">obj.meth</span></code> 创建临时的“绑定方法”对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<p><strong>继承：</strong></p>
<p>此旗标绝不会被没有设置 <a class="reference internal" href="#c.Py_TPFLAGS_IMMUTABLETYPE" title="Py_TPFLAGS_IMMUTABLETYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_IMMUTABLETYPE</span></code></a> 旗标的类型所继承。 对于扩展类型，当 <a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a> 被继承时它也会被继承。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_MANAGED_DICT">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_MANAGED_DICT</span></span></span><br /></dt>
<dd><p>该比特位表示类的实例具有 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 属性，并且该字典的空间是由 VM 管理的。</p>
<p>如果设置了该旗标，则 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 也应当被设置。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p><strong>继承：</strong></p>
<p>此旗标将被继承，除非某个超类设置了 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> 字段。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_MANAGED_WEAKREF">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_MANAGED_WEAKREF</span></span></span><br /></dt>
<dd><p>该比特位表示类的实例应当是可被弱引用的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p><strong>继承：</strong></p>
<p>此旗标将被继承，除非某个超类设置了 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> 字段。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_ITEMS_AT_END">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_ITEMS_AT_END</span></span></span><br /></dt>
<dd><p>仅适用于可变大小的类型，也就是说，具有非零 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 值的类型。</p>
<p>表示此类型的实例的可变大小部分位于该实例内存区的末尾，其偏移量为 <code class="docutils literal notranslate"><span class="pre">Py_TYPE(obj)-&gt;tp_basicsize</span></code> (每个子类可能不一样)。</p>
<p>当设置此旗标时，请确保所有子类要么使用此内存布局，要么不是可变大小。 Python 不会检查这一点。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p><strong>继承：</strong></p>
<p>这个旗标会被继承。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_LONG_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_LONG_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_LIST_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_LIST_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_TUPLE_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_TUPLE_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_BYTES_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_BYTES_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_UNICODE_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_UNICODE_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_DICT_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_DICT_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_BASE_EXC_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_BASE_EXC_SUBCLASS</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_TYPE_SUBCLASS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_TYPE_SUBCLASS</span></span></span><br /></dt>
<dd><p>这些旗标被 <a class="reference internal" href="long.xhtml#c.PyLong_Check" title="PyLong_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_Check()</span></code></a> 等函数用来快速确定一个类型是否为内置类型的子类；这样的专用检测比泛用检测如 <a class="reference internal" href="object.xhtml#c.PyObject_IsInstance" title="PyObject_IsInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_IsInstance()</span></code></a> 要更快速。 继承自内置类型的自定义类型应当正确地设置其 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a>，否则与这样的类型进行交互的代码将因所使用的检测种类而出现不同的行为。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_HAVE_FINALIZE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_HAVE_FINALIZE</span></span></span><br /></dt>
<dd><p>当类型结构体中存在 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 槽位时会设置这个比特位。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.8 版本弃用: </span>此旗标已不再是必要的，因为解释器会假定类型结构体中总是存在 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 槽位。</p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_HAVE_VECTORCALL">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></span></span><br /></dt>
<dd><p>当类实现了 <a class="reference internal" href="call.xhtml#vectorcall"><span class="std std-ref">vectorcall 协议</span></a> 时会设置这个比特位。 请参阅 <a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a> 了解详情。</p>
<p><strong>继承：</strong></p>
<p>如果继承了 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> 则也会继承这个比特位。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在当类的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法被重新赋值时该旗标将从类中移除。</p>
<p>现在该旗标能被可变类所继承。</p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_IMMUTABLETYPE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_IMMUTABLETYPE</span></span></span><br /></dt>
<dd><p>不可变的类型对象会设置这个比特位：类型属性无法被设置或删除。</p>
<p><a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 会自动对 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a> 应用这个旗标。</p>
<p><strong>继承：</strong></p>
<p>这个旗标不会被继承。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_DISALLOW_INSTANTIATION">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_DISALLOW_INSTANTIATION</span></span></span><br /></dt>
<dd><p>不允许创建此类型的实例：将 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 设为 NULL 并且不会在类型字符中创建 <code class="docutils literal notranslate"><span class="pre">__new__</span></code> 键。</p>
<p>这个旗标必须在创建该类型之前设置，而不是在之后。 例如，它必须在该类型调用 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 之前被设置。</p>
<p>如果 <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a> 为 NULL 或者 <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code> 和 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 为 NULL 则该旗标会在 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a> 上自动设置。</p>
<p><strong>继承：</strong></p>
<p>这个旗标不会被继承。 但是，子类将不能被实例化，除非它们提供了不为 NULL 的 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> (这只能通过 C API 实现)。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>要禁止直接实例化一个类但允许实例化其子类 (例如对于 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>)，请勿使用此旗标。 替代的做法是，让 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 只对子类可用。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_MAPPING">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_MAPPING</span></span></span><br /></dt>
<dd><p>这个比特位指明该类的实例可以在被用作 <a class="reference internal" href="../reference/compound_stmts.xhtml#match"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">match</span></code></a> 代码块的目标时匹配映射模式。 它会在注册或子类化 <a class="reference internal" href="../library/collections.abc.xhtml#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 时自动设置，并在注册 <a class="reference internal" href="../library/collections.abc.xhtml#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 时取消设置。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MAPPING</span></code></a> 和 <a class="reference internal" href="#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_SEQUENCE</span></code></a> 是互斥的；同时启用两个旗标将导致报错。</p>
</div>
<p><strong>继承：</strong></p>
<p>这个旗标将被尚未设置 <a class="reference internal" href="#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_SEQUENCE</span></code></a> 的类型所继承。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a><span class="link-target"> [https://peps.python.org/pep-0634/]</span> —— 结构化模式匹配：规范</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_SEQUENCE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_SEQUENCE</span></span></span><br /></dt>
<dd><p>这个比特位指明该类的实例可以在被用作 <a class="reference internal" href="../reference/compound_stmts.xhtml#match"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">match</span></code></a> 代码块的目标时匹配序列模式。 它会在注册或子类化 <a class="reference internal" href="../library/collections.abc.xhtml#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 时自动设置，并在注册 <a class="reference internal" href="../library/collections.abc.xhtml#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 时取消设置。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MAPPING</span></code></a> 和 <a class="reference internal" href="#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_SEQUENCE</span></code></a> 是互斥的；同时启用两个旗标将导致报错。</p>
</div>
<p><strong>继承：</strong></p>
<p>这个旗标将被尚未设置 <a class="reference internal" href="#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MAPPING</span></code></a> 的类型所继承。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a><span class="link-target"> [https://peps.python.org/pep-0634/]</span> —— 结构化模式匹配：规范</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_TPFLAGS_VALID_VERSION_TAG">
<span class="sig-name descname"><span class="n"><span class="pre">Py_TPFLAGS_VALID_VERSION_TAG</span></span></span><br /></dt>
<dd><p>内部使用。 请不要设置或取消设置此旗标。 用于指明一个类具有被修改的调用 <a class="reference internal" href="type.xhtml#c.PyType_Modified" title="PyType_Modified"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Modified()</span></code></a></p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>这个旗标存在于头文件中，但是属于内部特性而不应直接使用。 它将在未来的 CPython 版本中被移除</p>
</div>
</dd></dl>

</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_doc">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_doc</span></span></span><br /></dt>
<dd><p>一个可选的指向给出该类型对象的文档字符串的以 NUL 结束的 C 字符串的指针。 该指针被暴露为类型和类型实例上的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 属性。</p>
<p><strong>继承：</strong></p>
<p>这个字段 <em>不会</em> 被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_traverse">
<a class="reference internal" href="gcsupport.xhtml#c.traverseproc" title="traverseproc"><span class="n"><span class="pre">traverseproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_traverse</span></span></span><br /></dt>
<dd><p>一个可选的指向针对垃圾回收器的遍历函数的指针。 该指针仅会在设置了 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位时被使用。 函数签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_traverse</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">visitproc</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
<p>有关 Python 垃圾回收方案的更多信息可在 <a class="reference internal" href="gcsupport.xhtml#supporting-cycle-detection"><span class="std std-ref">使对象类型支持循环垃圾回收</span></a> 一节中查看。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 指针被垃圾回收器用来检测循环引用。 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 函数的典型实现会在实例的每个属于该实例所拥有的 Python 对象的成员上简单地调用 <a class="reference internal" href="gcsupport.xhtml#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a>。 例如，以下是来自 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code> 扩展模块的函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">local_traverse()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">local_traverse</span><span class="p">(</span><span class="n">localobject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">visitproc</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意 <a class="reference internal" href="gcsupport.xhtml#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a> 仅能在可以参加循环引用的成员上被调用。 虽然还存在一个 <code class="docutils literal notranslate"><span class="pre">self-&gt;key</span></code> 成员，但它只能为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 Python 字符串因而不能成为循环引用的一部分。</p>
<p>在另一方面，即使你知道某个成员永远不会成为循环引用的一部分，作为调试的辅助你仍然可能想要访问它因此 <a class="reference internal" href="../library/gc.xhtml#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模块的 <a class="reference internal" href="../library/gc.xhtml#gc.get_referents" title="gc.get_referents"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_referents()</span></code></a> 函数将会包括它。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>当实现 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 时，只有实例所 <em>拥有</em> 的成员 (就是有指向它们的 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">强引用</span></a>) 才必须被访问。 举例来说，如果一个对象通过 <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a> 槽位支持弱引用，那么支持链表 (<em>tp_weaklist</em> 所指向的对象) 的指针就 <strong>不能</strong> 被访问因为实例并不直接拥有指向自身的弱引用 (弱引用列表被用来支持弱引用机制，但实例没有指向其中的元素的强引用，因为即使实例还存在它们也允许被删除)。</p>
</div>
<p>Note that <a class="reference internal" href="gcsupport.xhtml#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a> requires the <em>visit</em> and <em>arg</em> parameters to
<code class="xref c c-func docutils literal notranslate"><span class="pre">local_traverse()</span></code> to have these specific names; don't name them just
anything.</p>
<p><a class="reference internal" href="#heap-types"><span class="std std-ref">堆分配类型</span></a> 的实例会持有一个指向其类型的引用。 因此它们的遍历函数必须要么访问 <a class="reference internal" href="structures.xhtml#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code></a>，要么通过调用其他堆分配类型（例如一个堆分配超类）的 <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> 将此任务委托出去。 如果没有这样做，类型对象可能不会被垃圾回收。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>堆分配类型应当访问 <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code>。 在较早的 Python 版本中，由于 <a class="reference external" href="https://bugs.python.org/issue40217">bug 40217</a><span class="link-target"> [https://bugs.python.org/issue40217]</span>，这样做可能会导致在超类中发生崩溃。</p>
</div>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a></p>
<p>该字段会与 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 和 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位一起被子类型所继承：如果旗标位, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 在子类型中均为零则它们都将从基类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_clear">
<a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><span class="n"><span class="pre">inquiry</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_clear</span></span></span><br /></dt>
<dd><p>一个可选的指向针对垃圾回收器的清理函数的指针。 该指针仅会在设置了 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位时被使用。 函数签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_clear</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 成员函数被用来打破垃圾回收器在循环垃圾中检测到的循环引用。 总的来说，系统中的所有 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数必须合到一起以打破所有引用循环。 这是个微妙的问题，并且如有任何疑问都需要提供 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数。 例如，元组类型不会实现 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数，因为有可能证明完全用元组是不会构成循环引用的。 因此其他类型的 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数必须足以打破任何包含元组的循环。 这不是立即能明确的，并且很少会有避免实现 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 的适当理由。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 的实现应当丢弃实例指向其成员的可能为 Python 对象的引用，并将指向这些成员的指针设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，如下面的例子所示:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">local_clear</span><span class="p">(</span><span class="n">localobject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>应当使用 <a class="reference internal" href="refcounting.xhtml#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_CLEAR()</span></code></a> 宏，因为清除引用是很微妙的：指向被包含对象的引用必须在指向被包含对象的指针被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 之后才能被释放 (通过 <a class="reference internal" href="refcounting.xhtml#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a>)。 这是因为释放引用可能会导致被包含的对象变成垃圾，触发一连串的回收活动，其中可能包括发起调用任意 Python 代码 (由于关联到被包含对象的终结器或弱引用回调)。 如果这样的代码有可能再次引用 <em>self</em>，那么这时指向被包含对象的指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 就是非常重要的，这样 <em>self</em> 就知道被包含对象不可再被使用。 <a class="reference internal" href="refcounting.xhtml#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_CLEAR()</span></code></a> 宏将以安全的顺序执行此操作。</p>
<p>请注意 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 并非 <em>总是</em> 在实例被取消分配之前被调用。 例如，当引用计数足以确定对象不再被使用时，就不会涉及循环垃圾回收器而是直接调用 <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a>。</p>
<p>因为 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 函数的目的是打破循环引用，所以不需要清除所包含的对象如 Python 字符串或 Python 整数，它们无法参与循环引用。 另一方面，清除所包含的全部 Python 对象，并编写类型的 <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a> 函数来发起调用 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 也很方便。</p>
<p>有关 Python 垃圾回收方案的更多信息可在 <a class="reference internal" href="gcsupport.xhtml#supporting-cycle-detection"><span class="std std-ref">使对象类型支持循环垃圾回收</span></a> 一节中查看。</p>
<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a></p>
<p>该字段会与 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位一起被子类型所继承：如果旗标位, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 在子类型中均为零则它们都将从基类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_richcompare">
<a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><span class="n"><span class="pre">richcmpfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_richcompare</span></span></span><br /></dt>
<dd><p>一个可选的指向富比较函数的指针，函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_richcompare</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>第一个形参将保证为 <a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 所定义的类型的实例。</p>
<p>该函数应当返回比较的结果 (通常为 <code class="docutils literal notranslate"><span class="pre">Py_True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Py_False</span></code>)。 如果未定义比较运算，它必须返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，如果发生了其他错误则它必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并设置一个异常条件。</p>
<p>以下常量被定义用作 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="object.xhtml#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_RichCompare()</span></code></a> 的第三个参数：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>常量</p></th>
<th class="head"><p>对照</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.Py_LT">
<span class="sig-name descname"><span class="n"><span class="pre">Py_LT</span></span></span><br /></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.Py_LE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_LE</span></span></span><br /></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.Py_EQ">
<span class="sig-name descname"><span class="n"><span class="pre">Py_EQ</span></span></span><br /></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.Py_NE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_NE</span></span></span><br /></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.Py_GT">
<span class="sig-name descname"><span class="n"><span class="pre">Py_GT</span></span></span><br /></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.Py_GE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_GE</span></span></span><br /></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
</tbody>
</table>
<p>定义以下宏是为了简化编写丰富的比较函数：</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_RETURN_RICHCOMPARE">
<span class="sig-name descname"><span class="n"><span class="pre">Py_RETURN_RICHCOMPARE</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">VAL_A</span></span>, <span class="n"><span class="pre">VAL_B</span></span>, <span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>从该函数返回 <code class="docutils literal notranslate"><span class="pre">Py_True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Py_False</span></code>，这取决于比较的结果。 VAL_A 和 VAL_B 必须是可通过 C 比较运算符进行排序的（例如，它们可以为 C 整数或浮点数）。 第三个参数指明所请求的运算，与 <a class="reference internal" href="object.xhtml#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_RichCompare()</span></code></a> 的参数一样。</p>
<p>返回值是一个新的 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">strong reference</span></a>。</p>
<p>发生错误时，将设置异常并从该函数返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<p><strong>继承：</strong></p>
<p>分组: <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a></p>
<p>该字段会被子类型同 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a> 一起继承：当子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a> 均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时子类型将同时继承 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 和 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 提供了一个 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a> 的实现，它可以被继承。 但是，如果只定义了 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>，则不会使用被继承的函数并且该类型的实例将无法参加任何比较。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_weaklistoffset">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_weaklistoffset</span></span></span><br /></dt>
<dd><p>虽然此字段仍然受到支持，但是如果可能就应当改用 <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_WEAKREF</span></code></a>。</p>
<p>如果此类型的实例是可被弱引用的，则该字段将大于零并包含在弱引用列表头的实例结构体中的偏移量（忽略 GC 头，如果存在的话）；该偏移量将被 <a class="reference internal" href="weakref.xhtml#c.PyObject_ClearWeakRefs" title="PyObject_ClearWeakRefs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_ClearWeakRefs()</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">PyWeakref_*</span></code> 函数使用。 实例结构体需要包括一个 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> 类型的字段并初始化为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>不要将该字段与 <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a> 混淆；后者是指向类型对象本身的弱引用的列表头。</p>
<p>同时设置 <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_WEAKREF</span></code></a> 位和 <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a> 将导致报错。</p>
<p><strong>继承：</strong></p>
<p>该字段会被子类型继承，但注意参阅下面列出的规则。 子类型可以覆盖此偏移量；这意味着子类型将使用不同于基类型的弱引用列表。 由于列表头总是通过 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> 找到的，所以这应该不成问题。</p>
<p><strong>默认：</strong></p>
<p>如果在 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> 字段中设置了 <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_WEAKREF</span></code></a> 位，则 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> 将被设为负值，用以表明使用此字段是不安全的。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_iter">
<a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><span class="n"><span class="pre">getiterfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_iter</span></span></span><br /></dt>
<dd><p>一个可选的指向函数的指针，该函数返回对象的 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a>。 它的存在通常表明该类型的实例为 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a> (尽管序列在没有此函数的情况下也可能为可迭代对象)。</p>
<p>此函数的签名与 <a class="reference internal" href="object.xhtml#c.PyObject_GetIter" title="PyObject_GetIter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetIter()</span></code></a> 的相同:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_iter</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_iternext">
<a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><span class="n"><span class="pre">iternextfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_iternext</span></span></span><br /></dt>
<dd><p>一个可选的指向函数的指针，该函数返回 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 中的下一项。 其签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_iternext</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>当该迭代器被耗尽时，它必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；<a class="reference internal" href="../library/exceptions.xhtml#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常可能会设置也可能不设置。 当发生另一个错误时，它也必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 它的存在表明该类型的实际是迭代器。</p>
<p>迭代器类型也应当定义 <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 函数，并且该函数应当返回迭代器实例本身（而不是新的迭代器实例）。</p>
<p>此函数的签名与 <a class="reference internal" href="iter.xhtml#c.PyIter_Next" title="PyIter_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Next()</span></code></a> 的相同。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_methods">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyMethodDef" title="PyMethodDef"><span class="n"><span class="pre">PyMethodDef</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_methods</span></span></span><br /></dt>
<dd><p>一个可选的指向 <a class="reference internal" href="structures.xhtml#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 结构体的以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 结束的静态数组的指针，它声明了此类型的常规方法。</p>
<p>对于该数组中的每一项，都会向类型的字典 (参见下面的 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>) 添加一个包含方法描述器的条目。</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（方法是通过不同的机制来继承的）。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_members">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyMemberDef" title="PyMemberDef"><span class="n"><span class="pre">PyMemberDef</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_members</span></span></span><br /></dt>
<dd><p>一个可选的指向 <a class="reference internal" href="structures.xhtml#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> 结构体的以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 结束的静态数组的指针，它声明了此类型的常规数据成员（字段或槽位）。</p>
<p>对于该数组中的每一项，都会向类型的字典 (参见下面的 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>) 添加一个包含方法描述器的条目。</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（成员是通过不同的机制来继承的）。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_getset">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyGetSetDef" title="PyGetSetDef"><span class="n"><span class="pre">PyGetSetDef</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_getset</span></span></span><br /></dt>
<dd><p>一个可选的指向 <a class="reference internal" href="structures.xhtml#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> 结构体的以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 结束的静态数组的指针，它声明了此类型的实例中的被计算属性。</p>
<p>对于该数组中的每一项，都会向类型的字典 (参见下面的 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>) 添加一个包含读写描述器的条目。</p>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（被计算属性是通过不同的机制来继承的）。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_base">
<a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_base</span></span></span><br /></dt>
<dd><p>一个可选的指向类型特征属性所继承的基类型的指针。 在这个层级上，只支持单继承；多重继承需要通过调用元类型动态地创建类型对象。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>槽位初始化需要遵循初始化全局变量的规则。 C99 要求初始化器为“地址常量”。 隐式转换为指针的函数指示器如 <a class="reference internal" href="type.xhtml#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericNew()</span></code></a> 都是有效的 C99 地址常量。</p>
<p>但是，生成地址常量并不需要应用于非静态变量如 <code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 的单目运算符 '&amp;'。 编译器可能支持该运算符（如 gcc），但 MSVC 则不支持。 这两种编译器在这一特定行为上都是严格符合标准的。</p>
<p>因此，应当在扩展模块的初始化函数中设置 <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a>。</p>
</div>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型继承（显然）。</p>
<p><strong>默认：</strong></p>
<p>该字段默认为 <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code> (对 Python 程序员来说即 <a class="reference internal" href="../library/functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 类型)。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_dict">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_dict</span></span></span><br /></dt>
<dd><p>类型的字典将由 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 存储到这里。</p>
<p>该字段通常应当在 PyType_Ready 被调用之前初始化为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；它也可以初始化为一个包含类型初始属性的字典。 一旦 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 完成类型的初始化，该类型的额外属性只有在它们不与被重载的操作 (如 <a class="reference internal" href="../reference/datamodel.xhtml#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>) 相对应的情况下才会被添加到该字典中。 一旦类型的初始化结束，该字段就应被视为是只读的。</p>
<p>某些类型不会将它们的字典存储在该槽位中。 请使用 <a class="reference internal" href="type.xhtml#c.PyType_GetDict" title="PyType_GetDict"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetDict()</span></code></a> 来获取任意类型对应的字典。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>内部细节：对于静态内置类型，该值总是为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 这种类型的字典是存储在 <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code> 中。 请使用 <a class="reference internal" href="type.xhtml#c.PyType_GetDict" title="PyType_GetDict"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetDict()</span></code></a> 来获取任意类型的字典。</p>
</div>
<p><strong>继承：</strong></p>
<p>该字段不会被子类型所继承（但在这里定义的属性是通过不同的机制来继承的）。</p>
<p><strong>默认：</strong></p>
<p>如果该字段为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，<a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 将为它分配一个新字典。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>通过字典 C-API 使用 <a class="reference internal" href="dict.xhtml#c.PyDict_SetItem" title="PyDict_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyDict_SetItem()</span></code></a> 或修改 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> 是不安全的。</p>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_descr_get">
<a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><span class="n"><span class="pre">descrgetfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_descr_get</span></span></span><br /></dt>
<dd><p>一个可选的指向“描述器获取”函数的指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">tp_descr_get</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_descr_set">
<a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><span class="n"><span class="pre">descrsetfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_descr_set</span></span></span><br /></dt>
<dd><p>一个指向用于设置和删除描述器值的函数的选项指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_descr_set</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>将 <em>value</em> 参数设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 以删除该值。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_dictoffset">
<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_dictoffset</span></span></span><br /></dt>
<dd><p>虽然此字段仍然受到支持，但是如果可能就应当改用 <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_DICT</span></code></a>。</p>
<p>如果该类型的实例具有一个包含实例变量的字典，则此字段将为非零值并包含该实例变量字典的类型的实例的偏移量；该偏移量将由 <a class="reference internal" href="object.xhtml#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a> 使用。</p>
<p>不要将该字段与 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> 混淆；后者是由类型对象本身的属性组成的字典。</p>
<p>该值指定字典相对实例结构体开始位置的偏移量。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> 应当被视为是只读的。 用于获取指向字典调用 <a class="reference internal" href="object.xhtml#c.PyObject_GenericGetDict" title="PyObject_GenericGetDict"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetDict()</span></code></a> 的指针。 调用 <a class="reference internal" href="object.xhtml#c.PyObject_GenericGetDict" title="PyObject_GenericGetDict"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetDict()</span></code></a> 可能需要为字典分配内存，因此在访问对象上的属性时调用 <a class="reference internal" href="object.xhtml#c.PyObject_GetAttr" title="PyObject_GetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetAttr()</span></code></a> 可能会更有效率。</p>
<p>同时设置 <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_WEAKREF" title="Py_TPFLAGS_MANAGED_WEAKREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_WEAKREF</span></code></a> 位和 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> 将导致报错。</p>
<p><strong>继承：</strong></p>
<p>该字段会被子类型所继承。 子类型不应重写这个偏移量；这样做是不安全的，如果 C 代码试图在之前的偏移量上访问字典的话。 要正确地支持继承，请使用 <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_DICT</span></code></a>。</p>
<p><strong>默认：</strong></p>
<p>这个槽位没有默认值。 对于 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a>，如果该字段为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则不会为实例创建 <a class="reference internal" href="../library/stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>。</p>
<p>If the <a class="reference internal" href="#c.Py_TPFLAGS_MANAGED_DICT" title="Py_TPFLAGS_MANAGED_DICT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MANAGED_DICT</span></code></a> bit is set in the
<a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a> field, then
<a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">-1</span></code>, to indicate
that it is unsafe to use this field.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_init">
<a class="reference internal" href="#c.initproc" title="initproc"><span class="n"><span class="pre">initproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_init</span></span></span><br /></dt>
<dd><p>一个可选的指向实例初始化函数的指针。</p>
<p>此函数对应于类的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法。 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 一样，创建实例时不调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 是有可能的，并且通过再次调用实例的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法将其重新初始化也是有可能的。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_init</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwds</span><span class="p">);</span>
</pre></div>
</div>
<p>self 参数是将要初始化的实例；<em>args</em> 和 <em>kwds</em> 参数代表调用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 时传入的位置和关键字参数。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 函数如果不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，将在通过调用类型正常创建其实例时被调用，即在类型的 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数返回一个该类型的实例时。 如果 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数返回了一个不是原始类型的子类型的其他类型的实例，则 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 函数不会被调用；如果 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 返回了一个原始类型的子类型的实例，则该子类型的 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 将被调用。</p>
<p>成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，发生错误时则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并在错误上设置一个异常。and sets an exception on error.</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>对于 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a> 来说该字段没有默认值。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_alloc">
<a class="reference internal" href="#c.allocfunc" title="allocfunc"><span class="n"><span class="pre">allocfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_alloc</span></span></span><br /></dt>
<dd><p>指向一个实例分配函数的可选指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_alloc</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nitems</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>继承：</strong></p>
<p>该字段会被静态子类型继承，但不会被动态子类型（通过 class 语句创建的子类型）继承。</p>
<p><strong>默认：</strong></p>
<p>对于动态子类型，该字段总是会被设为 <a class="reference internal" href="type.xhtml#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>，以强制应用标准的堆分配策略。</p>
<p>对于静态子类型，<code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 将使用 <a class="reference internal" href="type.xhtml#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>。 这是适用于所有静态定义类型的推荐值。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_new">
<a class="reference internal" href="#c.newfunc" title="newfunc"><span class="n"><span class="pre">newfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_new</span></span></span><br /></dt>
<dd><p>一个可选的指向实例创建函数的指针。</p>
<p>函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">tp_new</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">subtype</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwds</span><span class="p">);</span>
</pre></div>
</div>
<p><em>subtype</em> 参数是被创建的对象的类型；<em>args</em> 和 <em>kwds</em> 参数表示调用类型时传入的位置和关键字参数。 请注意 <em>subtype</em> 不是必须与被调用的 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数所属的类型相同；它可以是该类型的子类型（但不能是完全无关的类型）。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 函数应当调用 <code class="docutils literal notranslate"><span class="pre">subtype-&gt;tp_alloc(subtype,</span> <span class="pre">nitems)</span></code> 来为对象分配空间，然后只执行绝对有必要的进一步初始化操作。 可以安全地忽略或重复的初始化操作应当放在 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 处理器中。 一个关键的规则是对于不可变类型来说，所有初始化操作都应当在 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 中发生，而对于可变类型，大部分初始化操作都应当推迟到 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 再执行。</p>
<p>设置 <a class="reference internal" href="#c.Py_TPFLAGS_DISALLOW_INSTANTIATION" title="Py_TPFLAGS_DISALLOW_INSTANTIATION"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_DISALLOW_INSTANTIATION</span></code></a> 旗标以禁止在 Python 中创建该类型的实例。</p>
<p><strong>继承：</strong></p>
<p>该字段会被子类型所继承，例外情况是它不会被 <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code> 的 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a> 所继承。</p>
<p><strong>默认：</strong></p>
<p>对于 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a> 该字段没有默认值。 这意味着如果槽位被定义为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则无法调用此类型来创建新的实例；应当存在 其他办法来创建实例，例如工厂函数等。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_free">
<a class="reference internal" href="#c.freefunc" title="freefunc"><span class="n"><span class="pre">freefunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_free</span></span></span><br /></dt>
<dd><p>一个可选的指向实例释放函数的指针。 函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tp_free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>一个兼容该签名的初始化器是 <a class="reference internal" href="memory.xhtml#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>。</p>
<p><strong>继承：</strong></p>
<p>该字段会被静态子类型继承，但不会被动态子类型（通过 class 语句创建的子类型）继承</p>
<p><strong>默认：</strong></p>
<p>在动态子类型中，该字段会被设为一个适合与 <a class="reference internal" href="type.xhtml#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a> 以及 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标位的值相匹配的释放器。</p>
<p>对于静态子类型，<code class="xref c c-data docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code> 将使用 <a class="reference internal" href="allocation.xhtml#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_is_gc">
<a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><span class="n"><span class="pre">inquiry</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_is_gc</span></span></span><br /></dt>
<dd><p>可选的指向垃圾回收器所调用的函数的指针。</p>
<p>垃圾回收器需要知道某个特定的对象是否可以被回收。在一般情况下，垃圾回收器只需要检查这个对象类型的 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 字段、以及 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 标识位即可做出判断；但是有一些类型同时混合包含了静态和动态分配的实例，其中静态分配的实例不应该也无法被回收。本函数为后者情况而设计：对于可被垃圾回收的实例，本函数应当返回 <code class="docutils literal notranslate"><span class="pre">1</span></code> ；对于不可被垃圾回收的实例，本函数应当返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">tp_is_gc</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>（此对象的唯一样例是类型本身。 元类型 <a class="reference internal" href="type.xhtml#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a> 定义了该函数来区分静态和 <a class="reference internal" href="#heap-types"><span class="std std-ref">动态分配的类型</span></a>。）</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<p><strong>默认：</strong></p>
<p>此槽位没有默认值。 如果该字段为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则将使用 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 作为相同功能的替代。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_bases">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_bases</span></span></span><br /></dt>
<dd><p>基类型的元组。</p>
<p>此字段应当被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并被视为只读。 Python 将在类型 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">初始化时</span></code></a> 填充它。</p>
<p>对于动态创建的类，可以使用 <code class="docutils literal notranslate"><span class="pre">Py_tp_bases</span></code> <a class="reference internal" href="type.xhtml#c.PyType_Slot" title="PyType_Slot"><code class="xref c c-type docutils literal notranslate"><span class="pre">槽位</span></code></a> 来代替 <a class="reference internal" href="type.xhtml#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases()</span></code></a> 的 <em>bases</em> 参数。 推荐使用参数形式。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>多重继承不适合静态定义的类型。 如果你将 <code class="docutils literal notranslate"><span class="pre">tp_bases</span></code> 设为一个元组，Python 将不会引发错误，但某些槽位将只从第一个基类型继承。</p>
</div>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_mro">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_mro</span></span></span><br /></dt>
<dd><p>包含基类型的扩展集的元组，以类型本身开始并以 <a class="reference internal" href="../library/functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 作为结束，使用方法解析顺序。</p>
<p>此字段应当被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并被视为只读。 Python 将在类型 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">初始化时</span></code></a> 填充它。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承；它是通过 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 计算得到的。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_cache">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_cache</span></span></span><br /></dt>
<dd><p>尚未使用。 仅供内部使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_subclasses">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_subclasses</span></span></span><br /></dt>
<dd><p>一组子类。 仅限内部使用的。 可能为无效的指针。</p>
<p>要获取子类的列表。 请调用 Python 方法 <a class="reference internal" href="../library/stdtypes.xhtml#class.__subclasses__" title="class.__subclasses__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasses__()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对于某些类型，该字段将不带有效的 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>。 类型已被改为 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 以指明这一点。</p>
</div>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_weaklist">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_weaklist</span></span></span><br /></dt>
<dd><p>弱引用列表头，用于指向该类型对象的弱引用。 不会被继承。 仅限内部使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>内部细节：对于静态内置类型这将总是为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，即使添加了弱引用也是如此。 每个弱引用都转而保存在 <code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span></code> 上。 请使用公共 C-API 或内部 <code class="docutils literal notranslate"><span class="pre">_PyObject_GET_WEAKREFS_LISTPTR()</span></code> 宏来避免此差异。</p>
</div>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_del">
<a class="reference internal" href="#c.destructor" title="destructor"><span class="n"><span class="pre">destructor</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_del</span></span></span><br /></dt>
<dd><p>该字段已被弃用。 请改用 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_version_tag">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_version_tag</span></span></span><br /></dt>
<dd><p>用于索引至方法缓存。 仅限内部使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_finalize">
<a class="reference internal" href="#c.destructor" title="destructor"><span class="n"><span class="pre">destructor</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_finalize</span></span></span><br /></dt>
<dd><p>一个可选的指向实例最终化函数的指针。 函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">tp_finalize</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>如果设置了 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>，解释器将在最终化特定实例时调用它一次。 它将由垃圾回收器调用（如果实例是单独循环引用的一部分）或是在对象被释放之前被调用。 不论是哪种方式，它都肯定会在尝试打破循环引用之前被调用，以确保它所操作的对象处于正常状态。</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 不应改变当前异常状态；因此，编写非关键终结器的推荐做法如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">local_finalize</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">error_type</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">error_value</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">error_traceback</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Save the current exception, if any. */</span>
<span class="w">    </span><span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_type</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">error_value</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">error_traceback</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ... */</span>

<span class="w">    </span><span class="cm">/* Restore the saved exception. */</span>
<span class="w">    </span><span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">error_type</span><span class="p">,</span><span class="w"> </span><span class="n">error_value</span><span class="p">,</span><span class="w"> </span><span class="n">error_traceback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>另外还需要注意，在应用垃圾回收机制的 Python 中，<a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a> 可以从任意 Python 线程被调用，而不仅是创建该对象的线程（如果对象成为引用计数循环的一部分，则该循环可能会被任何线程上的垃圾回收操作所回收）。 这对 Python API 调用来说不是问题，因为 tp_dealloc 调用所在的线程将持有全局解释器锁（GIL）。 但是，如果被销毁的对象又销毁了来自其他 C 或 C++ 库的对象，则应当小心确保在调用 tp_dealloc 的线程上销毁这些对象不会破坏这些库的任何资源。</p>
<p><strong>继承：</strong></p>
<p>此字段会被子类型继承。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>在 3.8 版之前必须设置 <a class="reference internal" href="#c.Py_TPFLAGS_HAVE_FINALIZE" title="Py_TPFLAGS_HAVE_FINALIZE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_FINALIZE</span></code></a> 旗标才能让该字段被使用。 现在已不再需要这样做。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>&quot;安全的对象最终化&quot; (<span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0442/"><strong>PEP 442</strong></a><span class="link-target"> [https://peps.python.org/pep-0442/]</span>)</p>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_vectorcall">
<a class="reference internal" href="call.xhtml#c.vectorcallfunc" title="vectorcallfunc"><span class="n"><span class="pre">vectorcallfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_vectorcall</span></span></span><br /></dt>
<dd><p>用于此类型对象的调用的 vectorcall 函数。 换句话说，它是被用来实现 <code class="docutils literal notranslate"><span class="pre">type.__call__</span></code> 的 <a class="reference internal" href="call.xhtml#vectorcall"><span class="std std-ref">vectorcall</span></a>。 如果 <code class="docutils literal notranslate"><span class="pre">tp_vectorcall</span></code> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，默认调用实现将使用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 并且 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 将被使用。</p>
<p><strong>继承：</strong></p>
<p>这个字段不会被继承。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9: </span>（这个字段从 3.8 起即存在，但是从 3.9 开始投入使用）</p>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyTypeObject.tp_watched">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">tp_watched</span></span></span><br /></dt>
<dd><p>内部对象。 请勿使用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

</section>
<section id="static-types">
<span id="id4"></span><h2>静态类型</h2>
<p>在传统上，在 C 代码中定义的类型都是 <em>静态的</em>，也就是说，<a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 结构体在代码中直接定义并使用 <a class="reference internal" href="type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 来初始化。</p>
<p>这就导致了与在 Python 中定义的类型相关联的类型限制：</p>
<ul class="simple">
<li><p>静态类型只能拥有一个基类；换句话说，他们不能使用多重继承。</p></li>
<li><p>静态类型对象（但并非它们的实例）是不可变对象。 不可能在 Python 中添加或修改类型对象的属性。</p></li>
<li><p>静态类型对象是跨 <a class="reference internal" href="init.xhtml#sub-interpreter-support"><span class="std std-ref">子解释器</span></a> 共享的，因此它们不应包括任何子解释器专属的状态。</p></li>
</ul>
<p>此外，由于 <a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 只是作为不透明结构的 <a class="reference internal" href="stable.xhtml#limited-c-api"><span class="std std-ref">受限 API</span></a> 的一部分，因此任何使用静态类型的扩展模块都必须针对特定的 Python 次版本进行编译。</p>
</section>
<section id="heap-types">
<span id="id5"></span><h2>堆类型</h2>
<p>一种 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型的</span></a> 替代物是 <em>堆分配类型</em>，或者简称 <em>堆类型</em>，它与使用 Python 的 <code class="docutils literal notranslate"><span class="pre">class</span></code> 语句创建的类紧密对应。 堆类型设置了 <a class="reference internal" href="#c.Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code></a> 旗标。</p>
<p>这是通过填充 <a class="reference internal" href="type.xhtml#c.PyType_Spec" title="PyType_Spec"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Spec</span></code></a> 结构体并调用 <a class="reference internal" href="type.xhtml#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a>, <a class="reference internal" href="type.xhtml#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases()</span></code></a>, <a class="reference internal" href="type.xhtml#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a> 或 <a class="reference internal" href="type.xhtml#c.PyType_FromMetaclass" title="PyType_FromMetaclass"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromMetaclass()</span></code></a> 来实现的。</p>
</section>
</section>
<section id="number-object-structures">
<span id="number-structs"></span><h1>数字对象结构体</h1>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyNumberMethods">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyNumberMethods</span></span></span><br /></dt>
<dd><p>该结构体持有指向被对象用来实现数字协议的函数的指针。 每个函数都被 <a class="reference internal" href="number.xhtml#number"><span class="std std-ref">数字协议</span></a> 一节中记录的对应名称的函数所使用。</p>
<p>结构体定义如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_add</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_subtract</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_multiply</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_remainder</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_divmod</span><span class="p">;</span>
<span class="w">     </span><span class="n">ternaryfunc</span><span class="w"> </span><span class="n">nb_power</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_negative</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_positive</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_absolute</span><span class="p">;</span>
<span class="w">     </span><span class="n">inquiry</span><span class="w"> </span><span class="n">nb_bool</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_invert</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_lshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_rshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_and</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_xor</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_or</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_int</span><span class="p">;</span>
<span class="w">     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">nb_reserved</span><span class="p">;</span>
<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_float</span><span class="p">;</span>

<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_add</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_subtract</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_multiply</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_remainder</span><span class="p">;</span>
<span class="w">     </span><span class="n">ternaryfunc</span><span class="w"> </span><span class="n">nb_inplace_power</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_lshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_rshift</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_and</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_xor</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_or</span><span class="p">;</span>

<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_floor_divide</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_true_divide</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_floor_divide</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_true_divide</span><span class="p">;</span>

<span class="w">     </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">nb_index</span><span class="p">;</span>

<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_matrix_multiply</span><span class="p">;</span>
<span class="w">     </span><span class="n">binaryfunc</span><span class="w"> </span><span class="n">nb_inplace_matrix_multiply</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyNumberMethods</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>双目和三目函数必须检查其所有操作数的类型，并实现必要的转换（至少有一个操作数是所定义类型的实例）。 如果没有为所给出的操作数定义操作，则双目和三目函数必须返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，如果发生了其他错误则它们必须返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并设置一个异常。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#c.PyNumberMethods.nb_reserved" title="PyNumberMethods.nb_reserved"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_reserved</span></code></a> 字段应当始终为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 在之前版本中其名称为 <code class="xref c c-member docutils literal notranslate"><span class="pre">nb_long</span></code>，并在 Python 3.0.1 中改名。</p>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_add">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_add</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_subtract">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_subtract</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_multiply</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_remainder">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_remainder</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_divmod">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_divmod</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_power">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><span class="n"><span class="pre">ternaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_power</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_negative">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_negative</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_positive">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_positive</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_absolute">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_absolute</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_bool">
<a class="reference internal" href="gcsupport.xhtml#c.inquiry" title="inquiry"><span class="n"><span class="pre">inquiry</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_bool</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_invert">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_invert</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_lshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_lshift</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_rshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_rshift</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_and">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_and</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_xor">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_xor</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_or">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_or</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_int">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_int</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_reserved">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_reserved</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_float">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_float</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_add">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_add</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_subtract">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_subtract</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_multiply</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_remainder">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_remainder</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_power">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><span class="n"><span class="pre">ternaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_power</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_lshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_lshift</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_rshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_rshift</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_and">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_and</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_xor">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_xor</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_or">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_or</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_floor_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_floor_divide</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_true_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_true_divide</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_floor_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_floor_divide</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_true_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_true_divide</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_index">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_index</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_matrix_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_matrix_multiply</span></span></span><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyNumberMethods.nb_inplace_matrix_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><span class="n"><span class="pre">PyNumberMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">nb_inplace_matrix_multiply</span></span></span><br /></dt>
<dd></dd></dl>

</section>
<section id="mapping-object-structures">
<span id="mapping-structs"></span><h1>映射对象结构体</h1>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyMappingMethods">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMappingMethods</span></span></span><br /></dt>
<dd><p>该结构体持有指向对象用于实现映射协议的函数的指针。 它有三个成员：</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyMappingMethods.mp_length">
<a class="reference internal" href="#c.lenfunc" title="lenfunc"><span class="n"><span class="pre">lenfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><span class="n"><span class="pre">PyMappingMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">mp_length</span></span></span><br /></dt>
<dd><p>该函数将被 <a class="reference internal" href="mapping.xhtml#c.PyMapping_Size" title="PyMapping_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMapping_Size()</span></code></a> 和 <a class="reference internal" href="object.xhtml#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Size()</span></code></a> 使用，并具有相同的签名。 如果对象没有定义长度则此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyMappingMethods.mp_subscript">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><span class="n"><span class="pre">PyMappingMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">mp_subscript</span></span></span><br /></dt>
<dd><p>该函数将被 <a class="reference internal" href="object.xhtml#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code></a> 和 <a class="reference internal" href="sequence.xhtml#c.PySequence_GetSlice" title="PySequence_GetSlice"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_GetSlice()</span></code></a> 使用，并具有与 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code> 相同的签名。 此槽位必须被填充以便 <a class="reference internal" href="mapping.xhtml#c.PyMapping_Check" title="PyMapping_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMapping_Check()</span></code></a> 函数返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>，否则它可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyMappingMethods.mp_ass_subscript">
<a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><span class="n"><span class="pre">objobjargproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><span class="n"><span class="pre">PyMappingMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">mp_ass_subscript</span></span></span><br /></dt>
<dd><p>该函数将被 <a class="reference internal" href="object.xhtml#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code></a>, <a class="reference internal" href="object.xhtml#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelItem()</span></code></a>, <a class="reference internal" href="sequence.xhtml#c.PySequence_SetSlice" title="PySequence_SetSlice"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_SetSlice()</span></code></a> 和 <a class="reference internal" href="sequence.xhtml#c.PySequence_DelSlice" title="PySequence_DelSlice"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_DelSlice()</span></code></a> 使用。 它具有与 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code> 相同的签名，但 <em>v</em> 也可以被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 以删除一个条目。 如果此槽位为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则对象将不支持条目赋值和删除。</p>
</dd></dl>

</section>
<section id="sequence-object-structures">
<span id="sequence-structs"></span><h1>序列对象结构体</h1>
<dl class="c type">
<dt class="sig sig-object c" id="c.PySequenceMethods">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PySequenceMethods</span></span></span><br /></dt>
<dd><p>该结构体持有指向对象用于实现序列协议的函数的指针。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_length">
<a class="reference internal" href="#c.lenfunc" title="lenfunc"><span class="n"><span class="pre">lenfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_length</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_Size" title="PySequence_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Size()</span></code></a> 和 <a class="reference internal" href="object.xhtml#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Size()</span></code></a> 所使用，并具有与它们相同的签名。 它还被用于通过 <a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a> 和 <a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_ass_item</span></code></a> 槽位来处理负索引号。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_concat">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_concat</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Concat()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a> 槽位执行数值相加之后它还会被用于 <code class="docutils literal notranslate"><span class="pre">+</span></code> 运算符。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_repeat">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><span class="n"><span class="pre">ssizeargfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_repeat</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Repeat()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_multiply</span></code></a> 槽位执行数值相乘之后它还会被用于 <code class="docutils literal notranslate"><span class="pre">*</span></code> 运算符。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_item">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><span class="n"><span class="pre">ssizeargfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_item</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_GetItem" title="PySequence_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_GetItem()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_subscript</span></code></a> 槽位执行下标操作之后它还会被用于 <a class="reference internal" href="object.xhtml#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code></a>。 该槽位必须被填充以便 <a class="reference internal" href="sequence.xhtml#c.PySequence_Check" title="PySequence_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Check()</span></code></a> 函数返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>，否则它可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>负索引号是按如下方式处理的：如果 <a class="reference internal" href="#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_length</span></code></a> 槽位已被填充，它将被调用并使用序列长度来计算出正索引号并传给 <a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a>。 如果 <code class="xref c c-member docutils literal notranslate"><span class="pre">sq_length</span></code> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，索引号将原样传给此函数。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_ass_item">
<a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><span class="n"><span class="pre">ssizeobjargproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_ass_item</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_SetItem" title="PySequence_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_SetItem()</span></code></a> 所使用并具有相同的签名。 在尝试通过 <a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_ass_subscript</span></code></a> 槽位执行条目赋值和删除操作之后它还会被用于 <a class="reference internal" href="object.xhtml#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code></a> 和 <a class="reference internal" href="object.xhtml#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelItem()</span></code></a>。 如果对象不支持条目和删除则该槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_contains">
<a class="reference internal" href="#c.objobjproc" title="objobjproc"><span class="n"><span class="pre">objobjproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_contains</span></span></span><br /></dt>
<dd><p>该函数可供 <a class="reference internal" href="sequence.xhtml#c.PySequence_Contains" title="PySequence_Contains"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Contains()</span></code></a> 使用并具有相同的签名。 此槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在此情况下 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Contains()</span></code> 只需遍历该序列直到找到一个匹配。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_inplace_concat">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><span class="n"><span class="pre">binaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_inplace_concat</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_InPlaceConcat" title="PySequence_InPlaceConcat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceConcat()</span></code></a> 所使用并具有相同的签名。 它应当修改它的第一个操作数，并将其返回。 该槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在此情况下 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceConcat()</span></code> 将回退到 <a class="reference internal" href="sequence.xhtml#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Concat()</span></code></a>。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_add</span></code></a> 槽位执行数字原地相加之后它还会被用于增强赋值运算符 <code class="docutils literal notranslate"><span class="pre">+=</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PySequenceMethods.sq_inplace_repeat">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><span class="n"><span class="pre">ssizeargfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><span class="n"><span class="pre">PySequenceMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">sq_inplace_repeat</span></span></span><br /></dt>
<dd><p>此函数被 <a class="reference internal" href="sequence.xhtml#c.PySequence_InPlaceRepeat" title="PySequence_InPlaceRepeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceRepeat()</span></code></a> 所使用并具有相同的签名。 它应当修改它的第一个操作数，并将其返回。 该槽位可以保持为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，在此情况下 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceRepeat()</span></code> 将回退到 <a class="reference internal" href="sequence.xhtml#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Repeat()</span></code></a>。 在尝试通过 <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_multiply</span></code></a> 槽位执行数字原地相乘之后它还会被用于增强赋值运算符 <code class="docutils literal notranslate"><span class="pre">*=</span></code>。</p>
</dd></dl>

</section>
<section id="buffer-object-structures">
<span id="buffer-structs"></span><h1>缓冲区对象结构体</h1>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyBufferProcs">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBufferProcs</span></span></span><br /></dt>
<dd><p>此结构体持有指向 <a class="reference internal" href="buffer.xhtml#bufferobjects"><span class="std std-ref">缓冲区协议</span></a> 所需要的函数的指针。 该协议定义了导出方对象要如何向消费方对象暴露其内部数据。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyBufferProcs.bf_getbuffer">
<a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><span class="n"><span class="pre">getbufferproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><span class="n"><span class="pre">PyBufferProcs</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">bf_getbuffer</span></span></span><br /></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">exporter</span><span class="p">,</span><span class="w"> </span><span class="n">Py_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p>处理发给 <em>exporter</em> 的请求来填充 <em>flags</em> 所指定的 <em>view</em>。 除第 (3) 点外，此函数的实现必须执行以下步骤：</p>
<ol class="arabic simple">
<li><p>检查请求是否能被满足。 如果不能，则会引发 <a class="reference internal" href="../library/exceptions.xhtml#BufferError" title="BufferError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferError</span></code></a>，将 <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> 设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 并返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p></li>
<li><p>填充请求的字段。</p></li>
<li><p>递增用于保存导出次数的内部计数器。</p></li>
<li><p>将 <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> 设为 <em>exporter</em> 并递增 <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span>。</p></li>
<li><p>返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p></li>
</ol>
<p>如果 <em>exporter</em> 是缓冲区提供方的链式或树型结构的一部分，则可以使用两种主要方案：</p>
<ul class="simple">
<li><p>重导出：树型结构的每个成员作为导出对象并将 <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> 设为对其自身的新引用。</p></li>
<li><p>重定向：缓冲区请求将被重定向到树型结构的根对象。 在此，<span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span> 将为对根对象的新引用。</p></li>
</ul>
<p><em>view</em> 中每个字段的描述参见 <a class="reference internal" href="buffer.xhtml#buffer-structure"><span class="std std-ref">缓冲区结构体</span></a> 一节，导出方对于特定请求应当如何反应参见 <a class="reference internal" href="buffer.xhtml#buffer-request-types"><span class="std std-ref">缓冲区请求类型</span></a> 一节。</p>
<p>所有在 <a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 结构体中被指向的内存都属于导出方并必须保持有效直到不再有任何消费方。 <a class="reference internal" href="buffer.xhtml#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>, <a class="reference internal" href="buffer.xhtml#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="buffer.xhtml#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>, <a class="reference internal" href="buffer.xhtml#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code class="xref c c-member docutils literal notranslate"><span class="pre">suboffsets</span></code></a> 和 <a class="reference internal" href="buffer.xhtml#c.Py_buffer.internal" title="Py_buffer.internal"><code class="xref c c-member docutils literal notranslate"><span class="pre">internal</span></code></a> 对于消费方来说是只读的。</p>
<p><a class="reference internal" href="buffer.xhtml#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a> 提供了一种暴露简单字节缓冲区同时正确处理地所有请求类型的简便方式。</p>
<p><a class="reference internal" href="buffer.xhtml#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> 是针对包装此函数的消费方的接口。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyBufferProcs.bf_releasebuffer">
<a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><span class="n"><span class="pre">releasebufferproc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><span class="n"><span class="pre">PyBufferProcs</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">bf_releasebuffer</span></span></span><br /></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">exporter</span><span class="p">,</span><span class="w"> </span><span class="n">Py_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">view</span><span class="p">);</span>
</pre></div>
</div>
<p>处理释放缓冲区资源的请求。 如果不需要释放任何资源，则 <a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a> 可以为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 在其他情况下，此函数的标准实现将执行以下的可选步骤：</p>
<ol class="arabic simple">
<li><p>递减用于保存导出次数的内部计数器。</p></li>
<li><p>如果计数器为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，则释放所有关联到 <em>view</em> 的内存。</p></li>
</ol>
<p>导出方必须使用 <a class="reference internal" href="buffer.xhtml#c.Py_buffer.internal" title="Py_buffer.internal"><code class="xref c c-member docutils literal notranslate"><span class="pre">internal</span></code></a> 字段来记录缓冲区专属的资源。 该字段将确保恒定，而消费方则可能将原始缓冲区作为 <em>view</em> 参数传入。</p>
<p>此函数不可递减 <span class="c-expr sig sig-inline c"><span class="n">view</span><span class="o">-&gt;</span><span class="n">obj</span></span>，因为这是在 <a class="reference internal" href="buffer.xhtml#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> 中自动完成的（此方案适用于打破循环引用）。</p>
<p><a class="reference internal" href="buffer.xhtml#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> 是针对包装此函数的消费方的接口。</p>
</dd></dl>

</section>
<section id="async-object-structures">
<span id="async-structs"></span><h1>异步对象结构体</h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyAsyncMethods">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyAsyncMethods</span></span></span><br /></dt>
<dd><p>此结构体将持有指向需要用来实现 <a class="reference internal" href="../glossary.xhtml#term-awaitable"><span class="xref std std-term">awaitable</span></a> 和 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 对象的函数的指针。</p>
<p>结构体定义如下:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">am_await</span><span class="p">;</span>
<span class="w">    </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">am_aiter</span><span class="p">;</span>
<span class="w">    </span><span class="n">unaryfunc</span><span class="w"> </span><span class="n">am_anext</span><span class="p">;</span>
<span class="w">    </span><span class="n">sendfunc</span><span class="w"> </span><span class="n">am_send</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">PyAsyncMethods</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyAsyncMethods.am_await">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><span class="n"><span class="pre">PyAsyncMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">am_await</span></span></span><br /></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">am_await</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>返回的对象必须为 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a>，即对其执行 <a class="reference internal" href="iter.xhtml#c.PyIter_Check" title="PyIter_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Check()</span></code></a> 必须返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p>如果一个对象不是 <a class="reference internal" href="../glossary.xhtml#term-awaitable"><span class="xref std std-term">awaitable</span></a> 则此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyAsyncMethods.am_aiter">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><span class="n"><span class="pre">PyAsyncMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">am_aiter</span></span></span><br /></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">am_aiter</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>必须返回一个 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 对象。 请参阅 <a class="reference internal" href="../reference/datamodel.xhtml#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 了解详情。</p>
<p>如果一个对象没有实现异步迭代协议则此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyAsyncMethods.am_anext">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><span class="n"><span class="pre">unaryfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><span class="n"><span class="pre">PyAsyncMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">am_anext</span></span></span><br /></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">am_anext</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>必须返回一个 <a class="reference internal" href="../glossary.xhtml#term-awaitable"><span class="xref std std-term">awaitable</span></a> 对象。 请参阅 <a class="reference internal" href="../reference/datamodel.xhtml#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 了解详情。 此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyAsyncMethods.am_send">
<a class="reference internal" href="#c.sendfunc" title="sendfunc"><span class="n"><span class="pre">sendfunc</span></span></a><span class="w"> </span><span class="sig-prename descclassname"><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><span class="n"><span class="pre">PyAsyncMethods</span></span></a><span class="p"><span class="pre">.</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">am_send</span></span></span><br /></dt>
<dd><p>此函数的签名为:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PySendResult</span><span class="w"> </span><span class="nf">am_send</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">**</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
<p>请参阅 <a class="reference internal" href="iter.xhtml#c.PyIter_Send" title="PyIter_Send"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Send()</span></code></a> 了解详情。 此槽位可被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

</section>
<section id="slot-type-typedefs">
<span id="id6"></span><h1>槽位类型 typedef</h1>
<dl class="c type">
<dt class="sig sig-object c" id="c.allocfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">allocfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="type.xhtml#c.PyTypeObject" title="PyTypeObject"><span class="n"><span class="pre">PyTypeObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cls</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">nitems</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>此函数的设计目标是将内存分配与内存初始化进行分离。 它应当返回一个指向足够容纳实例长度，适当对齐，并初始化为零的内存块的指针，但将 <a class="reference internal" href="#c.PyObject.ob_refcnt" title="PyObject.ob_refcnt"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_refcnt</span></code></a> 设为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 并将 <a class="reference internal" href="#c.PyObject.ob_type" title="PyObject.ob_type"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_type</span></code></a> 设为 type 参数。 如果类型的 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 为非零值，则对象的 <a class="reference internal" href="#c.PyVarObject.ob_size" title="PyVarObject.ob_size"><code class="xref c c-member docutils literal notranslate"><span class="pre">ob_size</span></code></a> 字段应当被初始化为 <em>nitems</em> 而分配内存块的长度应为 <code class="docutils literal notranslate"><span class="pre">tp_basicsize</span> <span class="pre">+</span> <span class="pre">nitems*tp_itemsize</span></code>，并舍入到 <code class="docutils literal notranslate"><span class="pre">sizeof(void*)</span></code> 的倍数；在其他情况下，<em>nitems</em> 将不会被使用而内存块的长度应为 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>。</p>
<p>此函数不应执行任何其他实例初始化操作，即使是分配额外内存也不应执行；那应当由 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 来完成。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.destructor">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">destructor</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.freefunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">freefunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.newfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">newfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.initproc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">initproc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.reprfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">reprfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_repr</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.getattrfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">getattrfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回对象的指定属性的值。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.setattrfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">setattrfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>为对象设置指定属性的值。 将 value 参数设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 将删除该属性。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.getattrofunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">getattrofunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>返回对象的指定属性的值。</p>
<p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.setattrofunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">setattrofunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>为对象设置指定属性的值。 将 value 参数设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 将删除该属性。</p>
<p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.descrgetfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">descrgetfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.descrsetfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">descrsetfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_set</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.hashfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="hash.xhtml#c.Py_hash_t" title="Py_hash_t"><span class="n"><span class="pre">Py_hash_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">hashfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.richcmpfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">richcmpfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.getiterfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">getiterfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.iternextfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iternextfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>参见 <a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.lenfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">lenfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.getbufferproc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">getbufferproc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.12 版起.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.releasebufferproc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">releasebufferproc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.12 版起.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.unaryfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">unaryfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.binaryfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">binaryfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.sendfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="iter.xhtml#c.PySendResult" title="PySendResult"><span class="n"><span class="pre">PySendResult</span></span></a><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sendfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><p>参见 <a class="reference internal" href="#c.PyAsyncMethods.am_send" title="PyAsyncMethods.am_send"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_send</span></code></a>。</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.ternaryfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ternaryfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.ssizeargfunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ssizeargfunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.ssizeobjargproc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ssizeobjargproc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.objobjproc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">objobjproc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.objobjargproc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">objobjargproc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

</section>
<section id="examples">
<span id="typedef-examples"></span><h1>例子</h1>
<p>下面是一些 Python 类型定义的简单示例。 其中包括你可能会遇到的通常用法。 有些演示了令人困惑的边际情况。 要获取更多示例、实践信息以及教程，请参阅 <a class="reference internal" href="../extending/newtypes_tutorial.xhtml#defining-new-types"><span class="std std-ref">自定义扩展类型：教程</span></a> 和 <a class="reference internal" href="../extending/newtypes.xhtml#new-types-topics"><span class="std std-ref">定义扩展类型：已分类主题</span></a>。</p>
<p>一个基本的 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;My objects&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myobj_new</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_dealloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>你可能还会看到带有更繁琐的初始化器的较旧代码（特别是在 CPython 代码库中）:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span><span class="w">               </span><span class="cm">/* tp_name */</span>
<span class="w">    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span><span class="w">               </span><span class="cm">/* tp_basicsize */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_itemsize */</span>
<span class="w">    </span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span><span class="w">      </span><span class="cm">/* tp_dealloc */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_vectorcall_offset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_getattr */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_setattr */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_async */</span>
<span class="w">    </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span><span class="w">           </span><span class="cm">/* tp_repr */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_number */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_sequence */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_mapping */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_hash */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_call */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_str */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_getattro */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_setattro */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_as_buffer */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_flags */</span>
<span class="w">    </span><span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;My objects&quot;</span><span class="p">),</span><span class="w">        </span><span class="cm">/* tp_doc */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_traverse */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_clear */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_richcompare */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_weaklistoffset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_iter */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_iternext */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_methods */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_members */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_getset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_base */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_dict */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_descr_get */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_descr_set */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_dictoffset */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_init */</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w">                              </span><span class="cm">/* tp_alloc */</span>
<span class="w">    </span><span class="n">myobj_new</span><span class="p">,</span><span class="w">                      </span><span class="cm">/* tp_new */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>一个支持弱引用、实例字典和哈希运算的类型:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;My objects&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Py_TPFLAGS_BASETYPE</span><span class="w"> </span><span class="o">|</span>
<span class="w">         </span><span class="n">Py_TPFLAGS_HAVE_GC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Py_TPFLAGS_MANAGED_DICT</span><span class="w"> </span><span class="o">|</span>
<span class="w">         </span><span class="n">Py_TPFLAGS_MANAGED_WEAKREF</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myobj_new</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_traverse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">myobj_traverse</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">myobj_clear</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyType_GenericNew</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_dealloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hashfunc</span><span class="p">)</span><span class="n">myobj_hash</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_richcompare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBaseObject_Type</span><span class="p">.</span><span class="n">tp_richcompare</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>一个不能被子类化且不能被调用以使用 <a class="reference internal" href="#c.Py_TPFLAGS_DISALLOW_INSTANTIATION" title="Py_TPFLAGS_DISALLOW_INSTANTIATION"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_DISALLOW_INSTANTIATION</span></code></a> 旗标创建实例（例如使用单独的工厂函数）的 str 子类:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyUnicodeObject</span><span class="w"> </span><span class="n">raw</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">extra</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyStr</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyStr_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyStr&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyStr</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">  </span><span class="c1">// set to &amp;PyUnicode_Type in module init</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;my custom str&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Py_TPFLAGS_DISALLOW_INSTANTIATION</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>最简单的固定长度实例 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_HEAD</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>最简单的具有可变长度实例的 <a class="reference internal" href="#static-types"><span class="std std-ref">静态类型</span></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_VAR_HEAD</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="n">MyObject_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_basicsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">tp_itemsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>