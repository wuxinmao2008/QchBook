<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="解析参数并构建值变量" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/arg.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="在创建你自己的扩展函数和方法时，这些函数是有用的。其它的信息和样例见 扩展和嵌入 Python 解释器 。 这些函数描述的前三个， PyArg_ParseTuple() ， PyArg_ParseTupleAndKeywords() ，以及 PyArg_Parse() ，它们都使用 格式化字符串 来将函数期待的参数告知函数。这些函数都使用相同语法规则的格式化字符串。 解析参数: 一个格式化字..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="在创建你自己的扩展函数和方法时，这些函数是有用的。其它的信息和样例见 扩展和嵌入 Python 解释器 。 这些函数描述的前三个， PyArg_ParseTuple() ， PyArg_ParseTupleAndKeywords() ，以及 PyArg_Parse() ，它们都使用 格式化字符串 来将函数期待的参数告知函数。这些函数都使用相同语法规则的格式化字符串。 解析参数: 一个格式化字..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>解析参数并构建值变量</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/arg.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="parsing-arguments-and-building-values">
<span id="arg-parsing"></span><h1>解析参数并构建值变量</h1>
<p>在创建你自己的扩展函数和方法时，这些函数是有用的。其它的信息和样例见 <a class="reference internal" href="../extending/index.xhtml#extending-index"><span class="std std-ref">扩展和嵌入 Python 解释器</span></a> 。</p>
<p>这些函数描述的前三个，<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>，<a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>，以及 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code></a>，它们都使用 <em>格式化字符串</em> 来将函数期待的参数告知函数。这些函数都使用相同语法规则的格式化字符串。</p>
<section id="parsing-arguments">
<h2>解析参数</h2>
<p>一个格式化字符串包含 0 或者更多的格式单元。一个格式单元用来描述一个 Python 对象；它通常是一个字符或者由括号括起来的格式单元序列。除了少数例外，一个非括号序列的格式单元通常对应这些函数的具有单一地址的参数。在接下来的描述中，双引号内的表达式是格式单元；圆括号 () 内的是对应这个格式单元的 Python 对象类型；方括号 [] 内的是传递的 C 变量(变量集)类型。</p>
<section id="strings-and-buffers">
<h3>字符串和缓存区</h3>
<p>这些格式允许将对象按照连续的内存块形式进行访问。你没必要提供返回的 unicode 字符或者字节区的原始数据存储。</p>
<p>除非另有说明，缓冲区是不会以空终止的。</p>
<p>有三种办法可以将字符串和缓冲区转换到 C 类型:</p>
<ul>
<li><p>像 <code class="docutils literal notranslate"><span class="pre">y*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">s*</span></code> 这样的格式会填充一个 <a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 结构体。 这将锁定下层缓冲区以便调用者随后使用这个缓冲区即使是在 <a class="reference internal" href="init.xhtml#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 块中也不会有可变数据因大小调整或销毁所带来的风险。 因此，在你结束处理数据（或任何更早的中止场景）之前 <strong>你必须调用</strong> <a class="reference internal" href="buffer.xhtml#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">es</span></code>, <code class="docutils literal notranslate"><span class="pre">es#</span></code>, <code class="docutils literal notranslate"><span class="pre">et</span></code> 和 <code class="docutils literal notranslate"><span class="pre">et#</span></code> 等格式会分配结果缓冲区。 在你结束处理数据（或任何更早的中止场景）之后 <strong>你必须调用</strong> <a class="reference internal" href="memory.xhtml#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>。</p></li>
<li><p id="c-arg-borrowed-buffer">其他格式接受一个 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或只读的 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>，如 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>，并向其缓冲区提供一个 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> 指针。 在缓冲区是“被借入”的情况下：它将由对应的 Python 对象来管理，并共享此对象的生命期。 你不需要自行释放任何内存。</p>
<p>为确保下层缓冲区可以安全地被借入，对象的 <a class="reference internal" href="typeobj.xhtml#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a> 字段必须为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 这将不允许普通的可变对象如 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>，以及某些只读对象如 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的 <a class="reference internal" href="../library/stdtypes.xhtml#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。</p>
<p>在这个 <code class="docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code> 要求以外，没有用于验证输入对象是否为不可变对象的检查（例如它是否会接受可写缓冲区的请求，或者另一个线程是否能改变此数据）。</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>For all <code class="docutils literal notranslate"><span class="pre">#</span></code> variants of formats (<code class="docutils literal notranslate"><span class="pre">s#</span></code>, <code class="docutils literal notranslate"><span class="pre">y#</span></code>, etc.), the macro
<code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code> must be defined before including
<code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>. On Python 3.9 and older, the type of the length argument
is <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> if the <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code> macro is defined,
or int otherwise.</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *]</dt><dd><p>将一个 Unicode 对象转换成一个指向字符串的 C 指针。一个指针指向一个已经存在的字符串，这个字符串存储的是传如的字符指针变量。C 字符串是已空结束的。Python 字符串不能包含嵌入的无效的代码点；如果由，一个 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常会被引发。Unicode 对象被转化成 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码的 C 字符串。如果转换失败，一个 <a class="reference internal" href="../library/exceptions.xhtml#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> 异常被引发。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这个表达式不接受 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>。如果你想接受文件系统路径并将它们转化成 C 字符串，建议使用 <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> 表达式配合 <a class="reference internal" href="unicode.xhtml#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> 作为 <em>转化函数</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>以前，当 Python 字符串中遇到了嵌入的 null 代码点会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 。</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s*</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [Py_buffer]</dt><dd><p>这个表达式既接受 Unicode 对象也接受类字节类型对象。它为由调用者提供的 <a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 结构赋值。这里结果的 C 字符串可能包含嵌入的 NUL 字节。Unicode 对象通过 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码转化成 C 字符串。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, read-only <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>像是 <code class="docutils literal notranslate"><span class="pre">s*</span></code>，区别在于它提供了一个 <a class="reference internal" href="#c-arg-borrowed-buffer"><span class="std std-ref">借入的缓冲区</span></a>。 结果存储在两个 C 变量中，第一个是指向 C 字符串的指针，第二个是其长度。 该字符串可能包含嵌入的空字节。 Unicode 对象会使用 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码格式转换为 C 字符串。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p>与 <code class="docutils literal notranslate"><span class="pre">s</span></code> 类似，但 Python 对象也可能为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在这种情况下，C 指针设置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z*</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) [Py_buffer]</dt><dd><p>与 <code class="docutils literal notranslate"><span class="pre">s*</span></code> 类似，但 Python 对象也可能为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在这种情况下，<a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 结构的 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 成员设置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, read-only <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 或者 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>与 <code class="docutils literal notranslate"><span class="pre">s#</span></code> 类似，但 Python 对象也可能为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在这种情况下，C 指针设置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code> (read-only <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [const char *]</dt><dd><p>这个格式会将一个类字节对象转换为一个指向 <a class="reference internal" href="#c-arg-borrowed-buffer"><span class="std std-ref">借入的</span></a> 字符串的 C 指针；它不接受 Unicode 对象。 字节缓冲区不可包含嵌入的空字节；如果包含这样的内容，将会引发 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。exception is raised.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>以前，当字节缓冲区中遇到了嵌入的 null 字节会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 。</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y*</span></code> (<a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [Py_buffer]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s*</span></code> 的变式，不接受 Unicode 对象，只接受类字节类型变量。<strong>这是接受二进制数据的推荐方法。</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y#</span></code> (read-only <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code> 的变式，不接受 Unicode 对象，只接受类字节类型变量。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [PyBytesObject *]</dt><dd><p>要求 Python 对象为 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象，不尝试进行任何转换。 如果该对象不为 bytes 对象则会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 C 变量也可被声明为 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Y</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [PyByteArrayObject *]</dt><dd><p>要求 Python 对象为 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象，不尝试进行任何转换。 如果该对象不为 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象则会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 C 变量也可被声明为 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [PyObject *]</dt><dd><p>要求 Python 对象为 Unicode 对象，不尝试进行任何转换。 如果该对象不为 Unicode 对象则会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 C 变量也可被声明为 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w*</span></code> (可读写 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [Py_buffer]</dt><dd><p>这个表达式接受任何实现可读写缓存区接口的对象。它为调用者提供的 <a class="reference internal" href="buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 结构赋值。缓冲区可能存在嵌入的 null 字节。当缓冲区使用完后调用者需要调用 <a class="reference internal" href="buffer.xhtml#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span></code> 的变式，它将编码后的 Unicode 字符存入字符缓冲区。它只处理没有嵌 NUL 字节的已编码数据。</p>
<p>此格式需要两个参数。 第一个仅用作输入，并且必须为 <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span>，它指向一个以 NUL 结束的字符串表示的编码格式名称，或者为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，这种情况会使用 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码格式。 如果 Python 无法识别指定的编码格式则会引发异常。 第二个参数必须为 <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span><span class="p">*</span></span>；它所引用的指针值将被设为带有参数文本内容的缓冲区。 文本将以第一个参数所指定的编码格式进行编码。</p>
<p><a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 会分配一个足够大小的缓冲区，将编码后的数据拷贝进这个缓冲区并且设置 <em>*buffer</em> 引用这个新分配的内存空间。调用者有责任在使用后调用 <a class="reference internal" href="memory.xhtml#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> 去释放已经分配的缓冲区。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">et</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> or <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">es</span></code> 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> *buffer_length]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code> 的变式，它将已编码的 Unicode 字符存入字符缓冲区。不像 <code class="docutils literal notranslate"><span class="pre">es</span></code> 表达式，它允许传入的数据包含 NUL 字符。</p>
<p>它需要三个参数。 第一个仅用作输入，并且必须为 <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span>，它指向一个以  NUL 结束的字符串表示的编码格式名称，或者为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，这种情况会使用 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码格式。 如果 Python 无法识别指定的编码格式则会引发异常。 第二个参数必须为 <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span><span class="p">*</span></span>；它所引用的指针值将被设为带有参数文本内容的缓冲区。 文本将以第一个参数所指定的编码格式进行编码。 第三个参数必须为指向一个整数的指针；被引用的整数将被设为输出缓冲区中的字节数。</p>
<p>有两种操作方式：</p>
<p>如果 <em>*buffer</em> 指向 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，则函数将分配所需大小的缓冲区，将编码的数据复制到此缓冲区，并设置 <em>*buffer</em> 以引用新分配的存储。 呼叫者负责调用 <a class="reference internal" href="memory.xhtml#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> 以在使用后释放分配的缓冲区。</p>
<p>如果 <em>*buffer</em> 指向非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针（已分配的缓冲区），则 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 将使用此位置作为缓冲区，并将 <em>*buffer_length</em> 的初始值解释为缓冲区大小。 然后，它将将编码的数据复制到缓冲区，并终止它。 如果缓冲区不够大，将设置一个 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>在这两个例子中，<em>*buffer_length</em> 被设置为编码后结尾不为 NUL 的数据的长度。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">et#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> *buffer_length]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">es#</span></code> 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">u#</span></code>, <code class="docutils literal notranslate"><span class="pre">Z</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Z#</span></code> 已被移除因为它们只用于旧式的 <code class="docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code> 表示形式。</p>
</div>
</section>
<section id="numbers">
<h3>数字</h3>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p>将非负的 Python 整数转换为无符号的微整数，存储为一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p>将 Python 整数转换为微整数并且不进行溢出检查，存储为一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [short int]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned short int]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span>，不进行溢出检查。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [int]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned int]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span>，不进行溢出检查。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long int]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">int</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>，不进行溢出检查。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long long]</dt><dd><p>将 Python 整数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long long]</dt><dd><p>将Python整数转换为C:C:expr:'unsigned long-long'，而不进行溢出检查。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>将一个 Python 整型转化成一个 C <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> Python 元大小类型。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或者 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 长度为 1) [char]</dt><dd><p>将一个 Python 字节类型，如一个长度为 1 的 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象，转换为 C <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>允许 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类型的对象。</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 长度为 1) [int]</dt><dd><p>将一个 Python 字符，如一个长度为 1 的 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象，转换为 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (<a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [float]</dt><dd><p>将一个 Python 浮点数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">float</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [double]</dt><dd><p>将一个 Python 浮点数转换为 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.xhtml#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>) [Py_complex]</dt><dd><p>将一个 Python 复数类型转化成一个 C <a class="reference internal" href="complex.xhtml#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> Python 复数类型。</p>
</dd>
</dl>
</section>
<section id="other-objects">
<h3>其他对象</h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject *]</dt><dd><p>将 Python 对象（未经任何转换）存储到一个 C 对象指针中。 这样 C 程序就能接收到实际传递的对象。 对象的新 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">strong reference</span></a> 不会被创建（即其引用计数不会增加）。 存储的指针将不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O!</span></code> (object) [<em>typeobject</em>, PyObject *]</dt><dd><p>将一个 Python 对象存入一个 C 对象指针。 这类似于 <code class="docutils literal notranslate"><span class="pre">O</span></code>，但是接受两个 C 参数：第一个是 Python 类型对象的地址，第二个是存储对象指针的 C 变量 (类型为 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>)。 如果 Python 对象不具有所要求的类型，则会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</dd>
</dl>
<dl id="o-ampersand">
<dt><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt><dd><p>通过 <em>converter</em> 函数将 Python 对象转换为 C 变量。这需要两个参数：第一个是函数，第二个是 C 变量（任意类型）的地址，转换为 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span>。<em>转换器</em> 函数依次调用如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">converter</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">);</span>
</pre></div>
</div>
<p>其中 <em>object</em> 是待转换的 Python 对象而 <em>address</em> 为传给 <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> 函数的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 参数。 返回的 <em>status</em> 应当以 <code class="docutils literal notranslate"><span class="pre">1</span></code> 代表转换成功而以 <code class="docutils literal notranslate"><span class="pre">0</span></code> 代表转换失败。 当转换失败时，<em>converter</em> 函数应当引发异常并让 <em>address</em> 的内容保持未修改状态。</p>
<p>如果 <em>converter</em> 返回 <code class="docutils literal notranslate"><span class="pre">Py_CLEANUP_SUPPORTED</span></code> ，则如果参数解析最终失败，它可能会再次调用该函数，从而使转换器有机会释放已分配的任何内存。在第二个调用中，<em>object</em> 参数将为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ;因此，该参数将为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ;因此，该参数将为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，因此，该参数将为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> （如果值）为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <em>address</em> 的值与原始呼叫中的值相同。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Py_CLEANUP_SUPPORTED</span></code> 被添加。</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code> (<a class="reference internal" href="../library/functions.xhtml#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) [int]</dt><dd><p>测试传入的值是否为真(一个布尔判断)并且将结果转化为相对应的 C true/false 整型值。如果表达式为真置 <code class="docutils literal notranslate"><span class="pre">1</span></code>，假则置 <code class="docutils literal notranslate"><span class="pre">0</span></code>。它接受任何合法的 Python 值。参见 <a class="reference internal" href="../library/stdtypes.xhtml#truth"><span class="std std-ref">逻辑值检测</span></a> 获取更多关于 Python 如何测试值为真的信息。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt><dd><p>对象必须是 Python 序列，它的长度是 <em>items</em> 中格式单元的数量。C 参数必须对应 <em>items</em> 中每一个独立的格式单元。序列中的格式单元可能有嵌套。</p>
</dd>
</dl>
<p>传递 &quot;long&quot; 整型 (取值超出平台的 <code class="xref c c-macro docutils literal notranslate"><span class="pre">LONG_MAX</span></code> 限制的整形) 是可能的，然而不会进行适当的范围检测 --- 当接受字段太小而接收不到值时，最高有效比特位会被静默地截断 (实际上，该语义是继承自 C 的向下转换 --- 你的计数可能会发生变化)。</p>
<p>格式化字符串中还有一些其他的字符具有特殊的涵义。这些可能并不嵌套在圆括号中。它们是：</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p>表明在 Python 参数列表中剩下的参数都是可选的。C 变量对应的可选参数需要初始化为默认值——当一个可选参数没有指定时， <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>  不能访问相应的 C 变量(变量集)的内容。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p><a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> only：表明在 Python 参数列表中剩下的参数都是强制关键字参数。当前，所有强制关键字参数都必须也是可选参数，所以格式化字符串中  <code class="docutils literal notranslate"><span class="pre">|</span></code> 必须一直在 <code class="docutils literal notranslate"><span class="pre">$</span></code> 前面。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">:</span></code></dt><dd><p>格式单元的列表结束标志；冒号后的字符串被用来作为错误消息中的函数名(<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 函数引发的“关联值”异常)。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">;</span></code></dt><dd><p>格式单元的列表结束标志；分号后的字符串被用来作为错误消息取代默认的错误消息。 <code class="docutils literal notranslate"><span class="pre">:</span></code> 和 <code class="docutils literal notranslate"><span class="pre">;</span></code> 相互排斥。</p>
</dd>
</dl>
<p>请注意提供给调用者的任何 Python 对象引用都是 <em>借入</em> 引用；不要释放它们（即不要递减它们的引用计数）！</p>
<p>传递给这些函数的附加参数必须是由格式化字符串确定的变量的地址；这些都是用来存储输入元组的值。有一些情况，如上面的格式单元列表中所描述的，这些参数作为输入值使用；在这种情况下，它们应该匹配指定的相应的格式单元。</p>
<p>为了让转换成功，<em>arg</em> 对象必须匹配格式并且格式必须被用尽。 当成功时，<code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> 函数将返回真值，否则将返回假值并引发适当的异常。 当 <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> 函数由于某个格式单元转换出错而失败时，该格式单元及其后续格式单元对应的地址上的变量都将保持原样。</p>
</section>
<section id="api-functions">
<h3>API 函数</h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_ParseTuple">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_ParseTuple</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>解析一个函数的参数，表达式中的参数按参数位置顺序存入局部变量中。成功返回 true；失败返回 false 并且引发相应的异常。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_VaParse">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_VaParse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">vargs</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>和 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 相同，然而它接受一个 va_list 类型的参数而不是可变数量的参数集。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_ParseTupleAndKeywords">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_ParseTupleAndKeywords</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kw</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keywords</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>Parse the parameters of a function that takes both positional and keyword
parameters into local variables.  The <em>keywords</em> argument is a
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>-terminated array of keyword parameter names.  Empty names denote
<a class="reference internal" href="../glossary.xhtml#positional-only-parameter"><span class="std std-ref">positional-only parameters</span></a>.
Returns true on success; on failure, it returns false and raises the
appropriate exception.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>添加了 <a class="reference internal" href="../glossary.xhtml#positional-only-parameter"><span class="std std-ref">positional-only parameters</span></a> 的支持。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_VaParseTupleAndKeywords">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_VaParseTupleAndKeywords</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kw</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keywords</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">vargs</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>和 <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_ValidateKeywordArguments">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_ValidateKeywordArguments</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>确保字典中的关键字参数都是字符串。这个函数只被使用于 <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 不被使用的情况下，后者已经不再做这样的检查。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_Parse">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_Parse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>Function used to deconstruct the argument lists of &quot;old-style&quot; functions ---
these are functions which use the <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> parameter parsing
method, which has been removed in Python 3.  This is not recommended for use
in parameter parsing in new code, and most code in the standard interpreter
has been modified to no longer use this for that purpose.  It does remain a
convenient way to decompose other tuples, however, and may continue to be
used for that purpose.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_UnpackTuple">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_UnpackTuple</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>一个更简单的形参提取形式，它不使用格式字符串来指定参数类型。 使用此方法来提取其形参的函数应当在函数或方法表中声明为 <a class="reference internal" href="structures.xhtml#c.METH_VARARGS" title="METH_VARARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a>。 包含实际形参的元组应当作为 <em>args</em> 传入；它必须确实是一个元组。 该元组的长度必须至少为 <em>min</em> 且不超过 <em>max</em>； <em>min</em> 和 <em>max</em> 可能相等。 额外的参数必须被传给函数，每个参数应当是一个指向 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> 变量的指针；它们将以来自 <em>args</em> 的值来填充； 它们将包含 <a class="reference internal" href="../glossary.xhtml#term-borrowed-reference"><span class="xref std std-term">借入引用</span></a>。 对应于 <em>args</em> 未给出的可选形参的变量不会被填充； 它们应当由调用方来初始化。 此函数在执行成功时返回真值而在 <em>args</em> 不为元组或包含错误数量的元素时返回假值；如果执行失败则还将设置一个异常。</p>
<p>这是一个使用该函数的示例，取自 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_weakref</span></code> 弱引用辅助模块的源代码:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">weakref_ref</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ref&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">callback</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyWeakref_NewRef</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个例子中调用 <a class="reference internal" href="#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a> 完全等价于调用 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;O|O:ref&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="building-values">
<h2>创建变量</h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_BuildValue">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_BuildValue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>基于类似 <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> 函数族所接受内容的格式字符串和一个值序列来创建一个新值。 返回该值或在发生错误的情况下返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；如果返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则将引发一个异常。</p>
<p><a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> 并不一直创建一个元组。只有当它的格式化字符串包含两个或更多的格式单元才会创建一个元组。如果格式化字符串是空，它返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；如果它包含一个格式单元，它返回由格式单元描述的的任一对象。用圆括号包裹格式化字符串可以强制它返回一个大小为 0 或者 1 的元组。</p>
<p>当内存缓存区的数据以参数形式传递用来构建对象时，如 <code class="docutils literal notranslate"><span class="pre">s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">s#</span></code> 格式单元，会拷贝需要的数据。调用者提供的缓冲区从来都不会被由 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> 创建的对象来引用。换句话说，如果你的代码调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 并且将分配的内存空间传递给 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>，你的代码就有责任在 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> 返回时调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 。</p>
<p>在下面的描述中，双引号的表达式使格式单元；圆括号 () 内的是格式单元将要返回的 Python 对象类型；方括号 [] 内的是传递的 C 变量(变量集)的类型。</p>
<p>字符例如空格，制表符，冒号和逗号在格式化字符串中会被忽略(但是不包括格式单元，如 <code class="docutils literal notranslate"><span class="pre">s#</span></code>)。这可以使很长的格式化字符串具有更好的可读性。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p>使用 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码将空终止的 C 字符串转换为 Python <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象。如果 C 字符串指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则使用 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>使用 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码将 C 字符串及其长度转换为 Python <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象。如果 C 字符串指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则长度将被忽略，并返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [const char *]</dt><dd><p>这将 C 字符串转换为 Python <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。 如果 C 字符串指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>这会将 C 字符串及其长度转换为一个 Python 对象。 如果该 C 字符串指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">s</span></code> 一样。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">s#</span></code> 一样。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const wchar_t *]</dt><dd><p>将空终止的 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 的 Unicode （UTF-16 或 UCS-4） 数据缓冲区转换为 Python Unicode 对象。 如果 Unicode 缓冲区指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const wchar_t *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>将 Unicode （UTF-16 或 UCS-4） 数据缓冲区及其长度转换为 Python Unicode 对象。  如果 Unicode 缓冲区指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则长度将被忽略，并返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">s</span></code> 一样。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U#</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">s#</span></code> 一样。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [int]</dt><dd><p>将一个基本 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [char]</dt><dd><p>将一个基本 C <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [short int]</dt><dd><p>将一个基本 C <span class="c-expr sig sig-inline c"><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long int]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">int</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned short int]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned int]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long long]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long long]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> 转换为 Python 整数对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [<a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p>将一个 C <a class="reference internal" href="intro.xhtml#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 类型转化为 Python 整型。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 长度为1 ) [char]</dt><dd><p>将一个代表单个字节的 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 转换为长度为 1 的 Python <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 长度为 1) [int]</dt><dd><p>将一个代表单个字符的 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 转换为长度为 1 的 Python <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [double]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 转换为 Python 浮点数。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (<a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [float]</dt><dd><p>将一个 C <span class="c-expr sig sig-inline c"><span class="kt">float</span></span> 转换为 Python 浮点数。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.xhtml#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>) [Py_complex *]</dt><dd><p>将一个 C <a class="reference internal" href="complex.xhtml#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> 类型的结构转化为 Python 复数类型。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject *]</dt><dd><p>原封不动地传递一个 Python 对象，但为其创建一个新的 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">strong reference</span></a> (即其引用计数加一)。 如果传入的对象是一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，则会假定这是因为产生该参数的调用发现了错误并设置了异常。 因此，<a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> 将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 但不会引发异常。 如果尚未引发异常，则会设置 <a class="reference internal" href="../library/exceptions.xhtml#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (object) [PyObject *]</dt><dd><p>和 <code class="docutils literal notranslate"><span class="pre">O</span></code> 相同。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code> (object) [PyObject *]</dt><dd><p>与 <code class="docutils literal notranslate"><span class="pre">O</span></code> 相同，但它不会创建新的 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">strong reference</span></a>。 如果对象是通过调用参数列表中的对象构造器来创建的则该方法将很有用处。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt><dd><p>通过 <em>converter</em> 函数将 <em>anything</em> 转换为 Python 对象。 该函数在调用时附带 <em>anything</em> (它应当兼容 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span>) 作为其参数并且应返回一个 &quot;新的&quot; Python 对象，或者如果发生错误则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt><dd><p>将一个 C 变量序列转换成 Python 元组并保持相同的元素数量。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[items]</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) [<em>相关的元素</em>]</dt><dd><p>将一个 C 变量序列转换成 Python 列表并保持相同的元素数量。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{items}</span></code> (<a class="reference internal" href="../library/stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) [<em>相关的元素</em>]</dt><dd><p>将一个C变量序列转换成 Python 字典。每一对连续的 C 变量对作为一个元素插入字典中，分别作为关键字和值。</p>
</dd>
</dl>
<p>如果格式字符串中出现错误，则设置 <a class="reference internal" href="../library/exceptions.xhtml#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> 异常并返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_VaBuildValue">
<a class="reference internal" href="structures.xhtml#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_VaBuildValue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">vargs</span></span><span class="sig-paren">)</span><br /></dt>
<dd><em class="refcount return_new_ref">返回值：新的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.xhtml#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p>和 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> 相同，然而它接受一个 va_list 类型的参数而不是可变数量的参数集。</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>