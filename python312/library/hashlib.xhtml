<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="hashlib --- 安全哈希与消息摘要" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/hashlib.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源码： Lib/hashlib.py[https://github.com/python/cpython/tree/3.12/Lib/hashlib.py] 本模块针对许多不同的安全哈希和消息摘要算法实现了一个通用接口。 包括了 FIPS 安全哈希算法 SHA1, SHA224, SHA256, SHA384, SHA512, (定义见 the FIPS 180-4 standard[htt..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源码： Lib/hashlib.py[https://github.com/python/cpython/tree/3.12/Lib/hashlib.py] 本模块针对许多不同的安全哈希和消息摘要算法实现了一个通用接口。 包括了 FIPS 安全哈希算法 SHA1, SHA224, SHA256, SHA384, SHA512, (定义见 the FIPS 180-4 standard[htt..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>hashlib --- 安全哈希与消息摘要</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/hashlib.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-hashlib">
<span id="hashlib-secure-hashes-and-message-digests"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code> --- 安全哈希与消息摘要</h1>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/hashlib.py">Lib/hashlib.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/hashlib.py]</span></p>
<span class="target" id="index-0"></span><hr class="docutils" />
<p>本模块针对许多不同的安全哈希和消息摘要算法实现了一个通用接口。 包括了 FIPS 安全哈希算法 SHA1, SHA224, SHA256, SHA384, SHA512, (定义见 <a class="reference external" href="https://csrc.nist.gov/publications/detail/fips/180/4/final">the FIPS 180-4 standard</a><span class="link-target"> [https://csrc.nist.gov/publications/detail/fips/180/4/final]</span>), SHA-3 系列 (定义见 <a class="reference external" href="https://csrc.nist.gov/publications/detail/fips/202/final">the FIPS 202 standard</a><span class="link-target"> [https://csrc.nist.gov/publications/detail/fips/202/final]</span>) 以及 RSA 的 MD5 算法 (定义见互联网 <span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc1321.html]</span>)。 术语 &quot;安全哈希&quot; 和 &quot;消息摘要&quot; 是同义的。 较旧的算法被称为消息摘要。 现代的术语则是安全哈希。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你想找到 adler32 或 crc32 哈希函数，它们在 <a class="reference internal" href="zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块中。</p>
</div>
<section id="hash-algorithms">
<span id="id1"></span><h2>哈希算法</h2>
<p>每种类型的 <em class="dfn">hash</em> 都有一个构造器方法。 它们都返回一个具有相同简单接口的哈希对象。 例如，使用 <a class="reference internal" href="#hashlib.sha256" title="hashlib.sha256"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha256()</span></code></a> 创建一个 SHA-256 哈希对象。 你可以使用 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update</span></code></a> 方法向这个对象输入 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a> (通常是 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)。 在任何时候你都可以使用 <a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a> 或 <a class="reference internal" href="#hashlib.hash.hexdigest" title="hashlib.hash.hexdigest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code></a> 方法获得到目前为止输入这个对象的拼接数据的 <em class="dfn">digest</em>。</p>
<p>为了允许多线程，当在其构造器或 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">.update</span></code></a> 方法中计算一次性提供超过 2047 字节数据的哈希时将会释放 Python <a class="reference internal" href="../glossary.xhtml#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
<p id="index-2">本模块中总是存在的哈希算法构造器有 <a class="reference internal" href="#hashlib.sha1" title="hashlib.sha1"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha1()</span></code></a>, <a class="reference internal" href="#hashlib.sha224" title="hashlib.sha224"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha224()</span></code></a>, <a class="reference internal" href="#hashlib.sha256" title="hashlib.sha256"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha256()</span></code></a>, <a class="reference internal" href="#hashlib.sha384" title="hashlib.sha384"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha384()</span></code></a>, <a class="reference internal" href="#hashlib.sha512" title="hashlib.sha512"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha512()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_224" title="hashlib.sha3_224"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_224()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_256" title="hashlib.sha3_256"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_256()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_384" title="hashlib.sha3_384"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_384()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_512" title="hashlib.sha3_512"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_512()</span></code></a>, <a class="reference internal" href="#hashlib.shake_128" title="hashlib.shake_128"><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code></a>, <a class="reference internal" href="#hashlib.shake_256" title="hashlib.shake_256"><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code></a>, <a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a> 和 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>。 <a class="reference internal" href="#hashlib.md5" title="hashlib.md5"><code class="xref py py-func docutils literal notranslate"><span class="pre">md5()</span></code></a> 通常也是可用的，但在你使用稀有的 &quot;FIPS 兼容&quot; Python 编译版时它可能会缺失或被屏蔽。 这些构造器对应于 <a class="reference internal" href="#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code class="xref py py-data docutils literal notranslate"><span class="pre">algorithms_guaranteed</span></code></a>。</p>
<p>如果你的 Python 分发版的 <a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 是基于提供了其他算法的 OpenSSL 编译版上链接的那么还可能存在一些附加的算法。 其他算法在所有安装版上 <em>不保证全都可用</em> 并且仅可通过 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 使用名称来访问。 参见 <a class="reference internal" href="#hashlib.algorithms_available" title="hashlib.algorithms_available"><code class="xref py py-data docutils literal notranslate"><span class="pre">algorithms_available</span></code></a>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>一些算法具有已知的碰撞弱点（包括 MD5 和 SHA1）。 请参阅本文档末尾的 <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Attacks_on_cryptographic_hash_algorithms">Attacks on cryptographic hash algorithms</a><span class="link-target"> [https://en.wikipedia.org/wiki/Cryptographic_hash_function#Attacks_on_cryptographic_hash_algorithms]</span> 和 <a class="reference internal" href="#hashlib-seealso">hashlib-seealso</a> 小节。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6: </span>增加了 SHA3 (Keccak) 和 SHAKE 构造器 <a class="reference internal" href="#hashlib.sha3_224" title="hashlib.sha3_224"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_224()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_256" title="hashlib.sha3_256"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_256()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_384" title="hashlib.sha3_384"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_384()</span></code></a>, <a class="reference internal" href="#hashlib.sha3_512" title="hashlib.sha3_512"><code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_512()</span></code></a>, <a class="reference internal" href="#hashlib.shake_128" title="hashlib.shake_128"><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code></a>, <a class="reference internal" href="#hashlib.shake_256" title="hashlib.shake_256"><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code></a>。 并增加了 <a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a> 和 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>。</p>
</div>
<div class="versionchanged" id="hashlib-usedforsecurity">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>所有 hashlib 的构造器都接受仅限关键字参数 <em>usedforsecurity</em> 且其默认值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 设为假值即允许在受限的环境中使用不安全且阻塞的哈希算法。 <code class="docutils literal notranslate"><span class="pre">False</span></code> 表示此哈希算法不可用于安全场景，例如用作非加密的单向压缩函数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>现在 hashlib 会在 OpenSSL 有提供的情况下使用 SHA3 和 SHAKE。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>在所链接的 OpenSSL 未提供 MD5, SHA1, SHA2 或 SHA3 算法的情况下我们将回退至来自 <a class="reference external" href="https://github.com/hacl-star/hacl-star">HACL* project</a><span class="link-target"> [https://github.com/hacl-star/hacl-star]</span> 的已验证的实现。</p>
</div>
</section>
<section id="usage">
<h2>用法</h2>
<p>要获取字节串 <code class="docutils literal notranslate"><span class="pre">b&quot;Nobody</span> <span class="pre">inspects</span> <span class="pre">the</span> <span class="pre">spammish</span> <span class="pre">repetition&quot;</span></code> 的摘要:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot; the spammish repetition&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">b&#39;\x03\x1e\xdd}Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406&#39;</span>
</pre></div>
</div>
<p>更简要的写法：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects the spammish repetition&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406&#39;</span>
</pre></div>
</div>
</section>
<section id="constructors">
<h2>构造器</h2>
<dl class="py function">
<dt class="sig sig-object py" id="hashlib.new">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">new</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>接受想要的算法对应的字符串 <em>name</em> 作为其第一个形参的泛型构造器。 它还允许访问上面列出的哈希算法以及你的 OpenSSL 库可能提供的任何其他算法。</p>
</dd></dl>

<p>使用 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 并附带一个算法名称:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;sha256&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects the spammish repetition&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406&#39;</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="hashlib.md5">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">md5</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha1">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha1</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha224">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha224</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha256">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha256</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha384">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha384</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha512">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha512</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha3_224">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha3_224</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha3_256">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha3_256</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha3_384">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha3_384</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.sha3_512">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">sha3_512</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>这些带命名的构造器速度相比向 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 传入算法名称更快。</p>
</section>
<section id="attributes">
<h2>属性</h2>
<p>在 hashlib 中提供了下列常量模块属性:</p>
<dl class="py data">
<dt class="sig sig-object py" id="hashlib.algorithms_guaranteed">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">algorithms_guaranteed</span></span></dt>
<dd><p>一个集合，其中包含此模块在所有平台上都保证支持的哈希算法的名称。 请注意 'md5' 也在此清单中，虽然某些上游厂商提供了一个怪异的排除了此算法的 &quot;FIPS 兼容&quot; Python 编译版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="hashlib.algorithms_available">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">algorithms_available</span></span></dt>
<dd><p>一个集合，其中包含在所运行的 Python 解释器上可用的哈希算法的名称。 将这些名称传给 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 时将可被识别。 <a class="reference internal" href="#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">algorithms_guaranteed</span></code></a> 将总是它的一个子集。 同样的算法在此集合中可能以不同的名称出现多次（这是 OpenSSL 的原因）。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="hash-objects">
<h2>哈希对象</h2>
<p>下列值会以构造器所返回的哈希对象的常量属性的形式被提供:</p>
<dl class="py data">
<dt class="sig sig-object py" id="hashlib.hash.digest_size">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">digest_size</span></span></dt>
<dd><p>以字节表示的结果哈希对象的大小。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="hashlib.hash.block_size">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">block_size</span></span></dt>
<dd><p>以字节表示的哈希算法的内部块大小。</p>
</dd></dl>

<p>hash 对象具有以下属性：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="hashlib.hash.name">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>此哈希对象的规范名称，总是为小写形式并且总是可以作为 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 的形参用来创建另一个此类型的哈希对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>该属性名称自被引入起即存在于 CPython 中，但在 Python 3.4 之前并未正式指明，因此可能不存在于某些平台上。</p>
</div>
</dd></dl>

<p>哈希对象具有下列方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="hashlib.hash.update">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 来更新哈希对象。 重复调用相当于单次调用并传入所有参数的拼接结果: <code class="docutils literal notranslate"><span class="pre">m.update(a);</span> <span class="pre">m.update(b)</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">m.update(a+b)</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hashlib.hash.digest">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">digest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回当前已传给 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 方法的数据摘要。 这是一个大小为 <a class="reference internal" href="#hashlib.hash.digest_size" title="hashlib.hash.digest_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">digest_size</span></code></a> 的字节串对象，字节串中可包含 0 至 255 的完整取值范围。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hashlib.hash.hexdigest">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">hexdigest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a> 但摘要会以两倍长度字符串对象的形式返回，其中仅包含十六进制数码。 这可以被用于在电子邮件或其他非二进制环境中安全地交换数据值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hashlib.hash.copy">
<span class="sig-prename descclassname"><span class="pre">hash.</span></span><span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回哈希对象的副本（“克隆”）。 这可被用来高效地计算共享相同初始子串的数据的摘要。</p>
</dd></dl>

</section>
<section id="shake-variable-length-digests">
<h2>SHAKE 可变长度摘要</h2>
<dl class="py function">
<dt class="sig sig-object py" id="hashlib.shake_128">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">shake_128</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.shake_256">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">shake_256</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity=True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#hashlib.shake_128" title="hashlib.shake_128"><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code></a> 和 <a class="reference internal" href="#hashlib.shake_256" title="hashlib.shake_256"><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code></a> 算法提供安全的 length_in_bits//2 至 128 或 256 位可变长度摘要。 为此，它们的摘要需指定一个长度。 SHAKE 算法不限制最大长度。</p>
<dl class="py method">
<dt class="sig sig-object py" id="hashlib.shake.digest">
<span class="sig-prename descclassname"><span class="pre">shake.</span></span><span class="sig-name descname"><span class="pre">digest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回当前已传给 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 方法的数据摘要。 这是一个大小为 <em>length</em> 的字节串对象，其中可包含 0 至 255 完整范围内的字节值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hashlib.shake.hexdigest">
<span class="sig-prename descclassname"><span class="pre">shake.</span></span><span class="sig-name descname"><span class="pre">hexdigest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#hashlib.shake.digest" title="hashlib.shake.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a> 但摘要会以两倍长度字符串对象的形式返回，其中仅包含十六进制数码。 这可以被用于在电子邮件或其他非二进制环境中安全地交换数据值。</p>
</dd></dl>

<p>用法示例:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">shake_256</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Nobody inspects the spammish repetition&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&#39;44709d6fcb83d92a76dcb0b668c98e1b1d3dafe7&#39;</span>
</pre></div>
</div>
</section>
<section id="file-hashing">
<h2>文件哈希</h2>
<p>hashlib 模块提供了一个辅助函数用于文件或文件型对象的高效哈希操作。</p>
<dl class="py function">
<dt class="sig sig-object py" id="hashlib.file_digest">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">file_digest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">digest</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个根据文件对象进行更新的摘要对象。</p>
<p><em>fileobj</em> 必须是一个以二进制模式打开用于读取的文件型对象。 它接受来自内置 <a class="reference internal" href="functions.xhtml#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, <a class="reference internal" href="io.xhtml#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesIO</span></code></a> 实例, <a class="reference internal" href="socket.xhtml#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.makefile()</span></code></a> 创建的 SocketIO 及其他类似的文件对象。 此函数也可能绕过 Python 的并直接使用来自 <a class="reference internal" href="io.xhtml#io.IOBase.fileno" title="io.IOBase.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a> 的文件描述符。 在此函数返回或引发异常之后必须假定 <em>fileobj</em> 已处于未知状态。 应当由调用方来负责关闭 <em>fileobj</em>。</p>
<p><em>digest</em> 必须是一个 <em>str</em> 形式的哈希算法名称、哈希构造器或返回哈希对象的可调用对象。</p>
<p>示例:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span><span class="o">,</span> <span class="nn">hashlib</span><span class="o">,</span> <span class="nn">hmac</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">hashlib</span><span class="o">.</span><span class="vm">__file__</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">digest</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">file_digest</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;sha256&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">digest</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>  
<span class="go">&#39;...&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;somedata&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mac1</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">HMAC</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">digestmod</span><span class="o">=</span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">digest</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">file_digest</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mac1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digest</span> <span class="ow">is</span> <span class="n">mac1</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mac2</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">HMAC</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;somedata&quot;</span><span class="p">,</span> <span class="n">digestmod</span><span class="o">=</span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mac1</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">==</span> <span class="n">mac2</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</section>
<section id="key-derivation">
<h2>密钥派生</h2>
<p>密钥派生和密钥延展算法被设计用于安全密码哈希。 <code class="docutils literal notranslate"><span class="pre">sha1(password)</span></code> 这样的简单算法无法防御暴力攻击。 好的密码哈希函数必须可以微调、放慢步调，并且包含 <a class="reference external" href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">加盐</a><span class="link-target"> [https://en.wikipedia.org/wiki/Salt_%28cryptography%29]</span>。</p>
<dl class="py function">
<dt class="sig sig-object py" id="hashlib.pbkdf2_hmac">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">pbkdf2_hmac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hash_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">password</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dklen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此函数提供 PKCS#5 基于密码的密钥派生函数 2。 它使用 HMAC 作为伪随机函数。</p>
<p>字符串 <em>hash_name</em> 是要求用于 HMAC 的哈希摘要算法的名称，例如 'sha1' 或 'sha256'。 <em>password</em> 和 <em>salt</em> 会以字节串缓冲区的形式被解析。 应用和库应当将 <em>password</em> 限制在合理长度 (例如 1024)。 <em>salt</em> 应当为适当来源例如 <a class="reference internal" href="os.xhtml#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> 的大约 16 个或更多的字节串数据。</p>
<p><em>iterations</em> 的数值应当基于哈希算法和机器算力来选择。 在 2022 年，建议选择进行数万次的 SHA-256 迭代。 对于为何以及如何选择最适合你的应用程序的迭代次数的理由，请参阅 <a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST-SP-800-132</a><span class="link-target"> [https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf]</span> 的 <em>Appendix A.2.2</em>。 其中 <a class="reference external" href="https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pbkdf2-sha256/">stackexchange pbkdf2 迭代问题</a><span class="link-target"> [https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pbkdf2-sha256/]</span> 的解答提供的详细的说明。</p>
<p><em>dklen</em> is the length of the derived key in bytes. If <em>dklen</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> then the
digest size of the hash algorithm <em>hash_name</em> is used, e.g. 64 for SHA-512.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">pbkdf2_hmac</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">our_app_iters</span> <span class="o">=</span> <span class="mi">500_000</span>  <span class="c1"># Application specific, read above.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dk</span> <span class="o">=</span> <span class="n">pbkdf2_hmac</span><span class="p">(</span><span class="s1">&#39;sha256&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;bad salt&#39;</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">our_app_iters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dk</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;15530bba69924174860db778f2c6f8104d3aaf9d26241840c8c4a641c8d000a9&#39;</span>
</pre></div>
</div>
<p>此函数只有在 Python 附带 OpenSSL 编译时才可用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在此函数只有在 Python 附带 OpenSSL 构建时才可用。 慢速的纯 Python 实现已被移除。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.scrypt">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">scrypt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dklen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此函数提供基于密码加密的密钥派生函数，其定义参见 <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7914.html"><strong>RFC 7914</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc7914.html]</span>。</p>
<p><em>password</em> 和 <em>salt</em> 必须为 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">字节类对象</span></a>。 应用和库应当将 <em>password</em> 限制在合理长度 (例如 1024)。 <em>salt</em> 应当为适当来源例如 <a class="reference internal" href="os.xhtml#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> 的大约 16 个或更多的字节串数据。</p>
<p><em>n</em> is the CPU/Memory cost factor, <em>r</em> the block size, <em>p</em> parallelization
factor and <em>maxmem</em> limits memory (OpenSSL 1.1.0 defaults to 32 MiB).
<em>dklen</em> is the length of the derived key in bytes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

</section>
<section id="blake2">
<h2>BLAKE2</h2>
<p id="index-4"><a class="reference external" href="https://www.blake2.net">BLAKE2</a><span class="link-target"> [https://www.blake2.net]</span> 是在 <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7693.html"><strong>RFC 7693</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc7693.html]</span> 中定义的加密哈希函数，它有两种形式:</p>
<ul class="simple">
<li><p><strong>BLAKE2b</strong>，针对 64 位平台进行优化，并会生成长度介于 1 和 64 字节之间任意大小的摘要。</p></li>
<li><p><strong>BLAKE2s</strong>，针对 8 至 32 位平台进行优化，并会生成长度介于 1 和 32 字节之间任意大小的摘要。</p></li>
</ul>
<p>BLAKE2 支持 <strong>keyed mode</strong> (<a class="reference external" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a><span class="link-target"> [https://en.wikipedia.org/wiki/Hash-based_message_authentication_code]</span> 的更快速更简单的替代), <strong>salted hashing</strong>, <strong>personalization</strong> 和 <strong>tree hashing</strong>.</p>
<p>此模块的哈希对象遵循标准库 <a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 对象的 API。</p>
<section id="creating-hash-objects">
<h3>创建哈希对象</h3>
<p>新哈希对象可通过调用构造器函数来创建:</p>
<dl class="py function">
<dt class="sig sig-object py" id="hashlib.blake2b">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">blake2b</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">digest_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">person</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fanout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hashlib.blake2s">
<span class="sig-prename descclassname"><span class="pre">hashlib.</span></span><span class="sig-name descname"><span class="pre">blake2s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">digest_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">person</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fanout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">usedforsecurity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>这些函数返回用于计算 BLAKE2b 或 BLAKE2s 的相应的哈希对象。 它们接受下列可选通用形参:</p>
<ul class="simple">
<li><p><em>data</em>: 要哈希的初始数据块，它必须为 <a class="reference internal" href="../glossary.xhtml#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。 它只能作为位置参数传入。</p></li>
<li><p><em>digest_size</em>: 以字节数表示的输出摘要大小。</p></li>
<li><p><em>key</em>: 用于密钥哈希的密钥（对于 BLAKE2b 最长 64 字节，对于 BLAKE2s 最长 32 字节）。</p></li>
<li><p><em>salt</em>: 用于随机哈希的盐值（对于 BLAKE2b 最长 16 字节，对于 BLAKE2s 最长 8 字节）。</p></li>
<li><p><em>person</em>: 个性化字符串（对于 BLAKE2b 最长 16 字节，对于 BLAKE2s 最长 8 字节）。</p></li>
</ul>
<p>下表显示了常规参数的限制（以字节为单位）：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Hash</p></th>
<th class="head"><p>目标长度</p></th>
<th class="head"><p>长度（键）</p></th>
<th class="head"><p>长度（盐）</p></th>
<th class="head"><p>长度（个人）</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BLAKE2b</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
<td><p>16</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>BLAKE2s</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>BLAKE2 规格描述为盐值和个性化形参定义了固定的长度，但是为了方便起见，此实现接受指定在长度以内的任意大小的字节串。 如果形参长度小于指定值，它将以零值进行填充，因此举例来说，<code class="docutils literal notranslate"><span class="pre">b'salt'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">b'salt\x00'</span></code> 为相同的值 (<em>key</em> 的情况则并非如此。)</p>
</div>
<p>如下面的模块 <a class="reference internal" href="#constants">constants</a> 所描述，这些是可用的大小取值。</p>
<p>构造器函数还接受下列树形哈希形参:</p>
<ul class="simple">
<li><p><em>fanout</em>: 扇出值 (0 至 255，如无限制即为 0，连续模式下为 1)。</p></li>
<li><p><em>depth</em>: 树的最大深度 (1 至 255，如无限制则为 255，连续模式下为 1)。</p></li>
<li><p><em>leaf_size</em>: 叶子的最大字节长度 (0 至 <code class="docutils literal notranslate"><span class="pre">2**32-1</span></code>，如无限制或在连续模式下则为 0)。</p></li>
<li><p><em>node_offset</em>: 节点的偏移量 (对于 BLAKE2b 为 0 至 <code class="docutils literal notranslate"><span class="pre">2**64-1</span></code>，对于 BLAKE2s 为 0 至 <code class="docutils literal notranslate"><span class="pre">2**48-1</span></code>，对于最多边的第一个叶子或在连续模式下则为 0)。</p></li>
<li><p><em>node_depth</em>: 节点深度 (0 至 255，对于叶子或在连续模式下则为 0)。</p></li>
<li><p><em>inner_size</em>: 内部摘要大小 (对于 BLAKE2b 为 0 至 64，对于 BLAKE2s 为 0 至 32，连续模式下则为 0)。</p></li>
<li><p><em>last_node</em>: 一个指明所处理的节点是否为最后一个 (在连续模式下为 <code class="docutils literal notranslate"><span class="pre">False</span></code>) 的布尔值。</p></li>
</ul>
<figure class="align-default">
<img alt="树模式形参的说明。" class="invert-in-dark-mode" src="../_images/hashlib-blake2-tree.png" />
</figure>
<p>请参阅 <a class="reference external" href="https://www.blake2.net/blake2_20130129.pdf">BLAKE2 规格描述</a><span class="link-target"> [https://www.blake2.net/blake2_20130129.pdf]</span> 第 2.10 节获取有关树形哈希的完整介绍。</p>
</section>
<section id="constants">
<h3>常量</h3>
<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2b.SALT_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2b.</span></span><span class="sig-name descname"><span class="pre">SALT_SIZE</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2s.SALT_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2s.</span></span><span class="sig-name descname"><span class="pre">SALT_SIZE</span></span></dt>
<dd></dd></dl>

<p>盐值长度（构造器所接受的最大长度）。</p>
<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2b.PERSON_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2b.</span></span><span class="sig-name descname"><span class="pre">PERSON_SIZE</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2s.PERSON_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2s.</span></span><span class="sig-name descname"><span class="pre">PERSON_SIZE</span></span></dt>
<dd></dd></dl>

<p>个性化字符串长度（构造器所接受的最大长度）。</p>
<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2b.MAX_KEY_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2b.</span></span><span class="sig-name descname"><span class="pre">MAX_KEY_SIZE</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2s.MAX_KEY_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2s.</span></span><span class="sig-name descname"><span class="pre">MAX_KEY_SIZE</span></span></dt>
<dd></dd></dl>

<p>最大密钥长度。</p>
<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2b.MAX_DIGEST_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2b.</span></span><span class="sig-name descname"><span class="pre">MAX_DIGEST_SIZE</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="hashlib.blake2s.MAX_DIGEST_SIZE">
<span class="sig-prename descclassname"><span class="pre">blake2s.</span></span><span class="sig-name descname"><span class="pre">MAX_DIGEST_SIZE</span></span></dt>
<dd></dd></dl>

<p>哈希函数可输出的最大摘要长度。</p>
</section>
<section id="examples">
<h3>例子</h3>
<section id="simple-hashing">
<h4>简单哈希</h4>
<p>要计算某个数据的哈希值，你应该首先通过调用适当的构造器函数 (<a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a> 或 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>) 来构造一个哈希对象，然后通过在该对象上调用 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 来更新目标数据，最后再通过调用 <a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a> (或针对十六进制编码字符串的 <a class="reference internal" href="#hashlib.hash.hexdigest" title="hashlib.hash.hexdigest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code></a>) 来获取该对象的摘要。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
<p>作为快捷方式，你可以直接以位置参数的形式向构造器传入第一个数据块来直接更新:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
<p>你可以多次调用 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash.update()</span></code></a> 至你所想要的任意次数以迭代地更新哈希值:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;world&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
</section>
<section id="using-different-digest-sizes">
<h4>使用不同的摘要大小</h4>
<p>BLAKE2 具有可配置的摘要大小，对于 BLAKE2b 最多 64 字节，对于 BLAKE2s 最多 32 字节。 例如，要使用 BLAKE2b 来替代 SHA-1 而不改变输出大小，我们可以让 BLAKE2b 产生 20 个字节的摘要:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Replacing SHA1 with the more secure function&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;d24f26cf8de66472d58d4e1b1774b4c9158b1f4c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">digest_size</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="go">20</span>
</pre></div>
</div>
<p>不同摘要大小的哈希对象具有完全不同的输出（较短哈希值 <em>并非</em> 较长哈希值的前缀）；即使输出长度相同，BLAKE2b 和 BLAKE2s 也会产生不同的输出:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span><span class="p">,</span> <span class="n">blake2s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6fa1d8fcfd719046d762&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;eb6ec15daf9546254f0809&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2s</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;1bf21a98c78a1c376ae9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2s</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;567004bf96e4a25773ebf4&#39;</span>
</pre></div>
</div>
</section>
<section id="keyed-hashing">
<h4>密钥哈希</h4>
<p>带密钥的哈希运算可被用于身份验证，作为 <a class="reference external" href="https://en.wikipedia.org/wiki/HMAC">基于哈希的消息验证代码</a><span class="link-target"> [https://en.wikipedia.org/wiki/HMAC]</span> (HMAC) 的一种更快速更简单的替代。 BLAKE2 可被安全地用于前缀 MAC 模式，这是由于它从 BLAKE 继承而来的不可区分特性。</p>
<p>这个例子演示了如何使用密钥 <code class="docutils literal notranslate"><span class="pre">b'pseudorandom</span> <span class="pre">key'</span></code> 来为 <code class="docutils literal notranslate"><span class="pre">b'message</span> <span class="pre">data'</span></code> 获取一个（十六进制编码的）128 位验证代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;pseudorandom key&#39;</span><span class="p">,</span> <span class="n">digest_size</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;message data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;3d363ff7401e02026f4a4687d4863ced&#39;</span>
</pre></div>
</div>
<p>作为实际的例子，一个 Web 应用可为发送给用户的 cookies 进行对称签名，并在之后对其进行验证以确保它们没有被篡改:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hmac</span> <span class="kn">import</span> <span class="n">compare_digest</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;pseudorandomly generated server secret key&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AUTH_SIZE</span> <span class="o">=</span> <span class="mi">16</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="n">AUTH_SIZE</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">SECRET_KEY</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">good_sig</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">compare_digest</span><span class="p">(</span><span class="n">good_sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cookie</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;user-alice&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cookie</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">sig</span><span class="p">))</span>
<span class="go">user-alice,b&#39;43b3c982cf697e0c5ab22172d1ca7421&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;user-bob&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;0102030405060708090a0b0c0d0e0f00&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>即使存在原生的密钥哈希模式，BLAKE2 也同样可在 <a class="reference internal" href="hmac.xhtml#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 模块的 HMAC 构造过程中使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hmac</span><span class="o">,</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;secret key&#39;</span><span class="p">,</span> <span class="n">digestmod</span><span class="o">=</span><span class="n">hashlib</span><span class="o">.</span><span class="n">blake2s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142&#39;</span>
</pre></div>
</div>
</section>
<section id="randomized-hashing">
<h4>随机哈希</h4>
<p>用户可通过设置 <em>salt</em> 形参来为哈希函数引入随机化。 随机哈希适用于防止对数字签名中使用的哈希函数进行碰撞攻击。</p>
<blockquote>
<div><p>随机哈希被设计用来处理当一方（消息准备者）要生成由另一方（消息签名者）进行签名的全部或部分消息的情况。 如果消息准备者能够找到加密哈希函数的碰撞现象（即两条消息产生相同的哈希值），则他们就可以准备将产生相同哈希值和数字签名但却具有不同结果的有意义的消息版本（例如向某个账户转入 $1,000,000 而不是 $10）。 加密哈希函数的设计都是以防碰撞性能为其主要目标之一的，但是当前针对加密哈希函数的集中攻击可能导致特定加密哈希函数所提供的防碰撞性能低于预期。 随机哈希为签名者提供了额外的保护，可以降低准备者在数字签名生成过程中使得两条或更多条消息最终产生相同哈希值的可能性 --- 即使为特定哈希函数找到碰撞现象是可行的。 但是，当消息的所有部分均由签名者准备时，使用随机哈希可能降低数字签名所提供的安全性。</p>
<p>(<a class="reference external" href="https://csrc.nist.gov/publications/detail/sp/800-106/archive/2009-02-25">NIST SP-800-106 &quot;Randomized Hashing for Digital Signatures&quot;</a><span class="link-target"> [https://csrc.nist.gov/publications/detail/sp/800-106/archive/2009-02-25]</span>)</p>
</div></blockquote>
<p>在 BLAKE2 中，盐值会在初始化期间作为对哈希函数的一次性输入而不是对每个压缩函数的输入来处理。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>使用 BLAKE2 或任何其他通用加密哈希函数，例如 SHA-256 进行 <em>加盐哈希</em> (或纯哈希) 并不适用于对密码的哈希。 请参阅 <a class="reference external" href="https://www.blake2.net/#qa">BLAKE2 FAQ</a><span class="link-target"> [https://www.blake2.net/#qa]</span> 了解更多信息。</p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the first hash with a random salt.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">salt1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">blake2b</span><span class="o">.</span><span class="n">SALT_SIZE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">salt</span><span class="o">=</span><span class="n">salt1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the second hash with a different random salt.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">salt2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">blake2b</span><span class="o">.</span><span class="n">SALT_SIZE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">salt</span><span class="o">=</span><span class="n">salt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The digests are different.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">!=</span> <span class="n">h2</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="personalization">
<h4>个性化</h4>
<p>出于不同的目的强制让哈希函数为相同的输入生成不同的摘要有时也是有用的。 正如 Skein 哈希函数的作者所言:</p>
<blockquote>
<div><p>我们建议所有应用设计者慎重考虑这种做法；我们已看到有许多协议在协议的某一部分中计算出来的哈希值在另一个完全不同的部分中也可以被使用，因为两次哈希计算是针对类似或相关的数据进行的，这样攻击者可以强制应用为相同的输入生成哈希值。 个性化协议中所使用的每个哈希函数将有效地阻止这种类型的攻击。</p>
<p>(<a class="reference external" href="https://www.schneier.com/wp-content/uploads/2016/02/skein.pdf">Skein 哈希函数族</a><span class="link-target"> [https://www.schneier.com/wp-content/uploads/2016/02/skein.pdf]</span>, p. 21)</p>
</div></blockquote>
<p>BLAKE2 可通过向 <em>person</em> 参数传入字节串来进行个性化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FILES_HASH_PERSON</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;MyApp Files Hash&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BLOCK_HASH_PERSON</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;MyApp Block Hash&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">FILES_HASH_PERSON</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;the same content&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">BLOCK_HASH_PERSON</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;the same content&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3&#39;</span>
</pre></div>
</div>
<p>个性化配合密钥模式也可被用来从单个密钥派生出多个不同密钥。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64decode</span><span class="p">,</span> <span class="n">b64encode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_key</span> <span class="o">=</span> <span class="n">b64decode</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Rm5EPJai72qcK3RGBpW3vPNfZy5OZothY+kHY6h21KM=&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc_key</span> <span class="o">=</span> <span class="n">blake2s</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">orig_key</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;kEncrypt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mac_key</span> <span class="o">=</span> <span class="n">blake2s</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">orig_key</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;kMAC&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">enc_key</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">rbPb15S/Z9t+agffno5wuhB77VbRi6F9Iv2qIxU7WHw=</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">mac_key</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">G9GtHFE1YluXY1zWPlYk1e/nWfu0WSEb0KRcjhDeP/o=</span>
</pre></div>
</div>
</section>
<section id="tree-mode">
<h4>树形模式</h4>
<p>以下是对包含两个叶子节点的最小树进行哈希的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>  <span class="mi">10</span>
 <span class="o">/</span>  \
<span class="mi">00</span>  <span class="mi">01</span>
</pre></div>
</div>
<p>这个例子使用 64 字节内部摘要，返回 32 字节最终摘要:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FANOUT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DEPTH</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LEAF_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">INNER_SIZE</span> <span class="o">=</span> <span class="mi">64</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">6000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Left leaf</span>
<span class="gp">... </span><span class="n">h00</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">LEAF_SIZE</span><span class="p">],</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Right leaf</span>
<span class="gp">... </span><span class="n">h01</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">LEAF_SIZE</span><span class="p">:],</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Root node</span>
<span class="gp">... </span><span class="n">h10</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">h00</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">h01</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa&#39;</span>
</pre></div>
</div>
</section>
</section>
<section id="credits">
<h3>开发人员</h3>
<p><a class="reference external" href="https://www.blake2.net">BLAKE2</a><span class="link-target"> [https://www.blake2.net]</span> 是由 <em>Jean-Philippe Aumasson</em>, <em>Samuel Neves</em>, <em>Zooko Wilcox-O'Hearn</em> 和 <em>Christian Winnerlein</em> 基于 <em>Jean-Philippe Aumasson</em>, <em>Luca Henzen</em>, <em>Willi Meier</em> 和 <em>Raphael C.-W. Phan</em> 所创造的 <a class="reference external" href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">SHA-3</a><span class="link-target"> [https://en.wikipedia.org/wiki/Secure_Hash_Algorithms]</span> 入围方案 <a class="reference external" href="https://web.archive.org/web/20200918190133/https://131002.net/blake/">BLAKE</a><span class="link-target"> [https://web.archive.org/web/20200918190133/https://131002.net/blake/]</span> 进行设计的。</p>
<p>它使用的核心算法来自由 <em>Daniel J. Bernstein</em> 所设计的 <a class="reference external" href="https://cr.yp.to/chacha.html">ChaCha</a><span class="link-target"> [https://cr.yp.to/chacha.html]</span> 加密。</p>
<p>stdlib 实现是基于 <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a><span class="link-target"> [https://pythonhosted.org/pyblake2/]</span> 模块的。 它由 <em>Dmitry Chestnykh</em> 在 <em>Samuel Neves</em> 所编写的 C 实现的基础上编写。 此文档拷贝自 <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a><span class="link-target"> [https://pythonhosted.org/pyblake2/]</span> 并由 <em>Dmitry Chestnykh</em> 撰写。</p>
<p>C 代码由 <em>Christian Heimes</em> 针对 Python 进行了部分的重写。</p>
<p>以下公共领域贡献同时适用于 C 哈希函数实现、扩展代码和本文档:</p>
<blockquote>
<div><p>在法律许可的范围内，作者已将此软件的全部版权以及关联和邻接权利贡献到全球公共领域。 此软件的发布不附带任何担保。</p>
<p>你应该已收到此软件附带的 CC0 公共领域专属证书的副本。 如果没有，请参阅 <a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a>。</p>
</div></blockquote>
<p>根据创意分享公共领域贡献 1.0 通用规范，下列人士为此项目的开发提供了帮助或对公共领域的修改作出了贡献:</p>
<ul class="simple">
<li><p><em>Alexandr Sokolovskiy</em></p></li>
</ul>
<div class="admonition seealso" id="hashlib-seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt>模块 <a class="reference internal" href="hmac.xhtml#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a></dt><dd><p>使用哈希运算来生成消息验证代码的模块。</p>
</dd>
<dt>模块 <a class="reference internal" href="base64.xhtml#module-base64" title="base64: RFC 4648: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal notranslate"><span class="pre">base64</span></code></a></dt><dd><p>针对非二进制环境对二进制哈希值进行编辑的另一种方式。</p>
</dd>
<dt><a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf">https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf</a></dt><dd><p>有关安全哈希算法的 FIPS 180-4 发布版。</p>
</dd>
<dt><a class="reference external" href="https://csrc.nist.gov/publications/detail/fips/202/final">https://csrc.nist.gov/publications/detail/fips/202/final</a></dt><dd><p>关于 SHA-3 标准的 FIPS 202 公告。</p>
</dd>
<dt><a class="reference external" href="https://www.blake2.net/">https://www.blake2.net/</a></dt><dd><p>BLAKE2 官方网站</p>
</dd>
<dt><a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">https://en.wikipedia.org/wiki/Cryptographic_hash_function</a></dt><dd><p>包含关于哪些算法存在已知问题以及对其使用所造成的影响的信息的 Wikipedia 文章。</p>
</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc8018.txt">https://www.ietf.org/rfc/rfc8018.txt</a></dt><dd><p>PKCS #5: 基于密码的加密规范描述 2.1 版</p>
</dd>
<dt><a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf</a></dt><dd><p>NIST 对基于密码的密钥派生的建议。</p>
</dd>
</dl>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>