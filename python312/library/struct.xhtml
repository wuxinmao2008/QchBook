<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="struct --- Interpret bytes as packed binary data" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/struct.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/struct.py[https://github.com/python/cpython/tree/3.12/Lib/struct.py] 此模块可在 Python 值和以 Python bytes 对象表示的 C 结构体之间进行转换。 通过紧凑 格式字符串 描述预期的 Python 值转换目标/来源。 此模块的函数和对象可被用于两种相当不同的应用程序，与外部源（文件或网络连..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/struct.py[https://github.com/python/cpython/tree/3.12/Lib/struct.py] 此模块可在 Python 值和以 Python bytes 对象表示的 C 结构体之间进行转换。 通过紧凑 格式字符串 描述预期的 Python 值转换目标/来源。 此模块的函数和对象可被用于两种相当不同的应用程序，与外部源（文件或网络连..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>struct --- Interpret bytes as packed binary data</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/struct.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-struct">
<span id="struct-interpret-bytes-as-packed-binary-data"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> --- Interpret bytes as packed binary data</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/struct.py">Lib/struct.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/struct.py]</span></p>
<hr class="docutils" id="index-0" />
<p>此模块可在 Python 值和以 Python <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象表示的 C 结构体之间进行转换。 通过紧凑 <a class="reference internal" href="#struct-format-strings"><span class="std std-ref">格式字符串</span></a> 描述预期的 Python 值转换目标/来源。 此模块的函数和对象可被用于两种相当不同的应用程序，与外部源（文件或网络连接）进行数据交换，或者在 Python 应用和 C 层级之间进行数据传输。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>当未给出前缀字符时，将默认为原生模式。 它会基于构建 Python 解释器的平台和编译器来打包和解包数据。 打包一个给定 C 结构体的结果包括为所涉及的 C 类型保持正确对齐的填充字节；类似地，当解包时也会将对齐纳入考虑。 相反地，当在外部源之间进行数据通信时，将由程序员负责定义字节顺序和元素之间的填充。 请参阅 <a class="reference internal" href="#struct-alignment"><span class="std std-ref">字节顺序，大小和对齐方式</span></a> 了解详情。</p>
</div>
<p>某些 <a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 的函数（以及 <a class="reference internal" href="#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code></a> 的方法）接受一个 <em>buffer</em> 参数。 这将指向实现了 <a class="reference internal" href="../c-api/buffer.xhtml#bufferobjects"><span class="std std-ref">缓冲协议</span></a> 并提供只读或是可读写缓冲的对象。 用于此目的的最常见类型为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>，但许多其他可被视为字节数组的类型也实现了缓冲协议，因此它们无需额外从 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象复制即可被读取或填充。</p>
<section id="functions-and-exceptions">
<h2>函数和异常</h2>
<p>此模块定义了下列异常和函数：</p>
<dl class="py exception">
<dt class="sig sig-object py" id="struct.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">error</span></span></dt>
<dd><p>会在多种场合下被引发的异常；其参数为一个描述错误信息的字符串。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="struct.pack">
<span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 bytes 对象，其中包含根据格式字符串 <em>format</em> 打包的值 <em>v1</em>, <em>v2</em>, ... 参数个数必须与格式字符串所要求的值完全匹配。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="struct.pack_into">
<span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">pack_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>根据格式字符串 <em>format</em> 打包 <em>v1</em>, <em>v2</em>, ... 等值并将打包的字节串写入可写缓冲区 <em>buffer</em> 从 <em>offset</em> 开始的位置。 请注意 <em>offset</em> 是必需的参数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="struct.unpack">
<span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>根据格式字符串 <em>format</em> 从缓冲区 <em>buffer</em> 解包（假定是由 <code class="docutils literal notranslate"><span class="pre">pack(format,</span> <span class="pre">...)</span></code> 打包）。 结果为一个元组，即使其只包含一个条目。 缓冲区的字节大小必须匹配格式所要求的大小，如 <a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcsize()</span></code></a> 所示。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="struct.unpack_from">
<span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">unpack_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>对 <em>buffer</em> 从位置 <em>offset</em> 开始根据格式字符串 <em>format</em> 进行解包。 结果为一个元组，即使其中只包含一个条目。 缓冲区的字节大小从位置 <em>offset</em> 开始必须至少为 <a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcsize()</span></code></a> 显示的格式所要求的大小。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="struct.iter_unpack">
<span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">iter_unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>根据格式字符串 <em>format</em> 以迭代方式从缓冲区 <em>buffer</em> 中解包。 此函数返回一个迭代器，它将从缓冲区读取大小相等的块直到其所有内容耗尽为止。 缓冲区的字节大小必须是格式所要求的大小的整数倍，如 <a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcsize()</span></code></a> 所显示的。</p>
<p>每次迭代将产生一个如格式字符串所指定的元组。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="struct.calcsize">
<span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">calcsize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回与格式字符串 <em>format</em> 相对应的结构的大小（亦即 <code class="docutils literal notranslate"><span class="pre">pack(format,</span> <span class="pre">...)</span></code> 所产生的字节串对象的大小）。</p>
</dd></dl>

</section>
<section id="format-strings">
<span id="struct-format-strings"></span><h2>格式字符串</h2>
<p>格式字符串描述了打包和解包数据时的数据布局。 它们是使用 <a class="reference internal" href="#format-characters"><span class="std std-ref">格式字符</span></a> 来构建的，格式字符指明被打包/解包的数据的类型。 此外，还有用来控制 <a class="reference internal" href="#struct-alignment"><span class="std std-ref">字节顺序、大小和对齐</span></a> 的特殊字符。 每个格式字符串都是由一个可选的描述数据总体属性的前缀字符和一个或多个描述实际数据值和填充的格式字符组成的。</p>
<section id="byte-order-size-and-alignment">
<span id="struct-alignment"></span><h3>字节顺序，大小和对齐方式</h3>
<p>在默认情况下，C 类型将以所在机器的原生格式和字节顺序来表示，并在必要时通过跳过填充字节来正确地对齐（根据 C 编译器所使用的规则）。 选择此行为是为了使已打包结构体的字节与对应的 C 结构体的内存布局完全对应。 使用原生字节顺序和填充还是标准格式取决于应用程序本身。</p>
<p id="index-1">或者，根据下表，格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>字符</p></th>
<th class="head"><p>字节顺序</p></th>
<th class="head"><p>大小</p></th>
<th class="head"><p>对齐方式</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;</span></code></p></td>
<td><p>按原字节</p></td>
<td><p>按原字节</p></td>
<td><p>按原字节</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p>按原字节</p></td>
<td><p>标准</p></td>
<td><p>无</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p>小端</p></td>
<td><p>标准</p></td>
<td><p>无</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p>大端</p></td>
<td><p>标准</p></td>
<td><p>无</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">!</span></code></p></td>
<td><p>网络（=大端）</p></td>
<td><p>标准</p></td>
<td><p>无</p></td>
</tr>
</tbody>
</table>
<p>如果第一个字符不是其中之一，则假定为 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>数字 1023 (十六进制的 <code class="docutils literal notranslate"><span class="pre">0x3ff</span></code>) 具有以下字节表示形式：</p>
<ul class="simple">
<li><p>大端序 (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) 的 <code class="docutils literal notranslate"><span class="pre">03</span> <span class="pre">ff</span></code></p></li>
<li><p>小端序 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>) 的 <code class="docutils literal notranslate"><span class="pre">ff</span> <span class="pre">03</span></code></p></li>
</ul>
<p>Python 示例：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&gt;h&#39;</span><span class="p">,</span> <span class="mi">1023</span><span class="p">)</span>
<span class="go">b&#39;\x03\xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;h&#39;</span><span class="p">,</span> <span class="mi">1023</span><span class="p">)</span>
<span class="go">b&#39;\xff\x03&#39;</span>
</pre></div>
</div>
</div>
<p>原生字节顺序可能为大端序或小端序，具体取决于主机系统。 例如，Intel x86, AMD64 (x86-64) 和 Apple M1 是小端序的；IBM z 和许多旧式架构则是大端序的。 请使用 <a class="reference internal" href="sys.xhtml#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.byteorder</span></code></a> 来检查你的系统字节顺序。</p>
<p>本机大小和对齐方式是使用 C 编译器的 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 表达式来确定的。 这总是会与本机字节顺序相绑定。</p>
<p>标准大小仅取决于格式字符；请参阅 <a class="reference internal" href="#format-characters"><span class="std std-ref">格式字符</span></a> 部分中的表格。</p>
<p>请注意 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 之间的区别：两个都使用本机字节顺序，但后者的大小和对齐方式是标准化的。</p>
<p>形式 <code class="docutils literal notranslate"><span class="pre">'!'</span></code> 代表网络字节顺序总是使用在 <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc1700">IETF RFC 1700</a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc1700]</span> 中所定义的大端序。</p>
<p>没有什么方式能指定非本机字节顺序（强制字节对调）；请正确选择使用 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>。</p>
<p>注释：</p>
<ol class="arabic simple">
<li><p>填充只会在连续结构成员之间自动添加。 填充不会添加到已编码结构的开头和末尾。</p></li>
<li><p>当使用非本机大小和对齐方式即 '&lt;', '&gt;', '=', and '!' 时不会添加任何填充。</p></li>
<li><p>要将结构的末尾对齐到符合特定类型的对齐要求，请以该类型代码加重复计数的零作为格式结束。 参见 <a class="reference internal" href="#struct-examples"><span class="std std-ref">例子</span></a>。</p></li>
</ol>
</section>
<section id="format-characters">
<span id="id1"></span><h3>格式字符</h3>
<p>格式字符具有以下含义；C 和 Python 值之间的按其指定类型的转换应当是相当明显的。 ‘标准大小’列是指当使用标准大小时以字节表示的已打包值大小；也就是当格式字符串以 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'!'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 之一开头的情况。 当使用本机大小时，已打包值的大小取决于具体的平台。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>格式</p></th>
<th class="head"><p>C 类型</p></th>
<th class="head"><p>Python 类型</p></th>
<th class="head"><p>标准大小</p></th>
<th class="head"><p>备注</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span></code></p></td>
<td><p>填充字节</p></td>
<td><p>无</p></td>
<td></td>
<td><p>(7)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p>长度为 1 的字节串</p></td>
<td><p>1</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">b</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span></span></p></td>
<td><p>integer</p></td>
<td><p>1</p></td>
<td><p>(1), (2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">B</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span></p></td>
<td><p>integer</p></td>
<td><p>1</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">?</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span></p></td>
<td><p>bool</p></td>
<td><p>1</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">h</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">short</span></span></p></td>
<td><p>integer</p></td>
<td><p>2</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">H</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span></p></td>
<td><p>integer</p></td>
<td><p>2</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td>
<td><p>integer</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">I</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span></p></td>
<td><p>integer</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">l</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span></span></p></td>
<td><p>integer</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p>integer</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">q</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p>integer</p></td>
<td><p>8</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Q</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p>integer</p></td>
<td><p>8</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">n</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code></p></td>
<td><p>integer</p></td>
<td></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">N</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></p></td>
<td><p>integer</p></td>
<td></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e</span></code></p></td>
<td><p>(6)</p></td>
<td><p>float</p></td>
<td><p>2</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">float</span></span></p></td>
<td><p>float</p></td>
<td><p>4</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">double</span></span></p></td>
<td><p>float</p></td>
<td><p>8</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">[</span><span class="p">]</span></span></p></td>
<td><p>字节串</p></td>
<td></td>
<td><p>(9)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">[</span><span class="p">]</span></span></p></td>
<td><p>字节串</p></td>
<td></td>
<td><p>(8)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">P</span></code></p></td>
<td><p><span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span></p></td>
<td><p>integer</p></td>
<td></td>
<td><p>(5)</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>增加了对 <code class="docutils literal notranslate"><span class="pre">'n'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'N'</span></code> 格式的支持</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>添加了对 <code class="docutils literal notranslate"><span class="pre">'e'</span></code> 格式的支持。</p>
</div>
<p>注释：</p>
<ol class="arabic">
<li><p id="index-2"><code class="docutils literal notranslate"><span class="pre">'?'</span></code> 转换码对应于 C99 对应的 <span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span> 类型。 如此此类型不可用，则使用 <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> 来模块。 在标准模式下，它总是以一个字节表示。</p>
</li>
<li><p>当尝试使用任何整数转换码打包一个非整数时，如果该非整数具有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法，则会在打包之前将参数转换为一个整数。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了用于非整数的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法。</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'n'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'N'</span></code> 转换码仅对本机大小可用（选择为默认或使用 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 字节顺序字符）。 对于标准大小，你可以使用适合你的应用的任何其他整数格式。</p></li>
<li><p>对于 <code class="docutils literal notranslate"><span class="pre">'f'</span></code>, <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'e'</span></code> 转换码，打包表示形式将使用 IEEE 754 binary32, binary64 或 binary16 格式 (分别对应于 <code class="docutils literal notranslate"><span class="pre">'f'</span></code>, <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'e'</span></code>)，无论平台使用何种浮点格式。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'P'</span></code> 格式字符仅对本机字节顺序可用（选择为默认或使用 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 字节顺序字符）。 字节顺序字符 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 选择使用基于主机系统的小端或大端排序。 struct 模块不会将其解读为本机排序，因此 <code class="docutils literal notranslate"><span class="pre">'P'</span></code> 格式将不可用。</p></li>
<li><p>IEEE 754 binary16 &quot;半精度&quot; 类型是在 <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision">IEEE 754 标准</a><span class="link-target"> [https://en.wikipedia.org/wiki/IEEE_754-2008_revision]</span> 的 2008 修订版中引入的。 它包含一个符号位，5 个指数位和 11 个精度位（明确存储 10 位），可以完全精确地表示大致范围在 <code class="docutils literal notranslate"><span class="pre">6.1e-05</span></code> 和 <code class="docutils literal notranslate"><span class="pre">6.5e+04</span></code> 之间的数字。 此类型并不被 C 编译器广泛支持：在一台典型的机器上，可以使用 unsigned short 进行存储，但不会被用于数学运算。 请参阅维基百科页面 <a class="reference external" href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half-precision floating-point format</a><span class="link-target"> [https://en.wikipedia.org/wiki/Half-precision_floating-point_format]</span> 了解详情。</p></li>
<li><p>在打包时，<code class="docutils literal notranslate"><span class="pre">'x'</span></code> 会插入一个 NUL 字节。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'p'</span></code> 格式字符用于编码“Pascal 字符串”，即存储在由计数指定的 <em>固定长度字节</em> 中的可变长度短字符串。 所存储的第一个字节为字符串长度或 255 中的较小值。 之后是字符串对应的字节。 如果传入 <a class="reference internal" href="#struct.pack" title="struct.pack"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code></a> 的字符串过长（超过计数值减 1），则只有字符串前 <code class="docutils literal notranslate"><span class="pre">count-1</span></code> 个字节会被存储。 如果字符串短于 <code class="docutils literal notranslate"><span class="pre">count-1</span></code>，则会填充空字节以使得恰好使用了 count 个字节。 请注意对于 <a class="reference internal" href="#struct.unpack" title="struct.unpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack()</span></code></a>，<code class="docutils literal notranslate"><span class="pre">'p'</span></code> 格式字符会消耗 <code class="docutils literal notranslate"><span class="pre">count</span></code> 个字节，但返回的字符串永远不会包含超过 255 个字节。</p></li>
<li><p>对于 <code class="docutils literal notranslate"><span class="pre">'s'</span></code> 格式字符，计数会被解读为字节的长度，而不是像其他格式字符那样的重复计数；例如，<code class="docutils literal notranslate"><span class="pre">'10s'</span></code> 表示一个与特定的 Python 字节串互相映射的长度为 10 的字节数据，而 <code class="docutils literal notranslate"><span class="pre">'10c'</span></code> 则表示个 10 个与十个不同的 Python 字节对象互相映射的独立的一字节字符元素 (如 <code class="docutils literal notranslate"><span class="pre">cccccccccc</span></code>)。 (其中的差别的具体演示请参见 <a class="reference internal" href="#struct-examples"><span class="std std-ref">例子</span></a>。) 如果未给出计数，则默认值为 1。 对于打包操作，字节串会被适当地截断或填充空字节以符合尺寸要求。 对于解包操作，结果字节对象总是会恰好具有指定数量的字节。 作为特例，<code class="docutils literal notranslate"><span class="pre">'0s'</span></code> 表示单个空字节串 (而 <code class="docutils literal notranslate"><span class="pre">'0c'</span></code> 表示 0 个字符)。</p></li>
</ol>
<p>格式字符之前可以带有整数重复计数。 例如，格式字符串 <code class="docutils literal notranslate"><span class="pre">'4h'</span></code> 的含义与 <code class="docutils literal notranslate"><span class="pre">'hhhh'</span></code> 完全相同。</p>
<p>格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。</p>
<p>当使用某一种整数格式 (<code class="docutils literal notranslate"><span class="pre">'b'</span></code>, <code class="docutils literal notranslate"><span class="pre">'B'</span></code>, <code class="docutils literal notranslate"><span class="pre">'h'</span></code>, <code class="docutils literal notranslate"><span class="pre">'H'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'I'</span></code>, <code class="docutils literal notranslate"><span class="pre">'l'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'q'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Q'</span></code>) 打包值 <code class="docutils literal notranslate"><span class="pre">x</span></code> 时，如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 在该格式的有效范围之外则将引发 <a class="reference internal" href="#struct.error" title="struct.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">struct.error</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span>在之前版本中，某些整数格式包装了超范围的值并会引发 <a class="reference internal" href="exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 而不是 <a class="reference internal" href="#struct.error" title="struct.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">struct.error</span></code></a>。</p>
</div>
<p id="index-3">对于 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 格式字符，返回值为 <a class="reference internal" href="constants.xhtml#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 或 <a class="reference internal" href="constants.xhtml#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。 在打包时将会使用参数对象的逻辑值。 以本机或标准 bool 类型表示的 0 或 1 将被打包，任何非零值在解包时将为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</section>
<section id="examples">
<span id="struct-examples"></span><h3>例子</h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>原生字节顺序的示例 (由 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 格式前缀或不带任何前缀字符的形式指定) 可能与读者机器所产生的内容不匹配，因为这取决于具体的平台和编译器。</p>
</div>
<p>打包和解包三种不同大小的整数，使用大端序:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;bhl&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">b&#39;\x01\x00\x02\x00\x00\x00\x03&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&gt;bhl&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x00\x02\x00\x00\x00\x03</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;&gt;bhl&#39;</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>尝试打包一个对于所定义字段来说过大的整数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;h&quot;</span><span class="p">,</span> <span class="mi">99999</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">struct.error</span>: <span class="n">&#39;h&#39; format requires -32768 &lt;= number &lt;= 32767</span>
</pre></div>
</div>
<p>显示 <code class="docutils literal notranslate"><span class="pre">'s'</span></code> and <code class="docutils literal notranslate"><span class="pre">'c'</span></code> 格式字符之间的差异:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;@ccc&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="go">b&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;@3s&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">b&#39;123&#39;</span>
</pre></div>
</div>
<p>解包的字段可通过将它们赋值给变量或将结果包装为一个具名元组来命名:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;raymond   </span><span class="se">\x32\x12\x08\x01\x08</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="n">serialnum</span><span class="p">,</span> <span class="n">school</span><span class="p">,</span> <span class="n">gradelevel</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;10sHHb&#39;</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Student</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Student&#39;</span><span class="p">,</span> <span class="s1">&#39;name serialnum school gradelevel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Student</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;10sHHb&#39;</span><span class="p">,</span> <span class="n">record</span><span class="p">))</span>
<span class="go">Student(name=b&#39;raymond   &#39;, serialnum=4658, school=264, gradelevel=8)</span>
</pre></div>
</div>
<p>格式字符的顺序可能会因为填充是隐式的而对在原生模式中的大小产生影响。 在标准模式下，用户要负责插入任何必要的填充。 请注意下面的第一个 <code class="docutils literal notranslate"><span class="pre">pack</span></code> 调用中在已打包的 <code class="docutils literal notranslate"><span class="pre">'#'</span></code> 之后添加了三个 NUL 字节以便在四字节边界上对齐到下面的整数。 在这个例子中，输出是在一台小端序的机器上产生的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@ci&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="mh">0x12131415</span><span class="p">)</span>
<span class="go">b&#39;#\x00\x00\x00\x15\x14\x13\x12&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@ic&#39;</span><span class="p">,</span> <span class="mh">0x12131415</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;#&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x15\x14\x13\x12#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@ci&#39;</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@ic&#39;</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>以下格式 <code class="docutils literal notranslate"><span class="pre">'llh0l'</span></code> 将会在末尾添加两个填充字节，假定平台的 long 类型按 4 个字节的边界对齐的话:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@llh0l&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt>模块 <a class="reference internal" href="array.xhtml#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a></dt><dd><p>被打包为二进制存储的同质数据。</p>
</dd>
<dt>模块 <a class="reference internal" href="json.xhtml#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a></dt><dd><p>JSON 编码器和解码器。</p>
</dd>
<dt>模块 <a class="reference internal" href="pickle.xhtml#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a></dt><dd><p>Python 对象序列化。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="applications">
<span id="id2"></span><h2>应用</h2>
<p><a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块存在两个主要应用，即在一个应用程序或使用相同编译器编译的另一个应用程序中 Python 和 C 代码之间的数据交换 (<a class="reference internal" href="#struct-native-formats"><span class="std std-ref">原生格式</span></a>)，以及使用商定的数据布局的应用程序之间的数据交换 (<a class="reference internal" href="#struct-standard-formats"><span class="std std-ref">标准格式</span></a>)。 一般来说，针对这两个领域构造的格式字符串是不一样的。</p>
<section id="native-formats">
<span id="struct-native-formats"></span><h3>原生格式</h3>
<p>当构造模仿原生布局的格式字符串时，编译器和机器架构会决定字节顺序和填充。 在这种情况下，应当使用 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 格式字符来指明原生字节顺序和数据大小。 内部填充字节通常是自动插入的。 为了正确对齐连续的数据块可能会在格式字符串末尾需要一个零重复的格式代码以舍入到正确的字节边界。</p>
<p>请看这两个简单的示例（在 64 位的小端序机器上）:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@lhl&#39;</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@llh&#39;</span><span class="p">)</span>
<span class="go">18</span>
</pre></div>
</div>
<p>在不使用额外填充的情况下不会将数据填充到第二个格式字符串末尾的 8 字节边界上。 零重复的格式代码解决了这个问题:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@llh0l&#39;</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'x'</span></code> 格式代码可被用来指定重复，但对于原生格式来说最好是使用 <code class="docutils literal notranslate"><span class="pre">'0l'</span></code> 这样的零重复格式。</p>
<p>在默认情况下，将使用原生字节顺序和对齐，但最好是显式指定并使用 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 前缀字符。</p>
</section>
<section id="standard-formats">
<span id="struct-standard-formats"></span><h3>标准格式</h3>
<p>当与你的进程之外如网络或存储交换数据时，请务必保持精确。 准确地指定字节顺序、大小和对齐。 不要假定它们与特定机器的原生顺序相匹配。 例如，网络字节顺序是大端序的，而许多流行的 CPU 则是小端序的。 通过显式定义，用户将无需关心他们的代码运行所在平台的具体规格。 第一个字符通常应为 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (或者 <code class="docutils literal notranslate"><span class="pre">!</span></code>)。 程序员要负责填充操作。 零重复格式字符是无效的。 相反，用户必须在需要时显式地添加 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 填充字节。 回顾上一节中的示例，我们得到:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;&lt;qh6xq&#39;</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;qh6xq&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@lhl&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@llh&#39;</span><span class="p">)</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@llh&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;qqh&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;&lt;qqh6x&#39;</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@llh0l&#39;</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@llh0l&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;qqh6x&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>上述结果（在 64 位机器上执行）不保证在不同的机器上执行时仍能匹配。 例如，以下示例是在 32 位机器上执行的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;&lt;qqh6x&#39;</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;@llh0l&#39;</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;@llh0l&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;qqh6x&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
</section>
<section id="classes">
<span id="struct-objects"></span><h2>类</h2>
<p><a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块还定义了以下类型：</p>
<dl class="py class">
<dt class="sig sig-object py" id="struct.Struct">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">struct.</span></span><span class="sig-name descname"><span class="pre">Struct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 Struct 对象，它会根据格式字符串object which writes and reads binary data according to the format string <em>format</em> 来写入和读取二进制数据。 一次性地创建 <code class="docutils literal notranslate"><span class="pre">Struct</span></code> 对象并调用其方法相比调用相同格式的模块层级函数效率更高因为格式字符串只会被编译一次。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>传递线路模块层级函数的已编译版最新格式字符串会被缓存，因此只使用少量格式字符串的程序无需担心重用单独的 <a class="reference internal" href="#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code></a> 实例。</p>
</div>
<p>已编译的 Struct 对象支持以下方法和属性：</p>
<dl class="py method">
<dt class="sig sig-object py" id="struct.Struct.pack">
<span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#struct.pack" title="struct.pack"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code></a> 函数，使用了已编译的格式。 (<code class="docutils literal notranslate"><span class="pre">len(result)</span></code> 将等于 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>。)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="struct.Struct.pack_into">
<span class="sig-name descname"><span class="pre">pack_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#struct.pack_into" title="struct.pack_into"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack_into()</span></code></a> 函数，使用了已编译的格式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="struct.Struct.unpack">
<span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#struct.unpack" title="struct.unpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack()</span></code></a> 函数，使用了已编译的格式。 缓冲区的字节大小必须等于 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="struct.Struct.unpack_from">
<span class="sig-name descname"><span class="pre">unpack_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#struct.unpack_from" title="struct.unpack_from"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack_from()</span></code></a> 函数，使用了已编译的格式。 缓冲区的字节大小从位置 <em>offset</em> 开始必须至少为 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="struct.Struct.iter_unpack">
<span class="sig-name descname"><span class="pre">iter_unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#struct.iter_unpack" title="struct.iter_unpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter_unpack()</span></code></a> 函数，使用了已编译的格式。 缓冲区的大小必须为 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a> 的整数倍。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="struct.Struct.format">
<span class="sig-name descname"><span class="pre">format</span></span></dt>
<dd><p>用于构造此 Struct 对象的格式字符串。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>格式字符串类型现在是 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 而不再是 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="struct.Struct.size">
<span class="sig-name descname"><span class="pre">size</span></span></dt>
<dd><p>计算出对应于 <a class="reference internal" href="functions.xhtml#format" title="format"><code class="xref py py-attr docutils literal notranslate"><span class="pre">format</span></code></a> 的结构大小（亦即 <a class="reference internal" href="#struct.pack" title="struct.pack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pack()</span></code></a> 方法所产生的字节串对象的大小）。</p>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>