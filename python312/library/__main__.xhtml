<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="__main__ --- 最高层级代码环境" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/__main__.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Python 的特殊名__main__ 用于两个重要的构造： 程序的顶层环境的名称，可用表达式__name__ == '__main__' 来检查；以及, Python 包中的文件__main__.py 。. 这两个机制都与 Python 模块相关——用户与它们如何交互，及它们之间如何交互——下文详述。而教程的 模块 一节则为初学者介绍了 Python 模块。__name__ == '__m..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Python 的特殊名__main__ 用于两个重要的构造： 程序的顶层环境的名称，可用表达式__name__ == '__main__' 来检查；以及, Python 包中的文件__main__.py 。. 这两个机制都与 Python 模块相关——用户与它们如何交互，及它们之间如何交互——下文详述。而教程的 模块 一节则为初学者介绍了 Python 模块。__name__ == '__m..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>__main__ --- 最高层级代码环境</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/__main__.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-__main__">
<span id="main-top-level-code-environment"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code> --- 最高层级代码环境</h1>
<hr class="docutils" />
<p>Python 的特殊名 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 用于两个重要的构造：</p>
<ol class="arabic simple">
<li><p>程序的顶层环境的名称，可用表达式 <code class="docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 来检查；以及</p></li>
<li><p>Python 包中的文件 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code>。</p></li>
</ol>
<p>这两个机制都与 Python 模块相关——用户与它们如何交互，及它们之间如何交互——下文详述。而教程的 <a class="reference internal" href="../tutorial/modules.xhtml#tut-modules"><span class="std std-ref">模块</span></a> 一节则为初学者介绍了 Python 模块。</p>
<section id="name-main">
<span id="name-equals-main"></span><h2><code class="docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code></h2>
<p>当一个 Python 模块或包被导入时，<code class="docutils literal notranslate"><span class="pre">__name__</span></code> 被设为模块的名称——通常为 Python 文件本身的名称去掉 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 后缀：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">configparser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">configparser</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;configparser&#39;</span>
</pre></div>
</div>
<p>如果文件是包的一部分，则 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 还将包括父包的路径：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">process</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">process</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;concurrent.futures.process&#39;</span>
</pre></div>
</div>
<p>而若模块是在顶层代码环境中执行的，则其 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 被设为字符串 <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code>。</p>
<section id="what-is-the-top-level-code-environment">
<h3>什么是“顶层代码环境”？</h3>
<p><code class="docutils literal notranslate"><span class="pre">__main__</span></code> 是顶层代码运行环境的名称。“顶层代码”是指由用户指定的最先开始运行的那一个 Python 模块。之所以它是“顶层”，是因为它将导入程序所需的所有其它模块。有时“顶层代码”被称为应用程序的 <em>入口点</em>。</p>
<p>顶层代码环境可以是：</p>
<ul>
<li><p>交互提示符的作用域：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="vm">__name__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
</li>
<li><p>作为文件参数传给 Python 解释器的 Python 模块：</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>helloworld.py
<span class="go">Hello, world!</span>
</pre></div>
</div>
</li>
<li><p>与 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 一起传给 Python 解释器的 Python 模块或包：</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>-m<span class="w"> </span>tarfile
<span class="go">usage: tarfile.py [-h] [-v] (...)</span>
</pre></div>
</div>
</li>
<li><p>Python 解释器从标准输入中读取的 Python 代码：</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;import this&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>python
<span class="go">The Zen of Python, by Tim Peters</span>

<span class="go">Beautiful is better than ugly.</span>
<span class="go">Explicit is better than implicit.</span>
<span class="go">...</span>
</pre></div>
</div>
</li>
<li><p>与 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 一起传给 Python 解释器的 Python 代码：</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;import this&quot;</span>
<span class="go">The Zen of Python, by Tim Peters</span>

<span class="go">Beautiful is better than ugly.</span>
<span class="go">Explicit is better than implicit.</span>
<span class="go">...</span>
</pre></div>
</div>
</li>
</ul>
<p>上述每种情况中的顶层模块的 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 被设为 <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code>。</p>
<p>作为结果，模块通过检查自己的 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 可发现自己是否运行于顶层环境，使一些代码仅当模块不是被导入语句初始化的时候才执行：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Execute when the module is not initialized from an import statement.</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>关于在所有情况下 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 是被如何设置的，详见教程的 <a class="reference internal" href="../tutorial/modules.xhtml#tut-modules"><span class="std std-ref">模块</span></a> 一节。</p>
</div>
</section>
<section id="idiomatic-usage">
<h3>惯用法</h3>
<p>有些模块包含了仅供脚本使用的代码，比如解析命令行参数或从标准输入获取数据。 如果这样的模块被从不同的模块中导入，例如为了单元测试，脚本代码也会无意中执行。</p>
<p>这就是 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 代码块的用武之地。除非模块在顶层环境中被执行，否则该块内的代码不会运行。</p>
<p>将尽可能少的语句放在位于 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 之下的代码块中可以提高代码的清晰度和准确度。 通常，将由一个名为 <code class="docutils literal notranslate"><span class="pre">main</span></code> 的函数来封装程序的主要行为:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># echo.py</span>

<span class="kn">import</span> <span class="nn">shlex</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">phrase</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;A dummy wrapper around print.&quot;&quot;&quot;</span>
   <span class="c1"># for demonstration purposes, you can imagine that there is some</span>
   <span class="c1"># valuable and reusable logic inside this function</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Echo the input arguments to standard output&quot;&quot;&quot;</span>
    <span class="n">phrase</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
    <span class="n">echo</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>  <span class="c1"># next section explains the use of sys.exit</span>
</pre></div>
</div>
<p>请注意，如果模块没有将代码封装在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数内，而是直接放在 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 块内，那么这个 <code class="docutils literal notranslate"><span class="pre">phrase</span></code> 变量对整个模块来说就是全局变量。 这很容易出错，因为模块内的其他函数可能会无意中使用全局变量而不是局部名称。 一个 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数解决了这个问题。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数有一个额外的好处，就是 <code class="docutils literal notranslate"><span class="pre">echo</span></code> 函数本身是孤立的，可以在其他地方导入。当 <code class="docutils literal notranslate"><span class="pre">echo.py</span></code> 被导入时，<code class="docutils literal notranslate"><span class="pre">echo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数将被定义，但它们都不会被调用，因为 <code class="docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">!=</span> <span class="pre">'__main__'</span></code> 。</p>
</section>
<section id="packaging-considerations">
<h3>打包考量</h3>
<p><code class="docutils literal notranslate"><span class="pre">main</span></code> 函数经常被用来创建命令行工具，把它们指定为控制台脚本的入口点。 当这样做时，<a class="reference external" href="https://pip.pypa.io/">pip</a><span class="link-target"> [https://pip.pypa.io/]</span> 将函数调用插入到模板脚本中，其中 <code class="docutils literal notranslate"><span class="pre">main</span></code> 的返回值被传递到 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal notranslate"><span class="pre">main</span></code> 调用被包裹在 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 中，期望你的函数将返回一些可被 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 作为输入而接受的值；通常为一个整数或 <code class="docutils literal notranslate"><span class="pre">None</span></code> （如果你的函数没有返回语句，则隐含返回）。</p>
<p>通过主动遵循这一惯例，我们的模块在直接运行时 (即 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">echo.py</span></code>) 会有相同的行为，当我们以后把它打包成可用 pip 安装的软件包的控制台脚本入口时也会如此。</p>
<p>特别的是，要小心从你的 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中返回字符串。 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 将把一个字符串参数解释为失败信息，所以你的程序将有一个 <code class="docutils literal notranslate"><span class="pre">1</span></code> 的退出代码，表示失败。并且这个字符串将被写入 <a class="reference internal" href="sys.xhtml#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 。 前面的 <code class="docutils literal notranslate"><span class="pre">echo.py</span></code> 例子举例说明了使用 <code class="docutils literal notranslate"><span class="pre">sys.exit(main())</span></code> 的约定。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference external" href="https://packaging.python.org/">Python 打包用户指南</a><span class="link-target"> [https://packaging.python.org/]</span> 包含了一系列关于如何用现代工具分发和安装 Python 包的教程和参考资料。</p>
</div>
</section>
</section>
<section id="main-py-in-python-packages">
<h2>Python 包中的 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code></h2>
<p>如果你不熟悉Python包，请参阅本教程的 <a class="reference internal" href="../tutorial/modules.xhtml#tut-packages"><span class="std std-ref">包</span></a> 一节。最常见的是， <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件被用来为一个包提供命令行接口。假设有下面这个虚构的包，&quot;bandclass&quot;:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bandclass
  ├── __init__.py
  ├── __main__.py
  └── student.py
</pre></div>
</div>
<p>当使用 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 标志从命令行直接调用软件包本身时，将执行 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 。比如说。</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>-m<span class="w"> </span>bandclass
</pre></div>
</div>
<p>这个命令将导致 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 的运行。你如何利用这一机制将取决于你所编写的软件包的性质，但在这个假设的案例中，允许教师搜索学生可能是有意义的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># bandclass/__main__.py</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">.student</span> <span class="kn">import</span> <span class="n">search_students</span>

<span class="n">student_name</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found student: </span><span class="si">{</span><span class="n">search_students</span><span class="p">(</span><span class="n">student_name</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>注意， <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.student</span> <span class="pre">import</span> <span class="pre">search_students</span></code> 是一个相对导入的例子。 这种导入方式可以在引用一个包内的模块时使用。 更多细节，请参见教程 <a class="reference internal" href="../tutorial/modules.xhtml#tut-modules"><span class="std std-ref">模块</span></a> 中的 <a class="reference internal" href="../tutorial/modules.xhtml#intra-package-references"><span class="std std-ref">相对导入</span></a> 一节。</p>
<section id="id1">
<h3>惯用法</h3>
<p><code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 的内容通常不会用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 块围起来。 相反，这些文件会保持简短并从其他模块导入函数来执行。 这样其他模块就可以很容易地进行单元测试并可以适当地重用。</p>
<p>如果使用，一个 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 区块仍然会像预期的那样对包内的 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件起作用，因为如果导入，它的 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 属性将包括包的路径:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">asyncio.__main__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asyncio</span><span class="o">.</span><span class="n">__main__</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;asyncio.__main__&#39;</span>
</pre></div>
</div>
<p>但这对 .zip 文件的根目录中的 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件不起作用。 因此，为了保持一致性，像下面提到的 <a class="reference internal" href="venv.xhtml#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 这样的最小 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 是首选。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>请参阅 <a class="reference internal" href="venv.xhtml#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 以获取标准库中具有最小化 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 的软件包示例。 它不包含 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 代码块。 你可以用 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">venv</span> <span class="pre">[directory]</span></code> 来发起调用。</p>
<p>参见 <a class="reference internal" href="runpy.xhtml#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 以了解更多关于 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 标志对解释器可执行包的细节。</p>
<p>参见 <a class="reference internal" href="zipapp.xhtml#module-zipapp" title="zipapp: Manage executable Python zip archives"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code></a> 了解如何运行打包成 <em>.zip</em> 文件的应用程序。在这种情况下，Python 会在归档文件的根目录下寻找一个 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件。</p>
</div>
</section>
</section>
<section id="import-main">
<h2><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__main__</span></code></h2>
<p>不管 Python 程序是用哪个模块启动的，在同一程序中运行的其他模块可以通过导入 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块来导入顶级环境的范围 ( <a class="reference internal" href="../glossary.xhtml#term-namespace"><span class="xref std std-term">namespace</span></a> )。这并不是导入一个 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件，而是导入使用特殊名称 <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code> 的哪个模块。</p>
<p>下面是一个使用 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 命名空间的模块的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># namely.py</span>

<span class="kn">import</span> <span class="nn">__main__</span>

<span class="k">def</span> <span class="nf">did_user_define_their_name</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;my_name&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">__main__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">print_user_name</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">did_user_define_their_name</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Define the variable `my_name`!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;__file__&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">__main__</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">my_name</span><span class="p">,</span> <span class="s2">&quot;found in file&quot;</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">my_name</span><span class="p">)</span>
</pre></div>
</div>
<p>该模块的用法示例如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># start.py</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">namely</span> <span class="kn">import</span> <span class="n">print_user_name</span>

<span class="c1"># my_name = &quot;Dinsdale&quot;</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">print_user_name</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">ve</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>现在，如果我们启动我们的程序，结果会是这样的:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>start.py
<span class="go">Define the variable `my_name`!</span>
</pre></div>
</div>
<p>该程序的退出代码为 1 ，表明有错误。取消对 <code class="docutils literal notranslate"><span class="pre">my_name</span> <span class="pre">=</span> <span class="pre">&quot;Dinsdale&quot;</span></code> 这一行的注释，就可以修复程序，现在它的退出状态代码为 0 ，表示成功。</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>start.py
<span class="go">Dinsdale found in file /path/to/start.py</span>
</pre></div>
</div>
<p>请注意，导入 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 不会导致无意中运行旨在用于脚本的顶层代码的问题，这些代码被放在模块 <code class="docutils literal notranslate"><span class="pre">start</span></code> 的 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;</span></code> 块中。为什么这样做？</p>
<p>Python 解释器启动时会在 <a class="reference internal" href="sys.xhtml#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中插入一个空的 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块，并通过运行最高层级代码来填充它。 在我们的例子中这就是 <code class="docutils literal notranslate"><span class="pre">start</span></code> 模块，它逐行运行并导入 <code class="docutils literal notranslate"><span class="pre">namely</span></code>。 相应地，<code class="docutils literal notranslate"><span class="pre">namely</span></code> 会导入 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> (它实际上就是 <code class="docutils literal notranslate"><span class="pre">start</span></code>)。 这就是一个导入循环！ 幸运的是，由于部分填充的 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块存在于 <a class="reference internal" href="sys.xhtml#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，Python 会将其传递给 <code class="docutils literal notranslate"><span class="pre">namely</span></code>。 请参阅导入系统的参考文档中 <a class="reference internal" href="../reference/import.xhtml#import-dunder-main"><span class="std std-ref">有关 __main__ 的特别考量</span></a> 来了解其中的详情。</p>
<p>Python REPL 是另一个 &quot;顶层环境 &quot;的例子，所以在 REPL 中定义的任何东西都成为 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 范围的一部分:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">namely</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">namely</span><span class="o">.</span><span class="n">did_user_define_their_name</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">namely</span><span class="o">.</span><span class="n">print_user_name</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Define the variable `my_name`!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_name</span> <span class="o">=</span> <span class="s1">&#39;Jabberwocky&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">namely</span><span class="o">.</span><span class="n">did_user_define_their_name</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">namely</span><span class="o">.</span><span class="n">print_user_name</span><span class="p">()</span>
<span class="go">Jabberwocky</span>
</pre></div>
</div>
<p>注意，在这种情况下， <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 范围不包含 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 属性，因为它是交互式的。</p>
<p><code class="docutils literal notranslate"><span class="pre">__main__</span></code> 范围用于 <a class="reference internal" href="pdb.xhtml#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 和 <a class="reference internal" href="rlcompleter.xhtml#module-rlcompleter" title="rlcompleter: Python identifier completion, suitable for the GNU readline library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">rlcompleter</span></code></a> 的实现。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>