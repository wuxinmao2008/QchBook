<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="dis --- Python 字节码反汇编器" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/dis.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/dis.py[https://github.com/python/cpython/tree/3.12/Lib/dis.py] dis 模块通过反汇编支持CPython的 bytecode 分析。该模块作为输入的 CPython 字节码在文件 Include/opcode.h 中定义，并由编译器和解释器使用。 CPython 实现细节： 字节码是 CPytho..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Source code: Lib/dis.py[https://github.com/python/cpython/tree/3.12/Lib/dis.py] dis 模块通过反汇编支持CPython的 bytecode 分析。该模块作为输入的 CPython 字节码在文件 Include/opcode.h 中定义，并由编译器和解释器使用。 CPython 实现细节： 字节码是 CPytho..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>dis --- Python 字节码反汇编器</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/dis.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-dis">
<span id="dis-disassembler-for-python-bytecode"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code> --- Python 字节码反汇编器</h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/dis.py">Lib/dis.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/dis.py]</span></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块通过反汇编支持CPython的 <a class="reference internal" href="../glossary.xhtml#term-bytecode"><span class="xref std std-term">bytecode</span></a> 分析。该模块作为输入的 CPython 字节码在文件 <code class="file docutils literal notranslate"><span class="pre">Include/opcode.h</span></code> 中定义，并由编译器和解释器使用。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> 字节码是 CPython 解释器的实现细节。不保证不会在Python版本之间添加、删除或更改字节码。不应考虑将此模块的跨 Python VM 或 Python 版本的使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>每条指令使用2个字节。以前字节数因指令而异。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>跳转、异常处理和循环指令的参数现在将为指令偏移量而不是字节偏移量。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>有些指令带有一个或多个内联缓存条目，它们是采用 <a class="reference internal" href="#opcode-CACHE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CACHE</span></code></a> 指令的形式。 这些指令默认是隐藏的，但可以通过将 <code class="docutils literal notranslate"><span class="pre">show_caches=True</span></code> 传给任何 <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 工具对象来显示。 此外，解释器现在会适配字节码以使其能针对不同的运行时条件实现专门化。 适配的字节码可通过传入 <code class="docutils literal notranslate"><span class="pre">adaptive=True</span></code> 来显示。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>跳转的参数是目标指令相对于紧接在跳转指令的 <a class="reference internal" href="#opcode-CACHE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CACHE</span></code></a> 条目之后的指令的偏移量。</p>
<p>因此，<a class="reference internal" href="#opcode-CACHE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CACHE</span></code></a> 指令的存在对前向跳转是透明的但在处理后向跳转时则需要将其纳入考虑。</p>
</div>
</div>
<p>示例：给定函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">myfunc()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></div>
</div>
<p>可以使用以下命令显示 <code class="xref py py-func docutils literal notranslate"><span class="pre">myfunc()</span></code> 的反汇编：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="go">  2           0 RESUME                   0</span>

<span class="go">  3           2 LOAD_GLOBAL              1 (NULL + len)</span>
<span class="go">             12 LOAD_FAST                0 (alist)</span>
<span class="go">             14 CALL                     1</span>
<span class="go">             22 RETURN_VALUE</span>
</pre></div>
</div>
<p>(&quot;2&quot; 是行号)。</p>
<section id="command-line-interface">
<span id="dis-cli"></span><h2>命令行接口</h2>
<p><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块可以在命令行下作为一个脚本来发起调用：</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>python<span class="w"> </span>-m<span class="w"> </span>dis<span class="w"> </span><span class="o">[</span>-h<span class="o">]</span><span class="w"> </span><span class="o">[</span>infile<span class="o">]</span>
</pre></div>
</div>
<p>可以接受以下选项：</p>
<dl class="std cmdoption">
<dt class="sig sig-object std" id="cmdoption-dis-h">
<span id="cmdoption-dis-help"></span><span class="sig-name descname"><span class="pre">-h</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--help</span></span><span class="sig-prename descclassname"></span></dt>
<dd><p>显示用法并退出。</p>
</dd></dl>

<p>如果指定了 <code class="file docutils literal notranslate"><span class="pre">infile</span></code>，其反汇编代码将被写入到标准输出。 否则，反汇编将在从标准输入接收的已编译源代码上进行。</p>
</section>
<section id="bytecode-analysis">
<h2>字节码分析</h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<p>字节码分析 API 允许将 Python 代码片段包装在 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 对象中，以便轻松访问已编译代码的详细信息。</p>
<dl class="py class">
<dt class="sig sig-object py" id="dis.Bytecode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">Bytecode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_line</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>分析的字节码对应于函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象（由 <a class="reference internal" href="functions.xhtml#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 返回）。</p>
<p>这是下面列出的许多函数的便利包装，最值得注意的是 <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_instructions()</span></code></a> ，迭代于 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 的实例产生字节码操作 <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 的实例。</p>
<p>如果 <em>first_line</em> 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。</p>
<p>如果 <em>current_offset</em> 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则它指的是反汇编代码中的指令偏移量。设置它意味着 <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dis()</span></code></a> 将针对指定的操作码显示“当前指令”标记。</p>
<p>如果 <em>show_caches</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，<a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dis()</span></code></a> 将显示解释器用来专门化字节码的内联缓存条目。</p>
<p>如果 <em>adaptive</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，<a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dis()</span></code></a> 将显示可能不同于原始字节码的专门化字节码。</p>
<dl class="py method">
<dt class="sig sig-object py" id="dis.Bytecode.from_traceback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_traceback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tb</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从给定回溯构造一个 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 实例，将设置 <em>current_offset</em> 为异常负责的指令。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Bytecode.codeobj">
<span class="sig-name descname"><span class="pre">codeobj</span></span></dt>
<dd><p>已编译的代码对象。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Bytecode.first_line">
<span class="sig-name descname"><span class="pre">first_line</span></span></dt>
<dd><p>代码对象的第一个源代码行（如果可用）</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dis.Bytecode.dis">
<span class="sig-name descname"><span class="pre">dis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回字节码操作的格式化视图（与 <a class="reference internal" href="#dis.dis" title="dis.dis"><code class="xref py py-func docutils literal notranslate"><span class="pre">dis.dis()</span></code></a> 打印相同，但作为多行字符串返回）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dis.Bytecode.info">
<span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回带有关于代码对象的详细信息的格式化多行字符串，如 <a class="reference internal" href="#dis.code_info" title="dis.code_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">code_info()</span></code></a> 。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>现在可以处理协程和异步生成器对象。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了 <em>show_caches</em> 和 <em>adaptive</em> 形参。</p>
</div>
</dd></dl>

<p>示例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bytecode</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">Bytecode</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">bytecode</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">opname</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">RESUME</span>
<span class="go">LOAD_GLOBAL</span>
<span class="go">LOAD_FAST</span>
<span class="go">CALL</span>
<span class="go">RETURN_VALUE</span>
</pre></div>
</div>
</section>
<section id="analysis-functions">
<h2>分析函数</h2>
<p><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块还定义了以下分析函数，它们将输入直接转换为所需的输出。如果只执行单个操作，它们可能很有用，因此中间分析对象没用：</p>
<dl class="py function">
<dt class="sig sig-object py" id="dis.code_info">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">code_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回格式化的多行字符串，其包含详细代码对象信息的用于被提供的函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象。</p>
<p>请注意，代码信息字符串的确切内容是高度依赖于实现的，它们可能会在Python VM或Python版本中任意更改。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>现在可以处理协程和异步生成器对象。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.show_code">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">show_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将提供的函数、方法。源代码字符串或代码对象的详细代码对象信息打印到 <em>file</em> （如果未指定 <em>file</em> ，则为 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> ）。</p>
<p>这是 <code class="docutils literal notranslate"><span class="pre">print(code_info(x),</span> <span class="pre">file=file)</span></code> 的便捷简写，用于在解释器提示符下进行交互式探索。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>添加 <em>file</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.dis">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">dis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>反汇编 <em>x</em> 对象。  <em>x</em> 可以表示模块、类、方法、函数、生成器、异步生成器、协程、代码对象、源代码字符串或原始字节码的字节序列。 对于模块，它会反汇编所有函数。 对于一个类，它会反汇编所有方法（包括类方法和静态方法）。 对于代码对象或原始字节码序列，它会为每条字节码指令打印一行。 它还会递归地反汇编嵌套代码对象。 这些对象包括生成器表达式、嵌套函数、嵌套类的语句体以及用于 <a class="reference internal" href="../reference/executionmodel.xhtml#annotation-scopes"><span class="std std-ref">标注作用域</span></a> 的代码对象。 在反汇编之前，首先使用 <a class="reference internal" href="functions.xhtml#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 内置函数将字符串编译为代码对象。 如果未提供任何对象，则该函数将反汇编最后一次回溯。</p>
<p>如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 。</p>
<p>递归的最大深度受 <em>depth</em> 限制，除非它是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。 <code class="docutils literal notranslate"><span class="pre">depth=0</span></code> 表示没有递归。</p>
<p>如果 <em>show_caches</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，此函数将显示解释器用来专门化字节码的内联缓存条目。</p>
<p>如果 <em>adaptive</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，此函数将显示可能不同于原始字节码的专门化字节码。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>添加 <em>file</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>实现了递归反汇编并添加了 <em>depth</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>现在可以处理协程和异步生成器对象。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了 <em>show_caches</em> 和 <em>adaptive</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.distb">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">distb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果没有传递，则使用最后一个回溯来反汇编回溯的堆栈顶部函数。 指示了导致异常的指令。</p>
<p>如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>添加 <em>file</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了 <em>show_caches</em> 和 <em>adaptive</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.disassemble">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">disassemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lasti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py" id="dis.disco">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">disco</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lasti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>反汇编代码对象，如果提供了 <em>lasti</em> ，则指示最后一条指令。输出分为以下几列：</p>
<ol class="arabic simple">
<li><p>行号，用于每行的第一条指令</p></li>
<li><p>当前指令，表示为 <code class="docutils literal notranslate"><span class="pre">--&gt;</span></code> ，</p></li>
<li><p>一个标记的指令，用 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 表示，</p></li>
<li><p>指令的地址，</p></li>
<li><p>操作码名称，</p></li>
<li><p>操作参数，和</p></li>
<li><p>括号中参数的解释。</p></li>
</ol>
<p>参数解释识别本地和全局变量名称、常量值、分支目标和比较运算符。</p>
<p>如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>添加 <em>file</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了 <em>show_caches</em> 和 <em>adaptive</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.get_instructions">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">get_instructions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_line</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_caches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在所提供的函数、方法、源代码字符串或代码对象中的指令上返回一个迭代器。</p>
<p>迭代器生成一系列 <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> ，命名为元组，提供所提供代码中每个操作的详细信息。</p>
<p>如果 <em>first_line</em> 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。</p>
<p><em>show_caches</em> 和 <em>adaptive</em> 形参的作用与 <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-func docutils literal notranslate"><span class="pre">dis()</span></code></a> 中的同名形参相同。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了 <em>show_caches</em> 和 <em>adaptive</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.findlinestarts">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">findlinestarts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这个生成器函数使用 <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">代码对象</span></a> <em>code</em> 的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_lines" title="codeobject.co_lines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">co_lines()</span></code></a> 方法来查找源代码中行开头的偏移量。 它们将作为 <code class="docutils literal notranslate"><span class="pre">(offset,</span> <span class="pre">lineno)</span></code> 对被生成。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>行号可能会减少。 以前，他们总是在增加。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>使用 <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0626/"><strong>PEP 626</strong></a><span class="link-target"> [https://peps.python.org/pep-0626/]</span> <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_lines" title="codeobject.co_lines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">co_lines()</span></code></a> 方法而不是 <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">代码对象</span></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_firstlineno" title="codeobject.co_firstlineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_lnotab" title="codeobject.co_lnotab"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code></a> 属性。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.findlabels">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">findlabels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>检测作为跳转目标的原始编译后字节码字符串 <em>code</em> 中的所有偏移量，并返回这些偏移量的列表。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dis.stack_effect">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">stack_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opcode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oparg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jump</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>使用参数 <em>oparg</em> 计算 <em>opcode</em> 的堆栈效果。</p>
<p>如果代码有一个跳转目标并且 <em>jump</em> 是 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，则 <code class="xref py py-func docutils literal notranslate"><span class="pre">drag_effect()</span></code> 将返回跳转的堆栈效果。如果 <em>jump</em> 是 <code class="docutils literal notranslate"><span class="pre">False</span></code> ，它将返回不跳跃的堆栈效果。如果 <em>jump</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> （默认值），它将返回两种情况的最大堆栈效果。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>添加 <em>jump</em> 参数。</p>
</div>
</dd></dl>

</section>
<section id="python-bytecode-instructions">
<span id="bytecodes"></span><h2>Python字节码说明</h2>
<p><a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_instructions()</span></code></a> 函数和 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 类提供字节码指令的详细信息的 <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 实例：</p>
<dl class="py class">
<dt class="sig sig-object py" id="dis.Instruction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">Instruction</span></span></dt>
<dd><p>字节码操作的详细信息</p>
<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.opcode">
<span class="sig-name descname"><span class="pre">opcode</span></span></dt>
<dd><p>操作的数字代码，对应于下面列出的操作码值和 <a class="reference internal" href="#opcode-collections"><span class="std std-ref">操作码集合</span></a> 中的字节码值。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.opname">
<span class="sig-name descname"><span class="pre">opname</span></span></dt>
<dd><p>人类可读的操作名称</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.arg">
<span class="sig-name descname"><span class="pre">arg</span></span></dt>
<dd><p>操作的数字参数（如果有的话），否则为 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.argval">
<span class="sig-name descname"><span class="pre">argval</span></span></dt>
<dd><p>已解析的 arg 值（如果有的话），否则为 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.argrepr">
<span class="sig-name descname"><span class="pre">argrepr</span></span></dt>
<dd><p>人类可读的操作参数（如果存在）的描述，否则为空字符串。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.offset">
<span class="sig-name descname"><span class="pre">offset</span></span></dt>
<dd><p>在字节码序列中启动操作索引</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.starts_line">
<span class="sig-name descname"><span class="pre">starts_line</span></span></dt>
<dd><p>行由此操作码（如果有）启动，否则为 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.is_jump_target">
<span class="sig-name descname"><span class="pre">is_jump_target</span></span></dt>
<dd><p>如果其他代码跳到这里，则为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，否则为 <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Instruction.positions">
<span class="sig-name descname"><span class="pre">positions</span></span></dt>
<dd><p><a class="reference internal" href="#dis.Positions" title="dis.Positions"><code class="xref py py-class docutils literal notranslate"><span class="pre">dis.Positions</span></code></a> 对象保存了这条指令所涵盖的起始和结束位置。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">positions</span></code> 字段。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dis.Positions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">Positions</span></span></dt>
<dd><p>考虑到此信息不可用的情况，某些字段可能为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<dl class="py data">
<dt class="sig sig-object py" id="dis.Positions.lineno">
<span class="sig-name descname"><span class="pre">lineno</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Positions.end_lineno">
<span class="sig-name descname"><span class="pre">end_lineno</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Positions.col_offset">
<span class="sig-name descname"><span class="pre">col_offset</span></span></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.Positions.end_col_offset">
<span class="sig-name descname"><span class="pre">end_col_offset</span></span></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<p>Python编译器当前生成以下字节码指令。</p>
<p><strong>一般指令</strong></p>
<p>在下文中，我们将把解释器栈称为 <code class="docutils literal notranslate"><span class="pre">STACK</span></code> 并像描述 Python 列表一样描述对它的操作。 栈顶对应于该语言中的 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code>。</p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-NOP">
<span class="sig-name descname"><span class="pre">NOP</span></span></dt>
<dd><p>无操作代码。 被字节码优化器用作占位符，以及生成行追踪事件。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_TOP">
<span class="sig-name descname"><span class="pre">POP_TOP</span></span></dt>
<dd><p>移除除堆栈顶部的项：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-END_FOR">
<span class="sig-name descname"><span class="pre">END_FOR</span></span></dt>
<dd><p>连续移除堆栈顶部的两个值。 等价于 <code class="docutils literal notranslate"><span class="pre">POP_TOP</span></code>; <code class="docutils literal notranslate"><span class="pre">POP_TOP</span></code> 。 用于循环结束时的清理，因此而得名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-END_SEND">
<span class="sig-name descname"><span class="pre">END_SEND</span></span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">STACK[-2]</span></code>。 用于在生成器退出时进行清理。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-COPY">
<span class="sig-name descname"><span class="pre">COPY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>将第 <em>i</em> 项推入栈顶，并不移除原项：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SWAP">
<span class="sig-name descname"><span class="pre">SWAP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>将栈顶的项与栈中第 <em>i</em> 项互换：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CACHE">
<span class="sig-name descname"><span class="pre">CACHE</span></span></dt>
<dd><p>此操作码不是真正的指令，它被用来为解释器标记额外空间以便在字节码中直接缓存有用的数据。 它会被所有 <code class="docutils literal notranslate"><span class="pre">dis</span></code> 工具自动隐藏，但可以通过 <code class="docutils literal notranslate"><span class="pre">show_caches=True</span></code> 来查看。</p>
<p>从逻辑上说，此空间是之前的指令的组成部分。 许多操作码都预期带有固定数量的缓存，并会指示解释器在运行时跳过它们。</p>
<p>被填充的缓存看起来可以像是任意的指令，因此在读取或修改包含快取数据的原始自适应字节码时应当非常小心。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<p><strong>一元操作</strong></p>
<p>一元操作获取堆栈顶部元素，应用操作，并将结果推回堆栈。</p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-UNARY_NEGATIVE">
<span class="sig-name descname"><span class="pre">UNARY_NEGATIVE</span></span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">-STACK[-1]</span></code> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-UNARY_NOT">
<span class="sig-name descname"><span class="pre">UNARY_NOT</span></span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">not</span> <span class="pre">STACK[-1]</span></code> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-UNARY_INVERT">
<span class="sig-name descname"><span class="pre">UNARY_INVERT</span></span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">~STACK[-1]</span></code> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-GET_ITER">
<span class="sig-name descname"><span class="pre">GET_ITER</span></span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">iter(STACK[-1])</span></code> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-GET_YIELD_FROM_ITER">
<span class="sig-name descname"><span class="pre">GET_YIELD_FROM_ITER</span></span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是一个 <a class="reference internal" href="../glossary.xhtml#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> 或 <a class="reference internal" href="../glossary.xhtml#term-coroutine"><span class="xref std std-term">coroutine</span></a> 对象则它将保持原样。 否则，将实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">iter(STACK[-1])</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<p><strong>双目和原地操作</strong></p>
<p>双目操作移除栈顶的两项（ <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> ），执行其运算操作，并将结果放回栈中。</p>
<p>原地操作类似于双目操作，但当 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 支持时，操作将在原地进行。 结果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 可能（但不一定）是原先 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 的值。</p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BINARY_OP">
<span class="sig-name descname"><span class="pre">BINARY_OP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">op</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现双目和原地操作运算符（取决于 <em>op</em> 的值）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">rhs</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">lhs</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lhs</span> <span class="n">op</span> <span class="n">rhs</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BINARY_SUBSCR">
<span class="sig-name descname"><span class="pre">BINARY_SUBSCR</span></span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">key</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_SUBSCR">
<span class="sig-name descname"><span class="pre">STORE_SUBSCR</span></span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">key</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DELETE_SUBSCR">
<span class="sig-name descname"><span class="pre">DELETE_SUBSCR</span></span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">key</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="k">del</span> <span class="n">container</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BINARY_SLICE">
<span class="sig-name descname"><span class="pre">BINARY_SLICE</span></span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">end</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_SLICE">
<span class="sig-name descname"><span class="pre">STORE_SLICE</span></span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">end</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">container</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<p><strong>协程操作码</strong></p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-GET_AWAITABLE">
<span class="sig-name descname"><span class="pre">GET_AWAITABLE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">where</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">get_awaitable(STACK[-1])</span></code> 。其中对于 <code class="docutils literal notranslate"><span class="pre">get_awaitable(o)</span></code> ，当 <code class="docutils literal notranslate"><span class="pre">o</span></code> 是一个有 <a class="reference internal" href="inspect.xhtml#inspect.CO_ITERABLE_COROUTINE" title="inspect.CO_ITERABLE_COROUTINE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CO_ITERABLE_COROUTINE</span></code></a> 旗标的协程对象或生成器对象时，返回 <code class="docutils literal notranslate"><span class="pre">o</span></code>，否则解析 <code class="docutils literal notranslate"><span class="pre">o.__await__</span></code> 。</p>
<blockquote>
<div><p>如果 <code class="docutils literal notranslate"><span class="pre">where</span></code> 操作数为非零值，则表示指令所在的位置:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>：在调用 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> 之后</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code>：在调用 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 之后</p></li>
</ul>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>在之前版本中，该指令没有 oparg。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-GET_AITER">
<span class="sig-name descname"><span class="pre">GET_AITER</span></span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">STACK[-1].__aiter__()</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>已经不再支持从 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 返回可等待对象。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-GET_ANEXT">
<span class="sig-name descname"><span class="pre">GET_ANEXT</span></span></dt>
<dd><p>对堆栈实现 <code class="docutils literal notranslate"><span class="pre">STACK.append(get_awaitable(STACK[-1].__anext__()))</span></code> 。 关于 <code class="docutils literal notranslate"><span class="pre">get_awaitable</span></code> 的细节，见 <code class="docutils literal notranslate"><span class="pre">GET_AWAITABLE</span></code> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-END_ASYNC_FOR">
<span class="sig-name descname"><span class="pre">END_ASYNC_FOR</span></span></dt>
<dd><p>终结一个 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 循环。 在等待下一项时处理被引发的异常。 栈包含了 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 中的异步可迭代对象和 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 中的已引发异常。 两者都将被弹出。 如果异常不是 <a class="reference internal" href="exceptions.xhtml#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>，它会被重新引发。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>栈中的异常表示形式现在将由一个而不是三个条目组成。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CLEANUP_THROW">
<span class="sig-name descname"><span class="pre">CLEANUP_THROW</span></span></dt>
<dd><p>处理当前帧中由调用 <a class="reference internal" href="../reference/expressions.xhtml#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 或 <a class="reference internal" href="../reference/expressions.xhtml#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 引发的异常。 如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是 <a class="reference internal" href="exceptions.xhtml#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 的实例，则从栈中弹出三个值，并将其成员 <code class="docutils literal notranslate"><span class="pre">value</span></code> 的值推入栈中，否则重新引发 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BEFORE_ASYNC_WITH">
<span class="sig-name descname"><span class="pre">BEFORE_ASYNC_WITH</span></span></dt>
<dd><p>从 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 解析 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 。 将 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__aenter__()</span></code> 的结果推入栈中：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">STACK</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="fm">__aexit__</span><span class="p">,</span> <span class="fm">__aenter__</span><span class="p">())</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<p><strong>其他操作码</strong></p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SET_ADD">
<span class="sig-name descname"><span class="pre">SET_ADD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">item</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="nb">set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>用于实现集合推导式。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LIST_APPEND">
<span class="sig-name descname"><span class="pre">LIST_APPEND</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">item</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>用于实现列表推导式。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MAP_ADD">
<span class="sig-name descname"><span class="pre">MAP_ADD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>用于实现字典推导式。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>映射的值为 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> ，映射的键为 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 。之前它们是反过来的。</p>
</div>
</dd></dl>

<p>对于所有 <a class="reference internal" href="#opcode-SET_ADD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">SET_ADD</span></code></a> 、 <a class="reference internal" href="#opcode-LIST_APPEND"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LIST_APPEND</span></code></a> 和 <a class="reference internal" href="#opcode-MAP_ADD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">MAP_ADD</span></code></a> 指令，当弹出添加的值或键值对时，容器对象保留在堆栈上，以便它可用于循环的进一步迭代。</p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-RETURN_VALUE">
<span class="sig-name descname"><span class="pre">RETURN_VALUE</span></span></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 给函数的调用者。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-RETURN_CONST">
<span class="sig-name descname"><span class="pre">RETURN_CONST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">consti</span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">co_consts[consti]</span></code> 给函数的调用者。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-YIELD_VALUE">
<span class="sig-name descname"><span class="pre">YIELD_VALUE</span></span></dt>
<dd><p>从 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">generator</span></a> 产生 <code class="docutils literal notranslate"><span class="pre">STACK.pop()</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>oparg 被设为堆栈深度。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>oparg 被设为异常块的深度，以确保关闭生成器的效率。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SETUP_ANNOTATIONS">
<span class="sig-name descname"><span class="pre">SETUP_ANNOTATIONS</span></span></dt>
<dd><p>检查 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 是否在 <code class="docutils literal notranslate"><span class="pre">locals()</span></code> 中定义，如果没有，它被设置为空 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 。只有在类或模块体静态地包含 <a class="reference internal" href="../glossary.xhtml#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> 时才会发出此操作码。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_EXCEPT">
<span class="sig-name descname"><span class="pre">POP_EXCEPT</span></span></dt>
<dd><p>从栈中弹出一个值，它将被用来恢复异常状态。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>栈中的异常表示形式现在将由一个而不是三个条目组成。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-RERAISE">
<span class="sig-name descname"><span class="pre">RERAISE</span></span></dt>
<dd><p>重新引发当前位于栈顶的异常。 如果 oparg 为非零值，则从栈顶额外弹出一个值用来设置当前帧的 <a class="reference internal" href="../reference/datamodel.xhtml#frame.f_lasti" title="frame.f_lasti"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>栈中的异常表示形式现在将由一个而不是三个条目组成。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-PUSH_EXC_INFO">
<span class="sig-name descname"><span class="pre">PUSH_EXC_INFO</span></span></dt>
<dd><p>从栈中弹出一个值。 将当前异常推入栈顶。 将原先被弹出的值推回栈。 在异常处理器中使用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CHECK_EXC_MATCH">
<span class="sig-name descname"><span class="pre">CHECK_EXC_MATCH</span></span></dt>
<dd><p>为 <code class="docutils literal notranslate"><span class="pre">except</span></code> 执行异常匹配。 检测 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 是否为匹配 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 的异常。 弹出 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 并将测试的布尔值结果推入栈。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CHECK_EG_MATCH">
<span class="sig-name descname"><span class="pre">CHECK_EG_MATCH</span></span></dt>
<dd><p>为 <code class="docutils literal notranslate"><span class="pre">except*</span></code> 执行异常匹配。 在代表 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 的异常组上应用 <code class="docutils literal notranslate"><span class="pre">split(STACK[-1])</span></code>。</p>
<p>在匹配的情况下，从栈中弹出两项并推入不匹配的子分组 (如完全匹配则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>) 以及匹配的子分组。 当没有任何匹配时，则弹出一项 (匹配类型) 并推入 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-WITH_EXCEPT_START">
<span class="sig-name descname"><span class="pre">WITH_EXCEPT_START</span></span></dt>
<dd><p>调用栈中 4 号位置上的函数并附带代表位于栈顶的异常的参数 (type, val, tb)。 用于在 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句内发生异常时实现调用 <code class="docutils literal notranslate"><span class="pre">context_manager.__exit__(*exc_info())</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">__exit__</span></code> 函数位于栈的 4 号位而不是 7 号位。 栈中的异常表示形式现在由一项而不是三项组成。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_ASSERTION_ERROR">
<span class="sig-name descname"><span class="pre">LOAD_ASSERTION_ERROR</span></span></dt>
<dd><p>将 <a class="reference internal" href="exceptions.xhtml#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 推入栈顶。 由 <a class="reference internal" href="../reference/simple_stmts.xhtml#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 语句使用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_BUILD_CLASS">
<span class="sig-name descname"><span class="pre">LOAD_BUILD_CLASS</span></span></dt>
<dd><p>将 <code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.__build_class__()</span></code> 推入栈中。 之后它将会被调用来构造一个类。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BEFORE_WITH">
<span class="sig-name descname"><span class="pre">BEFORE_WITH</span></span></dt>
<dd><p>此操作码会在 with 代码块开始之前执行多个操作。 首先，它将从上下文管理器加载 <a class="reference internal" href="../reference/datamodel.xhtml#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 并将其推入栈顶以供 <a class="reference internal" href="#opcode-WITH_EXCEPT_START"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">WITH_EXCEPT_START</span></code></a> 后续使用。 然后，将调用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>。 最后，将调用 <code class="docutils literal notranslate"><span class="pre">__enter__()</span></code> 方法的结果推入栈顶。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-GET_LEN">
<span class="sig-name descname"><span class="pre">GET_LEN</span></span></dt>
<dd><p>执行 <code class="docutils literal notranslate"><span class="pre">STACK.append(len(STACK[-1]))</span></code> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MATCH_MAPPING">
<span class="sig-name descname"><span class="pre">MATCH_MAPPING</span></span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 的实例（或者更准确地说：如果在它的 <a class="reference internal" href="../c-api/typeobj.xhtml#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 中设置了 <a class="reference internal" href="../c-api/typeobj.xhtml#c.Py_TPFLAGS_MAPPING" title="Py_TPFLAGS_MAPPING"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_MAPPING</span></code></a> 旗标），则将 <code class="docutils literal notranslate"><span class="pre">True</span></code> 推入栈顶。 否则，推入 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MATCH_SEQUENCE">
<span class="sig-name descname"><span class="pre">MATCH_SEQUENCE</span></span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 的实例而 <em>不是</em>  <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>/<a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>/<a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的实例（或者更准确地说：如果在它的 <a class="reference internal" href="../c-api/typeobj.xhtml#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 中设置了 <a class="reference internal" href="../c-api/typeobj.xhtml#c.Py_TPFLAGS_SEQUENCE" title="Py_TPFLAGS_SEQUENCE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_SEQUENCE</span></code></a> 旗标），则将 <code class="docutils literal notranslate"><span class="pre">True</span></code> 推入栈顶。 否则 ，推入 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MATCH_KEYS">
<span class="sig-name descname"><span class="pre">MATCH_KEYS</span></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是一个映射键的元组，而 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 是匹配目标。 如果 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 包含 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 中的所有键，则推入一个包含对应值的 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>。 在其他情况下，推入 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>在之前的版本中，该指令还会推入一个表示成功 (<code class="docutils literal notranslate"><span class="pre">True</span></code>) 或失败 (<code class="docutils literal notranslate"><span class="pre">False</span></code>) 的布尔值。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_NAME">
<span class="sig-name descname"><span class="pre">STORE_NAME</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">STACK.pop()</span></code>。 <em>namei</em> 是 <em>name</em> 在 <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">代码对象</span></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_names" title="codeobject.co_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code></a> 属性中的索引。 在可能的情况下编译器会尝试使用 <a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a> 或 <a class="reference internal" href="#opcode-STORE_GLOBAL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_GLOBAL</span></code></a>。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DELETE_NAME">
<span class="sig-name descname"><span class="pre">DELETE_NAME</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">name</span></code>，其中 <em>namei</em> 是 <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">代码对象</span></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_names" title="codeobject.co_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code></a> 属性的索引。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-UNPACK_SEQUENCE">
<span class="sig-name descname"><span class="pre">UNPACK_SEQUENCE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 解包为 <em>count</em> 个单独的值，然后自右向左放入栈中。要求有确切的 <em>count</em> 值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()[:</span><span class="o">-</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-UNPACK_EX">
<span class="sig-name descname"><span class="pre">UNPACK_EX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">counts</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现带星号目标的赋值：将 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 中的可迭代对象解包为各个单独的值。 值的总数可以小于可迭代对象的项数：其中会有一个值是存放剩下的项的列表。</p>
<p>在列表前后的值的数量被限制在255。</p>
<p>列表前的值的数量被编码在操作码的参数之中。 如果列表后有值，则其数量会被用 <code class="docutils literal notranslate"><span class="pre">EXTENDED_ARG</span></code> 编码。 因此参数可以被认为是一个双字节值，其中低位字节代表列表前的值的数量，高位字节代表其后的值的数量。</p>
<p>提取出来的值被自右向左放入栈中，也就是说 <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">*b,</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span></code> 在执行完成之后会被这样储存： <code class="docutils literal notranslate"><span class="pre">STACK.extend((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_ATTR">
<span class="sig-name descname"><span class="pre">STORE_ATTR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>其中 <em>namei</em> 是 name 在 <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">代码对象</span></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_names" title="codeobject.co_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code></a> 中的索引。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DELETE_ATTR">
<span class="sig-name descname"><span class="pre">DELETE_ATTR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>其中 <em>namei</em> 是 name 在 <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">代码对象</span></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_names" title="codeobject.co_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code></a> 中的索引。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_GLOBAL">
<span class="sig-name descname"><span class="pre">STORE_GLOBAL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#opcode-STORE_NAME"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_NAME</span></code></a> 但会将 name 存储为全局变量。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DELETE_GLOBAL">
<span class="sig-name descname"><span class="pre">DELETE_GLOBAL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#opcode-DELETE_NAME"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">DELETE_NAME</span></code></a> 但会删除一个全局变量。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_CONST">
<span class="sig-name descname"><span class="pre">LOAD_CONST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">consti</span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="docutils literal notranslate"><span class="pre">co_consts[consti]</span></code> 推入栈顶。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_NAME">
<span class="sig-name descname"><span class="pre">LOAD_NAME</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code> 关联的值压入栈中。 名称的查找范围包括局部变量，然后是全局变量，然后是内置量。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_LOCALS">
<span class="sig-name descname"><span class="pre">LOAD_LOCALS</span></span></dt>
<dd><p>将一个局部变量字典的引用压入栈中。 被用于为 <a class="reference internal" href="#opcode-LOAD_FROM_DICT_OR_DEREF"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_FROM_DICT_OR_DEREF</span></code></a> 和 <a class="reference internal" href="#opcode-LOAD_FROM_DICT_OR_GLOBALS"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_FROM_DICT_OR_GLOBALS</span></code></a> 准备命名空间字典。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_FROM_DICT_OR_GLOBALS">
<span class="sig-name descname"><span class="pre">LOAD_FROM_DICT_OR_GLOBALS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>从栈中弹出一个映射，在其中查找 <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code>。 如果在此没有找到相应的名称，则在全局变量和内置量中查找，类似 <a class="reference internal" href="#opcode-LOAD_GLOBAL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code></a> 。 被用于在类定义中的 <a class="reference internal" href="../reference/executionmodel.xhtml#annotation-scopes"><span class="std std-ref">标注作用域</span></a> 中加载全局变量。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_TUPLE">
<span class="sig-name descname"><span class="pre">BUILD_TUPLE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个使用了来自栈的 <em>count</em> 个项的元组，并将结果元组推入栈顶：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">STACK</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">STACK</span><span class="p">[:</span><span class="o">-</span><span class="n">count</span><span class="p">],</span> <span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">count</span><span class="p">:]</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_LIST">
<span class="sig-name descname"><span class="pre">BUILD_LIST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#opcode-BUILD_TUPLE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE</span></code></a> 但会创建一个列表。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_SET">
<span class="sig-name descname"><span class="pre">BUILD_SET</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#opcode-BUILD_TUPLE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE</span></code></a> 但会创建一个集合。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_MAP">
<span class="sig-name descname"><span class="pre">BUILD_MAP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个新字典对象推入栈顶。 弹出 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">count</span></code> 项使得字典包含 <em>count</em> 个条目: <code class="docutils literal notranslate"><span class="pre">{...,</span> <span class="pre">STACK[-4]:</span> <span class="pre">STACK[-3],</span> <span class="pre">STACK[-2]:</span> <span class="pre">STACK[-1]}</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>字典是根据栈中的项创建而不是创建一个预设大小包含 <em>count</em> 项的空字典。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_CONST_KEY_MAP">
<span class="sig-name descname"><span class="pre">BUILD_CONST_KEY_MAP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#opcode-BUILD_MAP"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_MAP</span></code></a> 版本专用于常量键。 弹出的栈顶元素包含一个由键构成的元组，然后从 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 开始从构建字典的值中弹出 <em>count</em> 个值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_STRING">
<span class="sig-name descname"><span class="pre">BUILD_STRING</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p>拼接 <em>count</em> 个来自栈的字符串并将结果字符串推入栈顶。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LIST_EXTEND">
<span class="sig-name descname"><span class="pre">LIST_EXTEND</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="nb">list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
<p>用于构建列表。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SET_UPDATE">
<span class="sig-name descname"><span class="pre">SET_UPDATE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="nb">set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
<p>用于构建集合。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DICT_UPDATE">
<span class="sig-name descname"><span class="pre">DICT_UPDATE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="nb">dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">STACK</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="nb">map</span><span class="p">)</span>
</pre></div>
</div>
<p>用于构建字典。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DICT_MERGE">
<span class="sig-name descname"><span class="pre">DICT_MERGE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#opcode-DICT_UPDATE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">DICT_UPDATE</span></code></a> 但对于重复的键会引发异常。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_ATTR">
<span class="sig-name descname"><span class="pre">LOAD_ATTR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">namei</span></code> 的低位未设置，则将 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">getattr(STACK[-1],</span> <span class="pre">co_names[namei&gt;&gt;1])</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">namei</span></code> 的低位已设置，则会尝试从 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 对象加载名为 <code class="docutils literal notranslate"><span class="pre">co_names[namei&gt;&gt;1]</span></code> 的方法。 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 会被弹出。 此字节码会区分两种情况：如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 具有一个名称正确的方法，字节码会推入未绑定的方法和 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code>。 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 将被 <a class="reference internal" href="#opcode-CALL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL</span></code></a> 用作调用未绑定方法时的第一个参数 (<code class="docutils literal notranslate"><span class="pre">self</span></code>)。 否则，将推入 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 和属性查询所返回的对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>如果 <code class="docutils literal notranslate"><span class="pre">namei</span></code> 的低位已置，则会在属性或未绑定方法之前分别将 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">self</span></code> 推入栈。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_SUPER_ATTR">
<span class="sig-name descname"><span class="pre">LOAD_SUPER_ATTR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>该操作码实现了 <a class="reference internal" href="functions.xhtml#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>，包括零参数和双参数形式 (例如 <code class="docutils literal notranslate"><span class="pre">super().method()</span></code>, <code class="docutils literal notranslate"><span class="pre">super().attr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">super(cls,</span> <span class="pre">self).method()</span></code>, <code class="docutils literal notranslate"><span class="pre">super(cls,</span> <span class="pre">self).attr</span></code>)。</p>
<p>它会从栈中弹出三个值（从栈顶向下）: - <code class="docutils literal notranslate"><span class="pre">self</span></code>: 当前方法的第一个参数 - <code class="docutils literal notranslate"><span class="pre">cls</span></code>: 当前方法定义所在的类 - 全局 <code class="docutils literal notranslate"><span class="pre">super</span></code></p>
<p>对应于其参数，它的操作类似于 <a class="reference internal" href="#opcode-LOAD_ATTR"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_ATTR</span></code></a>，区别在于 <code class="docutils literal notranslate"><span class="pre">namei</span></code> 左移了 2 位而不是 1 位。</p>
<p><code class="docutils literal notranslate"><span class="pre">namei</span></code> 的低位发出尝试加载方法的信号，与 <a class="reference internal" href="#opcode-LOAD_ATTR"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_ATTR</span></code></a> 一样，其结果是推入 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 和所加载的方法。 当其被取消设置时会将单个值推入栈。</p>
<p><code class="docutils literal notranslate"><span class="pre">namei</span></code> 的次低比特位如果被设置，表示这是对 <a class="reference internal" href="functions.xhtml#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 附带两个参数的调用（未设置则表示附带零个参数）。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-COMPARE_OP">
<span class="sig-name descname"><span class="pre">COMPARE_OP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">opname</span></em><span class="sig-paren">)</span></dt>
<dd><p>执行布尔运算操作。 操作名称可在 <code class="docutils literal notranslate"><span class="pre">cmp_op[opname]</span></code> 中找到。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-IS_OP">
<span class="sig-name descname"><span class="pre">IS_OP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">invert</span></em><span class="sig-paren">)</span></dt>
<dd><p>执行 <code class="docutils literal notranslate"><span class="pre">is</span></code> 比较，或者如果 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 为 1 则执行 <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CONTAINS_OP">
<span class="sig-name descname"><span class="pre">CONTAINS_OP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">invert</span></em><span class="sig-paren">)</span></dt>
<dd><p>执行 <code class="docutils literal notranslate"><span class="pre">in</span></code> 比较，或者如果 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 为 1 则执行 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-IMPORT_NAME">
<span class="sig-name descname"><span class="pre">IMPORT_NAME</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>导入模块 <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code>。 会弹出 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 以提供 <em>fromlist</em> 和 <em>level</em> 参数给 <a class="reference internal" href="functions.xhtml#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 。 模块对象会被推入栈顶。 当前命名空间不受影响：对于一条标准 import 语句，会执行后续的 <a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a> 指令来修改命名空间。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-IMPORT_FROM">
<span class="sig-name descname"><span class="pre">IMPORT_FROM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>从在 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 内找到的模块中加载属性 <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code>。 结果对象会被推入栈顶，以便由后续的 <a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a> 指令来保存。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-JUMP_FORWARD">
<span class="sig-name descname"><span class="pre">JUMP_FORWARD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>将字节码计数器的值增加 <em>delta</em>。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-JUMP_BACKWARD">
<span class="sig-name descname"><span class="pre">JUMP_BACKWARD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>将字节码计数器减少 <em>delta</em>。 检查中断。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-JUMP_BACKWARD_NO_INTERRUPT">
<span class="sig-name descname"><span class="pre">JUMP_BACKWARD_NO_INTERRUPT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>将字节码计数器减少 <em>delta</em>。 不检查中断。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_JUMP_IF_TRUE">
<span class="sig-name descname"><span class="pre">POP_JUMP_IF_TRUE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 为真值，则将字节码计数器增加 <em>delta</em>。 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 将被弹出。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>操作符的参数现在是一个相对的差值而不是一个绝对的目标量。 此操作码是一个伪指令，在最终的字节码里被定向的版本（ forward/backward ）取代。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该操作码现在不再是伪指令。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_JUMP_IF_FALSE">
<span class="sig-name descname"><span class="pre">POP_JUMP_IF_FALSE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 为假值，则将字节码计数器增加 <em>delta</em>。 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 将被弹出。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>操作符的参数现在是一个相对的差值而不是一个绝对的目标量。 此操作码是一个伪指令，在最终的字节码里被定向的版本（ forward/backward ）取代。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该操作码现在不再是伪指令。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_JUMP_IF_NOT_NONE">
<span class="sig-name descname"><span class="pre">POP_JUMP_IF_NOT_NONE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 不为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则将字节码计数器增加 <em>delta</em>。 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 将被弹出。</p>
<p>此操作码是一个伪指令，在最终的字节码里被定向的版本（ forward/backward ）取代。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该操作码现在不再是伪指令。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_JUMP_IF_NONE">
<span class="sig-name descname"><span class="pre">POP_JUMP_IF_NONE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则将字节码计数器增加 <em>delta</em>。 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 将被弹出。</p>
<p>此操作码是一个伪指令，在最终的字节码里被定向的版本（ forward/backward ）取代。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>该操作码现在不再是伪指令。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-FOR_ITER">
<span class="sig-name descname"><span class="pre">FOR_ITER</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是一个 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a>。 调用其 <a class="reference internal" href="stdtypes.xhtml#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法。 如果产生一个新的值则压入栈中 （把迭代器压下去）。 如果迭代器已耗尽，则将字节码计数器增加 <em>delta</em> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>直到 3.11 ，当迭代器耗尽时，它会被从栈中弹出。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_GLOBAL">
<span class="sig-name descname"><span class="pre">LOAD_GLOBAL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">namei</span></em><span class="sig-paren">)</span></dt>
<dd><p>将名为 <code class="docutils literal notranslate"><span class="pre">co_names[namei&gt;&gt;1]</span></code> 的全局对象加载到栈顶。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>如果设置了 <code class="docutils literal notranslate"><span class="pre">namei</span></code> 的低比特位，则会在全局变量前将一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 推入栈。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_FAST">
<span class="sig-name descname"><span class="pre">LOAD_FAST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var_num</span></em><span class="sig-paren">)</span></dt>
<dd><p>将指向局部对象 <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code> 的引用推入栈顶。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>这个操作码目前只用在保证局部变量被初始化的情况下使用。它不能引发 <a class="reference internal" href="exceptions.xhtml#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> 。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_FAST_CHECK">
<span class="sig-name descname"><span class="pre">LOAD_FAST_CHECK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var_num</span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个指向局部变量 <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code> 的引用推入栈中，如果该局部变量未被初始化，引发一个 <a class="reference internal" href="exceptions.xhtml#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_FAST_AND_CLEAR">
<span class="sig-name descname"><span class="pre">LOAD_FAST_AND_CLEAR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var_num</span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个指向局部变量 <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code> 的引用推入栈中（如果该局部变量未被初始化，则推入一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ）然后将 <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_FAST">
<span class="sig-name descname"><span class="pre">STORE_FAST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var_num</span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="docutils literal notranslate"><span class="pre">STACK.pop()</span></code> 存放到局部变量 <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DELETE_FAST">
<span class="sig-name descname"><span class="pre">DELETE_FAST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var_num</span></em><span class="sig-paren">)</span></dt>
<dd><p>移除局部对象 <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code>。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MAKE_CELL">
<span class="sig-name descname"><span class="pre">MAKE_CELL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>在槽位 <code class="docutils literal notranslate"><span class="pre">i</span></code> 中创建一个新单元。 如果该槽位为非空则该值将存储到新单元中。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_CLOSURE">
<span class="sig-name descname"><span class="pre">LOAD_CLOSURE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>推入一个指向包含在 &quot;fast locals&quot; 存储的 <code class="docutils literal notranslate"><span class="pre">i</span></code> 号槽位的单元的引用。 变量名为 <code class="docutils literal notranslate"><span class="pre">co_fastlocalnames[i]</span></code>。</p>
<p>注意 <code class="docutils literal notranslate"><span class="pre">LOAD_CLOSURE</span></code> 实际上是 <code class="docutils literal notranslate"><span class="pre">LOAD_FAST</span></code> 的一个别名。 它的存在是为了让字节码的可读性更好一些。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">i</span></code> 不再是长度为 <code class="docutils literal notranslate"><span class="pre">co_varnames</span></code> 的偏移量。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_DEREF">
<span class="sig-name descname"><span class="pre">LOAD_DEREF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>加载包含在 &quot;fast locals&quot; 存储的 <code class="docutils literal notranslate"><span class="pre">i</span></code> 号槽位中的单元。 将一个指向该单元所包含对象的引用推入栈。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">i</span></code> 不再是 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_varnames" title="codeobject.co_varnames"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code></a> 的长度的偏移量。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_FROM_DICT_OR_DEREF">
<span class="sig-name descname"><span class="pre">LOAD_FROM_DICT_OR_DEREF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>从栈中弹出一个映射并查找与该映射中的“快速本地”存储的槽位 <code class="docutils literal notranslate"><span class="pre">i</span></code> 相关联的名称。 如果未在其中找到此名称，则从槽位 <code class="docutils literal notranslate"><span class="pre">i</span></code> 中包含的单元中加载它，与 <a class="reference internal" href="#opcode-LOAD_DEREF"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_DEREF</span></code></a> 类似。 这被用于加载类语句体中的自由变量 (在此之前使用是 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_CLASSDEREF</span></code>) 和类语句体中的 <a class="reference internal" href="../reference/executionmodel.xhtml#annotation-scopes"><span class="std std-ref">标注作用域</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-STORE_DEREF">
<span class="sig-name descname"><span class="pre">STORE_DEREF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="docutils literal notranslate"><span class="pre">STACK.pop()</span></code> 存放到 &quot;fast locals&quot; 存储中包含在 <code class="docutils literal notranslate"><span class="pre">i</span></code> 号槽位的单元内。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">i</span></code> 不再是 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_varnames" title="codeobject.co_varnames"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code></a> 的长度的偏移量。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-DELETE_DEREF">
<span class="sig-name descname"><span class="pre">DELETE_DEREF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em><span class="sig-paren">)</span></dt>
<dd><p>清空 &quot;fast locals&quot; 存储中包含在 <code class="docutils literal notranslate"><span class="pre">i</span></code> 号槽位的单元。 被用于 <a class="reference internal" href="../reference/simple_stmts.xhtml#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 语句。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">i</span></code> 不再是 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_varnames" title="codeobject.co_varnames"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code></a> 的长度的偏移量。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-COPY_FREE_VARS">
<span class="sig-name descname"><span class="pre">COPY_FREE_VARS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">n</span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个自由变量从闭包拷贝到帧中。 当调用闭包时不再需要调用方添加特殊的代码。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-RAISE_VARARGS">
<span class="sig-name descname"><span class="pre">RAISE_VARARGS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">argc</span></em><span class="sig-paren">)</span></dt>
<dd><p>使用 <code class="docutils literal notranslate"><span class="pre">raise</span></code> 语句的 3 种形式之一引发异常，具体形式取决于 <em>argc</em> 的值：</p>
<ul class="simple">
<li><p>0: <code class="docutils literal notranslate"><span class="pre">raise</span></code> (重新引发之前的异常)</p></li>
<li><p>1: <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">STACK[-1]</span></code> （在 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 上引发异常实例或类型）</p></li>
<li><p>2: <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">STACK[-2]</span> <span class="pre">from</span> <span class="pre">STACK[-1]</span></code> （在 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 上引发异常实例或类型并将 <code class="docutils literal notranslate"><span class="pre">__cause__</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> ）</p></li>
</ul>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CALL">
<span class="sig-name descname"><span class="pre">CALL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">argc</span></em><span class="sig-paren">)</span></dt>
<dd><p>调用一个可调用对象并传入由 <code class="docutils literal notranslate"><span class="pre">argc</span></code> 所指定数量的参数，包括之前的 <a class="reference internal" href="#opcode-KW_NAMES"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">KW_NAMES</span></code></a> 所指定的关键字参数，如果有的话。 在栈上（按升序排列），可以是:</p>
<ul class="simple">
<li><p>NULL</p></li>
<li><p>可调用对象</p></li>
<li><p>位置参数</p></li>
<li><p>关键字参数</p></li>
</ul>
<p>或者:</p>
<ul class="simple">
<li><p>可调用对象</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p>其余的位置参数</p></li>
<li><p>关键字参数</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">argc</span></code> 是位置和关键字参数的总和，当未提供 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 时将排除 <code class="docutils literal notranslate"><span class="pre">self</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">CALL</span></code> 将把所有参数和可调用对象弹出栈，附带这些参数调用该可调用对象，并将该可调用对象的返回值推入栈。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CALL_FUNCTION_EX">
<span class="sig-name descname"><span class="pre">CALL_FUNCTION_EX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flags</span></em><span class="sig-paren">)</span></dt>
<dd><p>调用一个可调用对象并附带位置参数和关键字参数变量集合。 如果设置了 <em>flags</em> 的最低位，则栈顶包含一个由额外关键字参数组成的映射对象。 在调用该可调用对象之前，映射对象和可迭代对象会被分别“解包”并将它们的内容分别作为关键字参数和位置参数传入。 <code class="docutils literal notranslate"><span class="pre">CALL_FUNCTION_EX</span></code> 会中栈中弹出所有参数及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-PUSH_NULL">
<span class="sig-name descname"><span class="pre">PUSH_NULL</span></span></dt>
<dd><p>将一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 推入栈。 在调用序列中用来匹配 <a class="reference internal" href="#opcode-LOAD_METHOD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_METHOD</span></code></a> 针对非方法调用推入栈的 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-KW_NAMES">
<span class="sig-name descname"><span class="pre">KW_NAMES</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">consti</span></em><span class="sig-paren">)</span></dt>
<dd><p>向 <a class="reference internal" href="#opcode-CALL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL</span></code></a> 添加前缀。 将指向 <code class="docutils literal notranslate"><span class="pre">co_consts[consti]</span></code> 的引用存入一个内部变量供 <a class="reference internal" href="#opcode-CALL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL</span></code></a> 使用。 <code class="docutils literal notranslate"><span class="pre">co_consts[consti]</span></code> 必须为一个字符串元组。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MAKE_FUNCTION">
<span class="sig-name descname"><span class="pre">MAKE_FUNCTION</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flags</span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个新函数对象推入栈顶。 从底端到顶端，如果参数带有指定的旗标值则所使用的栈必须由这些值组成。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x01</span></code> 一个默认值的元组，用于按位置排序的仅限位置形参以及位置或关键字形参</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x02</span></code> 一个仅限关键字形参的默认值的字典</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x04</span></code> 一个包含形参标注的字符串元组。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x08</span></code> 一个包含用于自由变量的单元的元组，生成一个闭包</p></li>
<li><p>与函数 (在 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> ) 相关联的代码</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>旗标值 <code class="docutils literal notranslate"><span class="pre">0x04</span></code> 是一个字符串元组而非字典。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>位于 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 的限定名称已被移除。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-BUILD_SLICE">
<span class="sig-name descname"><span class="pre">BUILD_SLICE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">argc</span></em><span class="sig-paren">)</span></dt>
<dd><p id="index-1">将一个切片对象推入栈中， <em>argc</em> 必须为2或3。 如果其为2，则实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">end</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
</pre></div>
</div>
<p>如果其为3，则实现：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">step</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
</pre></div>
</div>
<p>详见内置函数 <a class="reference internal" href="functions.xhtml#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> 。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-EXTENDED_ARG">
<span class="sig-name descname"><span class="pre">EXTENDED_ARG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ext</span></em><span class="sig-paren">)</span></dt>
<dd><p>为任意带有大到无法放入默认的单字节的参数的操作码添加前缀。 <em>ext</em> 存放一个附加字节作为参数中的高比特位。 对于每个操作码，最多允许三个 <code class="docutils literal notranslate"><span class="pre">EXTENDED_ARG</span></code> 前缀，构成两字节到三字节的参数。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-FORMAT_VALUE">
<span class="sig-name descname"><span class="pre">FORMAT_VALUE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flags</span></em><span class="sig-paren">)</span></dt>
<dd><p>用于实现格式化字面值字符串（f-字符串）。 从栈中弹出一个可选的 <em>fmt_spec</em>，然后是一个必须的 <em>value</em>。 <em>flags</em> 的解读方式如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x00</span></code>: <em>value</em> 按原样格式化。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x01</span></code>: 在格式化 <em>value</em> 之前调用其 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x02</span></code>: 在格式化 <em>value</em> 之前调用其 <a class="reference internal" href="functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x03</span></code>: 在格式化 <em>value</em> 之前调用其 <a class="reference internal" href="functions.xhtml#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x04)</span> <span class="pre">==</span> <span class="pre">0x04</span></code>: 从栈中弹出 <em>fmt_spec</em> 并使用它，否则使用空的 <em>fmt_spec</em>。</p></li>
</ul>
<p>使用 <a class="reference internal" href="../c-api/object.xhtml#c.PyObject_Format" title="PyObject_Format"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Format()</span></code></a> 执行格式化。 结果会被推入栈顶。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-MATCH_CLASS">
<span class="sig-name descname"><span class="pre">MATCH_CLASS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">count</span></em><span class="sig-paren">)</span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 是一个由关键字属性名称组成的元组，<code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 是要匹配的类， 而 <code class="docutils literal notranslate"><span class="pre">STACK[-3]</span></code> 是匹配的目标主题。 <em>count</em> 是位置子模式的数量。</p>
<p>弹出 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code>、<code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">STACK[-3]</span></code>。 如果 <code class="docutils literal notranslate"><span class="pre">STACK[-3]</span></code> 是 <code class="docutils literal notranslate"><span class="pre">STACK[-2]</span></code> 的实例并且具有 <em>count</em> 和 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 所要求的位置和关键字属性，则推入一个由已提取属性组成的元组。 在其他情况下，则推入 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>在之前的版本中，该指令还会推入一个表示成功 (<code class="docutils literal notranslate"><span class="pre">True</span></code>) 或失败 (<code class="docutils literal notranslate"><span class="pre">False</span></code>) 的布尔值。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-RESUME">
<span class="sig-name descname"><span class="pre">RESUME</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">where</span></em><span class="sig-paren">)</span></dt>
<dd><p>空操作。 执行内部追踪、调试和优化检查。</p>
<p><code class="docutils literal notranslate"><span class="pre">where</span></code> 操作数标记 <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> 在哪里发生:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> 在函数的开头。 函数不能是生成器、协程或者异步生成器。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> 在 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 表达式之后</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> 在 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 表达式之后</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> 在 <code class="docutils literal notranslate"><span class="pre">await</span></code> 表达式之后</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-RETURN_GENERATOR">
<span class="sig-name descname"><span class="pre">RETURN_GENERATOR</span></span></dt>
<dd><p>从当前帧中创建一个生成器，协程，或者异步生成器。 被用作上述可调用对象的代码对象第一个操作码。 清除当前帧，返回新创建的生成器。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SEND">
<span class="sig-name descname"><span class="pre">SEND</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">delta</span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span> <span class="pre">=</span> <span class="pre">STACK[-2].send(STACK[-1])</span></code> 。 被用于 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 和 <code class="docutils literal notranslate"><span class="pre">await</span></code> 语句。</p>
<p>如果调用引发了 <a class="reference internal" href="exceptions.xhtml#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，则从栈中弹出最上面的值，推入异常的 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性，并将字节码计数器值递增 <em>delta</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-HAVE_ARGUMENT">
<span class="sig-name descname"><span class="pre">HAVE_ARGUMENT</span></span></dt>
<dd><p>这不是一个真正的操作码。 它是 [0,255] 范围内使用与不使用参数的操作码（分别是 <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">HAVE_ARGUMENT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">HAVE_ARGUMENT</span></code> ）的分界线。</p>
<p>如果你的应用程序使用了伪指令，请使用 <a class="reference internal" href="#dis.hasarg" title="dis.hasarg"><code class="xref py py-data docutils literal notranslate"><span class="pre">hasarg</span></code></a> 作为替代。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>现在每条指令都带有参数，但操作码 <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">HAVE_ARGUMENT</span></code> 会忽略它。 之前仅限操作码 <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">HAVE_ARGUMENT</span></code> 带有参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>伪指令被添加到 <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块中，对于它们来说，“比较 <code class="docutils literal notranslate"><span class="pre">HAVE_ARGUMENT</span></code> 以确定其是否使用参数”不再有效。</p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CALL_INTRINSIC_1">
<span class="sig-name descname"><span class="pre">CALL_INTRINSIC_1</span></span></dt>
<dd><p>调用内联的函数并附带一个参数。 传入 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 作为参数并将 <code class="docutils literal notranslate"><span class="pre">STACK[-1]</span></code> 设为结果。 用于实现对性能不敏感的功能。</p>
<p>调用哪个内置函数取决于操作数：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>操作数</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_1_INVALID</span></code></p></td>
<td><p>无效</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_PRINT</span></code></p></td>
<td><p>将参数打印到标准输出。 被用于 REPL 。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_IMPORT_STAR</span></code></p></td>
<td><p>为指定模块执行 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code> 。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_STOPITERATION_ERROR</span></code></p></td>
<td><p>从 <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> 异常中提取返回值。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_ASYNC_GEN_WRAP</span></code></p></td>
<td><p>包裹一个异步生成器值</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_UNARY_POSITIVE</span></code></p></td>
<td><p>执行单目运算符 <code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_LIST_TO_TUPLE</span></code></p></td>
<td><p>将一个列表转换为元组</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_TYPEVAR</span></code></p></td>
<td><p>创建一个 <a class="reference internal" href="typing.xhtml#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVar</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_PARAMSPEC</span></code></p></td>
<td><p>创建一个 <a class="reference internal" href="typing.xhtml#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ParamSpec</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_TYPEVARTUPLE</span></code></p></td>
<td><p>创建一个 <a class="reference internal" href="typing.xhtml#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVarTuple</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_SUBSCRIPT_GENERIC</span></code></p></td>
<td><p>返回 <a class="reference internal" href="typing.xhtml#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a> 取参数下标。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_TYPEALIAS</span></code></p></td>
<td><p>创建一个 <a class="reference internal" href="typing.xhtml#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeAliasType</span></code></a> ；被用于 <a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句。 参数是一个由类型别名的名称、类型形参和值组成的元组。</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-CALL_INTRINSIC_2">
<span class="sig-name descname"><span class="pre">CALL_INTRINSIC_2</span></span></dt>
<dd><p>调用内联的函数并附带两个参数。 用于实现对性能不敏感的功能:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arg2</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">arg1</span> <span class="o">=</span> <span class="n">STACK</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">intrinsic2</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
<span class="n">STACK</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>调用哪个内置函数取决于操作数：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>操作数</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_2_INVALID</span></code></p></td>
<td><p>无效</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_PREP_RERAISE_STAR</span></code></p></td>
<td><p>计算 <a class="reference internal" href="exceptions.xhtml#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 以从 <code class="docutils literal notranslate"><span class="pre">try-except*</span></code> 中引发异常。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_TYPEVAR_WITH_BOUND</span></code></p></td>
<td><p>创建一个带范围的 <a class="reference internal" href="typing.xhtml#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVar</span></code></a> 。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_TYPEVAR_WITH_CONSTRAINTS</span></code></p></td>
<td><p>创建一个带约束的 <a class="reference internal" href="typing.xhtml#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVar</span></code></a> 。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTRINSIC_SET_FUNCTION_TYPE_PARAMS</span></code></p></td>
<td><p>为一个函数设置 <code class="docutils literal notranslate"><span class="pre">__type_params__</span></code> 属性。</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<p><strong>伪指令</strong></p>
<p>这些操作码并不出现在 Python 的字节码之中。 它们被编译器所使用，但在生成字节码之前会被替代成真正的操作码。</p>
<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SETUP_FINALLY">
<span class="sig-name descname"><span class="pre">SETUP_FINALLY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">target</span></em><span class="sig-paren">)</span></dt>
<dd><p>为下面的代码块设置一个异常处理器。 如果发生异常，值栈的级别将恢复到当前状态并将控制权移交给位于 <code class="docutils literal notranslate"><span class="pre">target</span></code> 的异常处理器。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SETUP_CLEANUP">
<span class="sig-name descname"><span class="pre">SETUP_CLEANUP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">target</span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <code class="docutils literal notranslate"><span class="pre">SETUP_FINALLY</span></code> 类似，但在出现异常的情况下也会将最后一条指令 (<code class="docutils literal notranslate"><span class="pre">lasti</span></code>) 推入栈以便 <code class="docutils literal notranslate"><span class="pre">RERAISE</span></code> 能恢复它。 如果出现异常，栈级别值和帧上的最后一条指令将恢复为其当前状态，控制权将转移到 <code class="docutils literal notranslate"><span class="pre">target</span></code> 上的异常处理器。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-SETUP_WITH">
<span class="sig-name descname"><span class="pre">SETUP_WITH</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">target</span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <code class="docutils literal notranslate"><span class="pre">SETUP_CLEANUP</span></code> 类似，但在出现异常的情况下会从栈中再弹出一项然后将控制权转移到 <code class="docutils literal notranslate"><span class="pre">target</span></code> 上的异常处理器。</p>
<p>该变体形式用于 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 和 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 结构，它们会将上下文管理器的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.xhtml#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> 的返回值推入栈。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-POP_BLOCK">
<span class="sig-name descname"><span class="pre">POP_BLOCK</span></span></dt>
<dd><p>标记与最后一个 <code class="docutils literal notranslate"><span class="pre">SETUP_FINALLY</span></code>、<code class="docutils literal notranslate"><span class="pre">SETUP_CLEANUP</span></code> 或 <code class="docutils literal notranslate"><span class="pre">SETUP_WITH</span></code> 相关联的代码块的结束。</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-JUMP">
<span class="sig-name descname"><span class="pre">JUMP</span></span></dt>
<dd></dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-JUMP_NO_INTERRUPT">
<span class="sig-name descname"><span class="pre">JUMP_NO_INTERRUPT</span></span></dt>
<dd><p>非定向相对跳转指令会被汇编器转换为它们定向版本（ forward/backward ）</p>
</dd></dl>

<dl class="std opcode">
<dt class="sig sig-object std" id="opcode-LOAD_METHOD">
<span class="sig-name descname"><span class="pre">LOAD_METHOD</span></span></dt>
<dd><p>经优化的非绑定方法查找。 以在 arg 中设置了旗标的 <code class="docutils literal notranslate"><span class="pre">LOAD_ATTR</span></code> 操作码的形式发出。</p>
</dd></dl>

</section>
<section id="opcode-collections">
<span id="id1"></span><h2>操作码集合</h2>
<p>提供这些集合用于字节码指令的自动内省：</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在此集合还包含一些伪指令和工具化指令。 这些操作码的值 <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">MIN_PSEUDO_OPCODE</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">MIN_INSTRUMENTED_OPCODE</span></code>。</p>
</div>
<dl class="py data">
<dt class="sig sig-object py" id="dis.opname">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">opname</span></span></dt>
<dd><p>操作名称的序列，可使用字节码来索引。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.opmap">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">opmap</span></span></dt>
<dd><p>映射操作名称到字节码的字典</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.cmp_op">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">cmp_op</span></span></dt>
<dd><p>所有比较操作名称的序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasarg">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasarg</span></span></dt>
<dd><p>所有使用参数的字节码的序列</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasconst">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasconst</span></span></dt>
<dd><p>访问常量的字节码序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasfree">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasfree</span></span></dt>
<dd><p>访问了 free 变量的字节码的序列。 这里的 ‘free’ 指的是当前作用域中被内层作用域引用的名称或外层作用域被当前作用域引用的名称。 它 <em>不包括</em> 全局或内置作用域的引用。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasname">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasname</span></span></dt>
<dd><p>按名称访问属性的字节码序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasjrel">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasjrel</span></span></dt>
<dd><p>具有相对跳转目标的字节码序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasjabs">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasjabs</span></span></dt>
<dd><p>具有绝对跳转目标的字节码序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.haslocal">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">haslocal</span></span></dt>
<dd><p>访问局部变量的字节码序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hascompare">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hascompare</span></span></dt>
<dd><p>布尔运算的字节码序列。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dis.hasexc">
<span class="sig-prename descclassname"><span class="pre">dis.</span></span><span class="sig-name descname"><span class="pre">hasexc</span></span></dt>
<dd><p>设置一个异常处理器的字节码序列。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>