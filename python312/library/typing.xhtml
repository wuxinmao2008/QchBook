<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="typing —— 对类型提示的支持" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/typing.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/typing.py[https://github.com/python/cpython/tree/3.12/Lib/typing.py] 本模块提供了对类型提示的运行时支持。 考虑下面的函数: 函数 moon_weight 接受一个预期为 float 实例的参数，如 类型提示 earth_weight: float 所指明的。 该函数预期返回一个 str 实例，如-> st..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/typing.py[https://github.com/python/cpython/tree/3.12/Lib/typing.py] 本模块提供了对类型提示的运行时支持。 考虑下面的函数: 函数 moon_weight 接受一个预期为 float 实例的参数，如 类型提示 earth_weight: float 所指明的。 该函数预期返回一个 str 实例，如-> st..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>typing —— 对类型提示的支持</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="typing-support-for-type-hints">
<h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> —— 对类型提示的支持</h1>
<div class="versionadded" id="module-typing">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/typing.py">Lib/typing.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/typing.py]</span></p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Python 运行时不强制要求函数与变量类型标注。 它们可被 <a class="reference internal" href="../glossary.xhtml#term-static-type-checker"><span class="xref std std-term">类型检查器</span></a>、IDE、语法检查器等第三方工具使用。</p>
</div>
<hr class="docutils" />
<p>本模块提供了对类型提示的运行时支持。</p>
<p>考虑下面的函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moon_weight</span><span class="p">(</span><span class="n">earth_weight</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;On the moon, you would weigh </span><span class="si">{</span><span class="n">earth_weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.166</span><span class="si">}</span><span class="s1"> kilograms.&#39;</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">moon_weight</span></code> 接受一个预期为 <a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 实例的参数，如 <em>类型提示</em> <code class="docutils literal notranslate"><span class="pre">earth_weight:</span> <span class="pre">float</span></code> 所指明的。 该函数预期返回一个 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 实例，如 <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">str</span></code> 提示所指明的。</p>
<p>类型提示可以是简单的类比如 <a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，它们也可以更为复杂。 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块提供了一套用于更高级类型提示的词汇。</p>
<p>新特性被频繁添加到 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块中。 <a class="reference external" href="https://pypi.org/project/typing_extensions/">typing_extensions</a><span class="link-target"> [https://pypi.org/project/typing_extensions/]</span> 包提供了这些新特性针对较旧版本 Python 的向下移植。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">&quot;类型系统备忘单&quot;</a><span class="link-target"> [https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html]</span></dt><dd><p>关于类型提示的概览（发布于 mypy 文档站点）</p>
</dd>
<dt><a class="reference external" href="https://mypy.readthedocs.io/en/stable/index.html">mypy 文档</a><span class="link-target"> [https://mypy.readthedocs.io/en/stable/index.html]</span> 的 &quot;Type System Reference&quot; 章节</dt><dd><p>Python 类型系统是通过 PEP 来标准化的，因此该参考应当广泛适用于大多数 Python 类型检查器。 （但某些部分仍然是 mypy 专属的。）</p>
</dd>
<dt><a class="reference external" href="https://typing.readthedocs.io/en/latest/">&quot;Static Typing with Python&quot;</a><span class="link-target"> [https://typing.readthedocs.io/en/latest/]</span></dt><dd><p>由社区编写的不限定具体类型检查器的文档，详细讲解了类型系统特性，有用的类型相关工具以及类型的最佳实践。</p>
</dd>
</dl>
</div>
<section id="specification-for-the-python-type-system">
<span id="relevant-peps"></span><h2>有关 Python 类型系统的规范说明</h2>
<p>Python 类型系统最新的规范说明可以在 <a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/index.html">&quot;Specification for the Python type system&quot;</a><span class="link-target"> [https://typing.readthedocs.io/en/latest/spec/index.html]</span> 查看。</p>
</section>
<section id="type-aliases">
<span id="id2"></span><h2>类型别名</h2>
<p>类型别名是使用 <a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句来定义的，它将创建一个 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 的实例。 在这个示例中，<code class="docutils literal notranslate"><span class="pre">Vector</span></code> 和 <code class="docutils literal notranslate"><span class="pre">list[float]</span></code> 将被静态类型检查器等同处理:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># passes type checking; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>类型别名适用于简化复杂的类型签名。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="nb">type</span> <span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句是在 Python 3.12 中新增加的。 为了向下兼容，类型别名也可以通过简单的赋值来创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p>或者用 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 标记来显式说明这是一个类型别名，而非一般的变量赋值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Vector</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="newtype">
<span id="distinct"></span><h2>NewType</h2>
<p>用 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> 助手创建与原类型不同的类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># passes type checking</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># fails type checking; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UserId</span></code> 类型的变量可执行所有 <code class="docutils literal notranslate"><span class="pre">int</span></code> 操作，但返回结果都是 <code class="docutils literal notranslate"><span class="pre">int</span></code> 类型。这种方式允许在预期 <code class="docutils literal notranslate"><span class="pre">int</span></code> 时传入 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>，还能防止意外创建无效的 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>注意，这些检查只由静态类型检查器强制执行。在运行时，语句 <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> 将产生一个 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 可调用对象，该对象立即返回你传递给它的任何参数。 这意味着语句 <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 不会创建一个新的类，也不会引入超出常规函数调用的很多开销。</p>
<p>更确切地说，在运行时，<code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> 表达式总为 True。</p>
<p>创建 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 的子类型是无效的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not pass type checking</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>然而，我们可以在 &quot;派生的&quot; <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 的基础上创建一个 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>同时，<code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> 的类型检查也可以按预期执行。</p>
<p>详见 <span class="target" id="index-154"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>请记住使用类型别名将声明两个类型是相互 <em>等价</em> 的。 使用 <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> 将使静态类型检查器在任何情况下都把 <code class="docutils literal notranslate"><span class="pre">Alias</span></code> 视为与 <code class="docutils literal notranslate"><span class="pre">Original</span></code> <em>完全等价</em>。 这在你想要简化复杂的类型签名时会很有用处。</p>
<p>反之，<code class="docutils literal notranslate"><span class="pre">NewType</span></code> 声明把一种类型当作另一种类型的 <em>子类型</em>。<code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> 时，静态类型检查器把 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 当作 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 的 <em>子类</em> ，即，<code class="docutils literal notranslate"><span class="pre">Original</span></code> 类型的值不能用在预期 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 类型的位置。这种方式适用于以最小运行时成本防止逻辑错误。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 现在是一个类而不是一个函数。 因此，当调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 而非常规函数时会有一些额外的运行时开销。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 的性能已恢复到 Python 3.9 时的水平。</p>
</div>
</section>
<section id="annotating-callable-objects">
<span id="annotating-callables"></span><h2>标注可调用对象</h2>
<p>函数 -- 或其他 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> 对象 -- 可以使用 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 或 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Callable</span></code></a> 来标注。 <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> 表示一个接受 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 类型的单个参数并返回 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的函数。</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Awaitable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p>下标语法总是要刚好使用两个值：参数列表和返回类型。 参数列表必须是一个由类型组成的列表、<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>、<a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 或省略号。 返回类型必须是单一类型。</p>
<p>如果将一个省略号字面值 <code class="docutils literal notranslate"><span class="pre">...</span></code> 作为参数列表，则表示可以接受包含任意形参列表的可调用对象:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">str</span>     <span class="c1"># OK</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">concat</span>  <span class="c1"># Also OK</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 无法表达复杂的签名如接受可变数量参数的函数，<a class="reference internal" href="#overload"><span class="std std-ref">重载的函数</span></a>，或具有仅限关键字形参的函数。 但是，这些签名可通过自定义具有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法的 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 类来表达：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="k">class</span> <span class="nc">Combiner</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">batch_proc</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">cb_results</span><span class="p">:</span> <span class="n">Combiner</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">def</span> <span class="nf">good_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">bad_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxitems</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">good_cb</span><span class="p">)</span>  <span class="c1"># OK</span>
<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">bad_cb</span><span class="p">)</span>   <span class="c1"># Error! Argument 2 has incompatible type because of</span>
                         <span class="c1"># different name and kind in the callback</span>
</pre></div>
</div>
<p>以其他可调用对象为参数的可调用对象可以使用 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 来表明其参数类型是相互依赖的。 此外，如果该可调用对象增加或删除了其他可调用对象的参数，可以使用 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 操作符。 它们分别采取 <code class="docutils literal notranslate"><span class="pre">Callable[ParamSpecVariable,</span> <span class="pre">ReturnType]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> 的形式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 现在支持 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。 详情见 <span class="target" id="index-155"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a><span class="link-target"> [https://peps.python.org/pep-0612/]</span>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 的文档提供了在 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 中使用的例子。</p>
</div>
</section>
<section id="generics">
<span id="id3"></span><h2>泛型（Generic）</h2>
<p>由于无法以通用方式静态地推断容器中保存的对象的类型信息，标准库中的许多容器类都支持下标操作来以表示容器元素的预期类型。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span> <span class="o">...</span>

<span class="c1"># Sequence[Employee] indicates that all elements in the sequence</span>
<span class="c1"># must be instances of &quot;Employee&quot;.</span>
<span class="c1"># Mapping[str, str] indicates that all keys and all values in the mapping</span>
<span class="c1"># must be strings.</span>
<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>泛型函数和类可以通过使用 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参语法</span></a> 来实现参数化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>  <span class="c1"># Function is generic over the TypeVar &quot;T&quot;</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>或直接使用 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 工厂：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>                  <span class="c1"># Declare type variable &quot;U&quot;</span>

<span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># Function is generic over the TypeVar &quot;U&quot;</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对泛型的语法支持是在 Python 3.12 中新增的。</p>
</div>
</section>
<section id="annotating-tuples">
<span id="id4"></span><h2>标注元组</h2>
<p>对于 Python 中的大多数容器，类型系统会假定容器中的所有元素都是相同类型的。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>

<span class="c1"># Type checker will infer that all elements in ``x`` are meant to be ints</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Type checker error: ``list`` only accepts a single type argument:</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]</span>

<span class="c1"># Type checker will infer that all keys in ``z`` are meant to be strings,</span>
<span class="c1"># and that all values in ``z`` are meant to be either strings or ints</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 只接受一个类型参数，因此类型检查器将在上述代码中对 <code class="docutils literal notranslate"><span class="pre">y</span></code> 赋值时报告错误。同样，<a class="reference internal" href="collections.abc.xhtml#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 只接受两个类型参数：第一个给出键的类型，第二个则给出值的类型。</p>
<p>然而，与大多数其它 Python 容器不同的是，在常见的 Python 代码中，元组中元素的类型并不相同。因此，在 Python 的类型系统中，元组是特殊情况。<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 可以接受 <em>任意数量</em> 的类型参数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>

<span class="c1"># OK: ``y`` is assigned to a tuple of length 2;</span>
<span class="c1"># element 1 is an int, element 2 is a str</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Error: the type annotation indicates a tuple of length 1,</span>
<span class="c1"># but ``z`` has been assigned to a tuple of length 3</span>
<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>要表示一个可以是 <em>任意</em> 长度的元组，并且其中的所有元素都是相同类型的 <code class="docutils literal notranslate"><span class="pre">T</span></code>，请使用 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">...]</span></code>。要表示空元组，请使用 <code class="docutils literal notranslate"><span class="pre">tuple[()]</span></code>。只使用 <code class="docutils literal notranslate"><span class="pre">tuple</span></code> 作为注解等效于使用``tuple[Any, ...]``：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1"># This reassignment is an error: all elements in ``x`` must be ints</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>

<span class="c1"># ``y`` can only ever be assigned to an empty tuple</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[()]</span> <span class="o">=</span> <span class="p">()</span>

<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="c1"># These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>
</div>
</section>
<section id="the-type-of-class-objects">
<span id="type-of-class-objects"></span><h2>类对象的类型</h2>
<p>用 <code class="docutils literal notranslate"><span class="pre">C</span></code> 注解的变量可以接受类型 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的值。然而，用类型 <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> （或者 <a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Type[C]</span></code></a> ）注解的变量则可以接受本身是类的值——准确地说，是接受 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的 <em>类对象</em> 。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type ``int``</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type ``type[int]``</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type ``type[int]``</span>
</pre></div>
</div>
<p>注意，<code class="docutils literal notranslate"><span class="pre">type[C]</span></code> 是协变的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>

<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>      <span class="c1"># OK</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>   <span class="c1"># Also OK: ``type[ProUser]`` is a subtype of ``type[User]``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>  <span class="c1"># Still fine</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">())</span>    <span class="c1"># Error: expected ``type[User]`` but got ``User``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>       <span class="c1"># Error: ``type[int]`` is not a subtype of ``type[User]``</span>
</pre></div>
</div>
<p><a class="reference internal" href="functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的合法形参只有类, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">类型变量</span></a> 以及前面这些类型的并集。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BasicUser</span> <span class="o">|</span> <span class="n">ProUser</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">BasicUser</span><span class="p">)</span>  <span class="c1"># OK</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>    <span class="c1"># OK</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>   <span class="c1"># Error: ``type[TeamUser]`` is not a subtype</span>
                              <span class="c1"># of ``type[BasicUser | ProUser]``</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>       <span class="c1"># Also an error</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type[Any]</span></code> 等价于 <a class="reference internal" href="functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>，它是 Python 的 <a class="reference internal" href="../reference/datamodel.xhtml#metaclasses"><span class="std std-ref">元类层级结构</span></a> 的根对象。</p>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2>用户定义的泛型类型</h2>
<p>用户定义的类可以定义为泛型类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>这种语法表示类 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> 是围绕单个 <a class="reference internal" href="#typevar"><span class="std std-ref">类型变量</span></a> <code class="docutils literal notranslate"><span class="pre">T</span></code> 实现参数化的。 这也使得 <code class="docutils literal notranslate"><span class="pre">T</span></code> 成为类体内部有效的类型。</p>
<p>泛型类隐式继承自 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>。为了与 Python 3.11 及更低版本兼容，也允许显式地从 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 继承以表示泛型类：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>泛型类具有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> 方法，这意味着泛型类可在运行时进行参数化（例如下面的 <code class="docutils literal notranslate"><span class="pre">LoggedVar[int]</span></code>）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>一个泛型可以有任何数量的类型变量。所有种类的 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 都可以作为泛型的参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span> <span class="nc">WeirdTrio</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]:</span>
    <span class="o">...</span>

<span class="n">OldT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldT&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldB</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldB&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldS</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldS&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OldWeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">OldT</span><span class="p">,</span> <span class="n">OldB</span><span class="p">,</span> <span class="n">OldS</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 类型变量的参数应各不相同。下列代码就是无效的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">]:</span>  <span class="c1"># SyntaxError</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>泛型类也可以从其他类继承：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Sized</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>从泛型类继承时，某些类型参数可被固定：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>在这个例子中，<code class="docutils literal notranslate"><span class="pre">MyDict</span></code> 就只有一个参数 <code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>未指定泛型类的类型参数时，会假定每个位置的类型都为 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。在下面的例子中，<code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> 不是泛型，但却隐式继承了 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>用户定义的泛型类型别名也同样受到支持。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="nb">type</span> <span class="n">Response</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>

<span class="c1"># Return type here is same as Iterable[str] | int</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)](</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>出于向后兼容性的考虑，也允许使用简单的赋值来创建泛型类型别名：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 不再支持自定义元类。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>3.12 版本新增了对泛型和类型别名的语法支持。在之前的版本中，泛型类必须显式继承自 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>，或者在其基类之一中包含有类型变量。</p>
</div>
<p>用户定义的参数表达式的泛型也受到支持，可以采用 <code class="docutils literal notranslate"><span class="pre">[**P]</span></code> 形式的参数规格变量来表示。该行为与上面描述的类型变量一致，因为参数规格变量被 typing 模块视为专门的类型变量。这方面的一个例外是，类型的列表可用于替代 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Z</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>  <span class="c1"># T is a TypeVar; P is a ParamSpec</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="go">__main__.Z[int, [dict, float]]</span>
</pre></div>
</div>
<p>带有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型类也可以使用从 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 显式继承的方式来创建。在这种情况下，不需要使用 <code class="docutils literal notranslate"><span class="pre">**</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">P</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 与 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的另一个区别在于只有单个参数规格变量的泛型会接受形如 <code class="docutils literal notranslate"><span class="pre">X[[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]]</span></code> 的参数列表，同时为了美观，也接受 <code class="docutils literal notranslate"><span class="pre">X[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]</span></code> 这样的形式。 在内部，后者被转换为前者，所以下面的内容是等价的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="go">__main__.X[[int, str]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="go">__main__.X[[int, str]]</span>
</pre></div>
</div>
<p>请注意：在某些情况下，具有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型在替换后可能不具有正确的 <code class="docutils literal notranslate"><span class="pre">__parameters__</span></code>，因为参数规格主要用于静态类型检查。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 现在可以通过参数表达式进行参数化。参见 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <span class="target" id="index-156"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a><span class="link-target"> [https://peps.python.org/pep-0612/]</span> 以了解更多细节。</p>
</div>
<p>用户定义的泛型类可以将 ABC 作为基类而不会导致元类冲突。 参数化泛型的输出结果会被缓存，且 typing 模块中的大多数类型都是 <a class="reference internal" href="../glossary.xhtml#term-hashable"><span class="xref std std-term">hashable</span></a> 并且支持相等性比较。</p>
</section>
<section id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型</h2>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 是一种特殊的类型。静态类型检查器认为所有类型均与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容，同样，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 也与所有类型兼容。</p>
<p>也就是说，可对 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值执行任何操作或方法调用，并赋值给任意变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># OK</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>注意，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值赋给更精确的类型时，不执行类型检查。例如，把 <code class="docutils literal notranslate"><span class="pre">a</span></code> 赋给 <code class="docutils literal notranslate"><span class="pre">s</span></code>，在运行时，即便 <code class="docutils literal notranslate"><span class="pre">s</span></code> 已声明为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型，但接收 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 值时，静态类型检查器也不会报错。</p>
<p>此外，未指定返回值与参数类型的函数，都隐式地默认使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>需要混用动态与静态类型代码时，此操作把 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 当作 <em>应急出口</em>。</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 和 <a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的区别。与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相似，所有类型都是 <a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的子类型。然而，与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 不同，object 不可逆：<a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> <em>不是</em> 其它类型的子类型。</p>
<p>就是说，值的类型是 <a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 时，类型检查器几乎会拒绝所有对它的操作，并且，把它赋给更精确的类型变量（或返回值）属于类型错误。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails type checking; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Passes type checking, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Passes type checking, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>，说明值能以类型安全的方式转为任何类型。使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，说明值是动态类型。</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2>名义子类型 vs 结构子类型</h2>
<p>最初 <span class="target" id="index-157"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span> 将 Python 静态类型系统定义为使用 <em>名义子类型</em>。这意味着当且仅当类 <code class="docutils literal notranslate"><span class="pre">A</span></code> 是 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的子类时，才满足有类 <code class="docutils literal notranslate"><span class="pre">B</span></code> 预期时使用类 <code class="docutils literal notranslate"><span class="pre">A</span></code> 。</p>
<p>此项要求以前也适用于抽象基类，例如，<a class="reference internal" href="collections.abc.xhtml#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 。这种方式的问题在于，定义类时必须显式说明，既不 Pythonic，也不是动态类型式 Python 代码的惯用写法。例如，下列代码就遵从了 <span class="target" id="index-158"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span> 的规范：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-159"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a><span class="link-target"> [https://peps.python.org/pep-0544/]</span> 允许用户在类定义时不显式说明基类，从而解决了这一问题，静态类型检查器隐式认为 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> 既是 <code class="docutils literal notranslate"><span class="pre">Sized</span></code> 的子类型，又是 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code> 的子类型。这就是 <em>结构子类型</em> （又称为静态鸭子类型）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># Note: no base classes</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</pre></div>
</div>
<p>此外，结构子类型的优势在于，通过继承特殊类 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> ，用户可以定义新的自定义协议（见下文中的例子）。</p>
</section>
<section id="module-contents">
<h2>模块内容</h2>
<p><code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块定义了下列类、函数和装饰器。</p>
<section id="special-typing-primitives">
<h3>特殊类型原语</h3>
<section id="special-types">
<h4>特殊类型</h4>
<p>这些类型可用于在注解中表示类型，但不支持下标用法（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Any">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Any</span></span></dt>
<dd><p>特殊类型，表示没有约束的类型。</p>
<ul class="simple">
<li><p>所有类型都与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容。</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 与所有类型都兼容。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 现在可以用作基类。这有助于避免类型检查器在高度动态或可通过鸭子类型使用的类上报错。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.AnyStr">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AnyStr</span></span></dt>
<dd><p><a class="reference internal" href="#typing-constrained-typevar"><span class="std std-ref">受约束的类型变量</span></a>。</p>
<p>定义：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 用于可接受 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 参数但不允许两者混用的函数。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>    <span class="c1"># OK, output has type &#39;str&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># OK, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>   <span class="c1"># Error, cannot mix str and bytes</span>
</pre></div>
</div>
<p>请注意：尽管名为 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>，但它与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal notranslate"><span class="pre">Any</span></code></a> 类型毫无关系，也不是指“任何字符串”。而且，<code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 更是和 <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">bytes</span></code> 彼此互不相同，各有各的使用场景：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Invalid use of AnyStr:</span>
<span class="c1"># The type variable is used only once in the function signature,</span>
<span class="c1"># so cannot be &quot;solved&quot; by the type checker</span>
<span class="k">def</span> <span class="nf">greet_bad</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>

<span class="c1"># The better way of annotating this function:</span>
<span class="k">def</span> <span class="nf">greet_proper</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.LiteralString">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">LiteralString</span></span></dt>
<dd><p>只包括字符串字面值的的特殊类型。</p>
<p>任何字符串字面值或其他 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 都与 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 兼容。但 <code class="docutils literal notranslate"><span class="pre">str</span></code> 类型的对象不与其兼容。组合 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 类型的对象产生的字符串也被认为是 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>。</p>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="n">sql</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">caller</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">literal_string</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM students&quot;</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM &quot;</span> <span class="o">+</span> <span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="n">run_query</span><span class="p">(</span>  <span class="c1"># type checker error</span>
        <span class="sa">f</span><span class="s2">&quot;SELECT * FROM students WHERE name = </span><span class="si">{</span><span class="n">arbitrary_string</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 对于会因用户可输入任意字符串而导致问题的敏感 API 很有用。例如，上述两处导致类型检查器报错的代码可能容易被 SQL 注入攻击。</p>
<p>请参阅 <span class="target" id="index-160"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a><span class="link-target"> [https://peps.python.org/pep-0675/]</span> 了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Never</span></span></dt>
<dt class="sig sig-object py" id="typing.NoReturn">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoReturn</span></span></dt>
<dd><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> 代表 <a class="reference external" href="https://en.wikipedia.org/wiki/Bottom_type">底类型</a><span class="link-target"> [https://en.wikipedia.org/wiki/Bottom_type]</span>，一种没有成员的类型。</p>
<p>它们可被用于指明一个函数绝不会返回，例如 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># or NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或者用于定义一个绝不应被调用的函数，因为不存在有效的参数，例如 <a class="reference internal" href="#typing.assert_never" title="typing.assert_never"><code class="xref py py-func docutils literal notranslate"><span class="pre">assert_never()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># or NoReturn</span>

<span class="k">def</span> <span class="nf">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># OK, arg is of type Never (or NoReturn)</span>
</pre></div>
</div>
<p><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> 在类型系统中具有相同的含义并且静态类型检查器会以相同的方式对待这两者。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.2: </span>增加了 <a class="reference internal" href="#typing.NoReturn" title="typing.NoReturn"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span>增加了 <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Self">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Self</span></span></dt>
<dd><p>特殊类型，表示当前闭包内的类。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Self</span><span class="p">,</span> <span class="n">reveal_type</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">SubclassOfFoo</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">Foo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># Revealed type is &quot;Foo&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">SubclassOfFoo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># Revealed type is &quot;SubclassOfFoo&quot;</span>
</pre></div>
</div>
<p>此注解在语法上等价于以下代码，但形式更为简洁：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">Self</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Self&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>通常来说，如果某些内容返回 <code class="docutils literal notranslate"><span class="pre">self</span></code>，如上面的示例所示，您应该使用 <code class="docutils literal notranslate"><span class="pre">Self</span></code> 作为返回值注解。如果 <code class="docutils literal notranslate"><span class="pre">Foo.return_self</span></code> 被注解为返回 <code class="docutils literal notranslate"><span class="pre">&quot;Foo&quot;</span></code>，那么类型检查器将推断从 <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo.return_self</span></code> 返回的对象是 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 类型，而不是 <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo</span></code>。</p>
<p>其它常见用例包括：</p>
<ul class="simple">
<li><p>被用作替代构造器的 <a class="reference internal" href="functions.xhtml#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>，它将返回 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 形参的实例。</p></li>
<li><p>标注一个返回自身的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法。</p></li>
</ul>
<p>如果不能保证在子类中方法会返回子类的实例（而非父类的实例），则不应使用 <code class="docutils literal notranslate"><span class="pre">Self</span></code> 作为返回值注解：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Eggs</span><span class="p">:</span>
    <span class="c1"># Self would be an incorrect return annotation here,</span>
    <span class="c1"># as the object returned is always an instance of Eggs,</span>
    <span class="c1"># even in subclasses</span>
    <span class="k">def</span> <span class="nf">returns_eggs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Eggs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eggs</span><span class="p">()</span>
</pre></div>
</div>
<p>更多细节请参见 <span class="target" id="index-161"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a><span class="link-target"> [https://peps.python.org/pep-0673/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeAlias">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAlias</span></span></dt>
<dd><p>特殊注解，用于显式声明 <a class="reference internal" href="#type-aliases"><span class="std std-ref">类型别名</span></a>.</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Factors</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>在较早的 Python 版本上，<code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> 对注解使用前向引用的别名时特别有用，因为类型检查器可能很难将这些别名与正常的变量赋值区分开来：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="c1"># &quot;Box&quot; does not exist yet,</span>
<span class="c1"># so we have to use quotes for the forward reference on Python &lt;3.12.</span>
<span class="c1"># Using ``TypeAlias`` tells the type checker that this is a type alias declaration,</span>
<span class="c1"># not a variable assignment to a string.</span>
<span class="n">BoxOfStrings</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;Box[str]&quot;</span>

<span class="k">class</span> <span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_box_of_strings</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoxOfStrings</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-162"></span><a class="pep reference external" href="https://peps.python.org/pep-0613/"><strong>PEP 613</strong></a><span class="link-target"> [https://peps.python.org/pep-0613/]</span> 了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用: </span><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 被弃用，请使用 <a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句，后者创建 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 的实例，并且天然支持正向引用。请注意，虽然 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 和 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 具有相似的用途和名称，但它们是不同的，后者并不是前者的类型。目前还没有移除 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 的计划，但鼓励用户迁移到 <a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句。</p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4>特殊形式</h4>
<p>这些内容在注解中可以视为类型，且都支持下标用法（<code class="docutils literal notranslate"><span class="pre">[]</span></code>），但每个都有唯一的语法。</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Union">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Union</span></span></dt>
<dd><p>联合类型； <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> ，意味着满足 X 或 Y 之一。</p>
<p>要定义一个联合类型，可以使用类似 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> 或简写 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>。建议使用这种简写。细节:</p>
<ul>
<li><p>参数必须是某种类型，且至少有一个。</p></li>
<li><p>联合类型之联合类型会被展平，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>单参数之联合类型就是该参数自身，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>冗余的参数会被跳过，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p>比较联合类型，不涉及参数顺序，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>不可创建 <code class="docutils literal notranslate"><span class="pre">Union</span></code> 的子类或实例。</p></li>
<li><p>没有 <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code> 这种写法。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>在运行时，不要移除联合类型中的显式子类。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>联合类型现在可以写成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>。 参见 <a class="reference internal" href="stdtypes.xhtml#types-union"><span class="std std-ref">联合类型表达式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Optional">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Optional</span></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> （或 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code> ） 。</p>
<p>注意，可选类型与含默认值的可选参数不同。含默认值的可选参数不需要在类型注解上添加 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 限定符，因为它仅是可选的。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>另一方面，显式应用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值时，不管该参数是否可选， <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 都适用。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>可选参数现在可以写成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code>。 参见 <a class="reference internal" href="stdtypes.xhtml#types-union"><span class="std std-ref">联合类型表达式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Concatenate">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Concatenate</span></span></dt>
<dd><p>特殊形式，用于注解高阶函数。</p>
<p><code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可用于与 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> 和 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 连用来注解高阶可调用对象，该可象可以添加、移除或转换另一个可调用对象的形参。  使用形式为 <code class="docutils literal notranslate"><span class="pre">Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable]</span></code>。 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 目前仅可用作传给 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> 的第一个参数。传给 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的最后一个形参必须是 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 或省略号（ <code class="docutils literal notranslate"><span class="pre">...</span></code> ）。</p>
<p>例如，为了注释一个装饰器 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code>，它为被装饰的函数提供了 <a class="reference internal" href="threading.xhtml#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>，<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可以用来表示 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> 期望一个可调用对象，该对象接收一个 <code class="docutils literal notranslate"><span class="pre">Lock</span></code> 作为第一个参数，并返回一个具有不同类型签名的可调用对象。 在这种情况下，<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 表示返回的可调用对象的参数类型取决于被传入的可调用程序的参数类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Concatenate</span>

<span class="c1"># Use this lock to ensure that only one thread is executing a function</span>
<span class="c1"># at any time.</span>
<span class="n">my_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">with_lock</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">Concatenate</span><span class="p">[</span><span class="n">Lock</span><span class="p">,</span> <span class="n">P</span><span class="p">],</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator which provides a lock.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="c1"># Provide the lock as the first argument.</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">my_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@with_lock</span>
<span class="k">def</span> <span class="nf">sum_threadsafe</span><span class="p">(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add a list of numbers together in a thread-safe manner.&#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="c1"># We don&#39;t need to pass in the lock ourselves thanks to the decorator.</span>
<span class="n">sum_threadsafe</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><span class="target" id="index-163"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a><span class="link-target"> [https://peps.python.org/pep-0612/]</span> -- 参数规范变量（引入 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的 PEP）</p></li>
<li><p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a></p></li>
<li><p><a class="reference internal" href="#annotating-callables"><span class="std std-ref">标注可调用对象</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Literal">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Literal</span></span></dt>
<dd><p>特殊类型注解形式，用于定义“字面值类型”。</p>
<p><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 可以用来向类型检查器说明被注解的对象具有与所提供的字面量之一相同的值。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Mode</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>      <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 不能创建子类。在运行时，任意值均可作为 <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 的类型参数，但类型检查器可以对此加以限制。字面量类型详见 <span class="target" id="index-164"></span><a class="pep reference external" href="https://peps.python.org/pep-0586/"><strong>PEP 586</strong></a><span class="link-target"> [https://peps.python.org/pep-0586/]</span> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9.1 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 现在能去除形参的重复。 <code class="docutils literal notranslate"><span class="pre">Literal</span></code> 对象的相等性比较不再依赖顺序。 现在如果有某个参数不为 <a class="reference internal" href="../glossary.xhtml#term-hashable"><span class="xref std std-term">hashable</span></a>，<code class="docutils literal notranslate"><span class="pre">Literal</span></code> 对象在相等性比较期间将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ClassVar">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ClassVar</span></span></dt>
<dd><p>特殊类型注解构造，用于标注类变量。</p>
<p>如 <span class="target" id="index-165"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a><span class="link-target"> [https://peps.python.org/pep-0526/]</span> 所述，打包在 ClassVar 内的变量注解是指，给定属性应当用作类变量，而不应设置在类实例上。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 仅接受类型，也不能使用下标。</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 本身不是类，不应用于 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 或 <a class="reference internal" href="functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>。<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 不改变 Python 运行时行为，但可以用于第三方类型检查器。例如，类型检查器会认为以下代码有错：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Final">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Final</span></span></dt>
<dd><p>特殊类型注解构造，用于向类型检查器表示最终名称。</p>
<p>不能在任何作用域中重新分配最终名称。类作用域中声明的最终名称不能在子类中重写。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p>这些属性没有运行时检查。详见 <span class="target" id="index-166"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a><span class="link-target"> [https://peps.python.org/pep-0591/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Required">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Required</span></span></dt>
<dd><p>特殊类型注解构造，用于标记 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 键为必填项。</p>
<p>这主要用于 <code class="docutils literal notranslate"><span class="pre">total=False</span></code> 的 TypedDict。有关更多详细信息，请参阅 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 和 <span class="target" id="index-167"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a><span class="link-target"> [https://peps.python.org/pep-0655/]</span> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NotRequired">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NotRequired</span></span></dt>
<dd><p>特殊类型注解构造，用于标记 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 键为可能不存在的键。</p>
<p>详情参见 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 和 <span class="target" id="index-168"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a><span class="link-target"> [https://peps.python.org/pep-0655/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Annotated">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Annotated</span></span></dt>
<dd><p>特殊类型注解形式，用于向注解添加特定于上下文的元数据。</p>
<p>使用注解 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> 将元数据 <code class="docutils literal notranslate"><span class="pre">x</span></code> 添加到给定类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 。使用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 添加的元数据可以被静态分析工具使用，也可以在运行时使用。在运行时使用的情况下，元数据存储在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code> 属性中。</p>
<p>如果库或工具遇到注解 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> ，并且没有针对这一元数据的特殊处理逻辑，则应该忽略该元数据，简单地将注解视为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 。因此， <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 对于希望将注解用于 Python 的静态类型注解系统之外的目的的代码很有用。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> 作为注解仍然允许对 <code class="docutils literal notranslate"><span class="pre">T</span></code> 进行静态类型检查，因为类型检查器将简单地忽略元数据 <code class="docutils literal notranslate"><span class="pre">x</span></code> 。因此，<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 不同于 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a> 装饰器，后者虽然也可以用于在类型注解系统范围之外添加注解，但是会完全禁用对函数或类的类型检查。</p>
<p>具体解释元数据的方式由遇到 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 注解的工具或库来负责。遇到 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型的工具或库可以扫描元数据的各个元素以确定其是否有意处理（比如使用 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> ）。</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">Annotated[&lt;type&gt;,</span> <span class="pre">&lt;metadata&gt;]</span></span></dt>
<dd></dd></dl>

<p>以下示例演示在进行区间范围分析时使用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 将元数据添加到类型注解的方法：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ValueRange</span><span class="p">:</span>
    <span class="n">lo</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">hi</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>语法细节：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 的第一个参数必须是有效的类型。</p></li>
<li><p>可提供多个元数据的元素（ <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 支持可变参数）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ctype</span><span class="p">:</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>由处理注解的工具决定是否允许向一个注解中添加多个元数据元素，以及如何合并这些注解。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 至少要有两个参数（ <code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code> 是无效的）</p></li>
<li><p>元数据元素的顺序会被保留，且影响等价检查：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>嵌套的 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型会被展平。元数据元素从最内层的注解开始依次展开：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>元数据中的重复元素不会被移除：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 可以与嵌套别名和泛型别名一起使用：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">MaxLen</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="c1"># When used in a type annotation, a type checker will treat &quot;V&quot; the same as</span>
<span class="c1"># ``Annotated[list[tuple[int, int]], MaxLen(10)]``:</span>
<span class="nb">type</span> <span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 不能与已解包的 <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a> 一起使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Variadic</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>  <span class="c1"># NOT valid</span>
</pre></div>
</div>
<p>这等价于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">T1</span></code> 、 <code class="docutils literal notranslate"><span class="pre">T2</span></code> 等都是 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVars</span></code></a> 。这种写法无效：应当只有一个类型被传递给 Annotated。</p>
</li>
<li><p>默认情况下， <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> 会去除注解中的元数据。传入 <code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code> 可以保留元数据：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">get_type_hints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: typing.Annotated[int, &#39;metadata&#39;], &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
</pre></div>
</div>
</li>
<li><p>在运行时，与特定 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型相关联的元数据可通过 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code> 属性来获取：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;very&quot;</span><span class="p">,</span> <span class="s2">&quot;important&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">typing.Annotated[int, &#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">__metadata__</span>
<span class="go">(&#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;)</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-169"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a><span class="link-target"> [https://peps.python.org/pep-0593/]</span> - 灵活的函数与变量标注</dt><dd><p>该 PEP 将 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 引入到标准库中。</p>
</dd>
</dl>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeGuard">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeGuard</span></span></dt>
<dd><p>用于标记用户自定义类型防护函数的特殊类型构造。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 可被用于标注用户自定义类型保护函数的返回类型。 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 只接受单独的类型参数。 在运行时，以这种方式标记的函数应当返回一个布尔值。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 旨在使 <em>类型收窄</em> 受益——这是静态类型检查器用以确定表达式在代码流中的较精确类型的一种技术。通常，类型收窄是以分析条件代码流并将收窄应用于一个代码块来完成的，涉及到的条件表达式有时即被称为“type guard”。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># &quot;isinstance&quot; type guard</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``str``</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, type of ``val`` is narrowed to ``float``.</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>定义一个布尔函数作为 type guard 有时会很方便，此时应使用 <code class="docutils literal notranslate"><span class="pre">TypeGuard[...]</span></code> 作为其返回类型以提醒静态类型检查器注意这一意图。</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeGuard</span></code> 告诉静态类型检查器，某函数：</p>
<ol class="arabic simple">
<li><p>返回一个布尔值。</p></li>
<li><p>如果返回值是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，那么其参数的类型是 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 内的类型。</p></li>
</ol>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``list[str]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Type of ``val`` remains as ``list[object]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a list of strings!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">is_str_list</span></code> 是一个类或实例方法，那么 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 中的类型映射到 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 或 <code class="docutils literal notranslate"><span class="pre">self</span></code> 之后的第二个参数的类型。</p>
<p>简而言之，<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(arg:</span> <span class="pre">TypeA)</span> <span class="pre">-&gt;</span> <span class="pre">TypeGuard[TypeB]:</span> <span class="pre">...</span></code> 形式的意思是：如果 <code class="docutils literal notranslate"><span class="pre">foo(arg)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 将把 <code class="docutils literal notranslate"><span class="pre">TypeA</span></code> 缩小为 <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeB</span></code> 无需为 <code class="docutils literal notranslate"><span class="pre">TypeA</span></code> 的缩小形式 -- 它甚至可以是扩大形式。 主要原因是允许像把 <code class="docutils literal notranslate"><span class="pre">list[object]</span></code> 缩小到 <code class="docutils literal notranslate"><span class="pre">list[str]</span></code> 这样的事情，即使后者不是前者的一个子类型，因为 <code class="docutils literal notranslate"><span class="pre">list</span></code> 是不变的。 编写类型安全的类型防护的责任留给了用户。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 也适用于类型变量。 详情参见 <span class="target" id="index-170"></span><a class="pep reference external" href="https://peps.python.org/pep-0647/"><strong>PEP 647</strong></a><span class="link-target"> [https://peps.python.org/pep-0647/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Unpack">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Unpack</span></span></dt>
<dd><p>在概念上将对象标记为已解包的类型运算符。</p>
<p>例如，在一个 <a class="reference internal" href="#typevartuple"><span class="std std-ref">类型变量元组</span></a> 上使用解包运算符 <code class="docutils literal notranslate"><span class="pre">*</span></code> 就等价于使用 <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 来将该类型变量元组标记为已被解包:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="c1"># Effectively does:</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>
</pre></div>
</div>
<p>实际上，<code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 在 <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVarTuple</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> 类型的上下文中可以和 <code class="docutils literal notranslate"><span class="pre">*</span></code> 互换使用。 你可能会看到 <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 在较旧版本的 Python 中被显式地使用，这时 <code class="docutils literal notranslate"><span class="pre">*</span></code> 在特定场合则是无法使用的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In older versions of Python, TypeVarTuple and Unpack</span>
<span class="c1"># are located in the `typing_extensions` backports package.</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">TypeVarTuple</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>         <span class="c1"># Syntax error on Python &lt;= 3.10!</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>  <span class="c1"># Semantically equivalent, and backwards-compatible</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 也可以与 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> 一起使用以便在函数签名中对 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 进行类型标注:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="k">class</span> <span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># This function expects two keyword arguments - `name` of type `str`</span>
<span class="c1"># and `year` of type `int`.</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">Movie</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-171"></span><a class="pep reference external" href="https://peps.python.org/pep-0692/"><strong>PEP 692</strong></a><span class="link-target"> [https://peps.python.org/pep-0692/]</span> 了解将 <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 用于 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 类型标注的更多细节。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types-and-type-aliases">
<h4>构造泛型类型与类型别名</h4>
<p>下列类不应被直接用作标注。 它们的设计目标是作为创建泛型类型和类型别名的构件。</p>
<p>这些对象可通过特殊语法 (<a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参列表</span></a> 和 <a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句) 来创建。 为了与 Python 3.11 及更早版本的兼容性，它们也可不用专门的语法来创建，如下文所述。</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generic</span></span></dt>
<dd><p>用于泛型类型的抽象基类。</p>
<p>泛型类型通常是通过在类名后添加一个类型形参列表来声明的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>这样的类将隐式地继承自 <code class="docutils literal notranslate"><span class="pre">Generic</span></code>。 对于该语法的运行语义的讨论参见 <a class="reference internal" href="../reference/compound_stmts.xhtml#generic-classes"><span class="std std-ref">语言参考</span></a>。</p>
<p>该类的用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lookup_name</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">](</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
<p>此处函数名之后的圆括号是表示 <a class="reference internal" href="../reference/compound_stmts.xhtml#generic-functions"><span class="std std-ref">泛型函数</span></a>。</p>
<p>为了保持向下兼容性，泛型类也可通过显式地继承自 <code class="docutils literal notranslate"><span class="pre">Generic</span></code> 来声明。 在此情况下，类型形参必须单独声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>
<span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class" id="typevar">
<dt class="sig sig-object py" id="typing.TypeVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类型变量。</p>
<p>构造类型变量的推荐方式是使用针对 <a class="reference internal" href="../reference/compound_stmts.xhtml#generic-functions"><span class="std std-ref">泛型函数</span></a>, <a class="reference internal" href="../reference/compound_stmts.xhtml#generic-classes"><span class="std std-ref">泛型类</span></a> 和 <a class="reference internal" href="../reference/compound_stmts.xhtml#generic-type-aliases"><span class="std std-ref">泛型类型别名</span></a> 的专门语法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># T is a TypeVar</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>此语法也可被用于创建绑定和带约束的类型变量:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StrSequence</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">]:</span>  <span class="c1"># S is a TypeVar bound to str</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">StrOrBytesSequence</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)]:</span>  <span class="c1"># A is a TypeVar constrained to str or bytes</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>不过，如有需要，也可通过手动方式来构造可重用的类型变量，就像这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># Can be any subtype of str</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be exactly str or bytes</span>
</pre></div>
</div>
<p>类型变量的主要用处是为静态类型检查器提供支持。 它们可作为泛型类型以及泛型函数和类型别名定义的形参。 请参阅 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 了解有关泛型类型的更多信息。 泛型函数的作用方式如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span> <span class="nf">print_capitalized</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)](</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>请注意，类型变量可以是 <em>被绑定的</em> ， <em>被约束的</em> ，或者两者都不是，但不能既是被绑定的 <em>又是</em> 被约束的。</p>
<p>类型变量的种类是在其通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参语法</span></a> 创建时或是在传入 <code class="docutils literal notranslate"><span class="pre">infer_variance=True</span></code> 时由类型检查器推断得到的。 手动创建的类型变量可通过传入 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> 被显式地标记为 covariant 或 contravariant。 在默认情况下，手动创建的类型变量为 invariant。 请参阅 <span class="target" id="index-172"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span> 和 <span class="target" id="index-173"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a><span class="link-target"> [https://peps.python.org/pep-0695/]</span> 了解更多细节。</p>
<p>绑定类型变量和约束类型变量在几个重要方面具有不同的主义。 使用 <em>绑定</em> 类型变量意味着 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 将尽可能使用最为专属的类型来解析:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="k">class</span> <span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># revealed type is StringSubclass</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># error: int is not a subtype of str</span>
</pre></div>
</div>
<p>类型变量可以被绑定到具体类型、抽象类型（ ABC 或 protocol ），甚至是类型的联合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Can be anything with an __abs__ method</span>
<span class="k">def</span> <span class="nf">print_abs</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="n">SupportsAbs</span><span class="p">](</span><span class="n">arg</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Absolute value:&quot;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Can be any subtype of the union str|bytes</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># Can be anything with an __abs__ method</span>
</pre></div>
</div>
<p id="typing-constrained-typevar">但是，如果使用 <em>约束</em> 类型变量，则意味着 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 只能被解析为恰好是给定的约束之一:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># revealed type is str, despite StringSubclass being passed in</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># error: type variable &#39;A&#39; can be either str or bytes in a function call, but not both</span>
</pre></div>
</div>
<p>在运行时，<code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> 将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span></dt>
<dd><p>类型变量的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__covariant__">
<span class="sig-name descname"><span class="pre">__covariant__</span></span></dt>
<dd><p>类型变量是否已被显式地标记为 covariant。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__contravariant__">
<span class="sig-name descname"><span class="pre">__contravariant__</span></span></dt>
<dd><p>类型变量是否已被显式地标记为 contravariant。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__infer_variance__">
<span class="sig-name descname"><span class="pre">__infer_variance__</span></span></dt>
<dd><p>类型变量的种类是否应由类型检查器来推断。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__bound__">
<span class="sig-name descname"><span class="pre">__bound__</span></span></dt>
<dd><p>类型变量的绑定，如果有的话。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对于通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参语法</span></a> 创建的类型变量，只有在属性被访问的时候才会对绑定求值，而不是在类型变量被创建的时候 (参见 <a class="reference internal" href="../reference/executionmodel.xhtml#lazy-evaluation"><span class="std std-ref">惰性求值</span></a>)。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__constraints__">
<span class="sig-name descname"><span class="pre">__constraints__</span></span></dt>
<dd><p>一个包含对类型变量的约束的元组，如果有的话。A tuple containing the constraints of the type variable, if any.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对于通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参语法</span></a> 创建的类型变量，只有在属性被访问的时候才会对约束求值，而不是在类型变量被创建的时候 (参见 <a class="reference internal" href="../reference/executionmodel.xhtml#lazy-evaluation"><span class="std std-ref">惰性求值</span></a>)。</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>类型变量现在可以通过使用 <span class="target" id="index-174"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a><span class="link-target"> [https://peps.python.org/pep-0695/]</span> 引入的 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参</span></a> 语法来声明。 增加了 <code class="docutils literal notranslate"><span class="pre">infer_variance</span></code> 形参。</p>
</div>
</dd></dl>

<dl class="py class" id="typevartuple">
<dt class="sig sig-object py" id="typing.TypeVarTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVarTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类型变量元组。 一种启用了 <em>variadic</em> 泛型的专属 <a class="reference internal" href="#typevar"><span class="std std-ref">类型变量</span></a> 形式。</p>
<p>类型变量元组可以通过在 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参列表</span></a> 中使用名称前的单个星号 (<code class="docutils literal notranslate"><span class="pre">*</span></code>) 来声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">move_first_element_to_last</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">](</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>或者通过显式地发起调用 <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> 构造器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s2">&quot;Ts&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>一个普通类型变量将启用单个类型的形参化。 作为对比，一个类型变量元组通过将 <em>任意</em> 数量的类型变量封包在一个元组中来允许 <em>任意</em> 数量类型的形参化。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># T is bound to int, Ts is bound to ()</span>
<span class="c1"># Return value is (1,), which has type tuple[int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>

<span class="c1"># T is bound to int, Ts is bound to (str,)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 1), which has type tuple[str, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">))</span>

<span class="c1"># T is bound to int, Ts is bound to (str, float)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 3.0, 1), which has type tuple[str, float, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>

<span class="c1"># This fails to type check (and fails at runtime)</span>
<span class="c1"># because tuple[()] is not compatible with tuple[T, *Ts]</span>
<span class="c1"># (at least one element is required)</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>请注意解包运算符 <code class="docutils literal notranslate"><span class="pre">*</span></code> 在 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> 中的使用。 在概念上，你可以将 <code class="docutils literal notranslate"><span class="pre">Ts</span></code> 当作一个由类型变量组成的元组 <code class="docutils literal notranslate"><span class="pre">(T1,</span> <span class="pre">T2,</span> <span class="pre">...)</span></code>。 那么 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> 就将变为 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*(T1,</span> <span class="pre">T2,</span> <span class="pre">...)]</span></code>，这等价于 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">T1,</span> <span class="pre">T2,</span> <span class="pre">...]</span></code>。 （请注意在旧版本 Python 中，你可能会看到改用 <a class="reference internal" href="#typing.Unpack" title="typing.Unpack"><code class="xref py py-data docutils literal notranslate"><span class="pre">Unpack</span></code></a> 的写法，如 <code class="docutils literal notranslate"><span class="pre">Unpack[Ts]</span></code>。）</p>
<p>类型变量元组 <em>总是</em> 要被解包。 这有助于区分类型变量元组和普通类型变量:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Ts</span>          <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Ts</span><span class="p">]</span>   <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>  <span class="c1"># The correct way to do it</span>
</pre></div>
</div>
<p>类型变量元组可被用在与普通类型变量相同的上下文中。 例如，在类定义、参数和返回类型中:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Array[*Shape]&quot;</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>类型变量元组可以很好地与普通类型变量结合在一起：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># This is fine</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Array2</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="n">DType</span><span class="p">]:</span>  <span class="c1"># This would also be fine</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Height</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">Width</span><span class="p">:</span> <span class="o">...</span>

<span class="n">float_array_1d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Height</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>     <span class="c1"># Totally fine</span>
<span class="n">int_array_2d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>  <span class="c1"># Yup, fine too</span>
</pre></div>
</div>
<p>但是，请注意在一个类型参数或类型形参列表中最多只能有一个类型变量元组:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>            <span class="c1"># Not valid</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># Not valid</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>最后，一个已解包的类型变量元组可以被用作 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 的类型标注:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">call_soon</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">](</span>
         <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
         <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>相比非解包的 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 标注 —— 例如 <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">int</span></code>，它将指明 <em>所有</em> 参数均为 <code class="docutils literal notranslate"><span class="pre">int</span></code> —— <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">*Ts</span></code> 启用了对 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 中 <em>单个</em> 参数的类型的引用。 在此，这允许我们确保传入 <code class="docutils literal notranslate"><span class="pre">call_soon</span></code> 的 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 的类型与 <code class="docutils literal notranslate"><span class="pre">callback</span></code> 的（位置）参数的类型相匹配。</p>
<p>关于类型变量元组的更多细节，请参见 <span class="target" id="index-175"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a><span class="link-target"> [https://peps.python.org/pep-0646/]</span>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVarTuple.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span></dt>
<dd><p>类型变量元组的名称。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>类型变量元组现在可以使用 <span class="target" id="index-176"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a><span class="link-target"> [https://peps.python.org/pep-0695/]</span> 所引入的 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参</span></a> 语法来声明。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ParamSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>形参专属变量。 <a class="reference internal" href="#typevar"><span class="std std-ref">类型变量</span></a> 的一个专用版本。</p>
<p>In <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参列表</span></a>，形参规格可以使用两个星号 (<code class="docutils literal notranslate"><span class="pre">**</span></code>) 来声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">IntFunc</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>为了保持与 Python 3.11 及更早版本的兼容性，<code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 对象也可以这样创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>参数规范变量的存在主要是为了使静态类型检查器受益。 它们被用来将一个可调用对象的参数类型转发给另一个可调用对象的参数类型——这种模式通常出现在高阶函数和装饰器中。 它们只有在 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 中使用时才有效，或者作为 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 的第一个参数，或者作为用户定义的泛型的参数。 参见 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 以了解更多关于泛型的信息。</p>
<p>例如，为了给一个函数添加基本的日志记录，我们可以创建一个装饰器 <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> 来记录函数调用。 参数规范变量告诉类型检查器，传入装饰器的可调用对象和由其返回的新可调用对象有相互依赖的类型参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">add_logging</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> was called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@add_logging</span>
<span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>如果没有 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>，以前注释这个的最简单的方法是使用一个 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 与绑定 <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>。</p>
<ol class="arabic simple">
<li><p>类型检查器不能对 <code class="docutils literal notranslate"><span class="pre">inner</span></code> 函数进行类型检查，因为 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 的类型必须是 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。</p></li>
<li><p><a class="reference internal" href="#typing.cast" title="typing.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 在返回 <code class="docutils literal notranslate"><span class="pre">inner</span></code> 函数时，可能需要在 <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> 装饰器的主体中进行，或者必须告诉静态类型检查器忽略 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">inner</span></code>。</p></li>
</ol>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.args">
<span class="sig-name descname"><span class="pre">args</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span></dt>
<dd><p>由于 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 同时捕获了位置参数和关键字参数，<code class="docutils literal notranslate"><span class="pre">P.args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 可以用来将 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 分割成其组成部分。 <code class="docutils literal notranslate"><span class="pre">P.args</span></code> 代表给定调用中的位置参数的元组，只能用于注释 <code class="docutils literal notranslate"><span class="pre">*args</span></code>。 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 代表给定调用中的关键字参数到其值的映射，只能用于注释 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>。在运行时，<code class="docutils literal notranslate"><span class="pre">P.args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 分别是 <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> 和 <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a> 的实例。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span></dt>
<dd><p>形参规格的名称。</p>
</dd></dl>

<p>用 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> 创建的参数规范变量可以用来声明协变或逆变泛型类型。 参数 <code class="docutils literal notranslate"><span class="pre">bound</span></code> 也被接受，类似于 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>。 然而这些关键字的实际语义还有待决定。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>形参说明现在可以使用 <span class="target" id="index-177"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a><span class="link-target"> [https://peps.python.org/pep-0695/]</span> 所引入的 <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参</span></a> 语法来声明。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>只有在全局范围内定义的参数规范变量可以被 pickle。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><span class="target" id="index-178"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a><span class="link-target"> [https://peps.python.org/pep-0612/]</span> -- 参数规范变量（引入 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的 PEP）</p></li>
<li><p><a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a></p></li>
<li><p><a class="reference internal" href="#annotating-callables"><span class="std std-ref">标注可调用对象</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ParamSpecArgs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecArgs</span></span></dt>
<dt class="sig sig-object py" id="typing.ParamSpecKwargs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecKwargs</span></span></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec`的参数和关键字参数属性。``ParamSpec`</span></code> 的 <code class="docutils literal notranslate"><span class="pre">P.args</span></code> 属性是 <code class="docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code> 的一个实例，<code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 是 <code class="docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code> 的一个实例。 它们的目的是用于运行时内部检查的，对静态类型检查器没有特殊意义。</p>
<p>在这些对象中的任何一个上调用 <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> 将返回原始的 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">get_origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypeAliasType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAliasType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通过 <a class="reference internal" href="../reference/simple_stmts.xhtml#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句创建的类型别名的类型。</p>
<p>示例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Alias</span><span class="p">)</span>
<span class="go">&lt;class &#39;typing.TypeAliasType&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span></dt>
<dd><p>类型别名的名称：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;Alias&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span></dt>
<dd><p>类型别名定义所在的模块名称:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__type_params__">
<span class="sig-name descname"><span class="pre">__type_params__</span></span></dt>
<dd><p>类型别名的类型形参，或者如果别名不属于泛型则为一个空元组:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">ListOrSet</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ListOrSet</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">(T,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">NotGeneric</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NotGeneric</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__value__">
<span class="sig-name descname"><span class="pre">__value__</span></span></dt>
<dd><p>类型别名的值。 它将被 <a class="reference internal" href="../reference/executionmodel.xhtml#lazy-evaluation"><span class="std std-ref">惰性求值</span></a>，因此别名定义中使用的名称将直到 <code class="docutils literal notranslate"><span class="pre">__value__</span></code> 属性被访问时才会被解析:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Mutually</span> <span class="o">=</span> <span class="n">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Recursive</span> <span class="o">=</span> <span class="n">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span>
<span class="go">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Mutually</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="other-special-directives">
<h4>其他特殊指令</h4>
<p>这些函数和类不应被直接用作标注。 它们的设计目标是作为创建和声明类型的构件。</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.NamedTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NamedTuple</span></span></dt>
<dd><p><a class="reference internal" href="collections.xhtml#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 的类型版本。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>这相当于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>为字段提供默认值，要在类体内赋值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>带默认值的字段必须在不带默认值的字段后面。</p>
<p>由此产生的类有一个额外的属性 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> ，给出一个 dict ，将字段名映射到字段类型。（字段名在 <code class="docutils literal notranslate"><span class="pre">_fields</span></code> 属性中，默认值在 <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> 属性中，这两者都是 <a class="reference internal" href="collections.xhtml#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a> API 的一部分。）</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 子类也支持文档字符串与方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 子类也可以为泛型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>反向兼容用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For creating a generic NamedTuple on Python 3.11 or lower</span>
<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>

<span class="c1"># A functional syntax is also supported</span>
<span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>添加了对 <span class="target" id="index-179"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a><span class="link-target"> [https://peps.python.org/pep-0526/]</span> 中变量注解句法的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6.1 版本发生变更: </span>添加了对默认值、方法、文档字符串的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 属性现已使用常规字典，不再使用 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 实例。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>移除了 <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 属性， 改用具有相同信息，但更标准的  <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 属性。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>添加对泛型命名元组的支持。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.NewType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NewType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于创建低开销的 <a class="reference internal" href="#distinct"><span class="std std-ref">独有类型</span></a> 的辅助类。</p>
<p><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 将被类型检查器视为一个独有类型。 但是，在运行时，调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 将原样返回其参数。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># Declare the NewType &quot;UserId&quot;</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># &quot;UserId&quot; returns the argument unchanged at runtime</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span></dt>
<dd><p>新类型定义所在的模块。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span></dt>
<dd><p>新类型的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__supertype__">
<span class="sig-name descname"><span class="pre">__supertype__</span></span></dt>
<dd><p>新类型所基于的类型。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 现在是一个类而不是函数。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Protocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Generic</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>协议类的基类。</p>
<p>协议类是这样定义的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>这些类主要与静态类型检查器搭配使用，用来识别结构子类型（静态鸭子类型），例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># Passes static type check</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-180"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a><span class="link-target"> [https://peps.python.org/pep-0544/]</span> 了解详情。 使用 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> 装饰的协议类（稍后将介绍）可作为只检查给定属性是否存在，而忽略其类型签名的简单的运行时协议。</p>
<p>Protocol 类可以是泛型，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>在需要兼容 Python 3.11 或更早版本的代码中，可以这样编写泛型协议:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.runtime_checkable">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">runtime_checkable</span></span></dt>
<dd><p>用于把 Protocol 类标记为运行时协议。</p>
<p>该协议可以与 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 一起使用。应用于非协议的类时，会触发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。该指令支持简易结构检查，与 <a class="reference internal" href="collections.abc.xhtml#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 的 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 非常类似，只擅长做一件事。  例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>

<span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Named</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="kn">import</span> <span class="nn">threading</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="n">Named</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code> 将只检查所需方法或属性是否存在，而不检查它们的类型签名或类型。 例如，<a class="reference internal" href="ssl.xhtml#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> 是一个类，因此它通过了针对 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> 的 <a class="reference internal" href="functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 检查。 但是，<code class="docutils literal notranslate"><span class="pre">ssl.SSLObject.__init__</span></code> 方法的存在只是引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 并附带更具信息量的消息，因此它无法调用 (实例化) <a class="reference internal" href="ssl.xhtml#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>针对运行时可检查协议的 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 检查相比针对非协议类的 <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> 检查可能会惊人的缓慢。 请考虑在性能敏感的代码中使用替代性写法如 <a class="reference internal" href="functions.xhtml#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 调用进行结构检查。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 的内部实现对于运行时可检查协议的检查会使用 <a class="reference internal" href="inspect.xhtml#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getattr_static()</span></code></a> 来查找属性 (在之前版本中，会使用 <a class="reference internal" href="functions.xhtml#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>)。 因此，在 Python 3.12+ 上一些以前被认为是运行时可检查协议的实例的对象可能不再被认为是该协议的实例，反之亦反。 大多数用户不太可能受到这一变化的影响。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>一旦类被创建则运行时可检查协议的成员就会被视为在运行时“已冻结”。 在运行时可检查协议上打上猴子补丁属性仍然有效，但不会影响将对象与协议进行比较的 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 检查。 请参阅 <a class="reference internal" href="../whatsnew/3.12.xhtml#whatsnew-typing-py312"><span class="std std-ref">&quot;Python 3.12 有什么新变化</span></a> 了解更多细节。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>把类型提示添加至字典的特殊构造器。在运行时，它是纯 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 声明一个字典类型，该类型预期所有实例都具有一组键集，其中，每个键都与对应类型的值关联。运行时不检查此预期，而是由类型检查器强制执行。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># Fails type check</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>为了在不支持 <span class="target" id="index-181"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a><span class="link-target"> [https://peps.python.org/pep-0526/]</span> 的旧版 Python 中使用此特性，<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 支持两种额外的等价语法形式:</p>
<ul>
<li><p>使用字面量 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 作为第二个参数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p>使用关键字参数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.11 版起不建议使用，将在 3.13 版中移除: </span>使用关键字的语法在 3.11 中被弃用，并且会于 3.13 被移除。同时，该语法可能不被静态类型检查器支持。</p>
</div>
<p>当任何一个键不是有效的 <a class="reference internal" href="../reference/lexical_analysis.xhtml#identifiers"><span class="std std-ref">标识符</span></a> 时，例如因为它们是关键字或包含连字符，也应该使用函数式语法。例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># raises SyntaxError</span>
<span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; is a keyword</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># name with hyphens</span>

<span class="c1"># OK, functional syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
</pre></div>
</div>
<p>默认情况下，所有的键都必须出现在一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中。 可以使用 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 将单独的键标记为非必要的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]})</span>
</pre></div>
</div>
<p>这意味着一个 <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以省略 <code class="docutils literal notranslate"><span class="pre">label</span></code> 键。</p>
<p>也可以通过全部指定 <code class="docutils literal notranslate"><span class="pre">False</span></code> 将所有键都标记为默认非必要的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>这意味着一个 <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以省略任何一个键。 类型检查器只需要支持一个字面的 <code class="docutils literal notranslate"><span class="pre">False</span></code> 或 <code class="docutils literal notranslate"><span class="pre">True</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数的值。 <code class="docutils literal notranslate"><span class="pre">True</span></code> 是默认的，它使类主体中定义的所有项目都是必需的。</p>
<p>一个 <code class="docutils literal notranslate"><span class="pre">total=False</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中单独的键可以使用 <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 标记为必要的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类型有可能使用基于类的语法从一个或多个其他 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类型继承。用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> 有三个项目 : <code class="docutils literal notranslate"><span class="pre">x</span></code> , <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code> 。 其等价于定义:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 不能从非 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类继承，除了 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># A non-TypedDict class</span>

<span class="k">class</span> <span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># OK</span>

<span class="k">class</span> <span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 也可以为泛型的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>要创建与 Python 3.11 或更低版本兼容的泛型 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>，请显式地从 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 继承：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以通过注解字典（参见 <a class="reference internal" href="../howto/annotations.xhtml#annotations-howto"><span class="std std-ref">注解最佳实践</span></a> 了解更多关于注解的最佳实践）、 <a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a> 、 <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> 和 <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> 进行内省。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__total__">
<span class="sig-name descname"><span class="pre">__total__</span></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> 给出了 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数的值。 例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This attribute reflects <em>only</em> the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument
to the current <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> class, not whether the class is semantically
total. For example, a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with <code class="docutils literal notranslate"><span class="pre">__total__</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> may
have keys marked with <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>, or it may inherit from another
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with <code class="docutils literal notranslate"><span class="pre">total=False</span></code>. Therefore, it is generally better to use
<a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> for introspection.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__required_keys__">
<span class="sig-name descname"><span class="pre">__required_keys__</span></span></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__optional_keys__">
<span class="sig-name descname"><span class="pre">__optional_keys__</span></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> 返回分别包含必要的和非必要的键的 <a class="reference internal" href="stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象。</p>
<p>标记为 <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 的键总是会出现在 <code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> 中而标记为 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 的键总是会出现在 <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code> 中。</p>
<p>为了向下兼容 Python 3.10 及更老的版本，还可以使用继承机制在同一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中同时声明必要和非必要的键。 这是通过声明一个具有 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数值的 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 然后在另一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中继承它并使用不同的 <code class="docutils literal notranslate"><span class="pre">total</span></code> 值来实现的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果使用了 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 或者如果以字符串形式给出标注，那么标注不会在定义 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 时被求值。 因此，<code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code> 所依赖的运行时内省可能无法正常工作，这些属性的值也可能不正确。</p>
</div>
</dd></dl>

<p>更多示例与 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的详细规则，详见 <span class="target" id="index-182"></span><a class="pep reference external" href="https://peps.python.org/pep-0589/"><strong>PEP 589</strong></a><span class="link-target"> [https://peps.python.org/pep-0589/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了对将单独的键标记为 <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 或 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 的支持。 参见 <span class="target" id="index-183"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a><span class="link-target"> [https://peps.python.org/pep-0655/]</span>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>添加对泛型 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的支持。</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3>协议</h3>
<p>下列协议由 typing 模块提供并已全被装饰为 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">可在运行时检查的</span></code></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsAbs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsAbs</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__abs__</span></code>，该方法与其返回类型协变。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsBytes</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsComplex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsComplex</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsFloat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsFloat</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__float__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsIndex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsIndex</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__index__</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsInt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsInt</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__int__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsRound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsRound</span></span></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__round__</span></code>，该方法与其返回类型协变。</p>
</dd></dl>

</section>
<section id="abcs-for-working-with-io">
<h3>与 IO 相关的抽象基类</h3>
<dl class="py class">
<dt class="sig sig-object py" id="typing.IO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">IO</span></span></dt>
<dt class="sig sig-object py" id="typing.TextIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TextIO</span></span></dt>
<dt class="sig sig-object py" id="typing.BinaryIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">BinaryIO</span></span></dt>
<dd><p>泛型 <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> 及其子类 <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code>、<code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code> 表示 I/O 流——例如 <a class="reference internal" href="functions.xhtml#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 返回的对象——的类型。</p>
</dd></dl>

</section>
<section id="functions-and-decorators">
<h3>函数与装饰器</h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.cast">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>把一个值转换为指定的类型。</p>
<p>这会把值原样返回。对类型检查器而言这代表了返回值具有指定的类型，在运行时我们故意没有设计任何检查（我们希望让这尽量快）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>让静态类型检查器确认 <em>val</em> 具有推断为 <em>typ</em> 的类型。</p>
<p>在运行时这将不做任何事：它会原样返回第一个参数而没有任何检查或附带影响，无论参数的实际类型是什么。</p>
<p>当静态类型检查器遇到对 <code class="docutils literal notranslate"><span class="pre">assert_type()</span></code> 的调用时，如果该值不是指定的类型则会报错:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># OK, inferred type of `name` is `str`</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># type checker error</span>
</pre></div>
</div>
<p>此函数适用于确保类型检查器对脚本的理解符合开发者的意图:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">complex_function</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Do some complex type-narrowing logic,</span>
    <span class="c1"># after which we hope the inferred type will be `int`</span>
    <span class="o">...</span>
    <span class="c1"># Test whether the type checker correctly understands our function</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_never</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>让静态类型检查器确认一行代码是不可达的。</p>
<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">as</span> <span class="n">unreachable</span><span class="p">:</span>
            <span class="n">assert_never</span><span class="p">(</span><span class="n">unreachable</span><span class="p">)</span>
</pre></div>
</div>
<p>在这里，标注允许类型检查器推断最后一种情况永远不会执行，因为 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 要么是 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 要么是 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，而这两种选项都已被之前的情况覆盖了。</p>
<p>如果类型检查器发现对 <code class="docutils literal notranslate"><span class="pre">assert_never()</span></code> 的调用是可达的，它将报告一个错误。 举例来说，如果 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 的类型标注改为 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">float</span></code>，则类型检查器将报告一个错误指出 <code class="docutils literal notranslate"><span class="pre">unreachable</span></code> 为 <a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 类型。 对于通过类型检查的 <code class="docutils literal notranslate"><span class="pre">assert_never</span></code> 调用，参数传入的推断类型必须为兜底类型 <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>，而不能为任何其他类型。</p>
<p>在运行时，如果调用此函数将抛出一个异常。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference external" href="https://typing.readthedocs.io/en/latest/source/unreachable.html">Unreachable Code and Exhaustiveness Checking</a><span class="link-target"> [https://typing.readthedocs.io/en/latest/source/unreachable.html]</span> 有更多关于使用静态类型进行穷尽性检查的信息。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.reveal_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">reveal_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>让静态类型检查器显示推测的表达式类型。</p>
<p>当静态类型检查器遇到一个对此函数的调用时，它将发出带有所推测参数类型的诊断信息。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;builtins.int&quot;</span>
</pre></div>
</div>
<p>这在你想要调试你的类型检查器如何处理一段特定代码时很有用处。</p>
<p>在运行时，此函数会将其参数类型打印到 <a class="reference internal" href="sys.xhtml#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 并不加修改地返回该参数 (以允许该调用在表达式中使用):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reveal_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># prints &quot;Runtime type is int&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># prints &quot;1&quot;</span>
</pre></div>
</div>
<p>请注意在运行时类型可能不同于类型静态检查器所推测的类型（明确程度可能更高也可能更低）。</p>
<p>大多数类型检查器都能在任何地方支持 <code class="docutils literal notranslate"><span class="pre">reveal_type()</span></code>，即使并未从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入该名称。 不过，从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入该名称将允许你的代码在运行时不会出现运行时错误并能更清晰地传递意图。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.dataclass_transform">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">dataclass_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_specifiers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个对象标记为提供类似 <a class="reference internal" href="dataclasses.xhtml#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass</span></code></a> 行为的装饰器。</p>
<p><code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 可被用于装饰类、元类或本身为装饰器的函数。 使用 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass_transform()</span></code> 将让静态类型检查器知道被装饰的对象会执行以类似 <a class="reference internal" href="dataclasses.xhtml#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> 的方式来转换类的运行时“魔法”。</p>
<p>装饰器函数使用方式的例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">create_model</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="nd">@create_model</span>
<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>在基类上:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ModelBase</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>在元类上:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ModelMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">ModelBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ModelMeta</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>上面定义的 <code class="docutils literal notranslate"><span class="pre">CustomerModel</span></code> 类将被类型检查器视为类似于使用 <a class="reference internal" href="dataclasses.xhtml#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> 创建的类。 例如，类型检查器将假定这些类具有接受 <code class="docutils literal notranslate"><span class="pre">id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 方法。</p>
<p>被装饰的类、元类或函数可以接受以下布尔值参数，类型检查器将假定它们具有与 <a class="reference internal" href="dataclasses.xhtml#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> 装饰器相同的效果: <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>, <code class="docutils literal notranslate"><span class="pre">frozen</span></code>, <code class="docutils literal notranslate"><span class="pre">match_args</span></code>, <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> 和 <code class="docutils literal notranslate"><span class="pre">slots</span></code>。 这些参数的值 (<code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>) 必须可以被静态地求值。</p>
<p>传给 <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 装饰器的参数可以被用来定制被装饰的类、元类或函数的默认行为:</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eq_default</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></li>
<li><p><strong>order_default</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">order</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
<li><p><strong>kw_only_default</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
<li><p><strong>frozen_default</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 .. versionadded:: 3.12</p></li>
<li><p><strong>field_specifiers</strong> (<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><em>tuple</em></a><em>[</em><a class="reference internal" href="collections.abc.xhtml#collections.abc.Callable" title="collections.abc.Callable"><em>Callable</em></a><em>[</em><em>...</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>...</em><em>]</em>) -- 指定一个受支持的类或描述字段的函数的静态列表，类似于 <a class="reference internal" href="dataclasses.xhtml#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclasses.field()</span></code></a>。 默认为 <code class="docutils literal notranslate"><span class="pre">()</span></code>。</p></li>
<li><p><strong>**kwargs</strong> (<em>Any</em>) -- 接受任何其他关键字以便允许可能的未来扩展。</p></li>
</ul>
</dd>
</dl>
<p>类型检查器能识别下列字段设定器的可选形参:</p>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text"><strong>字段设定器的可识别形参</strong></span></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>形参名称</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">init</span></code></p></td>
<td><p>指明字段是否应当被包括在合成的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 方法中。 如果未指明，则 <code class="docutils literal notranslate"><span class="pre">init</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">default</span></code></p></td>
<td><p>为字段提供默认值。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">default_factory</span></code></p></td>
<td><p>提供一个返回字段默认值的运行时回调。 如果 <code class="docutils literal notranslate"><span class="pre">default</span></code> 或 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 均未指定，则会假定字段没有默认值而在类被实例化时必须提供一个值。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">factory</span></code></p></td>
<td><p>字段说明符上 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 形参的别名。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">kw_only</span></code></p></td>
<td><p>指明字段是否应被标记为仅限关键字的。 如为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，字段将是仅限关键字的。 如为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，它将不是仅限关键字的。 如未指明，则将使用以 <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 装饰的对象的 <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> 形参的值，或者如果该值也未指明，则将使用 <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 上 <code class="docutils literal notranslate"><span class="pre">kw_only_default</span></code> 的值。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">alias</span></code></p></td>
<td><p>提供字段的替代名称。 该替代名称会被用于合成的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 方法。</p></td>
</tr>
</tbody>
</table>
<p>在运行时，该装饰器会将其参数记录到被装饰对象的 <code class="docutils literal notranslate"><span class="pre">__dataclass_transform__</span></code> 属性。 它没有其他的运行时影响。</p>
<p>更多细节请参见 <span class="target" id="index-184"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a><span class="link-target"> [https://peps.python.org/pep-0681/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function" id="overload">
<dt class="sig sig-object py" id="typing.overload">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">overload</span></span></dt>
<dd><p>用于创建重载函数和方法的装饰器。</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰器允许描述支持多参数类型不同组合的函数和方法。 一系列以 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义必须带上恰好一个非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义（用于同一个函数/方法）。</p>
<p>以 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义仅对类型检查器有用，因为它们将被非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义覆盖。 与此同时，非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义将在运行时使用但应被类型检查器忽略。 在运行时，直接调用以 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的函数将引发 <a class="reference internal" href="exceptions.xhtml#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
<p>一个提供了比使用联合或类型变量更精确的类型的重载的示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># actual implementation goes here</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-185"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span> 了解更多细节以及与其他类型语义的比较。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>现在可以使用 <a class="reference internal" href="#typing.get_overloads" title="typing.get_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_overloads()</span></code></a> 在运行时内省有重载的函数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_overloads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>为 <em>func</em> 返回以 <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a> 装饰的定义的序列。</p>
<p><em>func</em> 是用于实现过载函数的函数对象。 例如，根据文档中为 <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a> 给出的 <code class="docutils literal notranslate"><span class="pre">process</span></code> 定义，<code class="docutils literal notranslate"><span class="pre">get_overloads(process)</span></code> 将为所定义的三个过载函数返回由三个函数对象组成的序列。 如果在不带过载的函数上调用，<code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> 将返回一个空序列。</p>
<p><code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> 可被用来在运行时内省一个过载函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.clear_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">clear_overloads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>清空内部注册表中所有已注册的重载。</p>
<p>这可用于回收注册表所使用的内存。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.final">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">final</span></span></dt>
<dd><p>表示最终化方法和最终化类的装饰器。</p>
<p>以 <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> 装饰一个方法将向类型检查器指明该方法不可在子类中被重载。 以 <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> 装饰一个类表示它不可被子类化。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这些属性没有运行时检查。详见 <span class="target" id="index-186"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a><span class="link-target"> [https://peps.python.org/pep-0591/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>该装饰器现在将尝试在被装饰的对象上设置 <code class="docutils literal notranslate"><span class="pre">__final__</span></code> 属性为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 这样，可以在运行时使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__final__&quot;,</span> <span class="pre">False)</span></code> 这样的检查来确定对象 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 是否已被标记为终结。 如果被装饰的对象不支持设置属性，该装饰器将不加修改地返回对象而不会引发异常。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check</span></span></dt>
<dd><p>标明注解不是类型提示的装饰器。</p>
<p>此作用方式类似于类或函数的 <a class="reference internal" href="../glossary.xhtml#term-decorator"><span class="xref std std-term">decorator</span></a>。 对于类，它将递归地应用到该类中定义的所有方法和类（但不包括在其超类或子类中定义的方法）。 类型检查器将忽略带有此装饰器的函数或类的所有标注。</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code> 将原地改变被装饰的对象。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check_decorator">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check_decorator</span></span></dt>
<dd><p>让其他装饰器具有 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 效果的装饰器。</p>
<p>本装饰器用 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 里的装饰函数打包其他装饰器。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.override">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">override</span></span></dt>
<dd><p>该装饰器指明子类中的某个方法是重载超类中的方法或属性。</p>
<p>如果一个以 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code> 装饰的方法实际未重载任何东西则类型检查器应当报告错误。 这有助于防止当基类发生修改而子类未进行相应修改而导致的问题。</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Okay: overrides Base.log_status</span>
        <span class="o">...</span>

    <span class="nd">@override</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>没有对此特征属性的运行时检查。</p>
<p>该装饰器将尝试在被装饰的对象上设置 <code class="docutils literal notranslate"><span class="pre">__override__</span></code> 属性为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 这样，可以在运行时使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__override__&quot;,</span> <span class="pre">False)</span></code> 这样的检查来确定对象 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 是否已被标记为重载。 如果被装饰的对象不支持设置属性，该装饰器将不加修改地返回对象而不会引发异常。</p>
<p>更多细节参见 <span class="target" id="index-187"></span><a class="pep reference external" href="https://peps.python.org/pep-0698/"><strong>PEP 698</strong></a><span class="link-target"> [https://peps.python.org/pep-0698/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.type_check_only">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">type_check_only</span></span></dt>
<dd><p>将类或函数标记为在运行时不可用的装饰器。</p>
<p>在运行时，该装饰器本身不可用。实现返回的是私有类实例时，它主要是用于标记在类型存根文件中定义的类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>注意，建议不要返回私有类实例，最好将之设为公共类。</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3>内省辅助器</h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.get_type_hints">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_type_hints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_extras</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回函数、方法、模块、类对象的类型提示的字典。</p>
<p>这往往与 <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code> 相同。 此外，编码为字符串字面值的前向引用是通过在 <code class="docutils literal notranslate"><span class="pre">globals</span></code>, <code class="docutils literal notranslate"><span class="pre">locals</span></code> 和 (如果可用) <a class="reference internal" href="../reference/compound_stmts.xhtml#type-params"><span class="std std-ref">类型形参</span></a> 命名空间中执行求值来处理的。 对于一个类 <code class="docutils literal notranslate"><span class="pre">C</span></code>，将返回一个由所有 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 与 <code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code> 逆序合并构建而成的字典。</p>
<p>本函数会递归地将所有 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">T</span></code>，除非 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 被设为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (请参阅 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a> 了解详情)。 例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>

<span class="k">assert</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="k">assert</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="k">assert</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> 在导入的 <a class="reference internal" href="#type-aliases"><span class="std std-ref">类型别名</span></a> 中不工作，包括前向引用。启用注解的延迟评估（ <span class="target" id="index-188"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a><span class="link-target"> [https://peps.python.org/pep-0563/]</span> ）可能会消除对大多数前向引用的需要。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>增加了作为 <span class="target" id="index-189"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a><span class="link-target"> [https://peps.python.org/pep-0593/]</span> 组成部分的 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 形参。 请参阅 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Annotated</span></code></a> 文档了解详情。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>在之前，如果设置了等于 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的默认值则会为函数和方法标注添加 <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code>。 现在标注将被不加修改地返回。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_origin">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>获取一个类型的不带下标的版本：对于 <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 形式的类型对象将返回 <code class="docutils literal notranslate"><span class="pre">X</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是一个内置类型或 <a class="reference internal" href="collections.xhtml#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 类在 typing 模块中的别名，它将被正规化为原始的类。 如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是 <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> 或 <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a> 的实例，则返回下层的 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>。 对于不受支持的对象将返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_args">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>获取已执行所有下标的类型参数：对于 <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 形式的类型对象将返回 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是一个并集或是包含在另一个泛型类型中的 <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a>，则 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code> 的顺序可能因类型缓存而与原始参数 <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 存在差异。 对于不受支持的对象将返回 <code class="docutils literal notranslate"><span class="pre">()</span></code>。</p>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="p">()</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_typeddict">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_typeddict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>检查一个类型是否为 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a>。</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Film</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">assert</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">Film</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>

<span class="c1"># TypedDict is a factory for creating typed dicts,</span>
<span class="c1"># not a typed dict itself</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ForwardRef">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ForwardRef</span></span></dt>
<dd><p>用于字符串前向引用的内部类型表示的类。</p>
<p>例如，<code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> 会被隐式转换为 <code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>。  <code class="docutils literal notranslate"><span class="pre">ForwardRef</span></code> 不应由用户来实例化，但可以由内省工具使用。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><span class="target" id="index-190"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 泛型类型例如 <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code> 将不会被隐式地转换为 <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> 因而将不会自动解析为 <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.4.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3>常量</h3>
<dl class="py data">
<dt class="sig sig-object py" id="typing.TYPE_CHECKING">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TYPE_CHECKING</span></span></dt>
<dd><p>会被第 3 方静态类型检查器假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的特殊常量。 在运行时将为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>第一个类型注解必须用引号标注，才能把它当作“前向引用”，从而在解释器运行时中隐藏 <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> 引用。局部变量的类型注释不会被评估，因此，第二个注解不需要用引号引起来。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>若用了 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>，函数定义时则不求值注解，直接把注解以字符串形式存在 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 里。这时毋需为注解打引号（见 <span class="target" id="index-191"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a><span class="link-target"> [https://peps.python.org/pep-0563/]</span>）。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

</section>
<section id="deprecated-aliases">
<span id="generic-concrete-collections"></span><span id="id5"></span><h3>一些已被弃用的别名</h3>
<p>本模块给标准库中已有的类定义了许多别名，这些别名现已不再建议使用。起初 typing 模块包含这些别名是为了支持用 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 来参数化泛型类。然而，在 Python 3.9 中，对应的已有的类也支持了 <code class="docutils literal notranslate"><span class="pre">[]</span></code> (参见 <span class="target" id="index-192"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span>)，因此这些别名了就成了多余的了。</p>
<p>这些多余的类型从 Python 3.9 起被弃用。然而，虽然它们可能会在某一时刻被移除，但目前还没有移除它们的计划。因此，解释器目前不会对这些别名发出弃用警告。</p>
<p>一旦确定了何时这些别名将被移除，解释器将比正式移除之时提前至少两个版本发出弃用警告 (deprecation warning)。但保证至少在 Python 3.14 之前，这些别名仍会留在 typing 模块中，并且不会引发弃用警告。</p>
<p>如果被类型检查器检查的程序旨在运行于 Python 3.9 或更高版本，则鼓励类型检查器标记出这些不建议使用的类型。</p>
<section id="aliases-to-built-in-types">
<span id="corresponding-to-built-in-types"></span><h4>内置类型的别名</h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Dict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的已弃用的别名。</p>
<p>请注意，要注解参数，更推荐使用 <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 这样的抽象容器类型，而不是使用 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 或者 <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Dict</span></code> 。</p>
<p>该类型用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-193"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.List">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">list,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 的已弃用的别名。</p>
<p>请注意，要注解参数，更推荐使用 <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 或者 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 这样的抽象容器类型，而不是使用 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 或者 <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.List</span></code> 。</p>
<p>该类型用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vec2</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)](</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)](</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-194"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">set,</span> <span class="pre">MutableSet[T]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 的已弃用的别名。</p>
<p>请注意，要注解参数，更推荐使用 <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a> 这样的抽象容器类型，而不是使用 <a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 或者 <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Set</span></code> 。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-195"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.FrozenSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">FrozenSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">frozenset,</span> <span class="pre">AbstractSet[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-196"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Tuple">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span></dt>
<dd><p><a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 的已弃用的别名。</p>
<p><a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> 是类型系统中的特例；更多详细信息请参见 <a class="reference internal" href="#annotating-tuples"><span class="std std-ref">标注元组</span></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-197"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[CT_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的已弃用的别名。</p>
<p>有关在类型注解中使用 <a class="reference internal" href="functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">typing.Type</span></code> 的详细信息，请参阅 <a class="reference internal" href="#type-of-class-objects"><span class="std std-ref">类对象的类型</span></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="functions.xhtml#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-198"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-types-in-collections">
<span id="corresponding-to-types-in-collections"></span><h4><a class="reference internal" href="collections.xhtml#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 中的类型的别名。</h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.DefaultDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">DefaultDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.defaultdict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.xhtml#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.xhtml#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-199"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.OrderedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">OrderedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.OrderedDict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.xhtml#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.xhtml#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-200"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ChainMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.ChainMap,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.xhtml#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.xhtml#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-201"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Counter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Counter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.Counter,</span> <span class="pre">Dict[T,</span> <span class="pre">int]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.xhtml#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.xhtml#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-202"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Deque">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Deque</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deque,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.xhtml#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.xhtml#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-203"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-concrete-types">
<span id="other-concrete-types"></span><h4>其他具体类型的别名</h4>
<blockquote>
<div><div class="deprecated-removed">
<p><span class="versionmodified">从 3.8 版起不建议使用，将在 3.13 版中移除: </span><code class="docutils literal notranslate"><span class="pre">typing.io</span></code> 命名空间被弃用并将被删除。 这些类型应该被直接从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入。</p>
</div>
</div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span></dt>
<dt class="sig sig-object py" id="typing.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Match</span></span></dt>
<dd><p><a class="reference internal" href="re.xhtml#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 和 <a class="reference internal" href="re.xhtml#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> 的返回类型的已弃用的别名。</p>
<p>这些类型（与对应的函数）是 <a class="reference internal" href="#typing.AnyStr" title="typing.AnyStr"><code class="xref py py-data docutils literal notranslate"><span class="pre">AnyStr</span></code></a> 上的泛型。 <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> 可以被特化为 <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>；<code class="docutils literal notranslate"><span class="pre">Match</span></code> 可以被特化为 <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.8 版起不建议使用，将在 3.13 版中移除: </span><code class="docutils literal notranslate"><span class="pre">typing.re</span></code> 命名空间被弃用并将被删除。 这些类型应该被直接从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块中的 <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> 与 <code class="docutils literal notranslate"><span class="pre">Match</span></code> 类现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-204"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 与 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Text">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Text</span></span></dt>
<dd><p><a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的已弃用的别名。</p>
<p><code class="docutils literal notranslate"><span class="pre">Text</span></code> 被用来为 Python 2 代码提供向上兼容的路径：在 Python 2 中，<code class="docutils literal notranslate"><span class="pre">Text</span></code> 是 <code class="docutils literal notranslate"><span class="pre">unicode</span></code> 的别名。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Text</span></code> 时，值中必须包含 unicode 字符串，以兼容 Python 2 和 Python 3：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用: </span>Python 2 已不再受支持，并且大部分类型检查器也都不再支持 Python 2 代码的类型检查。 目前还没有计划移除该别名，但建议用户使用 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 来代替 <code class="docutils literal notranslate"><span class="pre">Text</span></code>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-container-abcs-in-collections-abc">
<span id="corresponding-to-collections-in-collections-abc"></span><span id="abstract-base-classes"></span><h4><a class="reference internal" href="collections.abc.xhtml#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中容器 ABC 的别名</h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.AbstractSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AbstractSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-205"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ByteString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ByteString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[int]</span></em><span class="sig-paren">)</span></dt>
<dd><p>该类型代表了 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、<a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>、<a class="reference internal" href="stdtypes.xhtml#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 等字节序列类型。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.9 版起不建议使用，将在 3.14 版中移除: </span>首选 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a>，或是 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">|</span> <span class="pre">bytearray</span> <span class="pre">|</span> <span class="pre">memoryview</span></code> 这样的并集。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sized,</span> <span class="pre">Iterable[T_co],</span> <span class="pre">Container[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-206"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Container">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Container</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-207"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[tuple[KT_co,</span> <span class="pre">VT_co]]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-208"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.KeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">KeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[KT_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-209"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Mapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[KT],</span> <span class="pre">Generic[KT,</span> <span class="pre">VT_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 的已弃用的别名。</p>
<p>该类型用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-210"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MappingView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MappingView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sized</span></span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-211"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableMapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableMapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Mapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-212"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[T]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-213"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AbstractSet[T]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-214"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Reversible[T_co],</span> <span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-215"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">Collection[_VT_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-216"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-asynchronous-abcs-in-collections-abc">
<span id="asynchronous-programming"></span><h4><a class="reference internal" href="collections.abc.xhtml#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中异步 ABC 的别名</h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Coroutine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Coroutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Awaitable[ReturnType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 的已弃用的别名。</p>
<p>类型变量的变化形式和顺序与 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 的相对应，例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Some coroutine defined elsewhere</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># Inferred type of &#39;x&#39; is list[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># Inferred type of &#39;y&#39; is int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-217"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 的已弃用的别名。</p>
<p>异步生成器可由泛型类型 <code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code> 注解。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>与常规生成器不同，异步生成器不能返回值，因此没有 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 类型参数。 与 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 类似，<code class="docutils literal notranslate"><span class="pre">SendType</span></code> 也属于逆变行为。</p>
<p>如果生成器只产生值，可将 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>此外，可用 <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code> 注解生成器的返回类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-218"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-219"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterable[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-220"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Awaitable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Awaitable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-221"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-abcs-in-collections-abc">
<span id="corresponding-to-other-types-in-collections-abc"></span><h4><a class="reference internal" href="collections.abc.xhtml#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中其他 ABC 的别名</h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 的已弃用的别名</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-222"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-223"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Callable">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Callable</span></span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 的已弃用的别名。</p>
<p>有关如何在类型标注中使用 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">typing.Callable</span></code> 的详细信息请参阅 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">标注可调用对象</span></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-224"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 现在支持 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。 详情见 <span class="target" id="index-225"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a><span class="link-target"> [https://peps.python.org/pep-0612/]</span>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Generator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 的已弃用的别名。</p>
<p>生成器可以由泛型类型 <code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code> 注解。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>注意，与 typing 模块里的其他泛型不同， <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 属于逆变行为，不是协变行为，也是不变行为。</p>
<p>如果生成器只产生值，可将 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 与 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>此外，还可以把生成器的返回类型注解为 <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-226"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Hashable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Hashable</span></span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用: </span>请改为直接使用 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Reversible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Reversible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.xhtml#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-227"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sized">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sized</span></span></dt>
<dd><p><a class="reference internal" href="collections.abc.xhtml#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用: </span>请改为直接使用 <a class="reference internal" href="collections.abc.xhtml#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-contextlib-abcs">
<span id="context-manager-types"></span><h4><a class="reference internal" href="contextlib.xhtml#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> ABC 的别名</h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.ContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="contextlib.xhtml#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="contextlib.xhtml#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-228"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="contextlib.xhtml#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="contextlib.xhtml#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 现在 支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-229"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span> 和 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
</section>
</section>
<section id="deprecation-timeline-of-major-features">
<h2>主要特性的弃用时间线</h2>
<p><code class="docutils literal notranslate"><span class="pre">typing</span></code> 的某些特性被弃用，并且可能在将来的 Python 版本中被移除。下表总结了主要的弃用特性。该表可能会被更改，而且并没有列出所有的弃用特性。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>特性</p></th>
<th class="head"><p>弃用于</p></th>
<th class="head"><p>计划移除</p></th>
<th class="head"><p>PEP/问题</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">typing.io</span></code> 和 <code class="docutils literal notranslate"><span class="pre">typing.re</span></code> 子模块</p></td>
<td><p>3.8</p></td>
<td><p>3.13</p></td>
<td><p><a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=38291">bpo-38291</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=38291]</span></p></td>
</tr>
<tr class="row-odd"><td><p>标准容器的 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 版本</p></td>
<td><p>3.9</p></td>
<td><p>未定（请参阅 <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">一些已被弃用的别名</span></a> 了解详情）</p></td>
<td><p><span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.ByteString" title="typing.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ByteString</span></code></a></p></td>
<td><p>3.9</p></td>
<td><p>3.14</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/91896">gh-91896</a><span class="link-target"> [https://github.com/python/cpython/issues/91896]</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.Text" title="typing.Text"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Text</span></code></a></p></td>
<td><p>3.11</p></td>
<td><p>未确定</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/92332">gh-92332</a><span class="link-target"> [https://github.com/python/cpython/issues/92332]</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.Hashable" title="typing.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Hashable</span></code></a> 和 <a class="reference internal" href="#typing.Sized" title="typing.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Sized</span></code></a></p></td>
<td><p>3.12</p></td>
<td><p>未确定</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/94309">gh-94309</a><span class="link-target"> [https://github.com/python/cpython/issues/94309]</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.TypeAlias</span></code></a></p></td>
<td><p>3.12</p></td>
<td><p>未确定</p></td>
<td><p><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a><span class="link-target"> [https://peps.python.org/pep-0695/]</span></p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>