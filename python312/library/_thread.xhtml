<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="_thread --- 低层级多线程 API" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/_thread.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="该模块提供了操作多个线程（也被称为 轻量级进程 或 任务 ）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 互斥锁 或 二进制信号 ）。 threading 模块基于该模块提供了更易用的高级多线程 API。 这个模块定义了以下常量和函数： 锁对象有以下方法： 除了这些方法之外，锁对象也可以通过 with 语句使用，例如： 注意事项： 线程与中断..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="该模块提供了操作多个线程（也被称为 轻量级进程 或 任务 ）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 互斥锁 或 二进制信号 ）。 threading 模块基于该模块提供了更易用的高级多线程 API。 这个模块定义了以下常量和函数： 锁对象有以下方法： 除了这些方法之外，锁对象也可以通过 with 语句使用，例如： 注意事项： 线程与中断..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>_thread --- 低层级多线程 API</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/_thread.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-_thread">
<span id="thread-low-level-threading-api"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code> --- 低层级多线程 API</h1>
<hr class="docutils" id="index-0" />
<p>该模块提供了操作多个线程（也被称为 <em class="dfn">轻量级进程</em> 或 <em class="dfn">任务</em>）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 <em class="dfn">互斥锁</em> 或 <em class="dfn">二进制信号</em>）。<a class="reference internal" href="threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块基于该模块提供了更易用的高级多线程 API。</p>
<div class="versionchanged" id="index-1">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>这个模块曾经为可选项，但现在总是可用。</p>
</div>
<p>这个模块定义了以下常量和函数：</p>
<dl class="py exception">
<dt class="sig sig-object py" id="thread.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">error</span></span></dt>
<dd><p>发生线程相关错误时抛出。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>现在是内建异常 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 的别名。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="thread.LockType">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">LockType</span></span></dt>
<dd><p>锁对象的类型。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.start_new_thread">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">start_new_thread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>开启一个新线程并返回其标识。 线程执行函数 <em>function</em> 并附带参数列表 <em>args</em> (必须是元组)。 可选的 <em>kwargs</em> 参数指定一个关键字参数字典。</p>
<p>当函数返回时，线程会静默地退出。</p>
<p>当函数因某个未处理异常而终结时，<a class="reference internal" href="sys.xhtml#sys.unraisablehook" title="sys.unraisablehook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.unraisablehook()</span></code></a> 会被调用以处理异常。 钩子参数的 <em>object</em> 属性为 <em>function</em>。 在默认情况下，会打印堆栈回溯然后该线程将退出（但其他线程会继续运行）。</p>
<p>当函数引发 <a class="reference internal" href="exceptions.xhtml#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 异常时，它会被静默地忽略。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">_thread.start_new_thread</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">function</span></code>, <code class="docutils literal notranslate"><span class="pre">args</span></code>, <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>现在会使用 <a class="reference internal" href="sys.xhtml#sys.unraisablehook" title="sys.unraisablehook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.unraisablehook()</span></code></a> 来处理未处理的异常。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.interrupt_main">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">interrupt_main</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">signal.SIGINT</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>模拟一个信号到达主线程的效果。 线程可使用此函数来打断主线程，虽然并不保证打断将立即发生。</p>
<p>如果给出 <em>signum</em>，则表示要模拟的信号的编号。 如果未给出 <em>signum</em>，则将模拟 <a class="reference internal" href="signal.xhtml#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a>。</p>
<p>如果给出的信号未被 Python 处理 (它被设为 <a class="reference internal" href="signal.xhtml#signal.SIG_DFL" title="signal.SIG_DFL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_DFL</span></code></a> 或 <a class="reference internal" href="signal.xhtml#signal.SIG_IGN" title="signal.SIG_IGN"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_IGN</span></code></a>)，则此函数将不做任何操作。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>添加了 <em>signum</em> 参数来定制信号的编号。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这并不会发出对应的信号而是将一个调用排入关联处理器的计划任务（如果句柄存在的话）。 如果你想要真的发出信号，请使用 <a class="reference internal" href="signal.xhtml#signal.raise_signal" title="signal.raise_signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.raise_signal()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.exit">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">exit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>抛出 <a class="reference internal" href="exceptions.xhtml#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 异常。如果没有捕获的话，这个异常会使线程退出。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.allocate_lock">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">allocate_lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的锁对象。锁中的方法在后面描述。初始情况下锁处于解锁状态。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.get_ident">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">get_ident</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.get_native_id">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">get_native_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX, DragonFlyBSD。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="thread.stack_size">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">stack_size</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回创建线程时使用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 <em>size</em> 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 错误。如果指定的堆栈大小不合法，会抛出 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: Windows, pthreads。</p>
<p>带有 POSIX 线程支持的 Unix 平台。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="thread.TIMEOUT_MAX">
<span class="sig-prename descclassname"><span class="pre">_thread.</span></span><span class="sig-name descname"><span class="pre">TIMEOUT_MAX</span></span></dt>
<dd><p><a class="reference internal" href="threading.xhtml#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lock.acquire</span></code></a> 的 <em>timeout</em> 形参所允许的最大值。 指定大于该值的 timeout 将引发 <a class="reference internal" href="exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<p>锁对象有以下方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="thread.lock.acquire">
<span class="sig-prename descclassname"><span class="pre">lock.</span></span><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>没有任何可选参数时，该方法无条件申请获得锁，有必要的话会等待其他线程释放锁（同时只有一个线程能获得锁 —— 这正是锁存在的原因）。</p>
<p>如果提供了 <em>blocking</em> 参数，具体的行为将取决于它的值：如果它为假值，则只在能够立即获取到锁而无需等待时才会获取，而如果它为真值，则会与上面一样无条件地获取锁。</p>
<p>如果提供了浮点数形式的 <em>timeout</em> 参数且为正值，它将指明在返回之前的最大等待秒数。 负的 <em>timeout</em> 参数表示无限期的等待。 如果 <em>blocking</em> 为假值则你不能指定 <em>timeout</em>。</p>
<p>如果成功获取到所会返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>新的 <em>timeout</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>现在获取锁的操作可以被 POSIX 信号中断。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thread.lock.release">
<span class="sig-prename descclassname"><span class="pre">lock.</span></span><span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>释放锁。锁必须已经被获取过，但不一定是同一个线程获取的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="thread.lock.locked">
<span class="sig-prename descclassname"><span class="pre">lock.</span></span><span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回锁的状态：如果已被某个线程获取，返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
</dd></dl>

<p>除了这些方法之外，锁对象也可以通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句使用，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">_thread</span>

<span class="n">a_lock</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">allocate_lock</span><span class="p">()</span>

<span class="k">with</span> <span class="n">a_lock</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a_lock is locked while this executes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>注意事项：</strong></p>
<ul class="simple" id="index-2">
<li><p>线程与中断奇怪地交互：<a class="reference internal" href="exceptions.xhtml#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 异常可能会被任意一个线程捕获。（如果 <a class="reference internal" href="signal.xhtml#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 模块可用的话，中断总是会进入主线程。）</p></li>
<li><p>调用 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 或是抛出 <a class="reference internal" href="exceptions.xhtml#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 异常等效于调用 <a class="reference internal" href="#thread.exit" title="_thread.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">_thread.exit()</span></code></a>。</p></li>
<li><p>不可能中断锁上的 <a class="reference internal" href="threading.xhtml#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> 方法 --- <a class="reference internal" href="exceptions.xhtml#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 异常将在获取锁之后发生。</p></li>
<li><p>当主线程退出时，由系统决定其他线程是否存活。在大多数系统中，这些线程会直接被杀掉，不会执行 <a class="reference internal" href="../reference/compound_stmts.xhtml#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> ... <a class="reference internal" href="../reference/compound_stmts.xhtml#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 语句，也不会执行对象析构函数。</p></li>
<li><p>当主线程退出时，不会进行正常的清理工作（除非使用了 <a class="reference internal" href="../reference/compound_stmts.xhtml#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> ... <a class="reference internal" href="../reference/compound_stmts.xhtml#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 语句），标准 I/O 文件也不会刷新。</p></li>
</ul>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>