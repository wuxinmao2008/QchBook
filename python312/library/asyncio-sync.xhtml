<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="同步原语" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/asyncio-sync.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/asyncio/locks.py[https://github.com/python/cpython/tree/3.12/Lib/asyncio/locks.py] asyncio 同步原语被设计为与 threading 模块的类似，但有两个关键注意事项: asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用 threading)；, 这些同..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码: Lib/asyncio/locks.py[https://github.com/python/cpython/tree/3.12/Lib/asyncio/locks.py] asyncio 同步原语被设计为与 threading 模块的类似，但有两个关键注意事项: asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用 threading)；, 这些同..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>同步原语</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-sync.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="synchronization-primitives">
<span id="asyncio-sync"></span><h1>同步原语</h1>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/locks.py">Lib/asyncio/locks.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/asyncio/locks.py]</span></p>
<hr class="docutils" />
<p>asyncio 同步原语被设计为与 <a class="reference internal" href="threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块的类似，但有两个关键注意事项:</p>
<ul class="simple">
<li><p>asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用 <a class="reference internal" href="threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>)；</p></li>
<li><p>这些同步原语的方法不接受 <em>timeout</em> 参数；请使用 <a class="reference internal" href="asyncio-task.xhtml#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.wait_for()</span></code></a> 函数来执行带有超时的操作。</p></li>
</ul>
<p>asyncio 具有下列基本同步原语:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#asyncio.Lock" title="asyncio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a></p></li>
<li><p><a class="reference internal" href="#asyncio.Event" title="asyncio.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a></p></li>
<li><p><a class="reference internal" href="#asyncio.Condition" title="asyncio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a></p></li>
<li><p><a class="reference internal" href="#asyncio.Semaphore" title="asyncio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a></p></li>
<li><p><a class="reference internal" href="#asyncio.BoundedSemaphore" title="asyncio.BoundedSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundedSemaphore</span></code></a></p></li>
<li><p><a class="reference internal" href="#asyncio.Barrier" title="asyncio.Barrier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Barrier</span></code></a></p></li>
</ul>
<hr class="docutils" />
<section id="lock">
<h2>Lock</h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Lock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Lock</span></span></dt>
<dd><p>实现一个用于 asyncio 任务的互斥锁。 非线程安全。</p>
<p>asyncio 锁可被用来保证对共享资源的独占访问。</p>
<p>使用 Lock 的推荐方式是通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 语句:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="c1"># ... later</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># access shared state</span>
</pre></div>
</div>
<p>这等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="c1"># ... later</span>
<span class="k">await</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># access shared state</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>移除了 <em>loop</em> 形参。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Lock.acquire">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>获取锁。</p>
<p>此方法会等待直至锁为 <em>unlocked</em>，将其设为 <em>locked</em> 并返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<p>当有一个以上的协程在 <a class="reference internal" href="#asyncio.Lock.acquire" title="asyncio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> 中被阻塞则会等待解锁，最终只有一个协程会被执行。</p>
<p>锁的获取是 <em>公平的</em>: 被执行的协程将是第一个开始等待锁的协程。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Lock.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>释放锁。</p>
<p>当锁为 <em>locked</em> 时，将其设为 <em>unlocked</em> 并返回。</p>
<p>如果锁为 <em>unlocked</em>，则会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Lock.locked">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>如果锁为 <em>locked</em> 则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

</dd></dl>

</section>
<section id="event">
<h2>事件</h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Event">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Event</span></span></dt>
<dd><p>事件对象。 该对象不是线程安全的。</p>
<p>asyncio 事件可被用来通知多个 asyncio 任务已经有事件发生。</p>
<p>Event 对象会管理一个内部旗标，可通过 <a class="reference internal" href="#asyncio.Event.set" title="asyncio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> 方法将其设为 <em>true</em> 并通过 <a class="reference internal" href="#asyncio.Event.clear" title="asyncio.Event.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code></a> 方法将其重设为 <em>false</em>。 <a class="reference internal" href="#asyncio.Event.wait" title="asyncio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 方法会阻塞直至该旗标被设为 <em>true</em>。 该旗标初始时会被设为 <em>false</em>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>移除了 <em>loop</em> 形参。</p>
</div>
<p id="asyncio-example-sync-event">示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">waiter</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;waiting for it ...&#39;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;... got it!&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create an Event object.</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="c1"># Spawn a Task to wait until &#39;event&#39; is set.</span>
    <span class="n">waiter_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">waiter</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

    <span class="c1"># Sleep for 1 second and set the event.</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="c1"># Wait until the waiter task is finished.</span>
    <span class="k">await</span> <span class="n">waiter_task</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Event.wait">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>等待直至事件被设置。</p>
<p>如果事件已被设置，则立即返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 否则将阻塞直至另一个任务调用 <a class="reference internal" href="#asyncio.Event.set" title="asyncio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Event.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>设置事件。</p>
<p>所有等待事件被设置的任务将被立即唤醒。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Event.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>清空（取消设置）事件。</p>
<p>通过 <a class="reference internal" href="#asyncio.Event.wait" title="asyncio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 进行等待的任务现在将会阻塞直至 <a class="reference internal" href="#asyncio.Event.set" title="asyncio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> 方法被再次调用。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Event.is_set">
<span class="sig-name descname"><span class="pre">is_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>如果事件已被设置则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

</dd></dl>

</section>
<section id="condition">
<h2>Condition</h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Condition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>条件对象。 该对象不是线程安全的。</p>
<p>asyncio 条件原语可被任务用于等待某个事件发生，然后获取对共享资源的独占访问。</p>
<p>在本质上，Condition 对象合并了 <a class="reference internal" href="#asyncio.Event" title="asyncio.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a> 和 <a class="reference internal" href="#asyncio.Lock" title="asyncio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> 的功能。 多个 Condition 对象有可能共享一个 Lock，这允许关注于共享资源的特定状态的不同任务实现对共享资源的协同独占访问。</p>
<p>可选的 <em>lock</em> 参数必须为 <a class="reference internal" href="#asyncio.Lock" title="asyncio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> 对象或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 在后一种情况下会自动创建一个新的 Lock 对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>移除了 <em>loop</em> 形参。</p>
</div>
<p>使用 Condition 的推荐方式是通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 语句:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cond</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>

<span class="c1"># ... later</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>这等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cond</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>

<span class="c1"># ... later</span>
<span class="k">await</span> <span class="n">cond</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">cond</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.acquire">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>获取下层的锁。</p>
<p>此方法会等待直至下层的锁为 <em>unlocked</em>，将其设为 <em>locked</em> 并返回 returns <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.notify">
<span class="sig-name descname"><span class="pre">notify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wake up at most <em>n</em> tasks (1 by default) waiting on this
condition.  The method is no-op if no tasks are waiting.</p>
<p>锁必须在此方法被调用前被获取并在随后被快速释放。 如果通过一个 <em>unlocked</em> 锁调用则会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.locked">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>如果下层的锁已被获取则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.notify_all">
<span class="sig-name descname"><span class="pre">notify_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>唤醒所有正在等待此条件的任务。</p>
<p>此方法的行为类似于 <a class="reference internal" href="#asyncio.Condition.notify" title="asyncio.Condition.notify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify()</span></code></a>，但会唤醒所有正在等待的任务。</p>
<p>锁必须在此方法被调用前被获取并在随后被快速释放。 如果通过一个 <em>unlocked</em> 锁调用则会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>释放下层的锁。</p>
<p>当在未锁定的锁上发起调用时，会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.wait">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>等待直至收到通知。</p>
<p>当此方法被调用时如果调用方任务未获得锁，则会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
<p>这个方法会释放下层的锁，然后保持阻塞直到被 <a class="reference internal" href="#asyncio.Condition.notify" title="asyncio.Condition.notify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify()</span></code></a> 或 <a class="reference internal" href="#asyncio.Condition.notify_all" title="asyncio.Condition.notify_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify_all()</span></code></a> 调用所唤醒。 一旦被唤醒，Condition 会重新获取它的锁并且此方法将返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Condition.wait_for">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等待直到目标值变为 <em>true</em>。</p>
<p>The predicate must be a callable which result will be
interpreted as a boolean value.  The final value is the
return value.</p>
</dd></dl>

</dd></dl>

</section>
<section id="semaphore">
<h2>Semaphore</h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Semaphore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Semaphore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>信号量对象。 该对象不是线程安全的。</p>
<p>信号量会管理一个内部计数器，该计数器会随每次 <a class="reference internal" href="#asyncio.Semaphore.acquire" title="asyncio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> 调用递减并随每次 <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> 调用递增。 计数器的值永远不会降到零以下；当 <a class="reference internal" href="#asyncio.Semaphore.acquire" title="asyncio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> 发现其值为零时，它将保持阻塞直到有某个任务调用了 <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a>。</p>
<p>可选的 <em>value</em> 参数用来为内部计数器赋初始值 (默认值为 <code class="docutils literal notranslate"><span class="pre">1</span></code>)。 如果给定的值小于 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>移除了 <em>loop</em> 形参。</p>
</div>
<p>使用 Semaphore 的推荐方式是通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 语句。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sem</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># ... later</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">sem</span><span class="p">:</span>
    <span class="c1"># work with shared resource</span>
</pre></div>
</div>
<p>这等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sem</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># ... later</span>
<span class="k">await</span> <span class="n">sem</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># work with shared resource</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Semaphore.acquire">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>获取一个信号量。</p>
<p>如果内部计数器的值大于零，则将其减一并立即返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 如果其值为零，则会等待直到 <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> 并调用并返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Semaphore.locked">
<span class="sig-name descname"><span class="pre">locked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>如果信号量对象无法被立即获取则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Semaphore.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>释放一个信号量对象，将内部计数器的值加一。 可以唤醒一个正在等待获取信号量对象的任务。</p>
<p>不同于 <a class="reference internal" href="#asyncio.BoundedSemaphore" title="asyncio.BoundedSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundedSemaphore</span></code></a>，<a class="reference internal" href="#asyncio.Semaphore" title="asyncio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> 允许执行的 <code class="docutils literal notranslate"><span class="pre">release()</span></code> 调用多于 <code class="docutils literal notranslate"><span class="pre">acquire()</span></code> 调用。</p>
</dd></dl>

</dd></dl>

</section>
<section id="boundedsemaphore">
<h2>BoundedSemaphore</h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.BoundedSemaphore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">BoundedSemaphore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>绑定的信号量对象。 该对象不是线程安全的。</p>
<p>BoundedSemaphore 是特殊版本的 <a class="reference internal" href="#asyncio.Semaphore" title="asyncio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a>，如果在 <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> 中内部计数器值增加到初始 <em>value</em> 以上它将引发一个 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>移除了 <em>loop</em> 形参。</p>
</div>
</dd></dl>

</section>
<section id="barrier">
<h2>Barrier</h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Barrier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Barrier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parties</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>屏障对象。 该对象不是线程安全的。</p>
<p>屏障是一个允许阻塞直到 <em>parties</em> 个任务在其上等待的简单同步原语。 任务可以在 <a class="reference internal" href="#asyncio.Barrier.wait" title="asyncio.Barrier.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 方法上等待并将被阻塞直到有指定数量的任务在 <a class="reference internal" href="#asyncio.Barrier.wait" title="asyncio.Barrier.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 上等待。 在那时所有正在等待的任务将同时撤销阻塞。</p>
<p><a class="reference internal" href="../reference/compound_stmts.xhtml#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 可以被用作在 <a class="reference internal" href="#asyncio.Barrier.wait" title="asyncio.Barrier.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 上等待的替代。</p>
<p>屏障可被重复使用任意次数。</p>
<p id="asyncio-example-barrier">示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">example_barrier</span><span class="p">():</span>
   <span class="c1"># barrier with 3 parties</span>
   <span class="n">b</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Barrier</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

   <span class="c1"># create 2 new waiting tasks</span>
   <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">wait</span><span class="p">())</span>
   <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">wait</span><span class="p">())</span>

   <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

   <span class="c1"># The third .wait() call passes the barrier</span>
   <span class="k">await</span> <span class="n">b</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;barrier passed&quot;</span><span class="p">)</span>

   <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">example_barrier</span><span class="p">())</span>
</pre></div>
</div>
<p>该示例的结果为:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">asyncio</span><span class="o">.</span><span class="n">locks</span><span class="o">.</span><span class="n">Barrier</span> <span class="nb">object</span> <span class="n">at</span> <span class="mi">0</span><span class="n">x</span><span class="o">...</span> <span class="p">[</span><span class="n">filling</span><span class="p">,</span> <span class="n">waiters</span><span class="p">:</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">asyncio</span><span class="o">.</span><span class="n">locks</span><span class="o">.</span><span class="n">Barrier</span> <span class="nb">object</span> <span class="n">at</span> <span class="mi">0</span><span class="n">x</span><span class="o">...</span> <span class="p">[</span><span class="n">draining</span><span class="p">,</span> <span class="n">waiters</span><span class="p">:</span><span class="mi">0</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span>
<span class="n">barrier</span> <span class="n">passed</span>
<span class="o">&lt;</span><span class="n">asyncio</span><span class="o">.</span><span class="n">locks</span><span class="o">.</span><span class="n">Barrier</span> <span class="nb">object</span> <span class="n">at</span> <span class="mi">0</span><span class="n">x</span><span class="o">...</span> <span class="p">[</span><span class="n">filling</span><span class="p">,</span> <span class="n">waiters</span><span class="p">:</span><span class="mi">0</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Barrier.wait">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>穿过屏障。 当屏障汇集的所有任务都调用了此函数时，它们将被同时撤销阻塞。</p>
<p>当该屏障中等待或阻塞的任务被取消时，此任务将退出屏障而屏障将保持相同状态。 如果屏障的状态为 &quot;正在填充&quot;，则等待的任务数量将减 1。</p>
<p>返回值是一个 0 到 <code class="docutils literal notranslate"><span class="pre">parties-1</span></code> 之间的整数，对于每个任务来说各不相同。 这可被用来选择一个任务以执行某些特别的操作。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">barrier</span> <span class="k">as</span> <span class="n">position</span><span class="p">:</span>
   <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># Only one task prints this</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;End of *draining phase*&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果屏障在有任务在等待时已被破坏或重置则此方法可能会引发 <a class="reference internal" href="#asyncio.BrokenBarrierError" title="asyncio.BrokenBarrierError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a>。 如果有任务被取消则它可能会引发 <a class="reference internal" href="asyncio-exceptions.xhtml#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Barrier.reset">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>将屏障返回为默认的空白状态。 任何正在其上等待的任务将会接收到 <a class="reference internal" href="#asyncio.BrokenBarrierError" title="asyncio.BrokenBarrierError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a> 异常。</p>
<p>如果屏障已被破坏则最好的是让其保持原状并创建一个新的屏障。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Barrier.abort">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">abort</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>使屏障处于已破坏状态。 这会导致任何现有和未来对 <a class="reference internal" href="asyncio-task.xhtml#asyncio.wait" title="asyncio.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 的调用失败并引发 <a class="reference internal" href="#asyncio.BrokenBarrierError" title="asyncio.BrokenBarrierError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a>。 例如可以在需要中止某个任务时使用此方法，以避免任务无限等待。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Barrier.parties">
<span class="sig-name descname"><span class="pre">parties</span></span></dt>
<dd><p>请求穿过该屏障的任务的数量。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Barrier.n_waiting">
<span class="sig-name descname"><span class="pre">n_waiting</span></span></dt>
<dd><p>当执行填充时正在屏障中等待的任务的数量。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Barrier.broken">
<span class="sig-name descname"><span class="pre">broken</span></span></dt>
<dd><p>一个布尔值，值为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 表明栅栏为破损态。</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="asyncio.BrokenBarrierError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">BrokenBarrierError</span></span></dt>
<dd><p>异常类，是 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 异常的子类，在 <a class="reference internal" href="#asyncio.Barrier" title="asyncio.Barrier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Barrier</span></code></a> 对象重置时仍有线程阻塞时和对象进入破损态时被引发。</p>
</dd></dl>

<hr class="docutils" />
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>使用 <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">lock</span></code> 或 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">lock</span></code> 以及/或者 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句 (<code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">await</span> <span class="pre">lock</span></code>, <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">(yield</span> <span class="pre">from</span> <span class="pre">lock)</span></code>) 来获取锁的操作已被移除。 请改用 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span> <span class="pre">lock</span></code>。</p>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>