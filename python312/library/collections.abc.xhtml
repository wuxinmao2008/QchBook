<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="collections.abc --- 容器的抽象基类" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/collections.abc.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/_collections_abc.py[https://github.com/python/cpython/tree/3.12/Lib/_collections_abc.py] 本模块提供了一些 抽象基类 ，它们可被用于测试一个类是否提供某个特定的接口；例如，它是否为 hashable 或是否为 mapping 等。 一个接口的 issubclass() 或 isinsta..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/_collections_abc.py[https://github.com/python/cpython/tree/3.12/Lib/_collections_abc.py] 本模块提供了一些 抽象基类 ，它们可被用于测试一个类是否提供某个特定的接口；例如，它是否为 hashable 或是否为 mapping 等。 一个接口的 issubclass() 或 isinsta..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>collections.abc --- 容器的抽象基类</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/collections.abc.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-collections.abc">
<span id="collections-abc-abstract-base-classes-for-containers"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> --- 容器的抽象基类</h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3: </span>该模块曾是 <a class="reference internal" href="collections.xhtml#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块的组成部分。</p>
</div>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/_collections_abc.py">Lib/_collections_abc.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/_collections_abc.py]</span></p>
<hr class="docutils" />
<p>本模块提供了一些 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">抽象基类</span></a>，它们可被用于测试一个类是否提供某个特定的接口；例如，它是否为 <a class="reference internal" href="../glossary.xhtml#term-hashable"><span class="xref std std-term">hashable</span></a> 或是否为 <a class="reference internal" href="../glossary.xhtml#term-mapping"><span class="xref std std-term">mapping</span></a> 等。</p>
<p>一个接口的 <a class="reference internal" href="functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 或 <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 测试采用以下三种方式之一。</p>
<p>1) A newly written class can inherit directly from one of the
abstract base classes.  The class must supply the required abstract
methods.  The remaining mixin methods come from inheritance and can be
overridden if desired.  Other methods may be added as needed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Sequence</span><span class="p">):</span>                      <span class="c1"># Direct inheritance</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>             <span class="c1"># Extra method not required by the ABC</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>  <span class="o">...</span>  <span class="c1"># Required abstract method</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="o">...</span>             <span class="c1"># Required abstract method</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="o">...</span>         <span class="c1"># Optionally override a mixin method</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">C</span><span class="p">(),</span> <span class="n">Sequence</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>2) Existing classes and built-in classes can be registered as &quot;virtual
subclasses&quot; of the ABCs.  Those classes should define the full API
including all of the abstract methods and all of the mixin methods.
This lets users rely on <a class="reference internal" href="functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> or <a class="reference internal" href="functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> tests
to determine whether the full interface is supported.  The exception to
this rule is for methods that are automatically inferred from the rest
of the API:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">:</span>                                 <span class="c1"># No inheritance</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>              <span class="c1"># Extra method not required by the ABC</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>  <span class="o">...</span>   <span class="c1"># Abstract method</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="o">...</span>              <span class="c1"># Abstract method</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="o">...</span>          <span class="c1"># Mixin method</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="o">...</span>          <span class="c1"># Mixin method</span>

<span class="n">Sequence</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>                     <span class="c1"># Register instead of inherit</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">D</span><span class="p">(),</span> <span class="n">Sequence</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>在这个例子中，<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code> 类不需要定义 <code class="docutils literal notranslate"><span class="pre">__contains__</span></code>, <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__reversed__</span></code>，因为 <a class="reference internal" href="../reference/expressions.xhtml#comparisons"><span class="std std-ref">in 运算符</span></a>, <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">迭代</span></a> 逻辑和 <a class="reference internal" href="functions.xhtml#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 函数会自动回退为使用 <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__len__</span></code>。</p>
<p>3) Some simple interfaces are directly recognizable by the presence of
the required methods (unless those methods have been set to
<a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">E</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">(),</span> <span class="n">Iterable</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>复杂的接口不支持最后这种技术手段因为接口并不只是作为方法名称存在。 接口指明了方法之间的语义和关系，这些是无法根据特定方法名称的存在推断出来的。 例如，知道一个类提供了 <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, <code class="docutils literal notranslate"><span class="pre">__len__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> 并不足以区分 <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 和 <a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9: </span>这些抽象类现在都支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。 参见 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a> 和 <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a><span class="link-target"> [https://peps.python.org/pep-0585/]</span>。</p>
</div>
<section id="collections-abstract-base-classes">
<span id="id1"></span><h2>容器抽象基类</h2>
<p>这个容器模块提供了以下 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">ABCs</span></a>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>抽象基类</p></th>
<th class="head"><p>继承自</p></th>
<th class="head"><p>抽象方法</p></th>
<th class="head"><p>Mixin 方法</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">Container</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hashable</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__hash__</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id19" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__iter__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__next__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__iter__</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">Reversible</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__reversed__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>  <a class="footnote-reference brackets" href="#id18" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">send</span></code>, <code class="docutils literal notranslate"><span class="pre">throw</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">close</span></code>, <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__next__</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sized</span></code></a>  <a class="footnote-reference brackets" href="#id18" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>  <a class="footnote-reference brackets" href="#id18" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__call__</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Collection</span></code></a>  <a class="footnote-reference brackets" href="#id18" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sized</span></code></a>,
<a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>,
<a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">Container</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">Reversible</span></code></a>,
<a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Collection</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>, <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__reversed__</span></code>,
<code class="docutils literal notranslate"><span class="pre">index</span></code>, and <code class="docutils literal notranslate"><span class="pre">count</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableSequence</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__delitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code>,
<code class="docutils literal notranslate"><span class="pre">insert</span></code></p></td>
<td><p>继承了 <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 的方法以及 <code class="docutils literal notranslate"><span class="pre">append</span></code>, <code class="docutils literal notranslate"><span class="pre">clear</span></code>, <code class="docutils literal notranslate"><span class="pre">reverse</span></code>, <code class="docutils literal notranslate"><span class="pre">extend</span></code>, <code class="docutils literal notranslate"><span class="pre">pop</span></code>, <code class="docutils literal notranslate"><span class="pre">remove</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__iadd__</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">ByteString</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td><p>继承自 <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 的方法</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Collection</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__le__</span></code>, <code class="docutils literal notranslate"><span class="pre">__lt__</span></code>, <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ne__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__gt__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ge__</span></code>, <code class="docutils literal notranslate"><span class="pre">__and__</span></code>, <code class="docutils literal notranslate"><span class="pre">__or__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__sub__</span></code>, <code class="docutils literal notranslate"><span class="pre">__xor__</span></code>, and <code class="docutils literal notranslate"><span class="pre">isdisjoint</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableSet</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code>,
<code class="docutils literal notranslate"><span class="pre">add</span></code>,
<code class="docutils literal notranslate"><span class="pre">discard</span></code></p></td>
<td><p>继承自 <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a> 的方法以及 <code class="docutils literal notranslate"><span class="pre">clear</span></code>, <code class="docutils literal notranslate"><span class="pre">pop</span></code>, <code class="docutils literal notranslate"><span class="pre">remove</span></code>, <code class="docutils literal notranslate"><span class="pre">__ior__</span></code>, <code class="docutils literal notranslate"><span class="pre">__iand__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ixor__</span></code>，和  <code class="docutils literal notranslate"><span class="pre">__isub__</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Collection</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>, <code class="docutils literal notranslate"><span class="pre">keys</span></code>, <code class="docutils literal notranslate"><span class="pre">items</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code>,
<code class="docutils literal notranslate"><span class="pre">get</span></code>, <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ne__</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__delitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
<td><p>继承自 <a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 的方法以及 <code class="docutils literal notranslate"><span class="pre">pop</span></code>, <code class="docutils literal notranslate"><span class="pre">popitem</span></code>, <code class="docutils literal notranslate"><span class="pre">clear</span></code>, <code class="docutils literal notranslate"><span class="pre">update</span></code>，和 <code class="docutils literal notranslate"><span class="pre">setdefault</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">MappingView</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sized</span></code></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__len__</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">ItemsView</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">MappingView</span></code></a>,
<a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeysView</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">MappingView</span></code></a>,
<a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValuesView</span></code></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">MappingView</span></code></a>,
<a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Collection</span></code></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__contains__</span></code>, <code class="docutils literal notranslate"><span class="pre">__iter__</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Awaitable</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__await__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Awaitable</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">send</span></code>, <code class="docutils literal notranslate"><span class="pre">throw</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">close</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterable</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterator</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterable</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncGenerator</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterator</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">asend</span></code>, <code class="docutils literal notranslate"><span class="pre">athrow</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">aclose</span></code>, <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a> <a class="footnote-reference brackets" href="#id18" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__buffer__</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id4">3</a>,<a role="doc-backlink" href="#id6">4</a>,<a role="doc-backlink" href="#id7">5</a>,<a role="doc-backlink" href="#id8">6</a>,<a role="doc-backlink" href="#id9">7</a>,<a role="doc-backlink" href="#id10">8</a>,<a role="doc-backlink" href="#id11">9</a>,<a role="doc-backlink" href="#id12">10</a>,<a role="doc-backlink" href="#id13">11</a>,<a role="doc-backlink" href="#id14">12</a>,<a role="doc-backlink" href="#id15">13</a>,<a role="doc-backlink" href="#id16">14</a>,<a role="doc-backlink" href="#id17">15</a>)</span>
<p>这些 ABC 重写了 <a class="reference internal" href="abc.xhtml#abc.ABCMeta.__subclasshook__" title="abc.ABCMeta.__subclasshook__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasshook__()</span></code></a> 以便支持通过验证所需的方法是否存在并且没有被设为 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 来测试一个接口。 这只适用于简单的接口。 更复杂的接口需要注册或者直接子类化。</p>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">2</a><span class="fn-bracket">]</span></span>
<p>检查 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">Iterable)</span></code> 是否侦测到被注册为 <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 或者具有 <a class="reference internal" href="stdtypes.xhtml#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法的类，但它不能侦测到使用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法进行迭代的类。 确定一个对象是否为 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a> 的唯一可靠方式是调用 <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code>。</p>
</aside>
</aside>
</section>
<section id="collections-abstract-base-classes-detailed-descriptions">
<h2>多项集抽象基类 -- 详细描述</h2>
<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Container">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Container</span></span></dt>
<dd><p>提供了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 方法的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Hashable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Hashable</span></span></dt>
<dd><p>提供了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Sized">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Sized</span></span></dt>
<dd><p>用于提供 <a class="reference internal" href="../reference/datamodel.xhtml#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 方法的类的 ABC</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Callable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Callable</span></span></dt>
<dd><p>用于提供 <a class="reference internal" href="../reference/datamodel.xhtml#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法的类的 ABC</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Iterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Iterable</span></span></dt>
<dd><p>用于提供 <a class="reference internal" href="stdtypes.xhtml#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法的类的 ABC</p>
<p>检查 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">Iterable)</span></code> 是否侦测到被注册为 <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 或者具有 <a class="reference internal" href="stdtypes.xhtml#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法的类，但它不能侦测到使用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法进行迭代的类。 确定一个对象是否为 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a> 的唯一可靠方式是调用 <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span></dt>
<dd><p>集合了 Sized 和 Iterable 类的抽象基类。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Iterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Iterator</span></span></dt>
<dd><p>提供了 <a class="reference internal" href="stdtypes.xhtml#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法的抽象基类。参见 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 的定义。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Reversible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Reversible</span></span></dt>
<dd><p>用于同时提供了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 方法的可迭代类的 ABC</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Generator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Generator</span></span></dt>
<dd><p>用于实现了 <span class="target" id="index-13"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a><span class="link-target"> [https://peps.python.org/pep-0342/]</span> 中定义的协议的 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">generator</span></a> 类的 ABC，它通过 <a class="reference internal" href="../reference/expressions.xhtml#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, <a class="reference internal" href="../reference/expressions.xhtml#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 和 <a class="reference internal" href="../reference/expressions.xhtml#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法对 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">迭代器</span></a> 进行了扩展。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.MutableSequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">MutableSequence</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.ByteString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">ByteString</span></span></dt>
<dd><p>只读的与可变的 <a class="reference internal" href="../glossary.xhtml#term-sequence"><span class="xref std std-term">序列</span></a> 的抽象基类。</p>
<p>实现注意事项：某些混入方法，如 <a class="reference internal" href="stdtypes.xhtml#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.xhtml#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>，会重复调用下层的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法。 因此，如果 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 被实现为常数级访问速度，则混入方法的性能将为线性级；但是，如果下层的方法是线性的（例如链表就是如此），则混入方法的性能将为平方级并可能需要被重写。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>index() 方法支持 <em>stop</em> 和 <em>start</em> 参数。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.12 版起不建议使用，将在 3.14 版中移除: </span><a class="reference internal" href="#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">ByteString</span></code></a> ABC 已被弃用。 当用于类型标注时，建议改为并集形式，如 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">|</span> <span class="pre">bytearray</span></code>，或 <a class="reference internal" href="#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a>。 当用作 ABC 时，建议改为 <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 或 <a class="reference internal" href="#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Set</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.MutableSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">MutableSet</span></span></dt>
<dd><p>用于只读和可变 <a class="reference internal" href="stdtypes.xhtml#types-set"><span class="std std-ref">集合</span></a> 的 ABC。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Mapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.MutableMapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">MutableMapping</span></span></dt>
<dd><p>只读的与可变的 <a class="reference internal" href="../glossary.xhtml#term-mapping"><span class="xref std std-term">映射</span></a> 的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.MappingView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">MappingView</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.ItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">ItemsView</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.KeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">KeysView</span></span></dt>
<dt class="sig sig-object py" id="collections.abc.ValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">ValuesView</span></span></dt>
<dd><p>映射及其键和值的 <a class="reference internal" href="../glossary.xhtml#term-dictionary-view"><span class="xref std std-term">视图</span></a> 的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Awaitable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Awaitable</span></span></dt>
<dd><p>针对 <a class="reference internal" href="../glossary.xhtml#term-awaitable"><span class="xref std std-term">awaitable</span></a> 对象的 ABC，它可被用于 <a class="reference internal" href="../reference/expressions.xhtml#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 表达式。 根据惯例所有实现都必须提供 <a class="reference internal" href="../reference/datamodel.xhtml#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 方法。</p>
<p><a class="reference internal" href="../glossary.xhtml#term-coroutine"><span class="xref std std-term">协程</span></a> 对象和 <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine</span></code></a> ABC 的实例都是这个 ABC 的实例。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 CPython 中，基于生成器的协程 (使用 <a class="reference internal" href="types.xhtml#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;types.coroutine</span></code></a> 装饰的 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">生成器</span></a>) 都是 <em>可等待对象</em>，即使它们没有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 方法。 对它们使用 <code class="docutils literal notranslate"><span class="pre">isinstance(gencoro,</span> <span class="pre">Awaitable)</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 请使用 <a class="reference internal" href="inspect.xhtml#inspect.isawaitable" title="inspect.isawaitable"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.isawaitable()</span></code></a> 来检测它们。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Coroutine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Coroutine</span></span></dt>
<dd><p>用于 <a class="reference internal" href="../glossary.xhtml#term-coroutine"><span class="xref std std-term">coroutine</span></a> 兼容类的 ABC。 实现了如下定义在 <a class="reference internal" href="../reference/datamodel.xhtml#coroutine-objects"><span class="std std-ref">协程对象</span></a> 里的方法: <a class="reference internal" href="../reference/datamodel.xhtml#coroutine.send" title="coroutine.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, <a class="reference internal" href="../reference/datamodel.xhtml#coroutine.throw" title="coroutine.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#coroutine.close" title="coroutine.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>。 根据惯例所有实现都还需要实现 <a class="reference internal" href="../reference/datamodel.xhtml#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>。 所有的 <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine</span></code></a> 实例同时也是 <a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Awaitable</span></code></a> 的实例。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 CPython 中，基于生成器的协程 (使用 <a class="reference internal" href="types.xhtml#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;types.coroutine</span></code></a> 装饰的 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">生成器</span></a>) 都是 <em>可等待对象</em>，即使它们没有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> 方法。 对它们使用 <code class="docutils literal notranslate"><span class="pre">isinstance(gencoro,</span> <span class="pre">Coroutine)</span></code> 将返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 请使用 <a class="reference internal" href="inspect.xhtml#inspect.isawaitable" title="inspect.isawaitable"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.isawaitable()</span></code></a> 来检测它们。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.AsyncIterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">AsyncIterable</span></span></dt>
<dd><p>针对提供了 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 方法的类的 ABC。 另请参阅 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterable"><span class="xref std std-term">asynchronous iterable</span></a> 的定义。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.AsyncIterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">AsyncIterator</span></span></dt>
<dd><p>提供了 <code class="docutils literal notranslate"><span class="pre">__aiter__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 方法的抽象基类。参见 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 的定义。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.AsyncGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">AsyncGenerator</span></span></dt>
<dd><p>针对实现了在 <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a><span class="link-target"> [https://peps.python.org/pep-0525/]</span> 和 <span class="target" id="index-15"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a><span class="link-target"> [https://peps.python.org/pep-0492/]</span> 中定义的协议的 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> 类的 ABC。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="collections.abc.Buffer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">collections.abc.</span></span><span class="sig-name descname"><span class="pre">Buffer</span></span></dt>
<dd><p>针对提供 <a class="reference internal" href="../reference/datamodel.xhtml#object.__buffer__" title="object.__buffer__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__buffer__()</span></code></a> 方法的类的 ABC，实现了 <a class="reference internal" href="../c-api/buffer.xhtml#bufferobjects"><span class="std std-ref">缓冲区协议</span></a>。 参见 <span class="target" id="index-16"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/"><strong>PEP 688</strong></a><span class="link-target"> [https://peps.python.org/pep-0688/]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

</section>
<section id="examples-and-recipes">
<h2>例子和配方</h2>
<p>ABC 允许我们询问类或实例是否提供特定的功能，例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">size</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">myvar</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">myvar</span><span class="p">)</span>
</pre></div>
</div>
<p>有些 ABC 还适用于作为混入类，这可以更容易地开发支持容器 API 的类。 例如，要写一个支持完整 <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a> API 的类，只需要提供三个下层抽象方法: <a class="reference internal" href="../reference/datamodel.xhtml#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="stdtypes.xhtml#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>。 ABC 会提供其余的方法如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code> 和 <a class="reference internal" href="stdtypes.xhtml#frozenset.isdisjoint" title="frozenset.isdisjoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isdisjoint()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListBasedSet</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Alternate set implementation favoring space over speed</span>
<span class="sd">        and not requiring the set elements to be hashable. &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">ListBasedSet</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">ListBasedSet</span><span class="p">(</span><span class="s1">&#39;defghi&#39;</span><span class="p">)</span>
<span class="n">overlap</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">&amp;</span> <span class="n">s2</span>            <span class="c1"># The __and__() method is supported automatically</span>
</pre></div>
</div>
<p>当把 <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a> 和 <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableSet</span></code></a> 用作混入类时需注意：</p>
<ol class="arabic simple">
<li><p>由于某些集合操作会创建新的集合，默认的混入方法需要一种根据 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a> 创建新实例的方式。 类构造器应当具有 <code class="docutils literal notranslate"><span class="pre">ClassName(iterable)</span></code> 形式的签名。 这样它将被重构为一个执行 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_from_iterable()</span></code> 的内部 <a class="reference internal" href="functions.xhtml#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>，该方法会调用 <code class="docutils literal notranslate"><span class="pre">cls(iterable)</span></code> 来产生一个新的集合。 如果 <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a> 混入类在具有不同构造器签名的类中被使用，你将需要通过一个能根据可迭代对象参数构造新实例的类方法或常规方法来重写 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_from_iterable()</span></code>。</p></li>
<li><p>要重写比较运算（应该是为了提高速度，因为其语义是固定的），请重新定义 <a class="reference internal" href="../reference/datamodel.xhtml#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a>，然后其他运算将自动跟进。</p></li>
<li><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code></a> 混入类提供了一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_hash()</span></code> 方法为集合计算哈希值；但是，<a class="reference internal" href="../reference/datamodel.xhtml#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 没有被定义因为并非所有集合都是 <a class="reference internal" href="../glossary.xhtml#term-hashable"><span class="xref std std-term">hashable</span></a> 或不可变对象。 要使用混入类为集合添加可哈希性，请同时继承 <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Set()</span></code></a> 和 <a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Hashable()</span></code></a>，然后定义 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">Set._hash</span></code>。</p></li>
</ol>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><a class="reference external" href="https://code.activestate.com/recipes/576694/">OrderedSet recipe</a><span class="link-target"> [https://code.activestate.com/recipes/576694/]</span> 是基于 <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableSet</span></code></a> 构建的一个示例。</p></li>
<li><p>对于抽象基类，参见 <a class="reference internal" href="abc.xhtml#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 模块和 <span class="target" id="index-17"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a><span class="link-target"> [https://peps.python.org/pep-3119/]</span>。</p></li>
</ul>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>