<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="copy --- 浅复制和深复制操作" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/copy.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/copy.py[https://github.com/python/cpython/tree/3.12/Lib/copy.py] Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。 接口摘要： 浅层与深层复制的区别仅与复合..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码: Lib/copy.py[https://github.com/python/cpython/tree/3.12/Lib/copy.py] Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。 接口摘要： 浅层与深层复制的区别仅与复合..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>copy --- 浅复制和深复制操作</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/copy.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-copy">
<span id="copy-shallow-and-deep-copy-operations"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code> --- 浅复制和深复制操作</h1>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/copy.py">Lib/copy.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/copy.py]</span></p>
<hr class="docutils" />
<p>Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。</p>
<p>接口摘要：</p>
<dl class="py function">
<dt class="sig sig-object py" id="copy.copy">
<span class="sig-prename descclassname"><span class="pre">copy.</span></span><span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的浅复制。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="copy.deepcopy">
<span class="sig-prename descclassname"><span class="pre">copy.</span></span><span class="sig-name descname"><span class="pre">deepcopy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的深复制。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="copy.Error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">copy.</span></span><span class="sig-name descname"><span class="pre">Error</span></span></dt>
<dd><p>针对模块特定错误引发。</p>
</dd></dl>

<p id="shallow-vs-deep-copy">浅层与深层复制的区别仅与复合对象（即包含列表或类的实例等其他对象的对象）相关：</p>
<ul class="simple">
<li><p><em>浅层复制</em> 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 <em>引用</em> 插入其中。</p></li>
<li><p><em>深层复制</em> 构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 <em>副本</em> 插入其中。</p></li>
</ul>
<p>深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：</p>
<ul class="simple">
<li><p>递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。</p></li>
<li><p>由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。</p></li>
</ul>
<p><a class="reference internal" href="#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">deepcopy()</span></code></a> 函数用以下方式避免了这些问题：</p>
<ul class="simple">
<li><p>保留在当前复制过程中已复制的对象的 &quot;备忘录&quot; （<code class="docutils literal notranslate"><span class="pre">memo</span></code>） 字典；以及</p></li>
<li><p>允许用户定义的类重写复制操作或复制的组件集合。</p></li>
</ul>
<p>此模块不会复制模块、方法、栈追踪、栈帧、文件、套接字、窗口以及任何相似的类型。 它会通过不加修改地返回原始对象来（浅层或深层地）“复制”函数和类；这与 <a class="reference internal" href="pickle.xhtml#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模块处理这类问题的方式是兼容的。</p>
<p>制作字典的浅层复制可以使用 <a class="reference internal" href="stdtypes.xhtml#dict.copy" title="dict.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.copy()</span></code></a> 方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如，<code class="docutils literal notranslate"><span class="pre">copied_list</span> <span class="pre">=</span> <span class="pre">original_list[:]</span></code>。</p>
<p id="index-0">类可以使用与控制序列化（pickling）操作相同的接口来控制复制操作，关于这些方法的描述信息请参考 <a class="reference internal" href="pickle.xhtml#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模块。实际上，<a class="reference internal" href="#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> 模块使用的正是从 <a class="reference internal" href="copyreg.xhtml#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 模块中注册的 pickle 函数。</p>
<p id="index-1">为了让一个类定义其自己的复制实现，它可以定义特殊方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__copy__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__deepcopy__()</span></code>。 前者用于实现浅复制操作，后者用于实现深复制操作，它接受一个参数，即 <code class="docutils literal notranslate"><span class="pre">memo</span></code> 字典。 如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__deepcopy__()</span></code> 实现需要对某个组件进行深复制，它应该调用 <a class="reference internal" href="#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">deepcopy()</span></code></a> 函数，组件作为第一个参数，memo 字典作为第二个参数。 memo 字典应被视为不透明对象。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt>模块 <a class="reference internal" href="pickle.xhtml#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a></dt><dd><p>讨论了支持对象状态检索和恢复的特殊方法。</p>
</dd>
</dl>
</div>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>