<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="低层级 API 索引" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/asyncio-llapi-index.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="本页列出所有低层级的 asyncio API。 获取事件循环:,, asyncio.get_running_loop(), 获取当前运行的事件循环 首选 函数。,, asyncio.get_event_loop(), 获取一个事件循环实例（正在运行的事件循环或通过当前策略确定的当前事件循环）。,, asyncio.set_event_loop(), 通过当前策略将事件循环设置当前事件循环。,..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="本页列出所有低层级的 asyncio API。 获取事件循环:,, asyncio.get_running_loop(), 获取当前运行的事件循环 首选 函数。,, asyncio.get_event_loop(), 获取一个事件循环实例（正在运行的事件循环或通过当前策略确定的当前事件循环）。,, asyncio.set_event_loop(), 通过当前策略将事件循环设置当前事件循环。,..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>低层级 API 索引</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-llapi-index.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="low-level-api-index">
<h1>低层级 API 索引</h1>
<p>本页列出所有低层级的 asyncio API。</p>
<section id="obtaining-the-event-loop">
<h2>获取事件循环</h2>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.get_running_loop()</span></code></a></p></td>
<td><p>获取当前运行的事件循环 <strong>首选</strong> 函数。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.get_event_loop()</span></code></a></p></td>
<td><p>获取一个事件循环实例（正在运行的事件循环或通过当前策略确定的当前事件循环）。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.set_event_loop()</span></code></a></p></td>
<td><p>通过当前策略将事件循环设置当前事件循环。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.new_event_loop()</span></code></a></p></td>
<td><p>创建一个新的事件循环。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">例子</p>
<ul class="simple">
<li><p><a class="reference internal" href="asyncio-future.xhtml#asyncio-example-future"><span class="std std-ref">使用asyncio.get_running_loop()</span></a>。</p></li>
</ul>
</section>
<section id="event-loop-methods">
<h2>事件循环方法集</h2>
<p>另请参阅有关 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio-event-loop-methods"><span class="std std-ref">事件循环方法集</span></a> 的主文档章节。</p>
<p class="rubric">生命周期</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_until_complete()</span></code></a></p></td>
<td><p>运行一个期程/任务/可等待对象直到完成。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a></p></td>
<td><p>一直运行事件循环。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.stop()</span></code></a></p></td>
<td><p>停止事件循环。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.close" title="asyncio.loop.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.close()</span></code></a></p></td>
<td><p>关闭事件循环。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.is_running" title="asyncio.loop.is_running"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.is_running()</span></code></a></p></td>
<td><p>返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ， 如果事件循环正在运行。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.is_closed" title="asyncio.loop.is_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.is_closed()</span></code></a></p></td>
<td><p>返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，如果事件循环已经被关闭 。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.shutdown_asyncgens" title="asyncio.loop.shutdown_asyncgens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.shutdown_asyncgens()</span></code></a></p></td>
<td><p>关闭异步生成器。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">调试</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.set_debug" title="asyncio.loop.set_debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_debug()</span></code></a></p></td>
<td><p>开启或禁用调试模式。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.get_debug" title="asyncio.loop.get_debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.get_debug()</span></code></a></p></td>
<td><p>获取当前测试模式。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">调度回调函数</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a></p></td>
<td><p>尽快调用回调。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a></p></td>
<td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 方法线程安全的变体。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a></p></td>
<td><p>在给定时间 <em>之后</em> 调用回调函数。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a></p></td>
<td><p>在 <em>指定</em> 时间调用回调函数。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">线程/进程池</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a></p></td>
<td><p>在  <a class="reference internal" href="concurrent.futures.xhtml#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> 执行器中运行一个独占CPU或其它阻塞函数。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.set_default_executor" title="asyncio.loop.set_default_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_default_executor()</span></code></a></p></td>
<td><p>设置  <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> 默认执行器。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">任务与期程</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_future" title="asyncio.loop.create_future"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_future()</span></code></a></p></td>
<td><p>创建一个 <a class="reference internal" href="asyncio-future.xhtml#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> 对象。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a></p></td>
<td><p>将协程当作 <a class="reference internal" href="asyncio-task.xhtml#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 一样调度。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.set_task_factory" title="asyncio.loop.set_task_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_task_factory()</span></code></a></p></td>
<td><p>设置 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> 使用的工厂，它将用来创建  <a class="reference internal" href="asyncio-task.xhtml#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tasks</span></code></a>  。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.get_task_factory" title="asyncio.loop.get_task_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.get_task_factory()</span></code></a></p></td>
<td><p>获取 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> 使用的工厂，它用来创建  <a class="reference internal" href="asyncio-task.xhtml#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tasks</span></code></a>  。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">DNS</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a></p></td>
<td><p>异步版的 <a class="reference internal" href="socket.xhtml#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a> 。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.getnameinfo" title="asyncio.loop.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getnameinfo()</span></code></a></p></td>
<td><p>异步版的 <a class="reference internal" href="socket.xhtml#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a> 。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">网络和IPC</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a></p></td>
<td><p>打开一个TCP链接。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a></p></td>
<td><p>创建一个TCP服务。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a></p></td>
<td><p>打开一个Unix socket连接。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a></p></td>
<td><p>创建一个Unix socket服务。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.connect_accepted_socket" title="asyncio.loop.connect_accepted_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_accepted_socket()</span></code></a></p></td>
<td><p>将 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 包装成  <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 对。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a></p></td>
<td><p>打开一个数据报(UDP)连接。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sendfile" title="asyncio.loop.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sendfile()</span></code></a></p></td>
<td><p>通过传输通道发送一个文件。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.start_tls" title="asyncio.loop.start_tls"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.start_tls()</span></code></a></p></td>
<td><p>将一个已建立的链接升级到TLS。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_read_pipe()</span></code></a></p></td>
<td><p>将管道读取端包装成  <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 对。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_write_pipe()</span></code></a></p></td>
<td><p>将管道写入端包装成  <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 对。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">套接字</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_recv" title="asyncio.loop.sock_recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_recv()</span></code></a></p></td>
<td><p>从 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 接收数据。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_recv_into" title="asyncio.loop.sock_recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_recv_into()</span></code></a></p></td>
<td><p>从 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 接收数据到一个缓冲区中。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_recvfrom" title="asyncio.loop.sock_recvfrom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_recvfrom()</span></code></a></p></td>
<td><p>从 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 接收数据报。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_recvfrom_into" title="asyncio.loop.sock_recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_recvfrom_into()</span></code></a></p></td>
<td><p>从 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 接收数据报并放入缓冲区。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_sendall" title="asyncio.loop.sock_sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_sendall()</span></code></a></p></td>
<td><p>发送数据到 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_sendto" title="asyncio.loop.sock_sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_sendto()</span></code></a></p></td>
<td><p>通过 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 向给定的地址发送数据报。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_connect" title="asyncio.loop.sock_connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_connect()</span></code></a></p></td>
<td><p>链接 <code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_connect" title="asyncio.loop.sock_connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_connect()</span></code></a> 。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_accept" title="asyncio.loop.sock_accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_accept()</span></code></a></p></td>
<td><p>接受一个 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 链接。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">await</span></code> <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.sock_sendfile" title="asyncio.loop.sock_sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sock_sendfile()</span></code></a></p></td>
<td><p>利用 <a class="reference internal" href="socket.xhtml#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 发送一个文件。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a></p></td>
<td><p>开始对一个文件描述符的可读性的监视。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.remove_reader" title="asyncio.loop.remove_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.remove_reader()</span></code></a></p></td>
<td><p>停止对一个文件描述符的可读性的监视。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.add_writer" title="asyncio.loop.add_writer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_writer()</span></code></a></p></td>
<td><p>开始对一个文件描述符的可写性的监视。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.remove_writer" title="asyncio.loop.remove_writer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.remove_writer()</span></code></a></p></td>
<td><p>停止对一个文件描述符的可写性的监视。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Unix信号</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a></p></td>
<td><p>给 <a class="reference internal" href="signal.xhtml#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 添加一个处理回调函数。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.remove_signal_handler" title="asyncio.loop.remove_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.remove_signal_handler()</span></code></a></p></td>
<td><p>删除 <a class="reference internal" href="signal.xhtml#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 的处理回调函数。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">子进程集</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a></p></td>
<td><p>衍生一个子进程</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a></p></td>
<td><p>从终端命令衍生一个子进程。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">错误处理</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_exception_handler()</span></code></a></p></td>
<td><p>调用异常处理器。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_exception_handler()</span></code></a></p></td>
<td><p>设置一个新的异常处理器。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.get_exception_handler" title="asyncio.loop.get_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.get_exception_handler()</span></code></a></p></td>
<td><p>获取当前异常处理器。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.default_exception_handler" title="asyncio.loop.default_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.default_exception_handler()</span></code></a></p></td>
<td><p>默认异常处理器实现。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">例子</p>
<ul class="simple">
<li><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio-example-lowlevel-helloworld"><span class="std std-ref">使用 asyncio.new_event_loop() 和 loop.run_forever()</span></a>.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio-example-call-later"><span class="std std-ref">使用 loop.call_later()</span></a>.</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">loop.create_connection()</span></code> 实现 <a class="reference internal" href="asyncio-protocol.xhtml#asyncio-example-tcp-echo-client-protocol"><span class="std std-ref">echo客户端</span></a>.</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">loop.create_connection()</span></code> 去 <a class="reference internal" href="asyncio-protocol.xhtml#asyncio-example-create-connection"><span class="std std-ref">链接socket</span></a>.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio-example-watch-fd"><span class="std std-ref">使用add_reader()监听FD(文件描述符)的读取事件</span></a>.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.xhtml#asyncio-example-unix-signals"><span class="std std-ref">使用loop.add_signal_handler()</span></a>.</p></li>
<li><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio-example-subprocess-proto"><span class="std std-ref">使用loop.add_signal_handler()</span></a>。</p></li>
</ul>
</section>
<section id="transports">
<h2>传输</h2>
<p>所有传输都实现以下方法:</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.close()</span></code></a></p></td>
<td><p>关闭传输。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseTransport.is_closing" title="asyncio.BaseTransport.is_closing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.is_closing()</span></code></a></p></td>
<td><p>返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，如果传输正在关闭或已经关闭。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseTransport.get_extra_info" title="asyncio.BaseTransport.get_extra_info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_extra_info()</span></code></a></p></td>
<td><p>请求传输的相关信息。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseTransport.set_protocol" title="asyncio.BaseTransport.set_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.set_protocol()</span></code></a></p></td>
<td><p>设置一个新协议。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseTransport.get_protocol" title="asyncio.BaseTransport.get_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_protocol()</span></code></a></p></td>
<td><p>返回当前协议。</p></td>
</tr>
</tbody>
</table>
<p>传输可以接收数据(TCP和Unix链接，管道等)。它通过 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_read_pipe()</span></code></a> 等方法返回。</p>
<p class="rubric">读取传输</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.ReadTransport.is_reading" title="asyncio.ReadTransport.is_reading"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.is_reading()</span></code></a></p></td>
<td><p>返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，如果传输正在接收。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.ReadTransport.pause_reading" title="asyncio.ReadTransport.pause_reading"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.pause_reading()</span></code></a></p></td>
<td><p>暂停接收。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.ReadTransport.resume_reading" title="asyncio.ReadTransport.resume_reading"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.resume_reading()</span></code></a></p></td>
<td><p>继续接收。</p></td>
</tr>
</tbody>
</table>
<p>传输可以发送数据(TCP和Unix链接，管道等)。它通过 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_write_pipe()</span></code></a> 等方法返回。</p>
<p class="rubric">写入传输</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.write" title="asyncio.WriteTransport.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.write()</span></code></a></p></td>
<td><p>向传输写入数据。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.write" title="asyncio.WriteTransport.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.write()</span></code></a></p></td>
<td><p>向传输写入缓冲。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.can_write_eof" title="asyncio.WriteTransport.can_write_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.can_write_eof()</span></code></a></p></td>
<td><p>返回  <a class="reference internal" href="constants.xhtml#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> ，如果传输支持发送 EOF。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.write_eof" title="asyncio.WriteTransport.write_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.write_eof()</span></code></a></p></td>
<td><p>在冲洗已缓冲的数据后关闭传输和发送EOF。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.abort" title="asyncio.WriteTransport.abort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.abort()</span></code></a></p></td>
<td><p>立即关闭传输。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.get_write_buffer_size" title="asyncio.WriteTransport.get_write_buffer_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_write_buffer_size()</span></code></a></p></td>
<td><p>返回当前输出缓冲区的大小。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.get_write_buffer_limits" title="asyncio.WriteTransport.get_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_write_buffer_limits()</span></code></a></p></td>
<td><p>返回写入流控制的高位标记位和低位标记位。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.WriteTransport.set_write_buffer_limits" title="asyncio.WriteTransport.set_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.set_write_buffer_limits()</span></code></a></p></td>
<td><p>设置新的写入流控制的高位标记位和低位标记位。</p></td>
</tr>
</tbody>
</table>
<p>由 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> 返回的传输:</p>
<p class="rubric">数据报传输</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.DatagramTransport.sendto" title="asyncio.DatagramTransport.sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.sendto()</span></code></a></p></td>
<td><p>发送数据到远程链接端。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.DatagramTransport.abort" title="asyncio.DatagramTransport.abort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.abort()</span></code></a></p></td>
<td><p>立即关闭传输。</p></td>
</tr>
</tbody>
</table>
<p>基于子进程的底层抽象传输，它由 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> 和 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> 返回:</p>
<p class="rubric">子进程传输</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.get_pid" title="asyncio.SubprocessTransport.get_pid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_pid()</span></code></a></p></td>
<td><p>返回子进程的进程ID。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.get_pipe_transport" title="asyncio.SubprocessTransport.get_pipe_transport"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_pipe_transport()</span></code></a></p></td>
<td><p>返回请求通信管道 (<em>stdin</em>, <em>stdout</em>, 或 <em>stderr</em>)的传输。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.get_returncode" title="asyncio.SubprocessTransport.get_returncode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.get_returncode()</span></code></a></p></td>
<td><p>返回子进程的返回代号。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.kill" title="asyncio.SubprocessTransport.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.kill()</span></code></a></p></td>
<td><p>杀死子进程。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.send_signal" title="asyncio.SubprocessTransport.send_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.send_signal()</span></code></a></p></td>
<td><p>发送一个信号到子进程。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.terminate" title="asyncio.SubprocessTransport.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.terminate()</span></code></a></p></td>
<td><p>停止子进程。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessTransport.close" title="asyncio.SubprocessTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.close()</span></code></a></p></td>
<td><p>杀死子进程并关闭所有管道。</p></td>
</tr>
</tbody>
</table>
</section>
<section id="protocols">
<h2>协议</h2>
<p>协议类可以由下面 <strong>回调方法</strong> 实现：</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code></a></p></td>
<td><p>连接建立时被调用。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_lost()</span></code></a></p></td>
<td><p>连接丢失或关闭时将被调用。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a></p></td>
<td><p>传输的缓冲区超过高位标记位时被调用。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a></p></td>
<td><p>传输的缓冲区传送到低位标记位时被调用。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">流协议 (TCP, Unix 套接字, 管道)</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.Protocol.data_received" title="asyncio.Protocol.data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">data_received()</span></code></a></p></td>
<td><p>接收到数据时被调用。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eof_received()</span></code></a></p></td>
<td><p>接收到EOF时被调用。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">缓冲流协议</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BufferedProtocol.get_buffer" title="asyncio.BufferedProtocol.get_buffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_buffer()</span></code></a></p></td>
<td><p>调用后会分配新的接收缓冲区。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BufferedProtocol.buffer_updated" title="asyncio.BufferedProtocol.buffer_updated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">buffer_updated()</span></code></a></p></td>
<td><p>用接收的数据更新缓冲区时被调用。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.BufferedProtocol.eof_received" title="asyncio.BufferedProtocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eof_received()</span></code></a></p></td>
<td><p>接收到EOF时被调用。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">数据报协议</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.DatagramProtocol.datagram_received" title="asyncio.DatagramProtocol.datagram_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datagram_received()</span></code></a></p></td>
<td><p>接收到数据报时被调用。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.DatagramProtocol.error_received" title="asyncio.DatagramProtocol.error_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error_received()</span></code></a></p></td>
<td><p>前一个发送或接收操作引发  <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 时被调用。</p></td>
</tr>
</tbody>
</table>
<p class="rubric">子进程协议</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessProtocol.pipe_data_received" title="asyncio.SubprocessProtocol.pipe_data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe_data_received()</span></code></a></p></td>
<td><p>子进程向 <em>stdout</em> 或 <em>stderr</em> 管道写入数据时被调用。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessProtocol.pipe_connection_lost" title="asyncio.SubprocessProtocol.pipe_connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe_connection_lost()</span></code></a></p></td>
<td><p>与子进程通信的其中一个管道关闭时被调用。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">callback</span></code> <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessProtocol.process_exited" title="asyncio.SubprocessProtocol.process_exited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process_exited()</span></code></a></p></td>
<td><p>当子进程退出时被调用。 可在 <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessProtocol.pipe_data_received" title="asyncio.SubprocessProtocol.pipe_data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe_data_received()</span></code></a> 和 <a class="reference internal" href="asyncio-protocol.xhtml#asyncio.SubprocessProtocol.pipe_connection_lost" title="asyncio.SubprocessProtocol.pipe_connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe_connection_lost()</span></code></a> 方法之前被调用。</p></td>
</tr>
</tbody>
</table>
</section>
<section id="event-loop-policies">
<h2>事件循环策略</h2>
<p>策略是改变 <a class="reference internal" href="asyncio-eventloop.xhtml#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.get_event_loop()</span></code></a> 这类函数行为的一个底层机制。更多细节可以查阅 <a class="reference internal" href="asyncio-policy.xhtml#asyncio-policies"><span class="std std-ref">策略部分</span></a>。</p>
<p class="rubric">访问策略</p>
<table class="full-width-table docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-policy.xhtml#asyncio.get_event_loop_policy" title="asyncio.get_event_loop_policy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.get_event_loop_policy()</span></code></a></p></td>
<td><p>返回当前进程域的策略。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="asyncio-policy.xhtml#asyncio.set_event_loop_policy" title="asyncio.set_event_loop_policy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.set_event_loop_policy()</span></code></a></p></td>
<td><p>设置一个新的进程域策略。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="asyncio-policy.xhtml#asyncio.AbstractEventLoopPolicy" title="asyncio.AbstractEventLoopPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractEventLoopPolicy</span></code></a></p></td>
<td><p>策略对象的基类。</p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>