<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="re --- 正则表达式操作" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/re.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/re/[https://github.com/python/cpython/tree/3.12/Lib/re/] 本模块提供了与 Perl 语言类似的正则表达式匹配操作。 模式和被搜索的字符串即可以是 Unicode 字符串 ( str)，也可以是 8 位字节串 ( bytes)。 但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能将 Unicode 字符..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码: Lib/re/[https://github.com/python/cpython/tree/3.12/Lib/re/] 本模块提供了与 Perl 语言类似的正则表达式匹配操作。 模式和被搜索的字符串即可以是 Unicode 字符串 ( str)，也可以是 8 位字节串 ( bytes)。 但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能将 Unicode 字符..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>re --- 正则表达式操作</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/re.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-re">
<span id="re-regular-expression-operations"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> --- 正则表达式操作</h1>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/re/">Lib/re/</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/re/]</span></p>
<hr class="docutils" />
<p>本模块提供了与 Perl 语言类似的正则表达式匹配操作。</p>
<p>模式和被搜索的字符串即可以是 Unicode 字符串 (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>)，也可以是 8 位字节串 (<a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)。 但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能将 Unicode 字符串与字节串模式进行匹配，反之亦然；同样地，在执行替换时，替换字串的类型也必须与所用的模式和搜索字串的类型一致。</p>
<p>正则表达式使用反斜杠字符 (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) 表示特殊形式或是允许在使用特殊字符时不引发它们的特殊含义。 这会与 Python 在字符串字面值中对于相同字符出于相同目的规定的用法发生冲突；例如，要匹配一个反斜杠字面值，用户将必须写成 <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> 因为正则表达式必须为 <code class="docutils literal notranslate"><span class="pre">\\</span></code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code class="docutils literal notranslate"><span class="pre">\\</span></code>。 而且，还要注意在 Python 的字符串字面值中使用的反斜杠现在如果有任何无效的转义序列将会产生 <a class="reference internal" href="exceptions.xhtml#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 并将在未来改为 <a class="reference internal" href="exceptions.xhtml#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>。 此行为即使对于正则表达式来说有效的转义字符同样会发生。</p>
<p>解决办法是对于正则表达式模式（patterns）使用 Python 的原始字符串表示法；在带有 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code> 表示包含 <code class="docutils literal notranslate"><span class="pre">'\'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'n'</span></code> 两个字符的字符串，而 <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code> 则表示只包含一个换行符的字符串。 模式在 Python 代码中通常都使用原始字符串表示法。</p>
<p>绝大多数正则表达式操作都提供为模块函数和方法，在 <a class="reference internal" href="#re-objects"><span class="std std-ref">编译正则表达式</span></a>.  这些函数是一个捷径，不需要先编译正则对象，但是损失了一些优化参数。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>第三方模块 <a class="reference external" href="https://pypi.org/project/regex/">regex</a><span class="link-target"> [https://pypi.org/project/regex/]</span> 提供了与标准库 <a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块兼容的 API，还提供了附加功能和更全面的 Unicode 支持。</p>
</div>
<section id="regular-expression-syntax">
<span id="re-syntax"></span><h2>正则表达式语法</h2>
<p>正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。</p>
<p>正则表达式可以拼接；如果 <em>A</em> 和 <em>B</em> 都是正则表达式，则 <em>AB</em> 也是正则表达式。通常，如果字符串 <em>p</em> 匹配 <em>A</em>，并且另一个字符串 <em>q</em> 匹配 <em>B</em>，那么 <em>pq</em> 可以匹配 AB。除非 <em>A</em> 或者 <em>B</em> 包含低优先级操作，<em>A</em> 和 <em>B</em> 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。更多正则表达式理论和实现，详见 the Friedl book <a class="reference internal" href="#frie09" id="id1"><span>[Frie09]</span></a> ，或者其他构建编译器的书籍。</p>
<p>以下是正则表达式格式的简要说明。更详细的信息和演示，参考  <a class="reference internal" href="../howto/regex.xhtml#regex-howto"><span class="std std-ref">正则表达式指南</span></a>。</p>
<p>正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, 或者 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 <code class="docutils literal notranslate"><span class="pre">last</span></code> 匹配字符串 <code class="docutils literal notranslate"><span class="pre">'last'</span></code>.  （在这一节的其他部分，我们将用 <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">special</span> <span class="pre">style</span></code> 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 <code class="docutils literal notranslate"><span class="pre">'in</span> <span class="pre">single</span> <span class="pre">quotes'</span></code> ，单引号形式。）</p>
<p>有些字符，比如 <code class="docutils literal notranslate"><span class="pre">'|'</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">'('</span></code>，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p>
<p>重复运算符或数量限定符 (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code> 等) 不能被直接嵌套。 这避免了非贪婪修饰符后缀 <code class="docutils literal notranslate"><span class="pre">?</span></code> 的歧义，也避免了其他实现中其他修饰符的歧义。 要将第二层重复应用到内层的重复中，可以使用圆括号。 例如，表达式 <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code> 将匹配六个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 字符的任意多次重复。</p>
<p>特殊字符有：</p>
<dl class="simple" id="index-0">
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(点号) 在默认模式下，匹配除换行符以外的任意字符。 如果指定了旗标 <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> ，它将匹配包括换行符在内的任意字符。</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(插入符)  匹配字符串的开头， 并且在 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 模式下也匹配换行后的首个符号。</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>匹配字符串尾或者在字符串尾的换行符的前一个字符，在 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 模式下也会匹配换行符之前的文本。 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 匹配 'foo' 和 'foobar'，但正则表达式 <code class="docutils literal notranslate"><span class="pre">foo$</span></code> 只匹配 'foo'。 更有趣的是，在 <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code> 中搜索 <code class="docutils literal notranslate"><span class="pre">foo.$</span></code>，通常匹配  'foo2'，但在 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 模式下可以匹配到 'foo1'；在 <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code> 中搜索 <code class="docutils literal notranslate"><span class="pre">$</span></code> 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。  <code class="docutils literal notranslate"><span class="pre">ab*</span></code> 会匹配 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，<code class="docutils literal notranslate"><span class="pre">'ab'</span></code>，或者 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 后面跟随任意个 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>。</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>对它前面的正则式匹配1到任意次重复。 <code class="docutils literal notranslate"><span class="pre">ab+</span></code> 会匹配 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 后面跟随1个以上到任意个 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>，它不会匹配 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>。</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>对它前面的正则式匹配0到1次重复。 <code class="docutils literal notranslate"><span class="pre">ab?</span></code> 会匹配 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>。</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 数量限定符都是 <em class="dfn">贪婪的</em>；它们会匹配尽可能多的文本。 有时这种行为并不被需要；如果 RE <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> 针对 <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code> 进行匹配，它将匹配整个字符串，而不只是 <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>。 在数量限定符之后添加 <code class="docutils literal notranslate"><span class="pre">?</span></code> 将使其以 <em class="dfn">非贪婪</em> 或 <em class="dfn">最小</em> 风格来执行匹配；也就是将匹配数量尽可能 <em>少的</em> 字符。 使用 RE <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> 将只匹配 <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>。</p>
</dd>
</dl>
<dl id="index-7">
<dt><code class="docutils literal notranslate"><span class="pre">*+</span></code>, <code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">?+</span></code></dt><dd><p>类似于 <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 数量限定符，添加了 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 的形式也将匹配尽可能多的次数。 但是，不同于真正的贪婪型数量限定符，这些形式在之后的表达式匹配失败时不允许反向追溯。 这些形式被称为 <em class="dfn">占有型</em> 数量限定符。 例如，<code class="docutils literal notranslate"><span class="pre">a*a</span></code> 将匹配 <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code> 因为 <code class="docutils literal notranslate"><span class="pre">a*</span></code> 将匹配所有的 4 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，但是，当遇到最后一个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 时，表达式将执行反向追溯以便最终 <code class="docutils literal notranslate"><span class="pre">a*</span></code> 最后变为匹配总计 3 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，而第四个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 将由最后一个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 来匹配。 然而，当使用 <code class="docutils literal notranslate"><span class="pre">a*+a</span></code> 时如果要匹配 <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code>，<code class="docutils literal notranslate"><span class="pre">a*+</span></code> 将匹配所有的 4 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，但是在最后一个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 无法找到更多字符来匹配时，表达式将无法被反向追溯并将因此匹配失败。 <code class="docutils literal notranslate"><span class="pre">x*+</span></code>, <code class="docutils literal notranslate"><span class="pre">x++</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x?+</span></code> 分别等价于 <code class="docutils literal notranslate"><span class="pre">(?&gt;x*)</span></code>, <code class="docutils literal notranslate"><span class="pre">(?&gt;x+)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">(?&gt;x?)</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-8">
<dt><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p>对其之前的正则式指定匹配 <em>m</em> 个重复；少于 <em>m</em> 的话就会导致匹配失败。比如， <code class="docutils literal notranslate"><span class="pre">a{6}</span></code> 将匹配6个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> , 但是不能是5个。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p>对正则式进行 <em>m</em> 到 <em>n</em> 次匹配，在 <em>m</em> 和 <em>n</em> 之间取尽量多。 比如，<code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> 将匹配 3 到 5个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>。忽略 <em>m</em> 意为指定下界为0，忽略 <em>n</em> 指定上界为无限次。 比如 <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code> 将匹配 <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> 或者1000个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 尾随一个 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>，但不能匹配 <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p>将导致结果 RE 匹配之前 RE 的 <em>m</em> 至 <em>n</em> 次重复，尝试匹配尽可能 <em>少的</em> 重复次数。 这是之前数量限定符的非贪婪版本。 例如，在 6 个字符的字符串 <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code> 上，<code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> 将匹配 5 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 字符，而 <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code> 将只匹配 3 个字符。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}+</span></code></dt><dd><p>将导致结果 RE 匹配之前 RE 的 <em>m</em> 至 <em>n</em> 次重复，尝试匹配尽可能多的重复而 <em>不会</em> 建立任何反向追溯点。 这是上述数量限定符的占有型版本。 例如，在 6 个字符的字符串 <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code> 上，<code class="docutils literal notranslate"><span class="pre">a{3,5}+aa</span></code> 将尝试匹配 5 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 字符，然后，要求再有 2 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，这将需要比可用的更多的字符因而会失败，而 <code class="docutils literal notranslate"><span class="pre">a{3,5}aa</span></code> 的匹配将使 <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> 先捕获 5 个，然后通过反向追溯再匹配 4 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，然后用模式中最后的 <code class="docutils literal notranslate"><span class="pre">aa</span></code> 来匹配最后的 2 个 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>。 <code class="docutils literal notranslate"><span class="pre">x{m,n}+</span></code> 就等同于 <code class="docutils literal notranslate"><span class="pre">(?&gt;x{m,n})</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-9">
<dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>转义特殊字符（允许你匹配 <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code>, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。</p>
<p>如果你没有使用原始字符串（ <code class="docutils literal notranslate"><span class="pre">r'raw'</span></code> ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p>
</dd>
</dl>
<dl id="index-10">
<dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>用于表示一个字符集合。在一个集合中：</p>
<ul class="simple">
<li><p>字符可以单独列出，比如 <code class="docutils literal notranslate"><span class="pre">[amk]</span></code> 匹配 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>， <code class="docutils literal notranslate"><span class="pre">'m'</span></code>， 或者 <code class="docutils literal notranslate"><span class="pre">'k'</span></code>。</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p>可以表示字符范围，通过用 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> 将两个字符连起来。比如 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> 将匹配任何小写ASCII字符， <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code> 将匹配从 <code class="docutils literal notranslate"><span class="pre">00</span></code> 到 <code class="docutils literal notranslate"><span class="pre">59</span></code> 的两位数字， <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code> 将匹配任何十六进制数位。 如果 <code class="docutils literal notranslate"><span class="pre">-</span></code> 进行了转义 （比如 <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>）或者它的位置在首位或者末尾（如 <code class="docutils literal notranslate"><span class="pre">[-a]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>），它就只表示普通字符 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>。</p></li>
<li><p>特殊字符在集合中会失去其特殊意义。比如 <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code> 只会匹配这几个字面字符之一 <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, or <code class="docutils literal notranslate"><span class="pre">')'</span></code>。</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p>字符类如 <code class="docutils literal notranslate"><span class="pre">\w</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">\S</span></code> (定义如下) 也在集合内被接受，不过它们可匹配的字符则依赖于所使用的 <a class="reference internal" href="#flags">flags</a>。</p></li>
</ul>
<ul class="simple" id="index-13">
<li><p>不在集合范围内的字符可以通过 <em class="dfn">取反</em> 来进行匹配。如果集合首字符是 <code class="docutils literal notranslate"><span class="pre">'^'</span></code> ，所有 <em>不</em> 在集合内的字符将会被匹配，比如 <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> 将匹配所有字符，除了 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>， <code class="docutils literal notranslate"><span class="pre">[^^]</span></code> 将匹配所有字符，除了 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>.  <code class="docutils literal notranslate"><span class="pre">^</span></code> 如果不在集合首位，就没有特殊含义。</p></li>
<li><p>要在集合内匹配一个 <code class="docutils literal notranslate"><span class="pre">']'</span></code> 字面值，可以在它前面加上反斜杠，或是将它放到集合的开头。 例如，<code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code> 都可以匹配右方括号，以及左方括号，花括号和圆括号。</p></li>
</ul>
<ul class="simple">
<li><p><a class="reference external" href="https://unicode.org/reports/tr18/">Unicode Technical Standard #18</a><span class="link-target"> [https://unicode.org/reports/tr18/]</span> 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 <a class="reference internal" href="exceptions.xhtml#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> 将会在有多义的情况里被 <code class="docutils literal notranslate"><span class="pre">raise</span></code>，包含以下几种情况，集合由 <code class="docutils literal notranslate"><span class="pre">'['</span></code> 开始，或者包含下列字符序列  <code class="docutils literal notranslate"><span class="pre">'--'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code>, 和 <code class="docutils literal notranslate"><span class="pre">'||'</span></code>。为了避免警告，需要将它们用反斜杠转义。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>如果一个字符串构建的语义在未来会改变的话，一个 <a class="reference internal" href="exceptions.xhtml#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> 会 <code class="docutils literal notranslate"><span class="pre">raise</span></code> 。</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>， <em>A</em> 和 <em>B</em> 可以是任意正则表达式，创建一个正则表达式，匹配 <em>A</em> 或者 <em>B</em>.  任意个正则表达式可以用 <code class="docutils literal notranslate"><span class="pre">'|'</span></code> 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， <code class="docutils literal notranslate"><span class="pre">'|'</span></code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 <em>A</em> 匹配成功， <em>B</em> 就不再进行匹配，即便它能产生一个更好的匹配。或者说，<code class="docutils literal notranslate"><span class="pre">'|'</span></code> 操作符绝不贪婪。  如果要匹配 <code class="docutils literal notranslate"><span class="pre">'|'</span></code> 字符，使用 <code class="docutils literal notranslate"><span class="pre">\|</span></code>， 或者把它包含在字符集里，比如 <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用  <code class="docutils literal notranslate"><span class="pre">\number</span></code> 转义序列进行再次匹配，之后进行详细说明。要匹配字符 <code class="docutils literal notranslate"><span class="pre">'('</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">')'</span></code>, 用 <code class="docutils literal notranslate"><span class="pre">\(</span></code> 或 <code class="docutils literal notranslate"><span class="pre">\)</span></code>, 或者把它们包含在字符集合里: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl id="index-16">
<dt><code class="docutils literal notranslate"><span class="pre">(?…)</span></code></dt><dd><p>这是个扩展标记法 （一个 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 跟随 <code class="docutils literal notranslate"><span class="pre">'('</span></code> 并无含义）。  <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 是唯一的例外。 以下是目前支持的扩展。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>（一个或多个来自 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 集合的字母。） 分组将与空字符串相匹配；这些字母将为整个正则表达式设置相应的旗标：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (仅限 ASCII 匹配)</p></li>
<li><p><a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (忽略大小写)</p></li>
<li><p><a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (依赖于语言区域)</p></li>
<li><p><a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (多行)</p></li>
<li><p><a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (点号匹配所有字符)</p></li>
<li><p><a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode 匹配)</p></li>
<li><p><a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (详细)</p></li>
</ul>
<p>（该旗标在 <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">模块内容</span></a> 中有介绍。） 这适用于当你希望将该旗标包括为正则表达式的一部分，而不是向 <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 函数传入 <em>flag</em> 参数的情况。 旗标应当在表达式字符串的开头使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>此构造只能在表达式的开头使用。</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt><code class="docutils literal notranslate"><span class="pre">(?:…)</span></code></dt><dd><p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:…)</span></code></dt><dd><p>（零个或多个来自 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 集合的字母，后面可以带 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> 再跟一个或多个来自 <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 集合的字母。） 这些字母将为这部分表达式设置或移除相应的旗标：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (仅限 ASCII 匹配)</p></li>
<li><p><a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (忽略大小写)</p></li>
<li><p><a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (依赖于语言区域)</p></li>
<li><p><a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (多行)</p></li>
<li><p><a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (点号匹配所有字符)</p></li>
<li><p><a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode 匹配)</p></li>
<li><p><a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (详细)</p></li>
</ul>
<p>（这些旗标在 <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">模块内容</span></a> 中有介绍。）</p>
<p>字母 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'u'</span></code> 在用作内联旗标时是互斥的，所以它们不能相互组合或者带 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>。 相反，当它们中的某一个出现于内联的分组时，它将覆盖外层分组中匹配的模式。 在 Unicode 模式中 <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> 将切换至仅限 ASCII 匹配，而 <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code> 将切换至 Unicode 匹配（默认）。 在字节串模式中 <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code> 将切换为基于语言区域的匹配，而 <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> 将切换为仅限 ASCII 匹配（默认）。 这种覆盖将只在内联分组范围内生效，而在分组之外将恢复为原始的匹配模式。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>符号 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'u'</span></code> 同样可以用在一个组合内。</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code></dt><dd><p>尝试匹配 <code class="docutils literal notranslate"><span class="pre">...</span></code> 就像它是一个单独的正则表达式，如果匹配成功，则继续匹配在它之后的剩余表达式。 如果之后的表达式匹配失败，则栈只能回溯到 <code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code> <em>之前</em> 的点，因为一旦退出，这个被称为 <em class="dfn">原子化分组</em> 的表达式将会丢弃其自身所有的栈点位。 因此，<code class="docutils literal notranslate"><span class="pre">(?&gt;.*).</span></code> 将永远不会匹配任何东西因为首先 <code class="docutils literal notranslate"><span class="pre">.*</span></code> 将匹配所有可能的字符，然后，由于没有任何剩余的字符可供匹配，最后的 <code class="docutils literal notranslate"><span class="pre">.</span></code> 将匹配失败。 由于原子化分组中没有保存任何栈点位，并且在它之前也没有任何栈点位，因此整个表达式将匹配失败。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-18">
<dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;…)</span></code></dt><dd><p>与常规的圆括号类似，但分组所匹配到了子字符串可通过符号分组名称 <em>name</em> 来访问。 分组名称必须是有效的 Python 标识符，并且在 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 模式中它们只能包含 ASCII 范围内的字节值。 每个分组名称在一个正则表达式中只能定义一次。 一个符号分组同时也是一个编号分组，就像这个分组没有被命名过一样。</p>
<p>命名组合可以在三种上下文中引用。如果样式是 <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code> （也就是说，匹配单引号或者双引号括起来的字符串)：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>引用组合 &quot;quote&quot; 的上下文</p></th>
<th class="head"><p>引用方法</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>在正则式自身内</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (如示)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>处理匹配对象 <em>m</em></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (等)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>传递到 <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code> 里的 <em>repl</em> 参数中</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>在 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 模式中，分组 <em>name</em> 只能包含 ASCII 范围内的字节值 (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>)。</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串。</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><code class="docutils literal notranslate"><span class="pre">(?#…)</span></code></dt><dd><p>注释；里面的内容会被忽略。</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><code class="docutils literal notranslate"><span class="pre">(?=…)</span></code></dt><dd><p>当 <code class="docutils literal notranslate"><span class="pre">…</span></code> 匹配时，匹配成功，但不消耗字符串中的任何字符。这个叫做 <em class="dfn">前视断言</em> （lookahead assertion）。比如， <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code> 将会匹配 <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> ，仅当其后紧跟  <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code> 。</p>
</dd>
</dl>
<dl class="simple" id="index-22">
<dt><code class="docutils literal notranslate"><span class="pre">(?!…)</span></code></dt><dd><p>当 <code class="docutils literal notranslate"><span class="pre">…</span></code> 不匹配时，匹配成功。这个叫 <em class="dfn">否定型前视断言</em> （negative lookahead assertion）。例如， <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code> 将会匹配 <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> ，仅当它后面 <em>不是</em> <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>   。</p>
</dd>
</dl>
<dl id="index-23">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=…)</span></code></dt><dd><p>如果 <code class="docutils literal notranslate"><span class="pre">...</span></code> 的匹配内容出现在当前位置的左侧，则匹配。这叫做 <em class="dfn">肯定型后视断言</em> （positive lookbehind assertion）。 <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code> 将会在 <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code> 中找到一个匹配，因为后视会回退3个字符并检查内部表达式是否匹配。内部表达式（匹配的内容）必须是固定长度的，意思就是 <code class="docutils literal notranslate"><span class="pre">abc</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a|b</span></code> 是允许的，但是 <code class="docutils literal notranslate"><span class="pre">a*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code> 不可以。注意，以肯定型后视断言开头的正则表达式，匹配项一般不会位于搜索字符串的开头。很可能你应该使用 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 函数，而不是 <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> 函数：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p>这个例子搜索一个跟随在连字符后的单词：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>添加定长组合引用的支持。</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-24">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!…)</span></code></dt><dd><p>如果 <code class="docutils literal notranslate"><span class="pre">...</span></code> 的匹配内容没有出现在当前位置的左侧，则匹配。这个叫做 <em class="dfn">否定型后视断言</em> （negative lookbehind assertion）。类似于肯定型后视断言，内部表达式（匹配的内容）必须是固定长度的。以否定型后视断言开头的正则表达式，匹配项可能位于搜索字符串的开头。</p>
</dd>
</dl>
<span id="re-conditional-expression"></span><dl id="index-25">
<dt><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p>如果给定的  <em>id</em> 或 <em>name</em> 存在，将会尝试匹配 <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code> ，否则就尝试匹配 <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code>，<code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> 可选，也可以被忽略。比如， <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;|$)</span></code> 是一个email样式匹配，将匹配 <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com&gt;'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com'</span></code> ，但不会匹配 <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com'</span></code> ，也不会匹配 <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com&gt;'</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>分组 <em>id</em> 只能包含 ASCII 数码。 在 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 模式中，分组 <em>name</em> 只能包含 ASCII 范围内的字节值 (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>)。</p>
</div>
</dd>
</dl>
<p id="re-special-sequences">由 <code class="docutils literal notranslate"><span class="pre">'\'</span></code> 和一个字符组成的特殊序列在以下列出。 如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，<code class="docutils literal notranslate"><span class="pre">\$</span></code> 匹配字符 <code class="docutils literal notranslate"><span class="pre">'$'</span></code>.</p>
<dl class="simple" id="index-26">
<dt><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p>匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code> 匹配 <code class="docutils literal notranslate"><span class="pre">'the</span> <span class="pre">the'</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>, 但不会匹配 <code class="docutils literal notranslate"><span class="pre">'thethe'</span></code> (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果  <em>number</em> 的第一个数位是0， 或者 <em>number</em> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 <code class="docutils literal notranslate"><span class="pre">'['</span></code> 和 <code class="docutils literal notranslate"><span class="pre">']'</span></code> 字符集合内，任何数字转义都被看作是字符。</p>
</dd>
</dl>
<dl class="simple" id="index-27">
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>只匹配字符串开始。</p>
</dd>
</dl>
<dl id="index-28">
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>匹配空字符串，但只在单词开始或结尾的位置。 一个单词被定义为一个单词字符的序列。 注意在通常情况下，<code class="docutils literal notranslate"><span class="pre">\b</span></code> 被定义为 <code class="docutils literal notranslate"><span class="pre">\w</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\W</span></code> 字符之间的边界（反之亦然），或是 <code class="docutils literal notranslate"><span class="pre">\w</span></code> 和字符串开始或结尾之间的边界。 这意味着 <code class="docutils literal notranslate"><span class="pre">r'\bat\b'</span></code> 将匹配 <code class="docutils literal notranslate"><span class="pre">'at'</span></code>, <code class="docutils literal notranslate"><span class="pre">'at.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(at)'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'as</span> <span class="pre">at</span> <span class="pre">ay'</span></code> 但不匹配 <code class="docutils literal notranslate"><span class="pre">'attempt'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'atlas'</span></code>。</p>
<p>Unicode (str) 模式中默认的单词类字符是 Unicode 字母数字和下划线，但这可以通过使用 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标来改变。 如果使用了 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 旗标则单词边界将根据当前语言区域来确定。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在一个字符范围内，<code class="docutils literal notranslate"><span class="pre">\b</span></code> 代表退格符，以便与 Python 的字符串字面值保持兼容。</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-29">
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>匹配空字符串，但仅限于它 <em>不在</em> 单词的开头或结尾的情况。 这意味着 <code class="docutils literal notranslate"><span class="pre">r'at\B'</span></code> 将匹配 <code class="docutils literal notranslate"><span class="pre">'athens'</span></code>, <code class="docutils literal notranslate"><span class="pre">'atom'</span></code>, <code class="docutils literal notranslate"><span class="pre">'attorney'</span></code>，但不匹配 <code class="docutils literal notranslate"><span class="pre">'at'</span></code>, <code class="docutils literal notranslate"><span class="pre">'at.'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'at!'</span></code>。 <code class="docutils literal notranslate"><span class="pre">\B</span></code> 与 <code class="docutils literal notranslate"><span class="pre">\b</span></code> 正相反，这样 Unicode (str) 模式中的单词类字符是 Unicode 字母数字或下划线，但这可以通过使用 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标来改变。 如果使用了 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 旗标则单词边界将根据当前语言区域来确定。</p>
</dd>
</dl>
<dl id="index-30">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl>
<dt>对于 Unicode (str) 样式：</dt><dd><p>匹配任意 Unicode 十进制数码（也就是说，任何属于 Unicode 字符类别 <a class="reference external" href="https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153">[Nd]</a><span class="link-target"> [https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153]</span> 的字符）。 这包括 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>，还包括许多其他的数码类字符。</p>
<p>如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标则匹配 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code></p>
</dd>
<dt>对于8位(bytes)样式：</dt><dd><p>匹配 ASCII 字符集内的任意十进制数码；这等价于 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>。</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-31">
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>匹配不属于十进制数码的任意字符。 这与 <code class="docutils literal notranslate"><span class="pre">\d</span></code> 正相反。</p>
<p>如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标则匹配 <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code></p>
</dd>
</dl>
<dl id="index-32">
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl>
<dt>对于 Unicode (str) 样式：</dt><dd><p>匹配 Unicode 空白字符（这包括 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>，还包括许多其他字符，例如许多语言中由排版规则约定的非中断空白字符）。</p>
<p>如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标则匹配 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>。</p>
</dd>
<dt>对于8位(bytes)样式：</dt><dd><p>匹配ASCII中的空白字符，就是 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> 。</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-33">
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>匹配不属于空白字符的任意字符。 这与 <code class="docutils literal notranslate"><span class="pre">\s</span></code> 正相反。</p>
<p>如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标则匹配 <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code></p>
</dd>
</dl>
<dl id="index-34">
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl>
<dt>对于 Unicode (str) 样式：</dt><dd><p>匹配 Unicode 单词类字符；这包括所有 Unicode 字母数字类字符 (由 <a class="reference internal" href="stdtypes.xhtml#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a> 定义)，以及下划线 (<code class="docutils literal notranslate"><span class="pre">_</span></code>)。</p>
<p>如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标则匹配 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>。</p>
</dd>
<dt>对于8位(bytes)样式：</dt><dd><p>匹配在 ASCII 字符集中被视为字母数字的字符；这等价于 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>。 如果使用了 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 旗标，则匹配在当前语言区域中被视为字母数字的字符以及下划线。</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-35">
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>匹配不属于单词类字符的任意字符。 这与 <code class="docutils literal notranslate"><span class="pre">\w</span></code> 正相反。 在默认情况下，将匹配除下划线 (<code class="docutils literal notranslate"><span class="pre">_</span></code>) 以外的 <a class="reference internal" href="stdtypes.xhtml#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 的字符。</p>
<p>如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标则匹配 <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>。</p>
<p>如果使用了 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 旗标，则匹配在当前语言区域中不属于字母数字且不为下划线的字符。</p>
</dd>
</dl>
<dl class="simple" id="index-36">
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>只匹配字符串尾。</p>
</dd>
</dl>
<p id="index-37">Python 字符串字面值支持的大多数 <a class="reference internal" href="../reference/lexical_analysis.xhtml#escape-sequences"><span class="std std-ref">转义序列</span></a> 也被正则表达式解析器所接受:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p>（注意 <code class="docutils literal notranslate"><span class="pre">\b</span></code> 被用于表示词语的边界，它只在字符集合内表示退格，比如 <code class="docutils literal notranslate"><span class="pre">[\b]</span></code> 。）</p>
<p><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> 转义序列仅在 Unicode (str) 模式中可被识别。 在字节串模式中它们会导致错误。 未知的 ASCII 字母转义符被保留在未来使用并会被视为错误。</p>
<p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> 转义序列。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>由 <code class="docutils literal notranslate"><span class="pre">'\'</span></code> 和一个ASCII字符组成的未知转义会被看成错误。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <code class="samp docutils literal notranslate"><span class="pre">'\N{</span><em><span class="pre">name</span></em><span class="pre">}'</span></code> 转义序列。 与在字符串字面值中一样，它扩展了指定的 Unicode 字符 (例如 <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>)。</p>
</div>
</section>
<section id="module-contents">
<span id="contents-of-module-re"></span><h2>模块内容</h2>
<p>模块定义了几个函数、常量，和一个异常。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。重要的应用程序大多会在使用前先编译正则表达式。</p>
<section id="flags">
<h3>标志</h3>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>标志常量现在是 <a class="reference internal" href="#re.RegexFlag" title="re.RegexFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code></a> 类的实例，这个类是 <a class="reference internal" href="enum.xhtml#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> 的子类。</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.RegexFlag">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">RegexFlag</span></span></dt>
<dd><p>包含以下列出的正则表达式选项的 <a class="reference internal" href="enum.xhtml#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> 类。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span>- added to <code class="docutils literal notranslate"><span class="pre">__all__</span></code></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.A">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">A</span></span></dt>
<dt class="sig sig-object py" id="re.ASCII">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">ASCII</span></span></dt>
<dd><p>使 <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\S</span></code> 执行仅限 ASCII 匹配而不是完整的 Unicode 匹配。 这仅对 Unicode (str) 模式有意义，而对字节串模式将被忽略。</p>
<p>对应于内联旗标 <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">U</span></code></a> 旗标仍然存在以保持下向兼容性，但在 Python 3 中是多余的因为对于 <code class="docutils literal notranslate"><span class="pre">str</span></code> 模式默认使用 Unicode，并且 Unicode 匹配对于 bytes 模式则是不允许的。 <a class="reference internal" href="#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">UNICODE</span></code></a> 和内联旗标 <code class="docutils literal notranslate"><span class="pre">(?u)</span></code> 同样也是多余的。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.DEBUG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DEBUG</span></span></dt>
<dd><p>显示有关被编译表达式的调试信息。</p>
<p>没有对应的内联旗标。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.I">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">I</span></span></dt>
<dt class="sig sig-object py" id="re.IGNORECASE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">IGNORECASE</span></span></dt>
<dd><p>执行忽略大小写的匹配；<code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> 这样的表达式也将匹配小写字母。 完全的 Unicode 匹配 (如 <code class="docutils literal notranslate"><span class="pre">Ü</span></code> 将匹配 <code class="docutils literal notranslate"><span class="pre">ü</span></code>) 同样适用，除非使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标来禁用非 ASCII 匹配。 当前语言区域不会改变该旗标的效果，除非还使用了 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 旗标。</p>
<p>对应于内联旗标 <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>。</p>
<p>请注意当 Unicode 模式 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> 与 <a class="reference internal" href="#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> 旗标一起使用时，它们将匹配 52 个 ASCII 字母和 4 个额外的非 ASCII 字母: 'İ' (U+0130, 大写拉丁字母 I 带有上方的点), 'ı' (U+0131, 小写拉丁字母 i 不带上方的点), 'ſ' (U+017F, 小写拉丁字母长 s) 和 'K' (U+212A, 开尔文标记)。 如果使用了 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 旗标，则只匹配字母 'a' 到 'z' 和 'A' 到 'Z'。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.L">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">L</span></span></dt>
<dt class="sig sig-object py" id="re.LOCALE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">LOCALE</span></span></dt>
<dd><p>使 <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> 和忽略大小写的匹配依赖于当前语言区域。 该旗标仅适用于 bytes 模式。</p>
<p>对应于内联旗标 <code class="docutils literal notranslate"><span class="pre">(?L)</span></code>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>该旗标已不建议使用；请考虑改用 Unicode 匹配。 语言区域机制相当不可靠因为它每次只能处理一种“文化”并且只适用于 8 位语言区域。 Unicode (str) 模式默认启用 Unicode 匹配并且能够处理不同的语言区域和语言。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 仅适用于 bytes 模式并且不能兼容 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>设置了 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 旗标的已编译正则表达式对象不会再依赖于编译时的语言区域。 只有在匹配时的语言区域才会影响匹配结果。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.M">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">M</span></span></dt>
<dt class="sig sig-object py" id="re.MULTILINE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">MULTILINE</span></span></dt>
<dd><p>在指定之后，模式字符 <code class="docutils literal notranslate"><span class="pre">'^'</span></code> 将匹配字符串的开始和每一行的开头（紧随在换行符之后）；而模式字符 <code class="docutils literal notranslate"><span class="pre">'$'</span></code> 将匹配字符串的末尾和每一行的末尾（紧接在换行符之前）。 在默认情况下，<code class="docutils literal notranslate"><span class="pre">'^'</span></code> 只匹配字符串的开头，而``'$'`` 只匹配字符串的末尾和紧接在字符串末尾（可能存在的）换行符之前。</p>
<p>对应于内联旗标 <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.NOFLAG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">NOFLAG</span></span></dt>
<dd><p>表示未应用任何旗标，该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 该旗标可被用作某个函数关键字参数的默认值或者用作将与其他旗标进行有条件 OR 运算的基准值。 用作默认值的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">NOFLAG</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.S">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">S</span></span></dt>
<dt class="sig sig-object py" id="re.DOTALL">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DOTALL</span></span></dt>
<dd><p>使 <code class="docutils literal notranslate"><span class="pre">'.'</span></code> 特殊字符匹配任意字符，包括换行符；如果没有这个旗标，<code class="docutils literal notranslate"><span class="pre">'.'</span></code> 将匹配 <em>除去</em> 换行符以外的任意字符。</p>
<p>对应于内联旗标 <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.U">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">U</span></span></dt>
<dt class="sig sig-object py" id="re.UNICODE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">UNICODE</span></span></dt>
<dd><p>在 Python 3 中，<code class="docutils literal notranslate"><span class="pre">str</span></code> 模式默认将匹配 Unicode 字符。 因此这个旗标多余且 <strong>无任何效果</strong>，仅保留用于向下兼容。</p>
<p>请参阅 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 了解如何改为仅限匹配 ASCII 字符。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.X">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">X</span></span></dt>
<dt class="sig sig-object py" id="re.VERBOSE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">VERBOSE</span></span></dt>
<dd><p id="index-38">这个旗标允许你通过在视觉上分隔表达式的逻辑段落和添加注释来编写更为友好并更具可读性的正则表达式。 表达式中的空白符会被忽略，除非是在字符类中，或前面有一个未转义的反斜杠，或者是在 <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code> 等形符之内。 例如，<code class="docutils literal notranslate"><span class="pre">(?</span> <span class="pre">:</span></code> 和 <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">?</span></code> 是不被允许的。 当一个行内包含不在字符类中并且前面没有未转义反斜杠的 <code class="docutils literal notranslate"><span class="pre">#</span></code> 时，则从最左边的此 <code class="docutils literal notranslate"><span class="pre">#</span></code> 直至行尾的所有字符都会被忽略。</p>
<p>意思就是下面两个正则表达式等价地匹配一个十进制数字：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # the integral part</span>
<span class="s2">                   \.    # the decimal point</span>
<span class="s2">                   \d *  # some fractional digits&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>对应内联标记 <code class="docutils literal notranslate"><span class="pre">(?x)</span></code> 。</p>
</dd></dl>

</section>
<section id="functions">
<h3>函数</h3>
<dl class="py function">
<dt class="sig sig-object py" id="re.compile">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将正则表达式的样式编译为一个 <a class="reference internal" href="#re-objects"><span class="std std-ref">正则表达式对象</span></a>  （正则对象），可以用于匹配，通过这个对象的方法  <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 以及其他如下描述。</p>
<p>表达式的行为可通过指定 <em>flags</em> 值来修改。 值可以是任意 <a class="reference internal" href="#flags">flags</a> 变量，可使用按位 OR (<code class="docutils literal notranslate"><span class="pre">|</span></code> 运算符) 进行组合。</p>
<p>序列</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>等价于</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>如果需要多次使用这个正则表达式的话，使用 <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 和保存这个正则对象以便复用，可以让程序更加高效。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>通过 <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.search">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>扫描整个 <em>string</em> 查找正则表达式 <em>pattern</em> 产生匹配的第一个位置，并返回相应的 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>。 如果字符串中没有与模式匹配的位置则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；请注意这不同于在字符串的某个位置上找到零长度匹配。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.match">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>string</em> 开头的零个或多个字符与正则表达式 <em>pattern</em> 匹配，则返回相应的 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>。 如果字符串与模式不匹配则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；请注意这与零长度匹配是不同的。</p>
<p>注意即便是 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 多行模式， <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> 也只匹配字符串的开始位置，而不匹配每行开始。</p>
<p>如果你想定位 <em>string</em> 的任何位置，使用 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 来替代（也可参考 <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a> ）</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.fullmatch">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果整个 <em>string</em> 与正则表达式 <em>pattern</em> 匹配，则返回相应的 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>。 如果字符串与模式不匹配则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；请注意这与零长度匹配是不同的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.split">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用 <em>pattern</em> 分开  <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p>如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>这样的话，分隔组将会出现在结果列表中同样的位置。</p>
<p>样式的空匹配仅在与前一个空匹配不相邻时才会拆分字符串。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span>增加了可选标记参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>增加了空字符串的样式分隔。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.findall">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>pattern</em> 在 <em>string</em> 中的所有非重叠匹配，以字符串列表或字符串元组列表的形式。对 <em>string</em> 的扫描从左至右，匹配结果按照找到的顺序返回。 空匹配也包括在结果中。</p>
<p>返回结果取决于模式中捕获组的数量。如果没有组，返回与整个模式匹配的字符串列表。如果有且仅有一个组，返回与该组匹配的字符串列表。如果有多个组，返回与这些组匹配的字符串元组列表。非捕获组不影响结果。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bf[a-z]*&#39;</span><span class="p">,</span> <span class="s1">&#39;which foot or hand fell fastest&#39;</span><span class="p">)</span>
<span class="go">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)=(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;set width=20 and height=10&#39;</span><span class="p">)</span>
<span class="go">[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>非空匹配现在可以在前一个空匹配之后出现了。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.finditer">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>针对正则表达式 <em>pattern</em> 在 <em>string</em> 里的所有非重叠匹配返回一个产生 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> 对象的 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a>。 <em>string</em> 将被从左至右地扫描，并且匹配也将按被找到的顺序返回。 空匹配也会被包括在结果中。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>非空匹配现在可以在前一个空匹配之后出现了。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.sub">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 <em>string</em>。 <em>repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code class="docutils literal notranslate"><span class="pre">\n</span></code> 会被转换为一个换行符，<code class="docutils literal notranslate"><span class="pre">\r</span></code> 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> 会保持原样。 向后引用像是 <code class="docutils literal notranslate"><span class="pre">\6</span></code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p>如果 <em>repl</em> 是一个函数，则它会针对每次 <em>pattern</em> 的非重叠出现的情况被调用。 该函数接受单个 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> 参数，并返回替换字符串。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p>模式可以是一个字符串或者 <a class="reference internal" href="#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pattern</span></code></a>。</p>
<p>可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以  <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code> 。</p>
<p id="index-39">在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> 会使用命名组合 <code class="docutils literal notranslate"><span class="pre">name</span></code>，（在  <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;…)</span></code> 语法中定义） <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code> 会使用数字组；<code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">\2</span></code>，但它避免了二义性，如 <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>。 <code class="docutils literal notranslate"><span class="pre">\20</span></code> 就会被解释为组20，而不是组2后面跟随一个字符 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>。向后引用 <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> 把 <em>pattern</em> 作为一整个组进行引用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span>增加了可选标记参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>不匹配的组合替换为空字符串。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span><em>pattern</em> 中的未知转义（由 <code class="docutils literal notranslate"><span class="pre">'\'</span></code> 和一个 ASCII 字符组成）被视为错误。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>Unknown escapes in <em>repl</em> consisting of <code class="docutils literal notranslate"><span class="pre">'\'</span></code> and an ASCII letter
now are errors.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>Empty matches for the pattern are replaced when adjacent to a previous
non-empty match.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>分组 <em>id</em> 只能包含 ASCII 数码。 在 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 替换字符串中，分组 <em>name</em> 只能包含 ASCII 范围内的字节值 (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>)。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.subn">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>行为与 <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 相同，但是返回一个元组 <code class="docutils literal notranslate"><span class="pre">(字符串,</span> <span class="pre">替换次数)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span>增加了可选标记参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>不匹配的组合替换为空字符串。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.escape">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">escape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>转义 <em>pattern</em> 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;https://www.python.org&#39;</span><span class="p">))</span>
<span class="go">https://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p>这个函数不能被用于 <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 和 <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a> 的替换字符串，只有反斜杠应该被转义。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">'_'</span></code> 不再被转义。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;`&quot;</span></code> 将不再会被转义。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.purge">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">purge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>清除正则表达式的缓存。</p>
</dd></dl>

</section>
<section id="exceptions">
<h3>异常</h3>
<dl class="py exception">
<dt class="sig sig-object py" id="re.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Exception raised when a string passed to one of the functions here is not a
valid regular expression (for example, it might contain unmatched parentheses)
or when some other error occurs during compilation or matching.  It is never an
error if a string contains no match for a pattern.  The error instance has
the following additional attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.msg">
<span class="sig-name descname"><span class="pre">msg</span></span></dt>
<dd><p>未格式化的错误消息。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.pattern">
<span class="sig-name descname"><span class="pre">pattern</span></span></dt>
<dd><p>正则表达式的模式串。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.pos">
<span class="sig-name descname"><span class="pre">pos</span></span></dt>
<dd><p>编译失败的 <em>pattern</em> 的位置索引（可以是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ）。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.lineno">
<span class="sig-name descname"><span class="pre">lineno</span></span></dt>
<dd><p>对应 <em>pos</em> (可以是 <code class="docutils literal notranslate"><span class="pre">None</span></code>) 的行号。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.colno">
<span class="sig-name descname"><span class="pre">colno</span></span></dt>
<dd><p>对应 <em>pos</em> (可以是 <code class="docutils literal notranslate"><span class="pre">None</span></code>) 的列号。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>增加了额外的属性。</p>
</div>
</dd></dl>

</section>
</section>
<section id="regular-expression-objects">
<span id="re-objects"></span><h2>正则表达式对象 （正则对象）</h2>
<dl class="py class">
<dt class="sig sig-object py" id="re.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span></dt>
<dd><p>由 <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 返回的已编译正则表达式对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span><a class="reference internal" href="#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Pattern</span></code></a> 支持用 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 表示 Unicode (str) 或字节串类型的模式。 参见 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.search">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>扫描整个 <em>string</em> 查找该正则表达式产生匹配的第一个位置，并返回相应的 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>。 如果字符串中没有与模式匹配的位置则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；请注意这不同于在字符串的某个位置上找到零长度匹配。</p>
<p>可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，它不完全等价于字符串切片； <code class="docutils literal notranslate"><span class="pre">'^'</span></code> 样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。</p>
<p>可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code class="docutils literal notranslate"><span class="pre">pos</span></code> 到 <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code> 的字符会被匹配。如果 <em>endpos</em> 小于 <em>pos</em>，就不会有匹配产生；另外，如果 <em>rx</em> 是一个编译后的正则对象， <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># Match at index 0</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># No match; search doesn&#39;t include the &quot;d&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.match">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>如果字符串 <em>开头</em> 的零个或多个字符与此正则表达式匹配，则返回相应的 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>。 如果字符串与模式不匹配则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；请注意这与零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 含义相同。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Match as &quot;o&quot; is the 2nd character of &quot;dog&quot;.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p>如果你想定位匹配在 <em>string</em> 中的位置，使用 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 来替代（另参考  <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.fullmatch">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>如果整个 <em>string</em> 与此正则表达式匹配，则返回相应的 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>。 如果字符串与模式不匹配则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>；请注意这与零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 含义相同。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># No match as not the full string matches.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Matches within given limits.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.split">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 函数，使用了编译后的样式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.findall">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>类似函数 <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.finditer">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>类似函数 <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.sub">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 函数，使用了编译后的样式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.subn">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>等价于 <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a> 函数，使用了编译后的样式。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.flags">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">flags</span></span></dt>
<dd><p>正则表达式匹配旗标。 这是一个传给 <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的旗标组合，模式中的任何 <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> 内联旗标，以及隐式旗标如当模式为 Unicode 字符串时的 <a class="reference internal" href="#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">UNICODE</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groups">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groups</span></span></dt>
<dd><p>捕获到的模式串中组的数量。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groupindex">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groupindex</span></span></dt>
<dd><p>映射由 <code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.pattern">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">pattern</span></span></dt>
<dd><p>编译对象的原始样式字符串。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>添加 <a class="reference internal" href="copy.xhtml#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> 和 <a class="reference internal" href="copy.xhtml#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 函数的支持。编译后的正则表达式对象被认为是原子性的。</p>
</div>
</section>
<section id="match-objects">
<span id="id3"></span><h2>匹配对象</h2>
<p>匹配对象总是有一个布尔值 <code class="docutils literal notranslate"><span class="pre">True</span></code>。如果没有匹配的话 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 和 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 所以你可以简单的用 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句来判断是否匹配</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Match</span></span></dt>
<dd><p>由成功的 <code class="docutils literal notranslate"><span class="pre">match</span></code> 和 <code class="docutils literal notranslate"><span class="pre">search</span></code> 所返回的匹配对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span><a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Match</span></code></a> 支持用 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 表示 Unicode (str) 或字节串类型的匹配。 参见 <a class="reference internal" href="stdtypes.xhtml#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.expand">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回通过在模板字符串 <em>template</em> 上执行反斜杠替换所获得的字符串，就像 <a class="reference internal" href="#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> 方法所做的那样。 转义符例如 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 将被转换为适当的字符，而数字反向引用 (<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>) 和命名反向引用 (<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>) 将被替换为相应分组的内容。 反向引用 <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> 将被替换为整个匹配的内容。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>不匹配的组合替换为空字符串。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.group">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">group</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，就引发一个 <a class="reference internal" href="exceptions.xhtml#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 异常。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Multiple arguments give us a tuple.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p>如果正则表达式使用了 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 语法， <em>groupN</em> 参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，就引发一个 <a class="reference internal" href="exceptions.xhtml#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 异常。</p>
<p>一个相对复杂的例子</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>命名组合同样可以通过索引值引用</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>如果一个组匹配成功多次，就只返回最后一个匹配</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># Matches 3 times.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># Returns only the last match.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.__getitem__">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这个等价于 <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>。这允许更方便的引用一个匹配</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<p>命名分组也是受支持的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;first_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;last_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groups">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p>如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，除非指定了 <em>default</em> 参数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># Second group defaults to None.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># Now, the second group defaults to &#39;0&#39;.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groupdict">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groupdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 例如</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.start">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py" id="re.Match.end">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">end</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>group</em> 匹配到的字串的开始和结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果  <em>group</em> 存在，但未产生匹配，就返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 。对于一个匹配对象 <em>m</em>， 和一个未参与匹配的组 <em>g</em> ，组 <em>g</em> (等价于 <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>)产生的匹配是</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p>注意 <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code> 将会等于 <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code> ，如果 <em>group</em> 匹配一个空字符串的话。比如，在 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code> 之后，<code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code> 为 1, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code> 为 2, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code> 都是 2, <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code> 引发一个 <a class="reference internal" href="exceptions.xhtml#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 异常。</p>
<p>这个例子会从email地址中移除掉 <em>remove_this</em></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.span">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">span</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>对于一个匹配 <em>m</em> ， 返回一个二元组 <code class="docutils literal notranslate"><span class="pre">(m.start(group),</span> <span class="pre">m.end(group))</span></code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code> 。<em>group</em> 默认为0，就是整个匹配。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.pos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">pos</span></span></dt>
<dd><p><em>pos</em> 的值，会传递给 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 或 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 的方法 a <a class="reference internal" href="#re-objects"><span class="std std-ref">正则对象</span></a> 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.endpos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">endpos</span></span></dt>
<dd><p><em>endpos</em> 的值，会传递给 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 或 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 的方法 a <a class="reference internal" href="#re-objects"><span class="std std-ref">正则对象</span></a> 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastindex">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastindex</span></span></dt>
<dd><p>捕获组的最后一个匹配的整数索引值，或者 <code class="docutils literal notranslate"><span class="pre">None</span></code> 如果没有匹配产生的话。比如，对于字符串 <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>，表达式 <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code>, 和 <code class="docutils literal notranslate"><span class="pre">((ab))</span></code> 将得到 <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code> ， 而 <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> 会得到 <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code> 。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastgroup">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastgroup</span></span></dt>
<dd><p>最后一个匹配的命名组名字，或者 <code class="docutils literal notranslate"><span class="pre">None</span></code> 如果没有产生匹配的话。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.re">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">re</span></span></dt>
<dd><p>返回产生这个实例的 <a class="reference internal" href="#re-objects"><span class="std std-ref">正则对象</span></a> ， 这个实例是由 正则对象的 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 或 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 方法产生的。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.string">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">string</span></span></dt>
<dd><p>传递到 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 或 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 的字符串。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>添加了对 <a class="reference internal" href="copy.xhtml#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> 和 <a class="reference internal" href="copy.xhtml#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 的支持。匹配对象被看作是原子性的。</p>
</div>
</section>
<section id="regular-expression-examples">
<span id="re-examples"></span><h2>正则表达式例子</h2>
<section id="checking-for-a-pair">
<h3>检查对子</h3>
<p>在这个例子里，我们使用以下辅助函数来更好地显示匹配对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p>假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，&quot;a&quot; 就是 A, &quot;k&quot;  K， &quot;q&quot;  Q, &quot;j&quot; J, &quot;t&quot; 为 10, &quot;2&quot; 到 &quot;9&quot; 表示2 到 9。</p>
<p>要看给定的字符串是否有效，我们可以按照以下步骤</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p>最后一手牌，<code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code> ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># Pair of 7s.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># No pairs.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># Pair of aces.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p>要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 <a class="reference internal" href="#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> 方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># Error because re.match() returns None, which doesn&#39;t have a group() method:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="simulating-scanf">
<h3>模拟 scanf()</h3>
<p id="index-40">目前 Python 没有 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 的等价物。 正则表达式通常比 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 格式字符串更强大，但也更冗长。 下表提供了 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 格式符和正则表达式之间一些大致等价的映射。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 形符</p></th>
<th class="head"><p>正则表达式</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p>从文件名和数字提取字符串</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>你应当这样使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 格式</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>等价的正则表达式是：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</section>
<section id="search-vs-match">
<span id="id4"></span><h3>search() vs. match()</h3>
<p>Python 基于正则表达式提供了不同的原始操作:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> 只在字符串的开头位置检测匹配。</p></li>
<li><p><a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> 在字符串中的任何位置检测匹配（这也是 Perl 在默认情况下所做的）</p></li>
<li><p><a class="reference internal" href="#re.fullmatch" title="re.fullmatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.fullmatch()</span></code></a> 检测整个字符串是否匹配</p></li>
</ul>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;p.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 6), match=&#39;python&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;r.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># No match</span>
</pre></div>
</div>
<p>在 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 中，可以用 <code class="docutils literal notranslate"><span class="pre">'^'</span></code> 作为开始来限制匹配到字符串的首位</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p>注意 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 多行模式中函数 <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> 只匹配字符串的开始，但使用 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 和以 <code class="docutils literal notranslate"><span class="pre">'^'</span></code> 开始的正则表达式会匹配每行的开始</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="making-a-phonebook">
<h3>制作一个电话本</h3>
<p><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。</p>
<p>首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p>最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 使用了 <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> 形参，因为地址中包含有被我们作为分割模式的空格符:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">:?</span></code> 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">4</span></code> ，我们还可以从地址中获取到房间号:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</section>
<section id="text-munging">
<h3>文字整理</h3>
<p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 替换字符串中出现的样式的每一个实例。这个例子证明了使用  <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 来整理文字，或者随机化每个字符的位置，除了首位和末尾字符</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs">
<h3>查找所有副词</h3>
<p><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> 匹配样式 <em>所有</em> 的出现，不仅是像 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs-and-their-positions">
<h3>查找所有的副词及其位置</h3>
<p>如果想要获得比匹配文本更多的关于模式的所有匹配信息，则 <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> 会很有用处因为它提供了 <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> 对象而不是字符串。 继续前面的例子，如果某位作者想要查找某段文本中的所有副词 <em>以及它们的位置</em>，可以按以下方式使用 <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</section>
<section id="raw-string-notation">
<h3>原始字符串标记</h3>
<p>原始字符串记法 (<code class="docutils literal notranslate"><span class="pre">r&quot;text&quot;</span></code>) 保持正则表达式正常。否则，每个正则式里的反斜杠(<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) 都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p>当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>。否则就必须用 <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>，来表示同样的意思</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="writing-a-tokenizer">
<h3>写一个词法分析器</h3>
<p>一个 <a class="reference external" href="https://en.wikipedia.org/wiki/Lexical_analysis">词法器或词法分析器</a><span class="link-target"> [https://en.wikipedia.org/wiki/Lexical_analysis]</span> 分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。</p>
<p>文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># Integer or decimal number</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># Assignment operator</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># Statement terminator</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># Identifiers</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># Arithmetic operators</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># Line endings</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># Skip over spaces and tabs</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># Any other character</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> unexpected on line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>该词法器产生以下的输出</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="frie09" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Frie09</a><span class="fn-bracket">]</span></span>
<p>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, 2009. 该书的第三版不再包含 Python，但第一版极详细地覆盖了正则表达式模式串的编写。</p>
</div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>