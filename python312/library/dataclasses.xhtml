<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="dataclasses --- 数据类" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/dataclasses.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源码： Lib/dataclasses.py[https://github.com/python/cpython/tree/3.12/Lib/dataclasses.py] 这个模块提供了一个装饰器和一些函数，用于自动为用户自定义的类添加生成的 特殊方法 例如__init__() 和__repr__() 。 它的初始描述见 PEP 557[https://peps.python.org/pe..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源码： Lib/dataclasses.py[https://github.com/python/cpython/tree/3.12/Lib/dataclasses.py] 这个模块提供了一个装饰器和一些函数，用于自动为用户自定义的类添加生成的 特殊方法 例如__init__() 和__repr__() 。 它的初始描述见 PEP 557[https://peps.python.org/pe..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>dataclasses --- 数据类</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/dataclasses.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-dataclasses">
<span id="dataclasses-data-classes"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code> --- 数据类</h1>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/dataclasses.py">Lib/dataclasses.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/dataclasses.py]</span></p>
<hr class="docutils" />
<p>这个模块提供了一个装饰器和一些函数，用于自动为用户自定义的类添加生成的 <a class="reference internal" href="../glossary.xhtml#term-special-method"><span class="xref std std-term">特殊方法</span></a> 例如 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a>。 它的初始描述见 <span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0557/"><strong>PEP 557</strong></a><span class="link-target"> [https://peps.python.org/pep-0557/]</span>。</p>
<p>在这些生成的方法中使用的成员变量是使用 <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a><span class="link-target"> [https://peps.python.org/pep-0526/]</span> 类型标注来定义的。例如以下代码：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">InventoryItem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for keeping track of an item in inventory.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">unit_price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">total_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_price</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantity_on_hand</span>
</pre></div>
</div>
<p>将添加多项内容，包括如下所示的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unit_price</span> <span class="o">=</span> <span class="n">unit_price</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">quantity_on_hand</span> <span class="o">=</span> <span class="n">quantity_on_hand</span>
</pre></div>
</div>
<p>请注意此方法会自动添加到类中：它不是在如上所示的 <code class="xref py py-class docutils literal notranslate"><span class="pre">InventoryItem</span></code> 定义中直接指定的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<section id="module-contents">
<h2>模块内容</h2>
<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.dataclass">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">dataclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unsafe_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weakref_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此函数是一个 <a class="reference internal" href="../glossary.xhtml#term-decorator"><span class="xref std std-term">decorator</span></a>，它被用于将生成的 <a class="reference internal" href="../glossary.xhtml#term-special-method"><span class="xref std std-term">特殊方法</span></a> 添加到类中，如下所述。</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 装饰器会检查类以找到其中的 <code class="docutils literal notranslate"><span class="pre">field</span></code>。 <code class="docutils literal notranslate"><span class="pre">field</span></code> 被定义为具有 <a class="reference internal" href="../glossary.xhtml#term-variable-annotation"><span class="xref std std-term">类型标注</span></a> 的类变量。 除了下面所述的两个例外，在 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 中没有任何东西会去检查变量标注中指定的类型。</p>
<p>这些字段在所有生成的方法中的顺序，都是它们在类定义中出现的顺序。</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 装饰器将把各种“双下线”方法添加到类，具体如下所述。 如果所添加的任何方法在类中已存在，其行为将取决于形参的值，具体如下所述。 该装饰器将返回执行其调用的类而不会创建新类。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 仅被用作不带形参的简单装饰器，其行为相当于使用在此签名中记录的默认值。 也就是说，这三种 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 的用法是等价的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>

<span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">match_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weakref_slot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 的形参有：</p>
<ul>
<li><p><em>init</em>: 如为真值（默认），将生成 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法。</p>
<p>如果类已经定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>，此形参将被忽略。</p>
</li>
<li><p><em>repr</em>: 如为真值（默认），将生成 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 方法。 生成的 repr 字符串将带有类名及每个字符的名称和 repr，并按它们在类中定义的顺序排列。 不包括被标记为从 repr 排除的字段。 例如: <code class="docutils literal notranslate"><span class="pre">InventoryItem(name='widget',</span> <span class="pre">unit_price=3.0,</span> <span class="pre">quantity_on_hand=10)</span></code>。</p>
<p>如果类已经定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code>，此形参将被忽略。</p>
</li>
<li><p><em>eq</em>: 如为真值（默认），将生成 <a class="reference internal" href="../reference/datamodel.xhtml#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 方法。 此方法将把类当作由其字段组成的元组那样按顺序进行比较。 要比较的两个实例必须是相同的类型。</p>
<p>如果类已经定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>，此形参将被忽略。</p>
</li>
<li><p><em>order</em>: 如为真值 (默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>)，将生成 <a class="reference internal" href="../reference/datamodel.xhtml#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.xhtml#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.xhtml#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 方法。 这些方法将把类当作由其字段组成的元组那样按顺序进行比较。 要比较的两个实例必须是相同的类型。 如果 <em>order</em> 为真值且 <em>eq</em> 为假值，则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果类已经定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code> 或者 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code> 中的任意一个，将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</li>
<li><p><em>unsafe_hash</em>: 如为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (默认值)，则会根据 <em>eq</em> 和 <em>frozen</em> 的设置情况生成 <a class="reference internal" href="../reference/datamodel.xhtml#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法。</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 会在对象被添加到哈希多项集例如字典和集合时由内置的 <a class="reference internal" href="functions.xhtml#hash" title="hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash()</span></code></a> 使用。 具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 就意味着类的实例是不可变的。 可变性是一个依赖于程序员的实际意图、<code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> 是否存在和具体行为，以及 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 装饰器中 <em>eq</em> 和 <em>frozen</em> 旗标值的复杂特征属性。</p>
<p>在默认情况下，<code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 不会隐式地添加 <a class="reference internal" href="../reference/datamodel.xhtml#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法，除非这样做是安全的。 它也没会添加或更改现有的显式定义的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法。 设置类属性 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 对 Python 具有特定含义，如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 文档中所述。</p>
<p>如果 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 没有被显式定义，或者它被设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> <em>可能</em> 会添加一个隐式 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法。 虽然并不推荐，但你可以用 <code class="docutils literal notranslate"><span class="pre">unsafe_hash=True</span></code> 来强制让 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 创建一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法。 如果你的类在逻辑上不可变但却仍然可被修改那么可能就是这种情况一。 这是一个特殊用例并且应当被小心地处理。</p>
<p>以下是针对隐式创建 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法的规则。 请注意你的数据类中不能既有显式的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法又设置 <code class="docutils literal notranslate"><span class="pre">unsafe_hash=True</span></code>；这将导致 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>如果 <em>eq</em> 和 <em>frozen</em> 均为真值，则默认 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 将为你生成 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法。 如果 <em>eq</em> 为真值而 <em>frozen</em> 为假值，则:meth:<cite>!__hash__</cite> 将被设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，即将其标记为不可哈希（因为它属于可变对象）。 如果 <em>eq</em> 为假值，则 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 将保持不变，这意味着将使用超类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法（如果超类是 <a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>，这意味着它将回退为基于 id 的哈希）。</p>
</li>
<li><p><em>frozen</em>: 如为真值 (默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>)，则对字段赋值将引发异常。 这模拟了只读的冻结实例。 如果在类中定义了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.xhtml#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a>，则将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 参见下文的讨论。</p></li>
<li><p><em>match_args</em>: 如为真值 (默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>)，则将根据传给生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法的形参列表来创建 <a class="reference internal" href="../reference/datamodel.xhtml#object.__match_args__" title="object.__match_args__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__match_args__</span></code></a> 元组 (即使没有生成 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>，见上文)。 如为假值，或者如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__match_args__</span></code> 已在类中定义，则不会生成 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__match_args__</span></code>。</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</div></blockquote>
<ul class="simple">
<li><p><em>kw_only</em>: 如为真值 (默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>)，则所有字段都将被标记为仅限关键字的。 如果一个字段被标记为仅限关键字的，则唯一的影响是由仅限关键字的字段生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 的对应形参在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 被调用时必须以关键字形式指定。 而数据类的任何其他行为都不会受影响。 详情参见 <a class="reference internal" href="../glossary.xhtml#term-parameter"><span class="xref std std-term">parameter</span></a> 术语表条目。 另请参阅 <a class="reference internal" href="#dataclasses.KW_ONLY" title="dataclasses.KW_ONLY"><code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code></a> 一节。</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</div></blockquote>
<ul class="simple">
<li><p><em>slots</em>: 如为真值 (默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>)，将会生成 <a class="reference internal" href="../reference/datamodel.xhtml#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 属性并将返回新类而不是原本的类。 如果类中已经定义了 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code>，则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 在数据类中使用 <code class="docutils literal notranslate"><span class="pre">slots=True</span></code> 调用无参数的 <a class="reference internal" href="functions.xhtml#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>  将导致引发以下异常: <code class="docutils literal notranslate"><span class="pre">TypeError:</span> <span class="pre">super(type,</span> <span class="pre">obj):</span> <span class="pre">obj</span> <span class="pre">must</span> <span class="pre">be</span> <span class="pre">an</span> <span class="pre">instance</span> <span class="pre">or</span> <span class="pre">subtype</span> <span class="pre">of</span> <span class="pre">type</span></code>。 可用的绕过方式是调用双参数的 <a class="reference internal" href="functions.xhtml#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>。 请参阅 <a class="reference external" href="https://github.com/python/cpython/issues/90562">gh-90562</a><span class="link-target"> [https://github.com/python/cpython/issues/90562]</span> 了解完整细节。</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>如果某个字段名称已经包括在基类的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 中，它将不会被包括在生成的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 中以防止 <a class="reference internal" href="../reference/datamodel.xhtml#datamodel-note-slots"><span class="std std-ref">重写它们</span></a>。 因此，请不要使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 来获取数据类的字段名称。 而应改用 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a>。 为了能够确定所继承的槽位，基类 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 可以是任意可迭代对象，但是 <em>不可以</em> 是迭代器。an iterator.</p>
</div>
</div></blockquote>
<ul class="simple">
<li><p><em>weakref_slot</em>: 如为真值 (默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>)，则添加一个名为 &quot;__weakref__&quot; 的槽位，这是使得一个实例可以被弱引用所必需的。 指定 <code class="docutils literal notranslate"><span class="pre">weakref_slot=True</span></code> 而不同时指定 <code class="docutils literal notranslate"><span class="pre">slots=True</span></code> 将会导致错误。</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</div></blockquote>
<p>可以用普通的 Python 语法为各个 <code class="docutils literal notranslate"><span class="pre">field</span></code> 指定默认值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>       <span class="c1"># &#39;a&#39; has no default value</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># assign a default value for &#39;b&#39;</span>
</pre></div>
</div>
<p>在这个例子中，<code class="xref py py-attr docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">b</span></code> 都将被包括在所添加的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法中，该方法将被定义为:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>如果在具有默认值的字段之后存在没有默认值的字段，将会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。无论此情况是发生在单个类中还是作为类继承的结果，都是如此。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.field">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MISSING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MISSING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compare</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metadata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MISSING</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>对于常见和简单的用例，不需要其他的功能。 但是，有些数据类的特性需要额外的每字段信息。 为了满足这种对额外信息的需求，你可以通过调用所提供的 <code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code> 函数来替换默认的字段值。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">mylist</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>如上所示，<a class="reference internal" href="#dataclasses.MISSING" title="dataclasses.MISSING"><code class="xref py py-const docutils literal notranslate"><span class="pre">MISSING</span></code></a> 值是一个哨兵对象，用于检测一些形参是否由用户提供。使用它是因为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 对于一些形参来说是有效的用户值。任何代码都不应该直接使用 <a class="reference internal" href="#dataclasses.MISSING" title="dataclasses.MISSING"><code class="xref py py-const docutils literal notranslate"><span class="pre">MISSING</span></code></a> 值。</p>
<p>传给 <code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code> 的形参有：</p>
<ul>
<li><p><em>default</em>: 如果提供，这将为该字段的默认值。 设置此形参是因为 <code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code> 调用本身会替换通常的默认值所在位置。</p></li>
<li><p><em>default_factory</em>: 如果提供，它必须是一个零参数的可调用对象，它将在该字段需要一个默认值时被调用。 在其他目的以外，它还可被用于指定具有可变默认值的字段，如下所述。 同时指定 <em>default</em> 和 <em>default_factory</em> 将会导致错误。</p></li>
<li><p><em>init</em>: 如为真值（默认），则该字段将作为一个形参被包括在生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法中。</p></li>
<li><p><em>repr</em>: 如为真值（默认值），则该字段将被包括在生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 方法所返回的字符串中。</p></li>
<li><p><em>hash</em>: 这可以是一个布尔值或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如为真值，则此字段将被包括在生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法中。 如果为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (默认)，则将使用 <em>compare</em> 的值：这通常是预期的行为。 一个字段如果被用于比较那么就应当在哈希时考虑到它。 不建议将该值设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 以外的任何其他值。</p>
<p>设置 <code class="docutils literal notranslate"><span class="pre">hash=False</span></code> 但 <code class="docutils literal notranslate"><span class="pre">compare=True</span></code> 的一个合理情况是，一个计算哈希值的代价很高的字段是检验等价性需要的，且还有其他字段可以用于计算类型的哈希值。可以从哈希值中排除该字段，但仍令它用于比较。</p>
</li>
<li><p><em>compare</em>: 如为真值（默认），则该字段将被包括在生成的相等和比较方法中 (<a class="reference internal" href="../reference/datamodel.xhtml#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.xhtml#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 等等)。</p></li>
<li><p><em>metadata</em>: 这可以是一个映射或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将被当作空字典来处理。 这个值将被包装在 <a class="reference internal" href="types.xhtml#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-func docutils literal notranslate"><span class="pre">MappingProxyType()</span></code></a> 以便其为只读，并暴露在 <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 对象上。 它完全不被数据类所使用，并且是作为第三方扩展机制提供的。 多个第三方可以各自拥有其本身的键，以用作元数据的命名空间。</p></li>
<li><p><em>kw_only</em>: 如为真值，则该字段将被标记为仅限关键字的。 这将在计算所生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法的形参时被使用。</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</div></blockquote>
<p>如果通过对 <code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code> 的调用来指定字段的默认值，那么该字段对应的类属性将被替换为指定的 <em>default</em> 值。 如果没有提供 <em>default</em>，那么该类属性将被删除。 其意图是在 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 装饰器运行之后，该类属性将包含所有字段的默认值，就像直接指定了默认值本身一样。 例如，在执行以下代码之后:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>
</div>
<p>类属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">C.z</span></code> 将为 <code class="docutils literal notranslate"><span class="pre">10</span></code>，类属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">C.t</span></code> 将为 <code class="docutils literal notranslate"><span class="pre">20</span></code>，类属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">C.x</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">C.y</span></code> 将不被设置。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dataclasses.Field">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">Field</span></span></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code> 对象描述每个已定义的字段。 这些对象是在内部创建的，并会由 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 模块块方法返回（见下文）。 用户绝不应直接实例化 <code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code> 对象。 已写入文档的属性如下：</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code>: 字段的名称。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">type</span></code>: 字段的类型。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">default_factory</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">init</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">repr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">hash</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">compare</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">metadata</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">kw_only</span></code> 具有与 <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 函数中对应参数相同的含义和值。</p></li>
</ul>
<p>可能存在其他属性，但它们是私有的。用户不应检查或依赖于这些属性。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.fields">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">fields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_or_instance</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个能描述此数据类所包含的字段的元组，元组的每一项都是 <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 对象。接受数据类或数据类的实例。如果没有传递一个数据类或实例将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。不返回 <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> 或 <code class="docutils literal notranslate"><span class="pre">InitVar</span></code> 等伪字段。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.asdict">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">asdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">dict</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将数据类 <em>obj</em> 转换为一个字典 (使用工厂函数 <em>dict_factory</em>)。 每个数据类会被转换为以 <code class="docutils literal notranslate"><span class="pre">name:</span> <span class="pre">value</span></code> 键值对来存储其字段的字典。 数据类、字典、列表和元组会被递归地处理。 其他对象会通过 <a class="reference internal" href="copy.xhtml#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 来拷贝。</p>
<p>在嵌套的数据类上使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">asdict()</span></code> 的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
     <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
     <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
     <span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">asdict</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">([</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="k">assert</span> <span class="n">asdict</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;mylist&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}]}</span>
</pre></div>
</div>
<p>要创建一个浅拷贝，可以使用以下的变通方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span>
</pre></div>
</div>
<p>如果 <em>obj</em> 不是一个数据类实例则 <code class="xref py py-func docutils literal notranslate"><span class="pre">asdict()</span></code> 将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.astuple">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">astuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tuple_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将数据类 <em>obj</em> 转换为元组 (使用工厂函数 <em>tuple_factory</em>)。 每个数据类将被转换为由其字段值组成的元组。 数据类、字典、列表和元组会被递归地处理。 其他对象会通过 <a class="reference internal" href="copy.xhtml#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 来拷贝。</p>
<p>继续前一个例子：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">astuple</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">astuple</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],)</span>
</pre></div>
</div>
<p>要创建一个浅拷贝，可以使用以下的变通方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</pre></div>
</div>
<p>如果 <em>obj</em> 不是一个数据类实例则 <code class="xref py py-func docutils literal notranslate"><span class="pre">astuple()</span></code> 将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.make_dataclass">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">make_dataclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unsafe_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weakref_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>新建一个名为 <em>cls_name</em> 的数据类，其字段在 <em>fields</em> 中定义，其基类在 <em>bases</em> 中给出，并使用在 <em>namespace</em> 中给定的命名空间来初始化。 <em>fields</em> 是一个可迭代对象，其中每个元素均为 <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">type)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">type,</span> <span class="pre">Field)</span></code> 的形式。 如果只提供了 <code class="docutils literal notranslate"><span class="pre">name</span></code>，则使用 <a class="reference internal" href="typing.xhtml#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Any</span></code></a> 作为 <code class="docutils literal notranslate"><span class="pre">type</span></code>。 <em>init</em>, <em>repr</em>, <em>eq</em>, <em>order</em>, <em>unsafe_hash</em>, <em>frozen</em>, <em>match_args</em>, <em>kw_only</em>, <em>slots</em> 和 <em>weakref_slot</em> 值的含义与 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 中的同名参数一致。</p>
<p>如果定义了 <em>module</em>，则该数据类的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 属性将被设为该值。 在默认情况下，它将被设为调用方的模块名。</p>
<p>此函数不是必需的，因为任何用于创建带有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 的新类的 Python 机制都可以进一步用 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 函数将创建的类转换为数据类。 提供此函数是为了方便。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                   <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                     <span class="s1">&#39;y&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">))],</span>
                   <span class="n">namespace</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;add_one&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
</pre></div>
</div>
<p>等价于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="s1">&#39;typing.Any&#39;</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.replace">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">changes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个与 <em>obj</em> 类型相同的新对象，将字段替换为 <em>changes</em> 的值。 如果 <em>obj</em> 不是数据类，则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 如果 <em>changes</em> 中的键不是给定数据类的字段名，则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>新返回的对象是通过调用数据类的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法来创建的。 这确保了如果存在 <a class="reference internal" href="#dataclasses.__post_init__" title="dataclasses.__post_init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code></a>，则它也会被调用。</p>
<p>如果存在任何没有默认值的仅初始化变量，那么必须在调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code> 时指定它们的值，以便它们可以被传递给 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 和 <a class="reference internal" href="#dataclasses.__post_init__" title="dataclasses.__post_init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code></a>。</p>
<p>如果 <em>changes</em> 包含被任何定义为 defined as having <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 的字段都会导致错误。 在此情况下将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>需要预先注意 <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 字段在对 <code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code> 的调用期间的行为。 如果它们会被初始化，它们就不会从源对象拷贝，而是在 <a class="reference internal" href="#dataclasses.__post_init__" title="dataclasses.__post_init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code></a> 中初始化。 通常预期 <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 字段将很少能被正确地使用。 如果要使用它们，那么更明智的做法是使用另外的类构造器，或者自定义的 <code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code> (或类似名称) 方法来处理实例的拷贝。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.is_dataclass">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">is_dataclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if its parameter is a dataclass (including subclasses of a
dataclass) or an instance of one, otherwise return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>如果你需要知道一个类是否是一个数据类的实例（而不是一个数据类本身），那么再添加一个 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> 检查：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_dataclass_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">is_dataclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dataclasses.MISSING">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">MISSING</span></span></dt>
<dd><p>一个指明“没有提供 default 或 default_factory”的监视值。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="dataclasses.KW_ONLY">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">KW_ONLY</span></span></dt>
<dd><p>一个用途类型标的监视值。 任何在伪字段之后的类型为 <code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code> 的字段会被标记为仅限关键字的字段。 请注意在其他情况下 <code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code> 类型的伪字段会被完全忽略。 这包括此类字段的名称。 根据惯例，名称 <code class="docutils literal notranslate"><span class="pre">_</span></code> 会被用作 <code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code> 字段。 仅限关键字字段指明当类被实例化时 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 形参必须以关键字形式来指定。</p>
<p>在这个例子中，字段 <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code> 将被标记为仅限关键字字段:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">KW_ONLY</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>在单个数据类中，指定一个以上 <code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code> 类型的字段将导致错误。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="dataclasses.FrozenInstanceError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">FrozenInstanceError</span></span></dt>
<dd><p>在定义时设置了 <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> 的类上调用隐式定义的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.xhtml#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 时引发。 这是 <a class="reference internal" href="exceptions.xhtml#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 的一个子类。</p>
</dd></dl>

</section>
<section id="post-init-processing">
<span id="id1"></span><h2>初始化后处理</h2>
<dl class="py function">
<dt class="sig sig-object py" id="dataclasses.__post_init__">
<span class="sig-prename descclassname"><span class="pre">dataclasses.</span></span><span class="sig-name descname"><span class="pre">__post_init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>当在类上定义时，它将被所生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 调用，通常是以 <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.__post_init__()</span></code> 的形式。 但是，如果定义了任何 <code class="docutils literal notranslate"><span class="pre">InitVar</span></code> 字段，它们也将按照它们在类中定义的顺序被传递给 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>。 如果没有生成 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法，那么 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 将不会被自动调用。</p>
<p>在其他用途中，这允许初始化依赖于一个或多个其他字段的字段值。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
</dd></dl>

<p>由 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法不会调用基类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法。 如果基类有必须被调用的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法，通常是在 <a class="reference internal" href="#dataclasses.__post_init__" title="dataclasses.__post_init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code></a> 方法中调用此方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rectangle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">):</span>
    <span class="n">side</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">side</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span><span class="p">)</span>
</pre></div>
</div>
<p>但是，请注意一般来说数据类生成的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法不需要被调用，因为派生的数据类将负责初始化任何本身为数据类的基类的所有字段。</p>
<p>请参阅下面有关仅初始化变量的小节来了解如何将形参传递给 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>。 另请参阅关于 <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a> 如何处理 <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 字段的警告。</p>
</section>
<section id="class-variables">
<span id="dataclasses-class-variables"></span><h2>类变量</h2>
<p>少数几个 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 会实际检查字段类型的地方之一是确定字段是否为如 <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a><span class="link-target"> [https://peps.python.org/pep-0526/]</span> 所定义的类变量。 它通过检查字段的类型是否为 <a class="reference internal" href="typing.xhtml#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.ClassVar</span></code></a> 来实现这一点。 如果一个字段是 <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code>，它将被排除在考虑范围之外并被数据类机制所忽略。 这样的 <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> 伪字段将不会被模块层级的 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 函数返回。</p>
</section>
<section id="init-only-variables">
<span id="dataclasses-init-only-variables"></span><h2>仅初始化变量</h2>
<p>另一个 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 会检查类型标注的地方是为了确定一个字段是否为仅限初始化的变量。 这通过检查字段的类型是否为 <code class="docutils literal notranslate"><span class="pre">dataclasses.InitVar</span></code> 来实现这一点。 如果一个字段是 <code class="docutils literal notranslate"><span class="pre">InitVar</span></code>，它会被当作是被称为仅限初始化字段的伪字段。 因为它不是一个真正的字段，所以它不会被模块层级的 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 函数返回。 仅限初始化字段会作为形参被添加到所生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法中，并被传递给可选的 <a class="reference internal" href="#dataclasses.__post_init__" title="dataclasses.__post_init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code></a> 方法。 在其他情况下它们将不会被数据类所使用。</p>
<p>例如，假设在创建类时没有为某个字段提供值，初始化时将从数据库中取值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">j</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">database</span><span class="p">:</span> <span class="n">InitVar</span><span class="p">[</span><span class="n">DatabaseType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="n">my_database</span><span class="p">)</span>
</pre></div>
</div>
<p>在这种情况下，<a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 将返回 <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 作为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">i</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">j</span></code>，但不包括 <code class="xref py py-attr docutils literal notranslate"><span class="pre">database</span></code>。</p>
</section>
<section id="frozen-instances">
<span id="dataclasses-frozen"></span><h2>冻结的实例</h2>
<p>创建真正不可变的 Python 对象是不可能的。 但是，你可以通过将 <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> 传递给 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 装饰器来模拟出不可变性。 在这种情况下，数据类将向类添加 <a class="reference internal" href="../reference/datamodel.xhtml#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 方法。 当被发起调用时这些方法将会引发 <a class="reference internal" href="#dataclasses.FrozenInstanceError" title="dataclasses.FrozenInstanceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FrozenInstanceError</span></code></a>。</p>
<p>在使用 <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> 时会有微小的性能损失: <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 不能使用简单赋值来初始化字段，而必须使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__setattr__()</span></code>。</p>
</section>
<section id="inheritance">
<span id="dataclasses-inheritance"></span><h2>继承</h2>
<p>当数据类由 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 装饰器创建时，它会按反向 MRO 顺序（也就是说，从 <a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 开始）查看它的所有基类，并将找到的每个数据类的字段添加到一个有序映射中。 所有生成的方法都将使用这个有序映射。 字段会遵守它们被插入的顺序，因此派生类会重写基类。 一个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div>
</div>
<p>最终的字段列表依次是 <code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">z</span></code>。 最终的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code> 类型是 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>，正如类 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 中所指定的。</p>
<p>为 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 生成的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法看起来像是这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
</pre></div>
</div>
</section>
<section id="re-ordering-of-keyword-only-parameters-in-init">
<h2><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 中仅限关键字形参的重新排序</h2>
<p>在计算出 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 所需要的形参之后，任何仅限关键字形参会被移至所有常规（非仅限关键字）形参的后面。 这是 Python 中实现仅限关键字形参所要求的：它们必须位于非仅限关键字形参之后。</p>
<p>在这个例子中，<code class="xref py py-attr docutils literal notranslate"><span class="pre">Base.y</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">Base.w</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">D.t</span></code> 是仅限关键字字段，而 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Base.x</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">D.z</span></code> 是常规字段:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">KW_ONLY</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">w</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>为 <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code> 生成的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法看起来像是这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>请注意形参原来在字段列表中出现的位置已被重新排序：前面是来自常规字段的形参而后面是来自仅限关键字字段的形参。</p>
<p>仅限关键字形参的相对顺序会在重新排序的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 列表中保持不变。</p>
</section>
<section id="default-factory-functions">
<h2>默认工厂函数</h2>
<p>如果一个 <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 指定了 <em>default_factory</em>，它将在该字段需要默认值时不带参数地被调用。 例如，要创建一个列表的新实例，则使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
</pre></div>
</div>
<p>如果一个字段被排除在 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 之外 (使用 <code class="docutils literal notranslate"><span class="pre">init=False</span></code>) 并且该字段还指定了 <em>default_factory</em>，则默认的工厂函数将总是会从生成的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 函数中被调用。 发生这种情况是因为没有其他方式能为字段提供初始值。</p>
</section>
<section id="mutable-default-values">
<h2>可变的默认值</h2>
<p>Python 在类属性中存储默认成员变量值。思考这个例子，不使用数据类:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">o1</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o2</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">o2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">o1</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">o1</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="n">o2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>请注意类 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 的两个实例将共享同一个类变量 <code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code>，正如预期的那样。</p>
<p>使用数据类，<em>如果</em> 此代码有效：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># This code raises ValueError</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre></div>
</div>
<p>它生成的代码类似于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>这具有与使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 类的原始示例相同的问题。 也就是说，当创建类实例时如果 <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code> 类的两个实例没有为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code> 指定值则将共享同一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code> 的副本。 因为数据类只是使用普通的 Python 类创建方式所以它们也会共享此行为。 数据类没有任何通用方式来检测这种情况。 相反地，<a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 装饰器在检测到不可哈希的默认形参时将会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 这一行为假定如果一个值是不可哈希的，则它就是可变对象。 这是一个部分解决方案，但它确实能防止许多常见错误。</p>
<p>使用默认工厂函数是一种创建可变类型新实例的方法，并将其作为字段的默认值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>现在不再是寻找并阻止使用类型为 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 的对象，而是不允许将不可哈希的对象用作默认值。 就是不可哈希性被作为不可变性的近似物了。</p>
</div>
</section>
<section id="descriptor-typed-fields">
<h2>描述器类型的字段</h2>
<p>当字段被 <a class="reference internal" href="../reference/datamodel.xhtml#descriptors"><span class="std std-ref">描述器对象</span></a> 赋值为默认值时会遵循以下行为:</p>
<ul class="simple">
<li><p>传递给数据类的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法的字段值会被传递给描述器的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 方法而不会覆盖描述器对象。</p></li>
<li><p>类似地，当获取或设置字段值时，将调用描述器的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> 方法而不是返回或重写描述器对象。</p></li>
<li><p>为了确定一个字段是否包含默认值，<a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass</span></code></a> 会使用类访问形式调用描述器的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> 方法: <code class="docutils literal notranslate"><span class="pre">descriptor.__get__(obj=None,</span> <span class="pre">type=cls)</span></code>。 如果在此情况下描述器返回了一个值，它将被用作字段的默认值。 另一方面，如果在此情况下描述器引发了 <a class="reference internal" href="exceptions.xhtml#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>，则不会为字段提供默认值。</p></li>
</ul>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IntConversionDescriptor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">InventoryItem</span><span class="p">:</span>
    <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="n">IntConversionDescriptor</span> <span class="o">=</span> <span class="n">IntConversionDescriptor</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">InventoryItem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">quantity_on_hand</span><span class="p">)</span>   <span class="c1"># 100</span>
<span class="n">i</span><span class="o">.</span><span class="n">quantity_on_hand</span> <span class="o">=</span> <span class="mf">2.5</span>    <span class="c1"># calls __set__ with 2.5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">quantity_on_hand</span><span class="p">)</span>   <span class="c1"># 2</span>
</pre></div>
</div>
<p>若一个字段的类型是描述器，但其默认值并不是描述器对象，那么该字段只会像普通的字段一样工作。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>