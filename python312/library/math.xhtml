<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="math --- 数学函数" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/math.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="该模块提供了对C标准定义的数学函数的访问。 这些函数不适用于复数；如果你需要计算复数，请使用 cmath 模块中的同名函数。将支持计算复数的函数区分开的目的，来自于大多数开发者并不愿意像数学家一样需要学习复数的概念。得到一个异常而不是一个复数结果使得开发者能够更早地监测到传递给这些函数的参数中包含复数，进而调查其产生的原因。 该模块提供了以下函数。除非另有明确说明，否则所有返回值均为浮点数。..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="该模块提供了对C标准定义的数学函数的访问。 这些函数不适用于复数；如果你需要计算复数，请使用 cmath 模块中的同名函数。将支持计算复数的函数区分开的目的，来自于大多数开发者并不愿意像数学家一样需要学习复数的概念。得到一个异常而不是一个复数结果使得开发者能够更早地监测到传递给这些函数的参数中包含复数，进而调查其产生的原因。 该模块提供了以下函数。除非另有明确说明，否则所有返回值均为浮点数。..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>math --- 数学函数</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/math.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-math">
<span id="math-mathematical-functions"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code> --- 数学函数</h1>
<hr class="docutils" />
<p>该模块提供了对C标准定义的数学函数的访问。</p>
<p>这些函数不适用于复数；如果你需要计算复数，请使用 <a class="reference internal" href="cmath.xhtml#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块中的同名函数。将支持计算复数的函数区分开的目的，来自于大多数开发者并不愿意像数学家一样需要学习复数的概念。得到一个异常而不是一个复数结果使得开发者能够更早地监测到传递给这些函数的参数中包含复数，进而调查其产生的原因。</p>
<p>该模块提供了以下函数。除非另有明确说明，否则所有返回值均为浮点数。</p>
<section id="number-theoretic-and-representation-functions">
<h2>数论与表示函数</h2>
<dl class="py function">
<dt class="sig sig-object py" id="math.ceil">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">ceil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的向上取整，即大于或等于 <em>x</em> 的最小的整数。如果 <em>x</em> 不是浮点数，委托给 <a class="reference internal" href="../reference/datamodel.xhtml#object.__ceil__" title="object.__ceil__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__ceil__</span></code></a> ，它应该返回一个 <a class="reference internal" href="numbers.xhtml#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> 的值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.comb">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">comb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回不重复且无顺序地从 <em>n</em> 项中选择 <em>k</em> 项的方式总数。</p>
<p>当 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> 时取值为 <code class="docutils literal notranslate"><span class="pre">n!</span> <span class="pre">/</span> <span class="pre">(k!</span> <span class="pre">*</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">k)!)</span></code>；当 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">n</span></code> 时取值为零。</p>
<p>也称为二项式系数，因为它等价于 <code class="docutils literal notranslate"><span class="pre">(1</span> <span class="pre">+</span> <span class="pre">x)ⁿ</span></code> 的多项式展开中第 k 项的系数。</p>
<p>如果任一参数不为整数则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 如果任一参数为负数则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.copysign">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">copysign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个基于 <em>x</em> 的绝对值和 <em>y</em> 的符号的浮点数。在支持带符号零的平台上，<code class="docutils literal notranslate"><span class="pre">copysign(1.0,</span> <span class="pre">-0.0)</span></code> 返回 <em>-1.0</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.fabs">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">fabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的绝对值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.factorial">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">factorial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <em>n</em> 的阶乘作为整数返回。 如果 <em>n</em> 不是正数或为负值则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span>接受具有整数值的浮点数 (例如 <code class="docutils literal notranslate"><span class="pre">5.0</span></code>) 的行为已被弃用。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.floor">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">floor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的向下取整，小于或等于 <em>x</em> 的最大整数。如果 <em>x</em> 不是浮点数，则委托给 <a class="reference internal" href="../reference/datamodel.xhtml#object.__floor__" title="object.__floor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__floor__</span></code></a> ，它应返回一个 <a class="reference internal" href="numbers.xhtml#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> 值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.fmod">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">fmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">fmod(x,</span> <span class="pre">y)</span></code> ，由平台C库定义。请注意，Python表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 可能不会返回相同的结果。C标准的目的是 <code class="docutils literal notranslate"><span class="pre">fmod(x,</span> <span class="pre">y)</span></code> 完全（数学上；到无限精度）等于 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">n*y</span></code> 对于某个整数 <em>n</em> ，使得结果具有 与 <em>x</em> 相同的符号和小于 <code class="docutils literal notranslate"><span class="pre">abs(y)</span></code> 的幅度。Python的 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 返回带有 <em>y</em> 符号的结果，并且可能不能完全计算浮点参数。 例如， <code class="docutils literal notranslate"><span class="pre">fmod(-1e-100,</span> <span class="pre">1e100)</span></code> 是 <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> ，但Python的 <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> 的结果是 <code class="docutils literal notranslate"><span class="pre">1e100-1e-100</span></code> ，它不能完全表示为浮点数，并且取整为令人惊讶的 <code class="docutils literal notranslate"><span class="pre">1e100</span></code> 。 出于这个原因，函数 <a class="reference internal" href="#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">fmod()</span></code></a> 在使用浮点数时通常是首选，而Python的 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 在使用整数时是首选。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.frexp">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">frexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>以 <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">e)</span></code> 对的形式返回 <em>x</em> 的尾数和指数。 <em>m</em> 是一个浮点数， <em>e</em> 是一个整数，正好是 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">m</span> <span class="pre">*</span> <span class="pre">2**e</span></code> 。 如果 <em>x</em> 为零，则返回 <code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0)</span></code> ，否则返回 <code class="docutils literal notranslate"><span class="pre">0.5</span> <span class="pre">&lt;=</span> <span class="pre">abs(m)</span> <span class="pre">&lt;</span> <span class="pre">1</span></code> 。这用于以可移植方式“分离”浮点数的内部表示。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.fsum">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">fsum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中的值的精确浮点总计值。 通过跟踪多个中间部分和来避免精度损失。</p>
<p>该算法的准确性取决于IEEE-754算术保证和舍入模式为半偶的典型情况。在某些非Windows版本中，底层C库使用扩展精度添加，并且有时可能会使中间和加倍，导致它在最低有效位中关闭。</p>
<p>For further discussion and two alternative approaches, see the <a class="reference external" href="https://code.activestate.com/recipes/393090-binary-floating-point-summation-accurate-to-full-p/">ASPN cookbook
recipes for accurate floating point summation</a><span class="link-target"> [https://code.activestate.com/recipes/393090-binary-floating-point-summation-accurate-to-full-p/]</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.gcd">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">gcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">integers</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回给定的整数参数的最大公约数。 如果有一个参数非零，则返回值将是能同时整除所有参数的最大正整数。 如果所有参数为零，则返回值为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 不带参数的 <code class="docutils literal notranslate"><span class="pre">gcd()</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>添加了对任意数量的参数的支持。 之前的版本只支持两个参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.isclose">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">isclose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>根据给定的绝对和相对容差确定两个值是否被认为是接近的。</p>
<p><em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code class="docutils literal notranslate"><span class="pre">rel_tol=0.05</span></code> 。默认容差为 <code class="docutils literal notranslate"><span class="pre">1e-09</span></code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。</p>
<p><em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。</p>
<p>如果没有错误发生，结果将是： <code class="docutils literal notranslate"><span class="pre">abs(a-b)</span> <span class="pre">&lt;=</span> <span class="pre">max(rel_tol</span> <span class="pre">*</span> <span class="pre">max(abs(a),</span> <span class="pre">abs(b)),</span> <span class="pre">abs_tol)</span></code> 。</p>
<p>IEEE 754特殊值 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> ， <code class="docutils literal notranslate"><span class="pre">inf</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-inf</span></code> 将根据IEEE规则处理。具体来说， <code class="docutils literal notranslate"><span class="pre">NaN</span></code> 不被认为接近任何其他值，包括 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> 。 <code class="docutils literal notranslate"><span class="pre">inf</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-inf</span></code> 只被认为接近自己。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0485/"><strong>PEP 485</strong></a><span class="link-target"> [https://peps.python.org/pep-0485/]</span> —— 用于测试近似相等的函数</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.isfinite">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">isfinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>x</em> 既不是无穷大也不是NaN，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。 （注意 <code class="docutils literal notranslate"><span class="pre">0.0</span></code> 被认为 <em>是</em> 有限的。）</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.isinf">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">isinf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>x</em> 是正或负无穷大，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.isnan">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">isnan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>x</em> 是 NaN（不是数字），则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.isqrt">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">isqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回非负整数 <em>n</em> 的整数平方根。 这就是对 <em>n</em> 的实际平方根向下取整，或者相当于使得 <em>a</em>² ≤ <em>n</em> 的最大整数 <em>a</em>。</p>
<p>对于某些应用来说，可以更适合取值为使得 <em>n</em> ≤ <em>a</em>² 的最小整数 <em>a</em> ，或者换句话说就是 <em>n</em> 的实际平方根向上取整。 对于正数 <em>n</em>，这可以使用 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">isqrt(n</span> <span class="pre">-</span> <span class="pre">1)</span></code> 来计算。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.lcm">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">lcm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">integers</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回给定的整数参数的最小公倍数。 如果所有参数均非零，则返回值将是为所有参数的整数倍的最小正整数。 如果参数之一为零，则返回值为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 不带参数的 <code class="docutils literal notranslate"><span class="pre">lcm()</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.ldexp">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">ldexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">(2**i)</span></code> 。 这基本上是函数  <a class="reference internal" href="#math.frexp" title="math.frexp"><code class="xref py py-func docutils literal notranslate"><span class="pre">frexp()</span></code></a>  的反函数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.modf">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">modf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的小数和整数部分。两个结果都带有 <em>x</em> 的符号并且是浮点数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.nextafter">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">nextafter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回从 <em>x</em> 到 <em>y</em> 的步数的浮点值 <em>steps</em>。</p>
<p>如果 <em>x</em> 等于 <em>y</em>，则返回 <em>y</em>，除非 <em>steps</em> 值为零。</p>
<p>示例：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">math.nextafter(x,</span> <span class="pre">math.inf)</span></code> 的方向朝上：趋向于正无穷。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">math.nextafter(x,</span> <span class="pre">-math.inf)</span></code> 的方向朝下：趋向于负无穷。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">math.nextafter(x,</span> <span class="pre">0.0)</span></code> 趋向于零。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">math.nextafter(x,</span> <span class="pre">math.copysign(math.inf,</span> <span class="pre">x))</span></code> 趋向于零的反方向。</p></li>
</ul>
<p>另请参阅 <a class="reference internal" href="#math.ulp" title="math.ulp"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.ulp()</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>增加了 <em>steps</em> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.perm">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">perm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回不重复且有顺序地从 <em>n</em> 项中选择 <em>k</em> 项的方式总数。</p>
<p>当 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> 时取值为 <code class="docutils literal notranslate"><span class="pre">n!</span> <span class="pre">/</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">k)!</span></code>；当 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">n</span></code> 时取值为零。</p>
<p>If <em>k</em> is not specified or is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then <em>k</em> defaults to <em>n</em>
and the function returns <code class="docutils literal notranslate"><span class="pre">n!</span></code>.</p>
<p>如果任一参数不为整数则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 如果任一参数为负数则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.prod">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">prod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>计算输入的 <em>iterable</em> 中所有元素的积。 积的默认 <em>start</em> 值为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p>当可迭代对象为空时，返回起始值。 此函数特别针对数字值使用，并会拒绝非数字类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.remainder">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">remainder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 IEEE 754 风格的 <em>x</em> 相对于 <em>y</em> 的余数。对于有限 <em>x</em> 和有限非零 <em>y</em> ，这是差异 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">n*y</span></code> ，其中 <code class="docutils literal notranslate"><span class="pre">n</span></code> 是与商 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 的精确值最接近的整数。如果 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 恰好位于两个连续整数之间，则将最接近的 <em>偶数</em> 用作 <code class="docutils literal notranslate"><span class="pre">n</span></code> 。 余数 <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">remainder(x,</span> <span class="pre">y)</span></code> 因此总是满足 <code class="docutils literal notranslate"><span class="pre">abs(r)</span> <span class="pre">&lt;=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">abs(y)</span></code>。</p>
<p>特殊情况遵循IEEE 754：特别是 <code class="docutils literal notranslate"><span class="pre">remainder(x,</span> <span class="pre">math.inf)</span></code> 对于任何有限 <em>x</em> 都是 <em>x</em> ，而 <code class="docutils literal notranslate"><span class="pre">remainder(x,</span> <span class="pre">0)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">remainder(math.inf,</span> <span class="pre">x)</span></code> 引发  <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 适用于任何非NaN的 <em>x</em> 。如果余数运算的结果为零，则该零将具有与 <em>x</em> 相同的符号。</p>
<p>在使用IEEE 754二进制浮点的平台上，此操作的结果始终可以完全表示：不会引入舍入错误。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.sumprod">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">sumprod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>两个可迭代对象 <em>p</em> 和 <em>q</em> 中的值的乘积的总计值。</p>
<p>如果输入值的长度不相等则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>大致相当于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
</pre></div>
</div>
<p>对于浮点数或混合整数/浮点数的输入，中间的乘积和总计值将使用扩展精度来计算。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.trunc">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">trunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回去除小数部分的 <em>x</em> ，只留下整数部分。 这样就可以四舍五入到0了： <code class="docutils literal notranslate"><span class="pre">trunc()</span></code> 对于正的 <em>x</em> 相当于 <a class="reference internal" href="#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> ，对于负的 <em>x</em> 相当于 <a class="reference internal" href="#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> 。如果 <em>x</em> 不是浮点数，委托给 <a class="reference internal" href="../reference/datamodel.xhtml#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.__trunc__</span></code></a> ，它应该返回一个 <a class="reference internal" href="numbers.xhtml#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> 值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.ulp">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">ulp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回浮点数 <em>x</em> 的最小有效比特位的值:</p>
<ul class="simple">
<li><p>如果 <em>x</em> 是 NaN (非数字)，则返回 <em>x</em>。</p></li>
<li><p>如果 <em>x</em> 为负数，则返回 <code class="docutils literal notranslate"><span class="pre">ulp(-x)</span></code>。</p></li>
<li><p>如果 <em>x</em> 为正数，则返回 <em>x</em>。</p></li>
<li><p>如果 <em>x</em> 等于零，则返回 <em>去正规化的</em> 可表示最小正浮点数 (小于 <em>正规化的</em> 最小正浮点数 <a class="reference internal" href="sys.xhtml#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info.min</span></code></a>)。</p></li>
<li><p>如果 <em>x</em> 等于可表示最大正浮点数，则返回 <em>x</em> 的最低有效比特位的值，使得小于 <em>x</em> 的第一个浮点数为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">ulp(x)</span></code>。</p></li>
<li><p>在其他情况下 (<em>x</em> 是一个有限的正数)，则返回 <em>x</em> 的最低有效比特位的值，使得大于 <em>x</em> 的第一个浮点数为 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">ulp(x)</span></code>。</p></li>
</ul>
<p>ULP 即 &quot;Unit in the Last Place&quot; 的缩写。</p>
<p>另请参阅 <a class="reference internal" href="#math.nextafter" title="math.nextafter"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.nextafter()</span></code></a> 和 <a class="reference internal" href="sys.xhtml#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info.epsilon</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<p>注意 <a class="reference internal" href="#math.frexp" title="math.frexp"><code class="xref py py-func docutils literal notranslate"><span class="pre">frexp()</span></code></a> 和 <a class="reference internal" href="#math.modf" title="math.modf"><code class="xref py py-func docutils literal notranslate"><span class="pre">modf()</span></code></a> 具有与它们的C等价函数不同的调用/返回模式：它们采用单个参数并返回一对值，而不是通过 '输出形参' 返回它们的第二个返回参数（Python中没有这样的东西）。</p>
<p>对于 <a class="reference internal" href="#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> ， <a class="reference internal" href="#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> 和 <a class="reference internal" href="#math.modf" title="math.modf"><code class="xref py py-func docutils literal notranslate"><span class="pre">modf()</span></code></a> 函数，请注意 <em>所有</em> 足够大的浮点数都是精确整数。Python浮点数通常不超过53位的精度（与平台C double类型相同），在这种情况下，任何浮点 <em>x</em> 与 <code class="docutils literal notranslate"><span class="pre">abs(x)</span> <span class="pre">&gt;=</span> <span class="pre">2**52</span></code> 必然没有小数位。</p>
</section>
<section id="power-and-logarithmic-functions">
<h2>幂函数与对数函数</h2>
<dl class="py function">
<dt class="sig sig-object py" id="math.cbrt">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">cbrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的立方根。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.exp">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>e</em> 的 <em>x</em> 次幂，其中 <em>e</em> = 2.718281... 是自然对数的基数。这通常比 <code class="docutils literal notranslate"><span class="pre">math.e</span> <span class="pre">**</span> <span class="pre">x</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pow(math.e,</span> <span class="pre">x)</span></code> 更精确。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.exp2">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">exp2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>2</em> 的 <em>x</em> 次幂。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.expm1">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">expm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>e</em> 的 <em>x</em>，减去 1。 这里 <em>e</em> 是以自然对数作为基数。 对于小浮点数 <em>x</em>，在 <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> 中的减法运算可能导致 <a class="reference external" href="https://en.wikipedia.org/wiki/Loss_of_significance">明显的精度损失</a><span class="link-target"> [https://en.wikipedia.org/wiki/Loss_of_significance]</span>; <a class="reference internal" href="#math.expm1" title="math.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a> 函数提供了一种以完整精度计算此数量的办法:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">expm1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># gives result accurate to 11 places</span>
<span class="go">1.0000050000069649e-05</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expm1</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>    <span class="c1"># result accurate to full precision</span>
<span class="go">1.0000050000166668e-05</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.log">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>使用一个参数，返回 <em>x</em> 的自然对数（底为 <em>e</em> ）。</p>
<p>使用两个参数，返回给定的 <em>base</em> 的对数 <em>x</em> ，计算为 <code class="docutils literal notranslate"><span class="pre">log(x)/log(base)</span></code> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.log1p">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">log1p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>1+x</em> 的自然对数（以 <em>e</em> 为底）。 以对于接近零的 <em>x</em> 精确的方式计算结果。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.log2">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">log2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 以2为底的对数。这通常比 <code class="docutils literal notranslate"><span class="pre">log(x,</span> <span class="pre">2)</span></code> 更准确。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="stdtypes.xhtml#int.bit_length" title="int.bit_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">int.bit_length()</span></code></a> 返回表示二进制整数所需的位数，不包括符号和前导零。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.log10">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 底为10的对数。这通常比 <code class="docutils literal notranslate"><span class="pre">log(x,</span> <span class="pre">10)</span></code> 更准确。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.pow">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">pow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的 <code class="docutils literal notranslate"><span class="pre">y</span></code> 次幂。 特殊情况将尽可能遵循 IEEE 754 标准。 特别地，<code class="docutils literal notranslate"><span class="pre">pow(1.0,</span> <span class="pre">x)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">0.0)</span></code> 总是返回 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>，即使当 <code class="docutils literal notranslate"><span class="pre">x</span></code> 为零或 NaN 也是如此。 如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 均为有限值，<code class="docutils literal notranslate"><span class="pre">x</span></code> 为负数，而 <code class="docutils literal notranslate"><span class="pre">y</span></code> 不是整数则 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> 是未定义的，并将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>与内置的 <code class="docutils literal notranslate"><span class="pre">**</span></code> 运算符不同， <a class="reference internal" href="#math.pow" title="math.pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.pow()</span></code></a> 将其参数转换为 <a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 类型。使用 <code class="docutils literal notranslate"><span class="pre">**</span></code> 或内置的 <a class="reference internal" href="functions.xhtml#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 函数来计算精确的整数幂。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>特殊情况 <code class="docutils literal notranslate"><span class="pre">pow(0.0,</span> <span class="pre">-inf)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pow(-0.0,</span> <span class="pre">-inf)</span></code> 已改为返回 <code class="docutils literal notranslate"><span class="pre">inf</span></code> 而不是引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，以便同 IEEE 754 保持一致。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.sqrt">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的平方根。</p>
</dd></dl>

</section>
<section id="trigonometric-functions">
<h2>三角函数</h2>
<dl class="py function">
<dt class="sig sig-object py" id="math.acos">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">acos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回以弧度为单位的 <em>x</em> 的反余弦值。 结果范围在 <code class="docutils literal notranslate"><span class="pre">0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 之间。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.asin">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">asin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回以弧度为单位的 <em>x</em> 的反正弦值。 结果范围在 <code class="docutils literal notranslate"><span class="pre">-pi/2</span></code> 到 <code class="docutils literal notranslate"><span class="pre">pi/2</span></code> 之间。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.atan">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">atan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回以弧度为单位的 <em>x</em> 的反正切值。 结果范围在 <code class="docutils literal notranslate"><span class="pre">-pi/2</span></code> 到 <code class="docutils literal notranslate"><span class="pre">pi/2</span></code> 之间。.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.atan2">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">atan2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>以弧度为单位返回 <code class="docutils literal notranslate"><span class="pre">atan(y</span> <span class="pre">/</span> <span class="pre">x)</span></code> 。结果是在 <code class="docutils literal notranslate"><span class="pre">-pi</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 之间。从原点到点 <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>  的平面矢量使该角度与正X轴成正比。 <a class="reference internal" href="#math.atan2" title="math.atan2"><code class="xref py py-func docutils literal notranslate"><span class="pre">atan2()</span></code></a> 的点的两个输入的符号都是已知的，因此它可以计算角度的正确象限。 例如， <code class="docutils literal notranslate"><span class="pre">atan(1)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">atan2(1,</span> <span class="pre">1)</span></code>  都是 <code class="docutils literal notranslate"><span class="pre">pi/4</span></code> ，但 <code class="docutils literal notranslate"><span class="pre">atan2(-1,</span> <span class="pre">-1)</span></code> 是 <code class="docutils literal notranslate"><span class="pre">-3*pi/4</span></code> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.cos">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 弧度的余弦值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.dist">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>p</em> 与 <em>q</em> 两点之间的欧几里得距离，以一个坐标序列（或可迭代对象）的形式给出。 两个点必须具有相同的维度。</p>
<p>大致相当于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">px</span> <span class="o">-</span> <span class="n">qx</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">qx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.hypot">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">hypot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">coordinates</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回欧几里得范数，<code class="docutils literal notranslate"><span class="pre">sqrt(sum(x**2</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">coordinates))</span></code>。 这是从原点到坐标给定点的向量长度。</p>
<p>对于一个二维点 <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>，这等价于使用毕达哥拉斯定义 <code class="docutils literal notranslate"><span class="pre">sqrt(x*x</span> <span class="pre">+</span> <span class="pre">y*y)</span></code> 计算一个直角三角形的斜边。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>添加了对 n 维点的支持。 之前的版本只支持二维点。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>改进了算法的精确性，使得最大误差在 1 ulp (最后一位的单位数值) 以下。 更为常见的情况是，结果几乎总是能正确地舍入到 1/2 ulp 范围之内。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.sin">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 弧度的正弦值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.tan">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">tan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 弧度的正切值。</p>
</dd></dl>

</section>
<section id="angular-conversion">
<h2>角度转换</h2>
<dl class="py function">
<dt class="sig sig-object py" id="math.degrees">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">degrees</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将角度 <em>x</em> 从弧度转换为度数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.radians">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">radians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将角度 <em>x</em> 从度数转换为弧度。</p>
</dd></dl>

</section>
<section id="hyperbolic-functions">
<h2>双曲函数</h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Hyperbolic_functions">双曲函数</a><span class="link-target"> [https://en.wikipedia.org/wiki/Hyperbolic_functions]</span> 是基于双曲线而非圆来对三解函数进行的模拟。</p>
<dl class="py function">
<dt class="sig sig-object py" id="math.acosh">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">acosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的反双曲余弦值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.asinh">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">asinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的反双曲正弦值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.atanh">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">atanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的反双曲正切值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.cosh">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">cosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的双曲余弦值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.sinh">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">sinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的双曲正弦值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.tanh">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 的双曲正切值。</p>
</dd></dl>

</section>
<section id="special-functions">
<h2>特殊函数</h2>
<dl class="py function">
<dt class="sig sig-object py" id="math.erf">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">erf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 处的 <a class="reference external" href="https://en.wikipedia.org/wiki/Error_function">误差函数</a><span class="link-target"> [https://en.wikipedia.org/wiki/Error_function]</span> 。</p>
<p>可以使用 <a class="reference internal" href="#math.erf" title="math.erf"><code class="xref py py-func docutils literal notranslate"><span class="pre">erf()</span></code></a> 函数来计算传统的统计函数如 <a class="reference external" href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">累积标准正态分布</a><span class="link-target"> [https://en.wikipedia.org/wiki/Cumulative_distribution_function]</span>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s1">&#39;Cumulative distribution function for the standard normal distribution&#39;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">erf</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.erfc">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 处的互补误差函数。 <a class="reference external" href="https://en.wikipedia.org/wiki/Error_function">互补错误函数</a><span class="link-target"> [https://en.wikipedia.org/wiki/Error_function]</span> 定义为 <code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">-</span> <span class="pre">erf(x)</span></code>。 它用于 <em>x</em> 的大值，从其中减去一个会导致 <a class="reference external" href="https://en.wikipedia.org/wiki/Loss_of_significance">有效位数损失</a><span class="link-target"> [https://en.wikipedia.org/wiki/Loss_of_significance]</span>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.gamma">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>x</em> 处的 <a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_function">伽马函数</a><span class="link-target"> [https://en.wikipedia.org/wiki/Gamma_function]</span> 值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="math.lgamma">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">lgamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回Gamma函数在 <em>x</em> 绝对值的自然对数。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="constants">
<h2>常量</h2>
<dl class="py data">
<dt class="sig sig-object py" id="math.pi">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">pi</span></span></dt>
<dd><p>数学常数 <em>π</em> = 3.141592...，精确到可用精度。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="math.e">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">e</span></span></dt>
<dd><p>数学常数 <em>e</em> = 2.718281...，精确到可用精度。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="math.tau">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">tau</span></span></dt>
<dd><p>数学常数 <em>τ</em> = 6.283185...，精确到可用精度。Tau 是一个圆周常数，等于 2<em>π</em>，圆的周长与半径之比。更多关于 Tau 的信息可参考 Vi Hart 的视频 <a class="reference external" href="https://www.youtube.com/watch?v=jG7vhMMXagQ">Pi is (still) Wrong</a><span class="link-target"> [https://www.youtube.com/watch?v=jG7vhMMXagQ]</span>。吃两倍多的派来庆祝 <a class="reference external" href="https://tauday.com/">Tau 日</a><span class="link-target"> [https://tauday.com/]</span> 吧！</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="math.inf">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">inf</span></span></dt>
<dd><p>浮点正无穷大。 （对于负无穷大，使用 <code class="docutils literal notranslate"><span class="pre">-math.inf</span></code> 。）相当于 <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code> 的输出。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="math.nan">
<span class="sig-prename descclassname"><span class="pre">math.</span></span><span class="sig-name descname"><span class="pre">nan</span></span></dt>
<dd><p>一个浮点数值 &quot;Not a Number&quot; (NaN)。 相当于 <code class="docutils literal notranslate"><span class="pre">float('nan')</span></code> 的输出。 根据 <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754 标准</a><span class="link-target"> [https://en.wikipedia.org/wiki/IEEE_754]</span> 要求，<code class="docutils literal notranslate"><span class="pre">math.nan</span></code> 和 <code class="docutils literal notranslate"><span class="pre">float('nan')</span></code> 不会被视为等于任何其他数值，包括其本身。 要检查一个数字是否为 NaN，请使用 <a class="reference internal" href="#math.isnan" title="math.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a> 函数来测试 NaN 而不能使用 <code class="docutils literal notranslate"><span class="pre">is</span></code> 或 <code class="docutils literal notranslate"><span class="pre">==</span></code>。 例如:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">nan</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>该常量现在总是可用。</p>
</div>
</dd></dl>

<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> <a class="reference internal" href="#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模块主要包含围绕平台C数学库函数的简单包装器。特殊情况下的行为在适当情况下遵循C99标准的附录F。当前的实现将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 用于无效操作，如 <code class="docutils literal notranslate"><span class="pre">sqrt(-1.0)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">log(0.0)</span></code> （其中C99附件F建议发出无效操作信号或被零除）， 和 <a class="reference internal" href="exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 用于溢出的结果（例如， <code class="docutils literal notranslate"><span class="pre">exp(1000.0)</span></code> ）。除非一个或多个输入参数是NaN，否则不会从上述任何函数返回NaN；在这种情况下，大多数函数将返回一个NaN，但是（再次遵循C99附件F）这个规则有一些例外，例如 <code class="docutils literal notranslate"><span class="pre">pow(float('nan'),</span> <span class="pre">0.0)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">hypot(float('nan'),</span> <span class="pre">float('inf'))</span></code> 。</p>
<p>请注意，Python不会将显式NaN与静默NaN区分开来，并且显式NaN的行为仍未明确。典型的行为是将所有NaN视为静默的。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference internal" href="cmath.xhtml#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块</dt><dd><p>这里很多函数的复数版本。</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>