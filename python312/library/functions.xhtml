<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="内置函数" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/functions.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。,,,, 内置函数,,, A, abs(), aiter(), all(), anext(), any(), ascii(),, B, bin(), bool(), breakpoint(), bytearray(), bytes(),, C, callable(), chr(), classmethod()..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。,,,, 内置函数,,, A, abs(), aiter(), all(), anext(), any(), ascii(),, B, bin(), bool(), breakpoint(), bytearray(), bytes(),, C, callable(), chr(), classmethod()..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>内置函数</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/functions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="built-in-functions">
<span id="built-in-funcs"></span><h1>内置函数</h1>
<p>Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head" colspan="4"><p>内置函数</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line"><strong>A</strong></div>
<div class="line"><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></div>
<div class="line"><a class="reference internal" href="#aiter" title="aiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">aiter()</span></code></a></div>
<div class="line"><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></div>
<div class="line"><a class="reference internal" href="#anext" title="anext"><code class="xref py py-func docutils literal notranslate"><span class="pre">anext()</span></code></a></div>
<div class="line"><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></div>
<div class="line"><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>B</strong></div>
<div class="line"><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></div>
<div class="line"><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></div>
<div class="line"><a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>C</strong></div>
<div class="line"><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></div>
<div class="line"><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></div>
<div class="line"><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></div>
<div class="line"><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>D</strong></div>
<div class="line"><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></div>
<div class="line"><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></div>
<div class="line"><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><strong>E</strong></div>
<div class="line"><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></div>
<div class="line"><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></div>
<div class="line"><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>F</strong></div>
<div class="line"><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></div>
<div class="line"><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></div>
<div class="line"><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>G</strong></div>
<div class="line"><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>H</strong></div>
<div class="line"><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></div>
<div class="line"><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></div>
<div class="line"><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>I</strong></div>
<div class="line"><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></div>
<div class="line"><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></div>
<div class="line"><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></div>
<div class="line"><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></div>
<div class="line"><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></div>
<div class="line"><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><strong>L</strong></div>
<div class="line"><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></div>
<div class="line"><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>M</strong></div>
<div class="line"><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></div>
<div class="line"><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></div>
<div class="line"><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>N</strong></div>
<div class="line"><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>O</strong></div>
<div class="line"><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></div>
<div class="line"><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></div>
<div class="line"><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></div>
<div class="line"><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>P</strong></div>
<div class="line"><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></div>
<div class="line"><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></div>
<div class="line"><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><strong>R</strong></div>
<div class="line"><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></div>
<div class="line"><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></div>
<div class="line"><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>S</strong></div>
<div class="line"><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></div>
<div class="line"><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></div>
<div class="line"><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></div>
<div class="line"><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></div>
<div class="line"><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></div>
<div class="line"><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></div>
<div class="line"><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></div>
<div class="line"><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>T</strong></div>
<div class="line"><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></div>
<div class="line"><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>V</strong></div>
<div class="line"><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>Z</strong></div>
<div class="line"><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></div>
<div class="line"><br /></div>
<div class="line"><strong>_</strong></div>
<div class="line"><a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></div>
</div>
</td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__abs__" title="object.__abs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__abs__()</span></code></a> 的对象。 如果参数是一个复数，则返回它的模。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="aiter">
<span class="sig-name descname"><span class="pre">aiter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回  <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterable"><span class="xref std std-term">asynchronous iterable</span></a> 的 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 。相当于调用 <code class="docutils literal notranslate"><span class="pre">x.__aiter__()</span></code>。</p>
<p>注意：与 <a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 不同，<a class="reference internal" href="#aiter" title="aiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">aiter()</span></code></a> 没有两个参数的版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="all">
<span class="sig-name descname"><span class="pre">all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>iterable</em> 的所有元素均为真值（或可迭代对象为空）则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。 等价于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anext">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-name descname"><span class="pre">anext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_iterator</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-name descname"><span class="pre">anext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">async_iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>当进入 await 状态时，从给定 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 返回下一数据项，迭代完毕则返回 <em>default</em>。</p>
<p>这是内置函数 <a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 的异步版本，类似于：</p>
<p>调用 <em>async_iterator</em> 的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 方法，返回一个 <a class="reference internal" href="../glossary.xhtml#term-awaitable"><span class="xref std std-term">awaitable</span></a>。等待返回迭代器的下一个值。若有给出 <em>default</em>，则在迭代完毕后会返回给出的值，否则会触发 <a class="reference internal" href="exceptions.xhtml#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="any">
<span class="sig-name descname"><span class="pre">any</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>iterable</em> 的任一元素为真值则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 如果可迭代对象为空，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ascii">
<span class="sig-name descname"><span class="pre">ascii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 类似，返回一个包含对象的可打印表示形式的字符串，但是使用 <code class="docutils literal notranslate"><span class="pre">\x</span></code>、<code class="docutils literal notranslate"><span class="pre">\u</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\U</span></code> 对 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的字符串中非 ASCII 编码的字符进行转义。生成的字符串和 Python 2 的 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的结果相似。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bin">
<span class="sig-name descname"><span class="pre">bin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个整数转换为带前缀 &quot;0b&quot; 的二进制数字符串。 结果是一个合法的 Python 表达式。 如果 <em>x</em> 不是一个 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，则它必须定义返回一个整数的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法。 下面是一些例子:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;0b11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;-0b1010&#39;</span>
</pre></div>
</div>
<p>若要控制是否显示前缀“0b”，可以采用以下两种方案：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;#b&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">14</span><span class="si">:</span><span class="s1">#b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">14</span><span class="si">:</span><span class="s1">b</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return a Boolean value, i.e. one of <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.  The argument
is converted using the standard <a class="reference internal" href="stdtypes.xhtml#truth"><span class="std std-ref">truth testing procedure</span></a>.
If the argument is false
or omitted, this returns <code class="docutils literal notranslate"><span class="pre">False</span></code>; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.  The
<a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> class is a subclass of <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> (see <a class="reference internal" href="stdtypes.xhtml#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a>).
It cannot be subclassed further.  Its only instances are <code class="docutils literal notranslate"><span class="pre">False</span></code> and
<code class="docutils literal notranslate"><span class="pre">True</span></code> (see <a class="reference internal" href="stdtypes.xhtml#typebool"><span class="std std-ref">布尔类型 - bool</span></a>).</p>
<div class="versionchanged" id="index-0">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>The parameter is now positional-only.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="breakpoint">
<span class="sig-name descname"><span class="pre">breakpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此函数会在调用点进入调试器。具体来说，它调用 <a class="reference internal" href="sys.xhtml#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> ，直接传递 <code class="docutils literal notranslate"><span class="pre">args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">kws</span></code> 。默认情况下， <code class="docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code> 调用 <a class="reference internal" href="pdb.xhtml#pdb.set_trace" title="pdb.set_trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.set_trace()</span></code></a> 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 <a class="reference internal" href="pdb.xhtml#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 且键入尽可能少的代码即可进入调试器。但是， <a class="reference internal" href="sys.xhtml#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> 可以设置为其他一些函数并被 <a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a> 自动调用，以允许进入你想用的调试器。如果 <a class="reference internal" href="sys.xhtml#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> 不可访问，这个函数将会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
<p>在默认情况下，<a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a> 的行为可使用 <span class="target" id="index-23"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONBREAKPOINT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONBREAKPOINT</span></code></a> 环境变量来改变。 请参阅 <a class="reference internal" href="sys.xhtml#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> 了解详细用法。</p>
<p>请注意这并不保证 <a class="reference internal" href="sys.xhtml#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> 会被替换。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.breakpoint</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">breakpointhook</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py class" id="func-bytearray">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 bytes 数组。 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，见 <a class="reference internal" href="stdtypes.xhtml#typesseq-mutable"><span class="std std-ref">可变序列类型</span></a> 的描述；同时有 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的大部分方法，参见 <a class="reference internal" href="stdtypes.xhtml#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a>。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul class="simple">
<li><p>如果是一个 <em>string</em>，您必须提供 <em>encoding</em> 参数（<em>errors</em> 参数仍是可选的）；<a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 会使用 <a class="reference internal" href="stdtypes.xhtml#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 方法来将 string 转变成 bytes。</p></li>
<li><p>如果是一个 <em>integer</em>，会初始化大小为该数字的数组，并使用 null 字节填充。</p></li>
<li><p>如果是一个遵循 <a class="reference internal" href="../c-api/buffer.xhtml#bufferobjects"><span class="std std-ref">缓冲区接口</span></a> 的对象，该对象的只读缓冲区将被用来初始化字节数组。</p></li>
<li><p>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数，它会被用作数组的初始内容。</p></li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<p>另见 <a class="reference internal" href="stdtypes.xhtml#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a> 和 <a class="reference internal" href="stdtypes.xhtml#typebytearray"><span class="std std-ref">bytearray 对象</span></a>。</p>
</dd></dl>

<dl class="py class" id="func-bytes">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数。<a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 是 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。</p>
<p>因此，构造函数的实参和 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 相同。</p>
<p>字节对象还可以用字面值创建，参见 <a class="reference internal" href="../reference/lexical_analysis.xhtml#strings"><span class="std std-ref">字符串与字节串字面值</span></a>。</p>
<p>另见 <a class="reference internal" href="stdtypes.xhtml#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a>，<a class="reference internal" href="stdtypes.xhtml#typebytes"><span class="std std-ref">bytes 对象</span></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="callable">
<span class="sig-name descname"><span class="pre">callable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>object</em> 参数是可调用的则返回 <a class="reference internal" href="constants.xhtml#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.xhtml#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。 如果返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，调用仍可能失败，但如果返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则调用 <em>object</em> 肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法则它就是可调用的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2: </span>这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="chr">
<span class="sig-name descname"><span class="pre">chr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code class="docutils literal notranslate"><span class="pre">chr(97)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，<code class="docutils literal notranslate"><span class="pre">chr(8364)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'€'</span></code>。这是 <a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="classmethod">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">classmethod</span></span></dt>
<dd><p>把一个方法封装成类方法。</p>
<p>类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 这样的形式称为函数的 <a class="reference internal" href="../glossary.xhtml#term-decorator"><span class="xref std std-term">decorator</span></a> -- 详情参阅 <a class="reference internal" href="../reference/compound_stmts.xhtml#function"><span class="std std-ref">函数定义</span></a>。</p>
<p>类方法的调用可以在类上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>) 也可以在实例上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。</p>
<p>类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 <a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>。 有关类方法的更多信息，请参阅 <a class="reference internal" href="../reference/datamodel.xhtml#types"><span class="std std-ref">标准类型层级结构</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>类方法现在可以包装其他 <a class="reference internal" href="../glossary.xhtml#term-descriptor"><span class="xref std std-term">描述器</span></a> 例如 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>类方法现在继承了方法的属性（ <code class="docutils literal notranslate"><span class="pre">__module__</span></code>、 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>、 <code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>、 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>），并拥有一个新的 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>类方法不再可以包装其他 <a class="reference internal" href="../glossary.xhtml#term-descriptor"><span class="xref std std-term">descriptors</span></a>  例如 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="compile">
<span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dont_inherit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 或 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。参见 <a class="reference internal" href="ast.xhtml#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块的文档了解如何使用 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code class="docutils literal notranslate"><span class="pre">'&lt;string&gt;'</span></code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code>；如果是单一表达式，可以是 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code>；如果是单个交互式语句，可以是 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>。（在最后一种情况下，如果表达式执行结果不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将会被打印出来。）</p>
<p>可选参数 <em>flags</em> 和 <em>dont_inherit</em> 控制应当激活哪个 <a class="reference internal" href="ast.xhtml#ast-compiler-flags"><span class="std std-ref">编译器选项</span></a> 以及应当允许哪个 <a class="reference internal" href="../reference/simple_stmts.xhtml#future"><span class="std std-ref">future 特性</span></a>。 如果两者都未提供 (或都为零) 则代码会应用与调用 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的代码相同的旗标来编译。 如果给出了 <em>flags</em> 参数而未给出 <em>dont_inherit</em> (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 <em>flags</em> 参数所指定的编译器选项和 future 语句。 如果 <em>dont_inherit</em> 为非零整数，则只使用 <em>flags</em> 参数 -- 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。</p>
<p>编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 <a class="reference internal" href="__future__.xhtml#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> 模块的 <a class="reference internal" href="__future__.xhtml#future__._Feature" title="__future__._Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">_Feature</span></code></a> 实例的 <a class="reference internal" href="__future__.xhtml#future__._Feature.compiler_flag" title="__future__._Feature.compiler_flag"><code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code></a> 属性中找到。 <a class="reference internal" href="ast.xhtml#ast-compiler-flags"><span class="std std-ref">编译器旗标</span></a> 可以在 <a class="reference internal" href="ast.xhtml#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块中查找带有 <code class="docutils literal notranslate"><span class="pre">PyCF_</span></code> 前缀的名称。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code class="docutils literal notranslate"><span class="pre">-1</span></code>  选择与解释器的 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项相同的优化级别。显式级别为 <code class="docutils literal notranslate"><span class="pre">0</span></code> （没有优化；<code class="docutils literal notranslate"><span class="pre">__debug__</span></code>  为真）、<code class="docutils literal notranslate"><span class="pre">1</span></code> （断言被删除， <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 为假）或 <code class="docutils literal notranslate"><span class="pre">2</span></code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <a class="reference internal" href="exceptions.xhtml#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常；如果源码包含 null 字节，则会触发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
<p>如果您想分析 Python 代码的 AST 表示，请参阅 <a class="reference internal" href="ast.xhtml#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.parse()</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">compile</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">source</span></code>, <code class="docutils literal notranslate"><span class="pre">filename</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>  或 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <a class="reference internal" href="code.xhtml#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> 模块更容易检测语句的完整性。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>Windows 和 Mac 的换行符均可使用。而且在 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 模式下的输入不必再以换行符结尾了。另增加了 <em>optimize</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>之前 <em>source</em> 中包含 null 字节的话会触发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8: </span><code class="docutils literal notranslate"><span class="pre">ast.PyCF_ALLOW_TOP_LEVEL_AWAIT</span></code> 现在可在旗标中传入以启用对最高层级 <code class="docutils literal notranslate"><span class="pre">await</span></code>, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 和 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 的支持。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="complex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Convert a single string or number to a complex number, or create a
complex number from real and imaginary parts.</p>
<p>示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">(1.23+0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="s1">&#39;-4.5j&#39;</span><span class="p">)</span>
<span class="go">-4.5j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="s1">&#39;-1.23+4.5j&#39;</span><span class="p">)</span>
<span class="go">(-1.23+4.5j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">( -1.23+4.5J )</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">(-1.23+4.5j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="s1">&#39;-Infinity+NaNj&#39;</span><span class="p">)</span>
<span class="go">(-inf+nanj)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="mf">1.23</span><span class="p">)</span>
<span class="go">(1.23+0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="n">imag</span><span class="o">=-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="go">-4.5j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mf">1.23</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">)</span>
<span class="go">(-1.23+4.5j)</span>
</pre></div>
</div>
<p>If the argument is a string, it must contain either a real part (in the
same format as for <a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>) or an imaginary part (in the same
format but with a <code class="docutils literal notranslate"><span class="pre">'j'</span></code> or <code class="docutils literal notranslate"><span class="pre">'J'</span></code> suffix), or both real and imaginary
parts (the sign of the imaginary part is mandatory in this case).
The string can optionally be surrounded by whitespaces and the round
parentheses <code class="docutils literal notranslate"><span class="pre">'('</span></code> and <code class="docutils literal notranslate"><span class="pre">')'</span></code>, which are ignored.
The string must not contain whitespace between <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'-'</span></code>, the
<code class="docutils literal notranslate"><span class="pre">'j'</span></code> or <code class="docutils literal notranslate"><span class="pre">'J'</span></code> suffix, and the decimal number.
For example, <code class="docutils literal notranslate"><span class="pre">complex('1+2j')</span></code> is fine, but <code class="docutils literal notranslate"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> raises
<a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.
More precisely, the input must conform to the <a class="reference internal" href="#grammar-token-float-complexvalue"><code class="xref std std-token docutils literal notranslate"><span class="pre">complexvalue</span></code></a>
production rule in the following grammar, after parentheses and leading and
trailing whitespace characters are removed:</p>
<pre>
<strong id="grammar-token-float-complexvalue">complexvalue</strong> ::=  <a class="reference internal" href="#grammar-token-float-floatvalue"><code class="xref docutils literal notranslate"><span class="pre">floatvalue</span></code></a> |
                  <a class="reference internal" href="#grammar-token-float-floatvalue"><code class="xref docutils literal notranslate"><span class="pre">floatvalue</span></code></a> (&quot;j&quot; | &quot;J&quot;) |
                  <a class="reference internal" href="#grammar-token-float-floatvalue"><code class="xref docutils literal notranslate"><span class="pre">floatvalue</span></code></a> <a class="reference internal" href="#grammar-token-float-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a> <a class="reference internal" href="#grammar-token-float-absfloatvalue"><code class="xref docutils literal notranslate"><span class="pre">absfloatvalue</span></code></a> (&quot;j&quot; | &quot;J&quot;)
</pre>
<p>If the argument is a number, the constructor serves as a numeric
conversion like <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> and <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.
For a general Python object <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">complex(x)</span></code> delegates to
<code class="docutils literal notranslate"><span class="pre">x.__complex__()</span></code>.
If <a class="reference internal" href="../reference/datamodel.xhtml#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> is not defined then it falls back
to <a class="reference internal" href="../reference/datamodel.xhtml#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a>.
If <code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code> is not defined then it falls back
to <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
<p>If two arguments are provided or keyword arguments are used, each argument
may be any numeric type (including complex).
If both arguments are real numbers, return a complex number with the real
component <em>real</em> and the imaginary component <em>imag</em>.
If both arguments are complex numbers, return a complex number with the real
component <code class="docutils literal notranslate"><span class="pre">real.real-imag.imag</span></code> and the imaginary component
<code class="docutils literal notranslate"><span class="pre">real.imag+imag.real</span></code>.
If one of arguments is a real number, only its real component is used in
the above expressions.</p>
<p>If all arguments are omitted, returns <code class="docutils literal notranslate"><span class="pre">0j</span></code>.</p>
<p><a class="reference internal" href="stdtypes.xhtml#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 描述了复数类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>如果 <a class="reference internal" href="../reference/datamodel.xhtml#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 均未定义则回退至 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="delattr">
<span class="sig-name descname"><span class="pre">delattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这是 <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> 的相关函数。 其参数是一个对象和一个字符串。 其中字符串必须是对象的某个属性的名称。 该函数会删除指定的属性，如果对象允许这样做的话。 例如，<code class="docutils literal notranslate"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x.foobar</span></code>。 <em>name</em> 不要求必须是 Python 标识符 (参见 <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>)。</p>
</dd></dl>

<dl class="py class" id="func-dict">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwarg</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwarg</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwarg</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的字典。<a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 对象是一个字典类。参见 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#typesmapping"><span class="std std-ref">映射类型 --- dict</span></a> 了解这个类。</p>
<p>其他容器类型，请参见内置的 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 类，以及 <a class="reference internal" href="collections.xhtml#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dir">
<span class="sig-name descname"><span class="pre">dir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <a class="reference internal" href="../reference/datamodel.xhtml#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a> 的方法，则该方法将被调用并且必须返回由属列组成的列表。 这允许实现自定义This allows objects that implement a custom <a class="reference internal" href="../reference/datamodel.xhtml#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 函数的对象能够定制 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 报告其属性的方式。</p>
<p>如果对象未提供 <a class="reference internal" href="../reference/datamodel.xhtml#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a>，该函数会尽量从对象所定义的 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性和其类型对象中收集信息。 结果列表不一定是完整的，并且当对象具有自定义的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 时还可能是不准确的。</p>
<p>默认的 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul class="simple">
<li><p>如果对象是模块对象，则列表包含模块的属性名称。</p></li>
<li><p>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</p></li>
<li><p>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</p></li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace  </span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module </span>
<span class="go">[&#39;Struct&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;,</span>
<span class="go"> &#39;__initializing__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;area&#39;, &#39;location&#39;, &#39;perimeter&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>因为 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="divmod">
<span class="sig-name descname"><span class="pre">divmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> 相同。对于浮点数则结果为 <code class="docutils literal notranslate"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code>，其中 <em>q</em> 通常为 <code class="docutils literal notranslate"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code>，但可能比它小 1。在任何情况下， <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 都非常接近 <em>a</em>，如果 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 非零，则结果符号与 <em>b</em> 相同，并且 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="enumerate">
<span class="sig-name descname"><span class="pre">enumerate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a>，或其他支持迭代的对象。 <a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 返回的迭代器的 <a class="reference internal" href="stdtypes.xhtml#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Spring&#39;</span><span class="p">,</span> <span class="s1">&#39;Summer&#39;</span><span class="p">,</span> <span class="s1">&#39;Fall&#39;</span><span class="p">,</span> <span class="s1">&#39;Winter&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span>
</pre></div>
</div>
<p>等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function" id="func-eval">
<dt class="sig sig-object py" id="eval">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expression</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expression</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> | <a class="reference internal" href="../reference/datamodel.xhtml#code-objects"><span class="std std-ref">code object</span></a>) -- 一个 Python 表达式。</p></li>
<li><p><strong>globals</strong> (<a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> | <code class="docutils literal notranslate"><span class="pre">None</span></code>) -- 全局命名空间 (默认值: <code class="docutils literal notranslate"><span class="pre">None</span></code>)。</p></li>
<li><p><strong>locals</strong> (<a class="reference internal" href="../glossary.xhtml#term-mapping"><span class="xref std std-term">mapping</span></a> | <code class="docutils literal notranslate"><span class="pre">None</span></code>) -- 局部命名空间 (默认值: <code class="docutils literal notranslate"><span class="pre">None</span></code>)。</p></li>
</ul>
</dd>
<dt class="field-even">返回<span class="colon">:</span></dt>
<dd class="field-even"><p>The result of the evaluated expression.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p>Syntax errors are reported as exceptions.</p>
</dd>
</dl>
<p>表达式解析参数 <em>expression</em> 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 <em>globals</em> 和 <em>locals</em> 字典作为全局和局部命名空间。 如果存在 <em>globals</em> 字典，并且不包含 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 键的值，则在解析 <em>expression</em> 之前会插入以该字符串为键以对内置模块 <a class="reference internal" href="builtins.xhtml#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 的字典的引用为值的项。 这样就可以在将 <em>globals</em> 传给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 之前通过向其传入你自己的 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 字典来控制可供被执行代码可以使用哪些内置模块。 如果 <em>locals</em> 字典被省略则它默认为 <em>globals</em> 字典。 如果两个字典都被省略，则将使用调用 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的环境中的 <em>globals</em> 和 <em>locals</em> 来执行该表达式。 注意，<em>eval()</em> 无法访问闭包环境中的 <a class="reference internal" href="../glossary.xhtml#term-nested-scope"><span class="xref std std-term">嵌套作用域</span></a> (非局部变量)。</p>
<p>示例:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>该函数还可用于执行任意代码对象（比如由 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为  <em>mode</em> 的 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 进行了编译，那么 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的返回值将为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>提示： <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数支持语句的动态执行。 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数分别返回当前的全局和本地字典，可供传给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 或 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 使用。</p>
<p>如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。</p>
<p>另外可以参阅 <a class="reference internal" href="ast.xhtml#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.literal_eval()</span></code></a>，该函数可以安全执行仅包含文字的表达式字符串。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">exec</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">code_object</span></code>。</p>
</dd></dl>

<dl class="py function" id="index-2">
<dt class="sig sig-object py" id="exec">
<span class="sig-name descname"><span class="pre">exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function supports dynamic execution of Python code. <em>object</em> must be
either a string or a code object.  If it is a string, the string is parsed as
a suite of Python statements which is then executed (unless a syntax error
occurs). <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> If it is a code object, it is simply executed.  In all cases,
the code that's executed is expected to be valid as file input (see the
section <a class="reference internal" href="../reference/toplevel_components.xhtml#file-input"><span class="std std-ref">文件输入</span></a> in the Reference Manual). Be aware that the
<a class="reference internal" href="../reference/simple_stmts.xhtml#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a>, <a class="reference internal" href="../reference/simple_stmts.xhtml#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>,  and <a class="reference internal" href="../reference/simple_stmts.xhtml#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>
statements may not be used outside of
function definitions even within the context of code passed to the
<a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> function. The return value is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>In all cases, if the optional parts are omitted, the code is executed in the
current scope.  If only <em>globals</em> is provided, it must be a dictionary
(and not a subclass of dictionary), which
will be used for both the global and the local variables.  If <em>globals</em> and
<em>locals</em> are given, they are used for the global and local variables,
respectively.  If provided, <em>locals</em> can be any mapping object.  Remember
that at the module level, globals and locals are the same dictionary.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Most users should just pass a <em>globals</em> argument and never <em>locals</em>.
If exec gets two separate objects as <em>globals</em> and <em>locals</em>, the code
will be executed as if it were embedded in a class definition.</p>
</div>
<p>如果 <em>globals</em> 字典不包含 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 键值，则将为该键插入对内建 <a class="reference internal" href="builtins.xhtml#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块字典的引用。因此，在将执行的代码传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 之前，可以通过将自己的 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<p><em>closure</em> 参数指定一个闭包  -- 即由 cellvar 组成的元组。 它仅在 <em>object</em> 是一个包含自由变量的代码对象时才可用。 该元组的长度必须与代码对象所引用的自由变量的数量完全一致。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">exec</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">code_object</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>内置 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 的第二个和第三个实参。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>The default <em>locals</em> act as described for function <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> below:
modifications to the default <em>locals</em> dictionary should not be attempted.
Pass an explicit <em>locals</em> dictionary if you need to see effects of the
code on <em>locals</em> after function <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> returns.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>添加了 <em>closure</em> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>使用 <em>iterable</em> 中 <em>function</em> 返回真值的元素构造一个迭代器。 <em>iterable</em> 可以是一个序列，一个支持迭代的容器或者一个迭代器。 如果 <em>function</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会使用标识号函数，也就是说，<em>iterable</em> 中所有具有假值的元素都将被移除。</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> 相当于一个生成器表达式，当 function 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code>；function 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code> 。</p>
<p>请参阅 <a class="reference internal" href="itertools.xhtml#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.filterfalse()</span></code></a> 来了解返回 <em>iterable</em> 中 <em>function</em> 返回假值的元素的补充函数。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="float">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p id="index-3">Return a floating point number constructed from a number or a string.</p>
<p>示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;   -12345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;1e-003&#39;</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1E6&#39;</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p>If the argument is a string, it should contain a decimal number, optionally
preceded by a sign, and optionally embedded in whitespace.  The optional
sign may be <code class="docutils literal notranslate"><span class="pre">'+'</span></code> or <code class="docutils literal notranslate"><span class="pre">'-'</span></code>; a <code class="docutils literal notranslate"><span class="pre">'+'</span></code> sign has no effect on the value
produced.  The argument may also be a string representing a NaN
(not-a-number), or positive or negative infinity.
More precisely, the input must conform to the <a class="reference internal" href="#grammar-token-float-floatvalue"><code class="xref std std-token docutils literal notranslate"><span class="pre">floatvalue</span></code></a>
production rule in the following grammar, after leading and trailing
whitespace characters are removed:</p>
<pre>
<strong id="grammar-token-float-sign">sign         </strong> ::=  &quot;+&quot; | &quot;-&quot;
<strong id="grammar-token-float-infinity">infinity     </strong> ::=  &quot;Infinity&quot; | &quot;inf&quot;
<strong id="grammar-token-float-nan">nan          </strong> ::=  &quot;nan&quot;
<strong id="grammar-token-float-digit">digit        </strong> ::=  &lt;a Unicode decimal digit, i.e. characters in Unicode general category Nd&gt;
<strong id="grammar-token-float-digitpart">digitpart    </strong> ::=  <a class="reference internal" href="#grammar-token-float-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a> ([&quot;_&quot;] <a class="reference internal" href="#grammar-token-float-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>)*
<strong id="grammar-token-float-number">number       </strong> ::=  [<a class="reference internal" href="#grammar-token-float-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a>] &quot;.&quot; <a class="reference internal" href="#grammar-token-float-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a> | <a class="reference internal" href="#grammar-token-float-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a> [&quot;.&quot;]
<strong id="grammar-token-float-exponent">exponent     </strong> ::=  (&quot;e&quot; | &quot;E&quot;) [<a class="reference internal" href="#grammar-token-float-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-float-digitpart"><code class="xref docutils literal notranslate"><span class="pre">digitpart</span></code></a>
<strong id="grammar-token-float-floatnumber">floatnumber  </strong> ::=  <a class="reference internal" href="#grammar-token-float-number"><code class="xref docutils literal notranslate"><span class="pre">number</span></code></a> [<a class="reference internal" href="#grammar-token-float-exponent"><code class="xref docutils literal notranslate"><span class="pre">exponent</span></code></a>]
<strong id="grammar-token-float-absfloatvalue">absfloatvalue</strong> ::=  <a class="reference internal" href="#grammar-token-float-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-float-infinity"><code class="xref docutils literal notranslate"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-float-nan"><code class="xref docutils literal notranslate"><span class="pre">nan</span></code></a>
<strong id="grammar-token-float-floatvalue">floatvalue   </strong> ::=  [<a class="reference internal" href="#grammar-token-float-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-float-absfloatvalue"><code class="xref docutils literal notranslate"><span class="pre">absfloatvalue</span></code></a>
</pre>
<p>大小写是无影响的，因此举例来说，&quot;inf&quot;, &quot;Inf&quot;, &quot;INFINITY&quot; 和 &quot;iNfINity&quot; 都是正无穷可接受的拼写形式。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <a class="reference internal" href="exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<p>对于一个普通 Python 对象 <code class="docutils literal notranslate"><span class="pre">x</span></code>，<code class="docutils literal notranslate"><span class="pre">float(x)</span></code> 会委托给 <code class="docutils literal notranslate"><span class="pre">x.__float__()</span></code>。 如果 <a class="reference internal" href="../reference/datamodel.xhtml#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 未定义则将回退至 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>。</p>
<p>如果没有实参，则返回 <code class="docutils literal notranslate"><span class="pre">0.0</span></code> 。</p>
<p><a class="reference internal" href="stdtypes.xhtml#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 描述了浮点类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>The parameter is now positional-only.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>如果 <a class="reference internal" href="../reference/datamodel.xhtml#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 未定义则回退至 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function" id="index-4">
<dt class="sig sig-object py" id="format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_spec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <em>value</em> 转换为“格式化后”的形式，格式由 <em>format_spec</em> 进行控制。<em>format_spec</em> 的解释方式取决于 <em>value</em> 参数的类型；但大多数内置类型使用一种标准的格式化语法： <a class="reference internal" href="string.xhtml#formatspec"><span class="std std-ref">格式规格迷你语言</span></a>。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常给出与调用 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(value)</span></code></a> 相同的结果。</p>
<p>对 <code class="docutils literal notranslate"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></code> 的调用会转写为 <code class="docutils literal notranslate"><span class="pre">type(value).__format__(value,</span> <span class="pre">format_spec)</span></code>，这样在搜索值的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 方法时将绕过实例字典。 如果方法搜索到达 <a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal notranslate"><span class="pre">object</span></code></a> 并且 <em>format_spec</em> 不为空，或者如果 <em>format_spec</em> 或返回值不为字符串则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>当 <em>format_spec</em> 不是空字符串时， <code class="docutils literal notranslate"><span class="pre">object().__format__(format_spec)</span></code> 会触发  <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class" id="func-frozenset">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">frozenset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">set()</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code class="docutils literal notranslate"><span class="pre">frozenset</span></code> 是一个内置的类。有关此类的文档，请参阅 <a class="reference internal" href="stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#types-set"><span class="std std-ref">集合类型 --- set, frozenset</span></a>。</p>
<p>请参阅内建的 <a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>、<a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.xhtml#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块来了解其它的容器。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="getattr">
<span class="sig-name descname"><span class="pre">getattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">getattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span></dt>
<dd><p><em>object</em> 中指定名称的属性的值。  <em>name</em> 必须是字符串。 如果该字符串是对象的某一属性的名称，则结果将为该属性的值。 例如，<code class="docutils literal notranslate"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">x.foobar</span></code>。 如果指定名称的属性不存在，则如果提供了 <em>default</em> 则返回该值，否则将引发 <a class="reference internal" href="exceptions.xhtml#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。 <em>name</em> 不必是一个 Python 标识符 (参见 <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>)。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于 <a class="reference internal" href="../reference/expressions.xhtml#private-name-mangling"><span class="std std-ref">私有名称混合</span></a> 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以使用 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 来提取它。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="globals">
<span class="sig-name descname"><span class="pre">globals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回实现当前模块命名空间的字典。对于函数内的代码，这是在定义函数时设置的，无论函数在哪里被调用都保持不变。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hasattr">
<span class="sig-name descname"><span class="pre">hasattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。（此功能是通过调用 <code class="docutils literal notranslate"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> 看是否有 <a class="reference internal" href="exceptions.xhtml#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 异常来实现的。）</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hash">
<span class="sig-name descname"><span class="pre">hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于具有自定义 <a class="reference internal" href="../reference/datamodel.xhtml#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法的对象，请注意 <a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 会根据宿主机的字长来截断返回值。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="help">
<span class="sig-name descname"><span class="pre">help</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">help</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>请注意，如果在调用 <a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。详情请参阅 <a class="reference internal" href="../faq/programming.xhtml#faq-positional-only-arguments"><span class="std std-ref">有关仅限位置形参的 FAQ 条目</span></a>。</p>
<p>该函数通过 <a class="reference internal" href="site.xhtml#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块加入到内置命名空间。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span><a class="reference internal" href="pydoc.xhtml#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 和 <a class="reference internal" href="inspect.xhtml#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 的变更使得可调用对象的签名信息更加全面和一致。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hex">
<span class="sig-name descname"><span class="pre">hex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将整数转换为带前缀 &quot;0x&quot; 前缀的小写十六进制数字符串。 如果 <em>x</em> 不是一个 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，则它必须定义返回一个整数的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法。 下面是一些例子:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">&#39;0xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;-0x2a&#39;</span>
</pre></div>
</div>
<p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;#x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">255</span><span class="si">:</span><span class="s1">#x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">255</span><span class="si">:</span><span class="s1">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">255</span><span class="si">:</span><span class="s1">X</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<p>另请参阅 <a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 将十六进制字符串转换为以 16 为基数的整数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果要获取浮点数的十六进制字符串形式，请使用 <a class="reference internal" href="stdtypes.xhtml#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 方法。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 值。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> 这是对象在内存中的地址。</p>
</div>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.id</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">id</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="input">
<span class="sig-name descname"><span class="pre">input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prompt</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;--&gt; &#39;</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p>如果加载了 <a class="reference internal" href="readline.xhtml#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块，<a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 将使用它来提供复杂的行编辑和历史记录功能。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.input</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">prompt</span></code>。</p>
<p class="audit-hook"><p>在成功读取输入之后引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">builtins.input/result</span></code> 附带结果。</p>
</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="int">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return an integer object constructed from a number or a string, or return
<code class="docutils literal notranslate"><span class="pre">0</span></code> if no arguments are given.</p>
<p>示例：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="mf">123.45</span><span class="p">)</span>
<span class="go">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;   -12_345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;FACE&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="go">64206</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;0xface&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">64206</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;01110011&#39;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">115</span>
</pre></div>
</div>
<p>If the argument defines <a class="reference internal" href="../reference/datamodel.xhtml#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>,
<code class="docutils literal notranslate"><span class="pre">int(x)</span></code> returns <code class="docutils literal notranslate"><span class="pre">x.__int__()</span></code>.  If the argument defines <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>,
it returns <code class="docutils literal notranslate"><span class="pre">x.__index__()</span></code>.  If the argument defines <a class="reference internal" href="../reference/datamodel.xhtml#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a>,
it returns <code class="docutils literal notranslate"><span class="pre">x.__trunc__()</span></code>.
For floating point numbers, this truncates towards zero.</p>
<p>If the argument is not a number or if <em>base</em> is given, then it must be a string,
<a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, or <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> instance representing an integer
in radix <em>base</em>.  Optionally, the string can be preceded by <code class="docutils literal notranslate"><span class="pre">+</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code>
(with no space in between), have leading zeros, be surrounded by whitespace,
and have single underscores interspersed between digits.</p>
<p>一个以 n 为基数的整数字符串包含多个数位，每个数位代表从 0 到 n-1 范围内的值。 0--9 的值可以用任何 Unicode 十进制数码来表示。 10--35 的值可以用 <code class="docutils literal notranslate"><span class="pre">a</span></code> 到 <code class="docutils literal notranslate"><span class="pre">z</span></code> (或 <code class="docutils literal notranslate"><span class="pre">A</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Z</span></code>) 来表示。 默认的 <em>base</em> 为 10。 允许的基数为 0 和 2--36。 对于基数 2, -8 和 -16 来说字符串前面还能加上可选的 <code class="docutils literal notranslate"><span class="pre">0b</span></code>/<code class="docutils literal notranslate"><span class="pre">0B</span></code>, <code class="docutils literal notranslate"><span class="pre">0o</span></code>/<code class="docutils literal notranslate"><span class="pre">0O</span></code> 或 <code class="docutils literal notranslate"><span class="pre">0x</span></code>/<code class="docutils literal notranslate"><span class="pre">0X</span></code> 前缀，就像代码中的整数字面值那样。 对于基数 0 来说，字符串会以与 <a class="reference internal" href="../reference/lexical_analysis.xhtml#integers"><span class="std std-ref">代码中的整数字面值</span></a> 类似的方式来解读，即实际的基数将由前缀确定为 2, 8, 10 或 16。 基数为 0 还会禁用前导的零: <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">0)</span></code> 将是无效的，而 <code class="docutils literal notranslate"><span class="pre">int('010')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">8)</span></code> 则是有效的。</p>
<p>整数类型定义请参阅 <a class="reference internal" href="stdtypes.xhtml#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>如果 <em>base</em> 不是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的实例，但 <em>base</em> 对象有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a> 方法，则会调用该方法来获取进制数。以前的版本使用 <a class="reference internal" href="../reference/datamodel.xhtml#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__int__</span></code></a> 而不是 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>The first parameter is now positional-only.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>如果 <a class="reference internal" href="../reference/datamodel.xhtml#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 未定义则回退至 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>委托给 <a class="reference internal" href="../reference/datamodel.xhtml#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> 的做法已被弃用。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> string inputs and string representations can be limited to
help avoid denial of service attacks. A <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised when
the limit is exceeded while converting a string to an <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or
when converting an <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> into a string would exceed the limit.
See the <a class="reference internal" href="stdtypes.xhtml#int-max-str-digits"><span class="std std-ref">integer string conversion length limitation</span></a> documentation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="isinstance">
<span class="sig-name descname"><span class="pre">isinstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classinfo</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>object</em> 参数是 <em>classinfo</em> 参数的实例，或者是其 (直接、间接或 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a>) 子类的实例则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 如果 <em>object</em> 不是给定类型的对象，则该函数总是返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 如果 <em>classinfo</em> 是由类型对象结成的元组 (或是由其他此类元组递归生成) 或者是多个类型的 <a class="reference internal" href="stdtypes.xhtml#types-union"><span class="std std-ref">union 类型</span></a>，则如果 <em>object</em> 是其中任一类型的实例时将会返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 如果 <em>classinfo</em> 不是一个类型或类型元组及此类元组，则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。 如果之前的检查成功执行则可以不会为无效的类型引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><em>classinfo</em> 可以是一个 <a class="reference internal" href="stdtypes.xhtml#types-union"><span class="std std-ref">union 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="issubclass">
<span class="sig-name descname"><span class="pre">issubclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classinfo</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>class</em> 是 <em>classinfo</em> 的子类（直接、间接或 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">虚的</span></a> ），则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。类将视为自己的子类。<em>classinfo</em> 可为类对象的元组（或递归地，其他这样的元组）或 <a class="reference internal" href="stdtypes.xhtml#types-union"><span class="std std-ref">union 类型</span></a>，这时如果 <em>class</em> 是 <em>classinfo</em> 中任何条目的子类，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。任何其他情况都会触发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><em>classinfo</em> 可以是一个 <a class="reference internal" href="stdtypes.xhtml#types-union"><span class="std std-ref">union 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sentinel</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 对象。 根据是否存在第二个参数，对第一个参数的解读会有很大的不同。 如果没有第二个参数，<em>object</em> 必须是一个支持 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a> 协议 (有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法) 的多项集对象，或者必须支持序列协议 (有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法并使用从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始的整数参数)。 如果它不支持这些协议，则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 如果给出了第二个参数 <em>sentinel</em>，则 <em>object</em> 必须是一个可调用对象。 在这种情况下创建的迭代器将针对每次调用其 <a class="reference internal" href="stdtypes.xhtml#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法不带参数地调用 <em>object</em>；如果返回的值等于 <em>sentinel</em>，则会引发 <a class="reference internal" href="exceptions.xhtml#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，否则将返回该值。</p>
<p>另请参阅 <a class="reference internal" href="stdtypes.xhtml#typeiter"><span class="std std-ref">迭代器类型</span></a>。</p>
<p>适合 <a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mydata.db&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">process_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="len">
<span class="sig-name descname"><span class="pre">len</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> <code class="docutils literal notranslate"><span class="pre">len</span></code> 对于大于 <a class="reference internal" href="sys.xhtml#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 的长度如 <a class="reference internal" href="stdtypes.xhtml#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range(2</span> <span class="pre">**</span> <span class="pre">100)</span></code></a> 会引发 <a class="reference internal" href="exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class" id="func-list">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，<a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 实际上是一种可变序列类型，详情请参阅 <a class="reference internal" href="stdtypes.xhtml#typesseq-list"><span class="std std-ref">列表</span></a> 和 <a class="reference internal" href="stdtypes.xhtml#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="locals">
<span class="sig-name descname"><span class="pre">locals</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Update and return a dictionary representing the current local symbol table.
Free variables are returned by <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> when it is called in function
blocks, but not in class blocks. Note that at the module level, <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>
and <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> are the same dictionary.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>The contents of this dictionary should not be modified; changes may not
affect the values of local and free variables used by the interpreter.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个将 <em>function</em> 应用于 <em>iterable</em> 的每一项，并产生其结果的迭代器。 如果传入了额外的 <em>iterables</em> 参数，则 <em>function</em> 必须接受相同个数的参数并被用于到从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，当最短的可迭代对象耗尽则整个迭代将会停止。  对于函数的输入已经是参数元组的情况，请参阅 <a class="reference internal" href="itertools.xhtml#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.starmap()</span></code></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个位置参数，它必须是非空 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a>，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.xhtml#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc,</span> <span class="pre">reverse=True)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nlargest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>增加了 <em>default</em> 仅限关键字形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span><em>key</em> 可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</div>
</dd></dl>

<dl class="py class" id="func-memoryview">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">memoryview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.xhtml#typememoryview"><span class="std std-ref">内存视图</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个位置参数，它必须是 <a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a>，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.xhtml#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>增加了 <em>default</em> 仅限关键字形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span><em>key</em> 可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通过调用 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 的 <a class="reference internal" href="stdtypes.xhtml#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <a class="reference internal" href="exceptions.xhtml#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="object">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">object</span></span></dt>
<dd><p>返回一个不带特征的新对象。<a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 是所有类的基类。它带有所有 Python 类实例均通用的方法。本函数不接受任何参数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 没有 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>，因此无法将任意属性赋给 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的实例。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oct">
<span class="sig-name descname"><span class="pre">oct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将整数转换为带前缀 &quot;0o&quot; 的八进制数字符串。 结果是一个合法的 Python 表达式。 如果 <em>x</em> 不是一个 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，则它必须定义返回一个整数的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法。 例如:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0o10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="o">-</span><span class="mi">56</span><span class="p">)</span>
<span class="go">&#39;-0o70&#39;</span>
</pre></div>
</div>
<p>若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;#o&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">10</span><span class="si">:</span><span class="s1">#o</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">10</span><span class="si">:</span><span class="s1">o</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
</dd></dl>

<dl class="py function" id="index-5">
<dt class="sig sig-object py" id="open">
<span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">closefd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opener</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>打开 <em>file</em> 并返回对应的 <a class="reference internal" href="../glossary.xhtml#term-file-object"><span class="xref std std-term">file object</span></a>。 如果该文件不能被打开，则引发 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。 请参阅 <a class="reference internal" href="../tutorial/inputoutput.xhtml#tut-files"><span class="std std-ref">读写文件</span></a> 获取此函数的更多用法示例。</p>
<p><em>file</em> 是一个 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">path-like object</span></a>，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的 I/O 对象关闭时它也会关闭，除非将 <em>closefd</em> 设为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。）</p>
<p><em>mode</em> 是一个指明文件打开模式的可选字符串。 它默认为 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 表示以文本模式读取。 其他常见模式有表示写入的 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> (若文件已存在则将其清空)，表示独占创建的 <code class="docutils literal notranslate"><span class="pre">'x'</span></code>，以及表示追加写入的 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> (在 <em>某些</em> Unix 系统上，这意味着无论当前查找位置在哪里 <em>所有</em> 写入操作都将追加到文件末尾)。 在文本模式下，如果未指定 <em>encoding</em> 则所使用的编码格式将依赖于具体平台: <a class="reference internal" href="locale.xhtml#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> 会被调用以获取当前语言区域的编码格式。 (对于读取和写入原始字节数据请使用二进制模式并且不要指定 <em>encoding</em>。) 可用的模式有:</p>
<span id="filemodes"></span><table class="docutils align-default" id="index-6">
<thead>
<tr class="row-odd"><th class="head"><p>字符</p></th>
<th class="head"><p>含意</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
<td><p>读取（默认）</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w'</span></code></p></td>
<td><p>写入，并先截断文件</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x'</span></code></p></td>
<td><p>排它性创建，如果文件已存在则失败</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
<td><p>打开文件用于写入，如果文件存在则在末尾追加</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p>二进制模式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'t'</span></code></p></td>
<td><p>文本模式（默认）</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'+'</span></code></p></td>
<td><p>打开用于更新（读取与写入）</p></td>
</tr>
</tbody>
</table>
<p>默认模式为 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> （打开文件用于读取文本，与 <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> 同义）。<code class="docutils literal notranslate"><span class="pre">'w+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'w+b'</span></code> 模式将打开文件并清空内容。而 <code class="docutils literal notranslate"><span class="pre">'r+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'r+b'</span></code> 模式将打开文件但不清空内容。</p>
<p>正如在 <a class="reference internal" href="io.xhtml#io-overview"><span class="std std-ref">概述</span></a> 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 <em>mode</em> 参数中的 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> ）返回的内容为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象，不进行任何解码。在文本模式下（默认情况下，或者在 <em>mode</em> 参数中包含 <code class="docutils literal notranslate"><span class="pre">'t'</span></code> ）时，文件内容返回为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ，首先使用指定的 <em>encoding</em> （如果给定）或者使用平台默认的的字节编码解码。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。</p>
</div>
<p><em>buffering</em> 是一个可选的整数，用于设置缓冲策略。 传入 0 来关闭缓冲（仅在二进制模式下允许），传入 1 来选择行缓冲（仅在文本模式下写入时可用），传一个整数 &gt; 1 来表示固定大小的块缓冲区的字节大小。 注意这样指定缓冲区的大小适用于二进制缓冲的 I/O,但 <code class="docutils literal notranslate"><span class="pre">TextIOWrapper</span></code> (即用 <code class="docutils literal notranslate"><span class="pre">mode='r+'</span></code> 打开的文件) 会有另一种缓冲。 要禁用 <code class="docutils literal notranslate"><span class="pre">TextIOWrapper</span></code> 中的缓冲，请考虑为 <a class="reference internal" href="io.xhtml#io.TextIOWrapper.reconfigure" title="io.TextIOWrapper.reconfigure"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.TextIOWrapper.reconfigure()</span></code></a> 使用 <code class="docutils literal notranslate"><span class="pre">write_through</span></code> 旗标。 当没有给出 <em>buffering</em> 参数时，默认的缓冲策略规则如下:</p>
<ul class="simple">
<li><p>二进制文件以固定大小的块进行缓冲；缓冲区的大小是使用启发方式来尝试确定底层设备的“块大小”并会回退至 <a class="reference internal" href="io.xhtml#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-const docutils literal notranslate"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a>。 在许多系统上，缓冲区的长度通常为 4096 或 8192 字节。</p></li>
<li><p>“交互式”文本文件（ <a class="reference internal" href="io.xhtml#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isatty()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</p></li>
</ul>
<p><em>encoding</em> 是用于编码或编码文件的编码格式名称。 这应当只有文本模式下使用。 默认的编码格式依赖于具体平台 (即 <a class="reference internal" href="locale.xhtml#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> 所返回的值)，但是任何 Python 支持的 <a class="reference internal" href="../glossary.xhtml#term-text-encoding"><span class="xref std std-term">text encoding</span></a> 都可以被使用。 请参阅 <a class="reference internal" href="codecs.xhtml#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块获取受支持的编码格式列表。</p>
<p><em>errors</em> 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 <a class="reference internal" href="codecs.xhtml#error-handlers"><span class="std std-ref">错误处理方案</span></a> ），但是使用 <a class="reference internal" href="codecs.xhtml#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 注册的任何错误处理名称也是有效的。标准名称包括:</p>
<ul class="simple">
<li><p>如果存在编码错误，<code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。 默认值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 具有相同的效果。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 忽略错误。请注意，忽略编码错误可能会导致数据丢失。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 会将替换标记（例如 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> ）插入有错误数据的地方。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 错误处理器时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> 仅在写入文件时才受到支持。 编码格式不支持的字符将被替换为相应的 XML 字符引用 <code class="samp docutils literal notranslate"><span class="pre">&amp;#</span><em><span class="pre">nnn</span></em><span class="pre">;</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 用Python的反向转义序列替换格式错误的数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> （也只在编写时支持）用 <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 转义序列替换不支持的字符。</p></li>
</ul>
<p id="open-newline-parameter"><span id="index-7"></span><em>newline</em> 决定如何解析来自流的换行符。 它可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>。 它的工作原理如下:</p>
<ul class="simple">
<li><p>从流中读取输入时，如果 <em>newline</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则启用通用换行模式。输入中的行可以以 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，<code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 结尾，这些行被翻译成 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 在返回呼叫者之前。如果它是 <code class="docutils literal notranslate"><span class="pre">''</span></code>，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。</p></li>
<li><p>将输出写入流时，如果 <em>newline</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则写入的任何 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符都将转换为系统默认行分隔符 <a class="reference internal" href="os.xhtml#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.linesep</span></code></a>。如果 <em>newline</em> 是 <code class="docutils literal notranslate"><span class="pre">''</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符将被转换为给定的字符串。</p></li>
</ul>
<p>如果 <em>closefd</em> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 <em>closefd</em> 必须为 <code class="docutils literal notranslate"><span class="pre">True</span></code> （默认值），否则将触发错误。</p>
<p>可以通过传递可调用的 <em>opener</em> 来使用自定义开启器。然后通过使用参数（ <em>file</em>，<em>flags</em> ）调用 <em>opener</em> 获得文件对象的基础文件描述符。 <em>opener</em> 必须返回一个打开的文件描述符（使用 <a class="reference internal" href="os.xhtml#os.open" title="os.open"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.open</span></code></a> as <em>opener</em> 时与传递 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的效果相同）。</p>
<p>新创建的文件是 <a class="reference internal" href="os.xhtml#fd-inheritance"><span class="std std-ref">不可继承的</span></a>。</p>
<p>下面的示例使用 <a class="reference internal" href="os.xhtml#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 函数的 <a class="reference internal" href="os.xhtml#dir-fd"><span class="std std-ref">dir_fd</span></a> 的形参，从给定的目录中用相对路径打开文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;spamspam.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This will be written to somedir/spamspam.txt&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don&#39;t leak a file descriptor</span>
</pre></div>
</div>
<p><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 函数所返回的 <a class="reference internal" href="../glossary.xhtml#term-file-object"><span class="xref std std-term">file object</span></a> 类型取决于所用模式。 当使用 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 以文本模式 (<code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wt'</span></code>, <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> 等) 打开文件时，它将返回 <a class="reference internal" href="io.xhtml#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> (具体为 <a class="reference internal" href="io.xhtml#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 <a class="reference internal" href="io.xhtml#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 <a class="reference internal" href="io.xhtml#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a>；在写入二进制和追加二进制模式下，它将返回 <a class="reference internal" href="io.xhtml#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedWriter</span></code></a>，而在读/写模式下，它将返回 <a class="reference internal" href="io.xhtml#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedRandom</span></code></a>。 当禁用缓冲时，则会返回原始流，即 <a class="reference internal" href="io.xhtml#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的一个子类 <a class="reference internal" href="io.xhtml#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</p>
<p id="index-8">另请参阅文件操作模块，如 <a class="reference internal" href="fileinput.xhtml#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a>、<a class="reference internal" href="io.xhtml#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> （声明了 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>）、<a class="reference internal" href="os.xhtml#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>、<a class="reference internal" href="os.path.xhtml#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a>、<a class="reference internal" href="tempfile.xhtml#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a> 和 <a class="reference internal" href="shutil.xhtml#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">open</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">mode</span></code>, <code class="docutils literal notranslate"><span class="pre">flags</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">mode</span></code> 与 <code class="docutils literal notranslate"><span class="pre">flags</span></code> 参数可以在原始调用的基础上被修改或传递。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span></p>
<ul class="simple">
<li><p>增加了 <em>opener</em> 形参。</p></li>
<li><p>增加了 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 模式。</p></li>
<li><p>过去触发的 <a class="reference internal" href="exceptions.xhtml#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>，现在是 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p></li>
<li><p>如果文件已存在但使用了排它性创建模式（ <code class="docutils literal notranslate"><span class="pre">'x'</span></code> ），现在会触发 <a class="reference internal" href="exceptions.xhtml#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a>。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span></p>
<ul class="simple">
<li><p>文件现在禁止继承。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span></p>
<ul class="simple">
<li><p>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a class="reference internal" href="exceptions.xhtml#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 异常 (原因详见 <span class="target" id="index-24"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a><span class="link-target"> [https://peps.python.org/pep-0475/]</span>)。</p></li>
<li><p>增加了 <code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 错误处理接口。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span></p>
<ul class="simple">
<li><p>增加对实现了 <a class="reference internal" href="os.xhtml#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 对象的支持。</p></li>
<li><p>在 Windows 上，打开一个控制台缓冲区将返回 <a class="reference internal" href="io.xhtml#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的子类，而不是 <a class="reference internal" href="io.xhtml#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">'U'</span></code> 模式已被移除。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ord">
<span class="sig-name descname"><span class="pre">ord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code class="docutils literal notranslate"><span class="pre">ord('a')</span></code> 返回整数 <code class="docutils literal notranslate"><span class="pre">97</span></code>， <code class="docutils literal notranslate"><span class="pre">ord('€')</span></code> （欧元符号）返回 <code class="docutils literal notranslate"><span class="pre">8364</span></code> 。这是 <a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 的逆函数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pow">
<span class="sig-name descname"><span class="pre">pow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>base</em> 的 <em>exp</em> 次幂；如果 <em>mod</em> 存在，则返回 <em>base</em> 的 <em>exp</em> 次幂对 <em>mod</em> 取余（比 <code class="docutils literal notranslate"><span class="pre">pow(base,</span> <span class="pre">exp)</span> <span class="pre">%</span> <span class="pre">mod</span></code> 更高效）。 两参数形式 <code class="docutils literal notranslate"><span class="pre">pow(base,</span> <span class="pre">exp)</span></code> 等价于乘方运算符: <code class="docutils literal notranslate"><span class="pre">base**exp</span></code>。</p>
<p>参数必须为数值类型。 对于混用的操作数类型，则适用二元算术运算符的类型强制转换规则。 对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数，结果具有与操作数相同的类型（转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。 例如，<code class="docutils literal notranslate"><span class="pre">pow(10,</span> <span class="pre">2)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">100</span></code>，但 <code class="docutils literal notranslate"><span class="pre">pow(10,</span> <span class="pre">-2)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0.01</span></code>。 对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 或 <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 类型的负基和一个非整数的指数，会产生一个复数作为结果。 例如， <code class="docutils literal notranslate"><span class="pre">pow(-9,</span> <span class="pre">0.5)</span></code> 返回一个接近于 <code class="docutils literal notranslate"><span class="pre">3j</span></code> 的值。</p>
<p>对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数 <em>base</em> 和 <em>exp</em>，如果给出 <em>mod</em>，则 <em>mod</em> 必须为整数类型并且 <em>mod</em> 必须不为零。 如果给出 <em>mod</em> 并且 <em>exp</em> 为负值，则 <em>base</em> 必须相对于 <em>mod</em> 不可整除。 在这种情况下，将会返回 <code class="docutils literal notranslate"><span class="pre">pow(inv_base,</span> <span class="pre">-exp,</span> <span class="pre">mod)</span></code>，其中 <em>inv_base</em> 为 <em>base</em> 的倒数对 <em>mod</em> 取余。</p>
<p>下面的例子是 <code class="docutils literal notranslate"><span class="pre">38</span></code> 的倒数对 <code class="docutils literal notranslate"><span class="pre">97</span></code> 取余:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">pow</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="mi">97</span><span class="p">)</span>
<span class="go">23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">23</span> <span class="o">*</span> <span class="mi">38</span> <span class="o">%</span> <span class="mi">97</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数，三参数形式的 <code class="docutils literal notranslate"><span class="pre">pow</span></code> 现在允许第二个参数为负值，即可以计算倒数的余数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>允许关键字参数。 之前只支持位置参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">objects</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span> <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\n'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flush</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <em>objects</em> 打印输出至 <em>file</em> 指定的文本流，以 <em>sep</em> 分隔并在末尾加上 <em>end</em>。 <em>sep</em> 、 <em>end</em> 、 <em>file</em> 和 <em>flush</em> 必须以关键字参数的形式给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 一样，并会被写入到流，以 <em>sep</em> 分隔并在末尾加上 <em>end</em>。 <em>sep</em> 和 <em>end</em> 都必须为字符串；它们也可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，这意味着使用默认值。 如果没有给出 <em>objects</em>，则 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 将只写入 <em>end</em>。</p>
<p><em>file</em> 参数必须是一个具有 <code class="docutils literal notranslate"><span class="pre">write(string)</span></code> 方法的对象；如果参数不存在或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则将使用 <a class="reference internal" href="sys.xhtml#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>。 由于要打印的参数会被转换为文本字符串，因此 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 不能用于二进制模式的文件对象。 对于这些对象，应改用 <code class="docutils literal notranslate"><span class="pre">file.write(...)</span></code>。</p>
<p>输出缓冲通常由 <em>file</em> 确定。 但是，如果 <em>flush</em> 为真值，流将被强制刷新。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>增加了 <em>flush</em> 关键字参数。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="property">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">property</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fget</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 property 属性。</p>
<p><em>fget</em> 是获取属性值的函数。 <em>fset</em> 是用于设置属性值的函数。 <em>fdel</em> 是用于删除属性值的函数。并且 <em>doc</em> 为属性对象创建文档字符串。</p>
<p>一个典型的用法是定义一个托管属性 <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <em>c</em> 为 <em>C</em> 的实例，<code class="docutils literal notranslate"><span class="pre">c.x</span></code> 将调用 getter，<code class="docutils literal notranslate"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></code> 将调用 setter， <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">c.x</span></code> 将调用 deleter。</p>
<p>如果给出，<em>doc</em> 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 <em>fget</em> 的文档字符串（如果存在）。 这令使用 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 作为 <a class="reference internal" href="../glossary.xhtml#term-decorator"><span class="xref std std-term">decorator</span></a> 来创建只读的特征属性可以很容易地实现:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 装饰器会将 <code class="xref py py-meth docutils literal notranslate"><span class="pre">voltage()</span></code> 方法转化为一个具有相同名称的只读属性 &quot;getter&quot;，并将 <em>voltage</em> 的文档字符串设为 &quot;Get the current voltage.&quot;</p>
<dl class="py function">
<dt class="sig sig-object py" id="property.getter">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">getter</span></span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="property.setter">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">setter</span></span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="property.deleter">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">deleter</span></span></dt>
<dd><p>特征属性对象具有 <code class="docutils literal notranslate"><span class="pre">getter</span></code>, <code class="docutils literal notranslate"><span class="pre">setter</span></code> 和 <code class="docutils literal notranslate"><span class="pre">deleter</span></code> 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来说明：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 <code class="docutils literal notranslate"><span class="pre">x</span></code>。)</p>
<p>返回的特征属性对象同样具有与构造器参数相对应的属性 <code class="docutils literal notranslate"><span class="pre">fget</span></code>, <code class="docutils literal notranslate"><span class="pre">fset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fdel</span></code>。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>特征属性对象的文档字符串现在是可写的。</p>
</div>
</dd></dl>

<dl class="py class" id="func-range">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，但 <a class="reference internal" href="stdtypes.xhtml#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 实际上是一个不可变的序列类型，参见在 <a class="reference internal" href="stdtypes.xhtml#typesseq-range"><span class="std std-ref">range 对象</span></a> 与 <a class="reference internal" href="stdtypes.xhtml#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a> 中的文档说明。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="repr">
<span class="sig-name descname"><span class="pre">repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回包含一个对象的可打印表示形式的字符串。 对于许多类型而言，此函数会尝试返回一个具有与传给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 时相同的值的字符串；在其他情况下，其表示形式将为一个包含对象类型名称和通常包括对象名称和地址的额外信息的用尖括号括起来的字符串。 一个类可以通过定义 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 方法来控制此函数为其实例所返回的内容。 如果 <a class="reference internal" href="sys.xhtml#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.displayhook()</span></code></a> 不可访问，则此函数将会引发 <a class="reference internal" href="exceptions.xhtml#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
<p>该类具有自定义的表示形式，它可被求值为:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

   <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Person(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="si">}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="reversed">
<span class="sig-name descname"><span class="pre">reversed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个反向的 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a>。 <em>seq</em> 必须是一个具有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 方法或是支持序列协议（具有 <a class="reference internal" href="../reference/datamodel.xhtml#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 方法和从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始的整数参数的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法）的对象。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="round">
<span class="sig-name descname"><span class="pre">round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndigits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>number</em> 舍入到小数点后 <em>ndigits</em> 位精度的值。 如果 <em>ndigits</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则返回最接近输入值的整数。</p>
<p>对于支持 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 方法的内置类型，结果值会舍入至最接近的 10 的负 <em>ndigits</em> 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，<code class="docutils literal notranslate"><span class="pre">round(0.5)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">round(-0.5)</span></code> 均得出 <code class="docutils literal notranslate"><span class="pre">0</span></code> 而 <code class="docutils literal notranslate"><span class="pre">round(1.5)</span></code> 则为 <code class="docutils literal notranslate"><span class="pre">2</span></code>。<em>ndigits</em> 可为任意整数值（正数、零或负数）。如果省略了 <em>ndigits</em> 或为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则返回值将为整数。否则返回值与 <em>number</em> 的类型相同。</p>
<p>对于一般的 Python 对象 <code class="docutils literal notranslate"><span class="pre">number</span></code>, <code class="docutils literal notranslate"><span class="pre">round</span></code> 将委托给 <code class="docutils literal notranslate"><span class="pre">number.__round__</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对浮点数执行 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 的行为可能会令人惊讶：例如，<code class="docutils literal notranslate"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code> 将给出 <code class="docutils literal notranslate"><span class="pre">2.67</span></code> 而不是期望的 <code class="docutils literal notranslate"><span class="pre">2.68</span></code>。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 <a class="reference internal" href="../tutorial/floatingpoint.xhtml#tut-fp-issues"><span class="std std-ref">浮点算术：争议和限制</span></a> 了解更多信息。</p>
</div>
</dd></dl>

<dl class="py class" id="func-set">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 对象，可以选择带有从 <em>iterable</em> 获取的元素。 <code class="docutils literal notranslate"><span class="pre">set</span></code> 是一个内置类型。 请查看 <a class="reference internal" href="stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#types-set"><span class="std std-ref">集合类型 --- set, frozenset</span></a> 获取关于这个类的文档。</p>
<p>有关其他容器请参看内置的 <a class="reference internal" href="stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.xhtml#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="setattr">
<span class="sig-name descname"><span class="pre">setattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>本函数与 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 <code class="docutils literal notranslate"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code>。</p>
<p><em>name</em> 无需为在 <a class="reference internal" href="../reference/lexical_analysis.xhtml#identifiers"><span class="std std-ref">标识符和关键字</span></a> 中定义的 Python 标识符除非对象选择强制这样做，例如在一个自定义的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 中或是通过 <a class="reference internal" href="../reference/datamodel.xhtml#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>。 一个名称不为标识符的属性将不可使用点号标记来访问，但是可以通过 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 等来访问。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于 <a class="reference internal" href="../reference/expressions.xhtml#private-name-mangling"><span class="std std-ref">私有名称混合</span></a> 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 <a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> 来设置它。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="slice">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个表示由 <code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 指定的索引集的 <a class="reference internal" href="../glossary.xhtml#term-slice"><span class="xref std std-term">slice</span></a> 对象。 <em>start</em> 和 <em>step</em> 参数默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="slice.start">
<span class="sig-name descname"><span class="pre">start</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="slice.stop">
<span class="sig-name descname"><span class="pre">stop</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="slice.step">
<span class="sig-name descname"><span class="pre">step</span></span></dt>
<dd><p>切片对象具有只读的数据属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code>，它们将简单地返回相应的参数值（或其默认值）。 它们没有其他显式的功能；但是，它们会被 NumPy 和其他第三方包所使用。</p>
</dd></dl>

<p>当使用扩展索引语法时也会生成切片对象。 例如: <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code>。 请参阅 <a class="reference internal" href="itertools.xhtml#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 了解返回 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 的替代版本。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>Slice 对象现在将为 <a class="reference internal" href="../glossary.xhtml#term-hashable"><span class="xref std std-term">hashable</span></a> (如果 <a class="reference internal" href="#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>, <a class="reference internal" href="#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> 和 <a class="reference internal" href="#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> 均为可哈希对象)。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sorted">
<span class="sig-name descname"><span class="pre">sorted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>根据 <em>iterable</em> 中的项返回一个新的已排序列表。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的函数，用于从 <em>iterable</em> 的每个元素中提取用于比较的键 (例如 <code class="docutils literal notranslate"><span class="pre">key=str.lower</span></code>)。 默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>使用 <a class="reference internal" href="functools.xhtml#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> 可将老式的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p>内置的 <a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<p>排序算法只使用 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 在项目之间比较。 虽然定义一个 <a class="reference internal" href="../reference/datamodel.xhtml#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 方法就足以进行排序，但 <span class="target" id="index-25"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a><span class="link-target"> [https://peps.python.org/pep-0008/]</span> 建议实现所有六个 <a class="reference internal" href="../reference/expressions.xhtml#comparisons"><span class="std std-ref">富比较</span></a> 。 这将有助于避免在与其他排序工具（如 <a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> ）使用相同的数据时出现错误，这些工具依赖于不同的底层方法。实现所有六个比较也有助于避免混合类型比较的混乱，因为混合类型比较可以调用反射到 <a class="reference internal" href="../reference/datamodel.xhtml#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 的方法。</p>
<p>有关排序示例和简要排序教程，请参阅 <a class="reference internal" href="../howto/sorting.xhtml#sortinghowto"><span class="std std-ref">排序的技术</span></a> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="staticmethod">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-name descname"><span class="pre">staticmethod</span></span></dt>
<dd><p>将方法转换为静态方法。</p>
<p>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">argN</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> 这样的形式称为函数的 <a class="reference internal" href="../glossary.xhtml#term-decorator"><span class="xref std std-term">decorator</span></a> -- 详情参阅 <a class="reference internal" href="../reference/compound_stmts.xhtml#function"><span class="std std-ref">函数定义</span></a>。</p>
<p>静态方式既可以在类上调用 (如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>)，也可以在实例上调用 (如 <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>)。 此外，静态方法 <a class="reference internal" href="../glossary.xhtml#term-descriptor"><span class="xref std std-term">descriptor</span></a> 也属于可调用对象，因而它们可以在类定义中使用 (如 <code class="docutils literal notranslate"><span class="pre">f()</span></code>)。</p>
<p>Python 的静态方法与 Java 或 C++ 类似。另请参阅 <a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> ，可用于创建另一种类构造函数。</p>
<p>像所有装饰器一样，也可以像常规函数一样调用 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">regular_function</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">regular_function</span><span class="p">)</span>
</pre></div>
</div>
<p>想了解更多有关静态方法的信息，请参阅 <a class="reference internal" href="../reference/datamodel.xhtml#types"><span class="std std-ref">标准类型层级结构</span></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>静态方法继承了方法的多个属性（ <code class="docutils literal notranslate"><span class="pre">__module__</span></code>、 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>、 <code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>、 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>），还拥有一个新的 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性，并且现在还可以作为普通函数进行调用。</p>
</div>
</dd></dl>

<dl class="py class" id="func-str">
<span id="index-11"></span><dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 版本的 <em>object</em> 。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">str</span></code> 是内置字符串 <a class="reference internal" href="../glossary.xhtml#term-class"><span class="xref std std-term">class</span></a> 。更多关于字符串的信息查看 <a class="reference internal" href="stdtypes.xhtml#textseq"><span class="std std-ref">文本序列类型 --- str</span></a>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从 <em>start</em> 开始自左向右对 <em>iterable</em> 的项求和并返回总计值。 <em>iterable</em> 的项通常为数字，而 start 值则不允许为字符串。</p>
<p>对某些用例来说，存在 <a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 的更好替代。 拼接字符串序列的更好更快方式是调用 <code class="docutils literal notranslate"><span class="pre">''.join(sequence)</span></code>。 要以扩展精度对浮点值求和，请参阅 <a class="reference internal" href="math.xhtml#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fsum()</span></code></a>。 要拼接一系列可迭代对象，请考虑使用 <a class="reference internal" href="itertools.xhtml#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.chain()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span><em>start</em> 形参可用关键字参数形式来指定。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>Summation of floats switched to an algorithm
that gives higher accuracy on most builds.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="super">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">super</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">super</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_or_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个代理对象，它会将方法调用委托给 <em>type</em> 的父类或兄弟类。 这对于访问已在类中被重写的继承方法很有用。</p>
<p><em>object_or_type</em> 确定要用于搜索的 <a class="reference internal" href="../glossary.xhtml#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a>。 搜索会从 <em>type</em> 之后的类开始。</p>
<p>举例来说，如果 <em>object_or_type</em> 的 <a class="reference internal" href="stdtypes.xhtml#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">object</span></code> 并且 <em>type</em> 的值为 <code class="docutils literal notranslate"><span class="pre">B</span></code>，则 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 将会搜索 <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">object</span></code>。</p>
<p><em>object_or_type</em> 的 <a class="reference internal" href="stdtypes.xhtml#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a> 属性列出了 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 和 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 所共同使用的方法解析搜索顺序。 该属性是动态的并可在任何继承层级结构发生更新时被改变。</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> 必须为真值。 如果第二个参数为一个类型，则 <code class="docutils literal notranslate"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code> 必须为真值（这适用于类方法）。</p>
<p><em>super</em> 有两个典型用例。 在具有单继承的类层级结构中，<em>super</em> 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 <em>super</em> 的用法非常相似。</p>
<p>第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。</p>
<p>对于以上两个用例，典型的超类调用看起来是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</pre></div>
</div>
<p>除了方法查找之外，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 <a class="reference internal" href="../glossary.xhtml#term-descriptor"><span class="xref std std-term">描述器</span></a>。</p>
<p>请注意 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 被实现为为显式的带点号属性查找的绑定过程的组成部分，例如 <code class="docutils literal notranslate"><span class="pre">super().__getitem__(name)</span></code>。 它做到这一点是通过实现自己的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 方法以便能够按支持协作多重继承的可预测的顺序来搜索类。 相应地，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 在像 <code class="docutils literal notranslate"><span class="pre">super()[name]</span></code> 这样使用语句或运算符进行隐式查找时则是未定义的。</p>
<p>还要注意的是，除了零个参数的形式以外，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。</p>
<p>对于有关如何使用 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 来如何设计协作类的实用建议，请参阅 <a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">使用 super() 的指南</a><span class="link-target"> [https://rhettinger.wordpress.com/2011/05/26/super-considered-super/]</span>。</p>
</dd></dl>

<dl class="py class" id="func-tuple">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tuple</span></span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，但 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 实际上是一个不可变的序列类型，参见在 <a class="reference internal" href="stdtypes.xhtml#typesseq-tuple"><span class="std std-ref">元组</span></a> 与 <a class="reference internal" href="stdtypes.xhtml#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a> 中的文档说明。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span></dt>
<dd><p id="index-12">传入一个参数时，返回 <em>object</em> 的类型。 返回值是一个 type 对象，通常与 <a class="reference internal" href="stdtypes.xhtml#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__class__</span></code></a> 所返回的对象相同。</p>
<p>推荐使用 <a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 内置函数来检测对象的类型，因为它会考虑子类的情况。</p>
<p>传入三个参数时，返回一个新的 type 对象。 这在本质上是 <a class="reference internal" href="../reference/compound_stmts.xhtml#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 语句的一种动态形式，<em>name</em> 字符串即类名并会成为 <a class="reference internal" href="stdtypes.xhtml#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性；<em>bases</em> 元组包含基类并会成为 <a class="reference internal" href="stdtypes.xhtml#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 属性；如果为空则会添加所有类的终极基类 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>。 <em>dict</em> 字典包含类主体的属性和方法定义；它在成为 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性之前可能会被拷贝或包装。 下面两条语句会创建相同的 <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 对象:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>另请参阅 <a class="reference internal" href="stdtypes.xhtml#bltin-type-objects"><span class="std std-ref">类型对象</span></a>。</p>
<p>提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a>)，相当于类定义中关键字 (除了 <em>metaclass</em>) 的行为方式。</p>
<p>另请参阅 <a class="reference internal" href="../reference/datamodel.xhtml#class-customization"><span class="std std-ref">自定义类创建</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span><a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的子类如果未重载 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>，将不再能使用一个参数的形式来获取对象的类型。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vars">
<span class="sig-name descname"><span class="pre">vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回模块、类、实例或任何其它具有 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性的对象的 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性。</p>
<p>模块和实例这样的对象具有可更新的 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性；但是，其它对象的 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性可能会设为限制写入（例如，类会使用 <a class="reference internal" href="types.xhtml#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> 来防止直接更新字典）。</p>
<p>不带参数时，<a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a> 的行为类似 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。</p>
<p>如果指定了一个对象但它没有 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性（例如，当它所属的类定义了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 属性时）则会引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zip">
<span class="sig-name descname"><span class="pre">zip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。</p>
<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;sugar&#39;</span><span class="p">,</span> <span class="s1">&#39;spice&#39;</span><span class="p">,</span> <span class="s1">&#39;everything nice&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, &#39;sugar&#39;)</span>
<span class="go">(2, &#39;spice&#39;)</span>
<span class="go">(3, &#39;everything nice&#39;)</span>
</pre></div>
</div>
<p>更正式的说法： <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 返回元组的迭代器，其中第 <em>i</em> 个元组包含的是每个参数迭代器的第 <em>i</em> 个元素。</p>
<p>不妨换一种方式认识 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> ：它会把行变成列，把列变成行。这类似于 <a class="reference external" href="https://en.wikipedia.org/wiki/Transpose">矩阵转置</a><span class="link-target"> [https://en.wikipedia.org/wiki/Transpose]</span> 。</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 是延迟执行的：直至迭代时才会对元素进行处理，比如 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 循环或放入 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 中。</p>
<p>值得考虑的是，传给 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python 提供了三种不同的处理方案：</p>
<ul>
<li><p>默认情况下，<a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;fee&#39;</span><span class="p">,</span> <span class="s1">&#39;fi&#39;</span><span class="p">,</span> <span class="s1">&#39;fo&#39;</span><span class="p">,</span> <span class="s1">&#39;fum&#39;</span><span class="p">]))</span>
<span class="go">[(0, &#39;fee&#39;), (1, &#39;fi&#39;), (2, &#39;fo&#39;)]</span>
</pre></div>
</div>
</li>
<li><p>通常 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 用于可迭代对象等长的情况下。这时建议用 <code class="docutils literal notranslate"><span class="pre">strict=True</span></code> 的选项。输出与普通的 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 相同：。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>与默认行为不同，如果一个可迭代对象在其他几个之前被耗尽则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;fee&#39;</span><span class="p">,</span> <span class="s1">&#39;fi&#39;</span><span class="p">,</span> <span class="s1">&#39;fo&#39;</span><span class="p">,</span> <span class="s1">&#39;fum&#39;</span><span class="p">],</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(0, &#39;fee&#39;)</span>
<span class="go">(1, &#39;fi&#39;)</span>
<span class="go">(2, &#39;fo&#39;)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">zip() argument 2 is longer than argument 1</span>
</pre></div>
</div>
<p>如果未指定 <code class="docutils literal notranslate"><span class="pre">strict=True</span></code> 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会在程序的其他地方表现为难以发现的错误。</p>
</li>
<li><p>为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 <a class="reference internal" href="itertools.xhtml#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a> 来完成。</p></li>
</ul>
<p>极端例子是只有一个可迭代对象参数，<a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。</p>
<p>小技巧：</p>
<ul>
<li><p>可确保迭代器的求值顺序是从左到右的。这样就能用 <code class="docutils literal notranslate"><span class="pre">zip(*[iter(s)]*n,</span> <span class="pre">strict=True)</span></code> 将数据列表按长度 n 进行分组。这将重复 <em>相同</em> 的迭代器 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次，输出的每个元组都包含 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。</p></li>
<li><p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 与 <code class="docutils literal notranslate"><span class="pre">*</span></code> 运算符相结合可以用来拆解一个列表:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">strict</span></code> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="import__">
<span class="sig-name descname"><span class="pre">__import__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><div class="admonition note" id="index-13">
<p class="admonition-title">备注</p>
<p>与 <a class="reference internal" href="importlib.xhtml#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 不同，这是一个日常 Python 编程中不需要用到的高级函数。</p>
</div>
<p>此函数会由 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句发起调用。 它可以被替换 (通过导入 <a class="reference internal" href="builtins.xhtml#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块并赋值给 <code class="docutils literal notranslate"><span class="pre">builtins.__import__</span></code>) 以便修改 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a><span class="link-target"> [https://peps.python.org/pep-0302/]</span>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 而应该用 <a class="reference internal" href="importlib.xhtml#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>。</p>
<p>本函数会导入模块 <em>name</em>，利用 <em>globals</em> 和 <em>locals</em> 来决定如何在包的上下文中解释该名称。<em>fromlist</em> 给出了应从 <em>name</em> 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到 <em>locals</em> 参数，只用到了 <em>globals</em> 用于确定 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句所在的包上下文。</p>
<p><em>level</em> 指定是使用绝对还是相对导入。 <code class="docutils literal notranslate"><span class="pre">0</span></code> (默认值) 意味着仅执行绝对导入。 <em>level</em> 为正数值表示相对于模块调用 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 的目录，将要搜索的父目录层数 (详情参见 <span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a><span class="link-target"> [https://peps.python.org/pep-0328/]</span>)。</p>
<p>当 <em>name</em> 变量的形式为 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 时，通常将会返回最高层级的包（第一个点号之前的名称），而 <em>不是</em> 以 <em>name</em> 命名的模块。 但是，当给出了非空的 <em>fromlist</em> 参数时，则将返回以 <em>name</em> 命名的模块。</p>
<p>例如，语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam</span></code> 的结果将为与以下代码作用相同的字节码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam.ham</span></code> 的结果将为以下调用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意在这里 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 是如何返回顶层模块的，因为这是通过 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句被绑定到特定名称的对象。</p>
<p>另一方面，语句 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></code> 的结果将为</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>在这里， <code class="docutils literal notranslate"><span class="pre">spam.ham</span></code> 模块会由 <a class="reference internal" href="#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果您只想按名称导入模块（可能在包中），请使用 <a class="reference internal" href="importlib.xhtml#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span><em>level</em> 的值不再支持负数（默认值也修改为0）。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>当使用了命令行参数 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-E"><code class="xref std std-option docutils literal notranslate"><span class="pre">-E</span></code></a> 或 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 时，环境变量 <span class="target" id="index-28"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONCASEOK</span></code></a> 现在将被忽略。</p>
</div>
</dd></dl>

<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换 Windows 或 Mac 风格的换行符。</p>
</aside>
</aside>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>