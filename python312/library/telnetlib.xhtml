<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="telnetlib -- Telnet 客户端" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/telnetlib.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/telnetlib.py[https://github.com/python/cpython/tree/3.12/Lib/telnetlib.py] telnetlib 模块提供一个实现Telnet协议的类 Telnet 。关于此协议的细节请参见 RFC 854[https://datatracker.ietf.org/doc/html/rfc854.html] 。此外，它..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/telnetlib.py[https://github.com/python/cpython/tree/3.12/Lib/telnetlib.py] telnetlib 模块提供一个实现Telnet协议的类 Telnet 。关于此协议的细节请参见 RFC 854[https://datatracker.ietf.org/doc/html/rfc854.html] 。此外，它..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>telnetlib -- Telnet 客户端</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/telnetlib.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-telnetlib">
<span id="telnetlib-telnet-client"></span><h1><a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">telnetlib</span></code></a> -- Telnet 客户端</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/telnetlib.py">Lib/telnetlib.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/telnetlib.py]</span></p>
<div class="deprecated-removed" id="index-0">
<p><span class="versionmodified">从 3.11 版起不建议使用，将在 3.13 版中移除: </span><a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">telnetlib</span></code></a> 模块已被弃用（请参阅 <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0594/#telnetlib"><strong>PEP 594</strong></a><span class="link-target"> [https://peps.python.org/pep-0594/#telnetlib]</span> 了解详情及其替代品）。</p>
</div>
<hr class="docutils" />
<p><a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">telnetlib</span></code></a> 模块提供一个实现Telnet协议的类 <a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a>。关于此协议的细节请参见 <span class="target" id="index-8"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc854.html"><strong>RFC 854</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc854.html]</span> 。此外，它还为协议字符（见下文）和 telnet 选项提供了对应的符号常量。telnet选项对应的符号名遵循 <code class="docutils literal notranslate"><span class="pre">arpa/telnet.h</span></code> 中的定义，但删除了前缀 <code class="docutils literal notranslate"><span class="pre">TELOPT_</span></code>。对于不在 <code class="docutils literal notranslate"><span class="pre">arpa/telnet.h</span></code> 的选项的符号常量名，请参考本模块源码。</p>
<p>telnet命令的符号常量名有： IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: 非 Emscripten，非 WASI。</p>
<p>此模块在 WebAssembly 平台 <code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> 和 <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code> 上不适用或不可用。 请参阅 <a class="reference internal" href="intro.xhtml#wasm-availability"><span class="std std-ref">WebAssembly 平台</span></a> 了解详情。</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="telnetlib.Telnet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">telnetlib.</span></span><span class="sig-name descname"><span class="pre">Telnet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a> 表示到 Telnet 服务器的连接. 实例初始化后默认不连接；必须使用 <a class="reference internal" href="#telnetlib.Telnet.open" title="telnetlib.Telnet.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 方法来建立连接。或者， 可选参数 host 和 port 也可以传递给构造函数，在这种情况下，到服务器的连接将在构造函数返回前建立。可选参数 <em>timeout</em> 为阻塞操作（如连接尝试）指定一个以秒为单位的超时时间（如果没有指定，将使用全局默认设置） 。</p>
<p>不要重新打开一个已经连接的实例。</p>
<p>这个类有很多 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_*()</span></code> 方法。 请注意，其中一些方法在读取结束时会触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> 异常，这是由于连接对象可能出于其它原因返回一个空字符串。 请参阅下面的个别描述。</p>
<p><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a> 对象一个上下文管理器，可以在 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用。当 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 块结束，<a class="reference internal" href="#telnetlib.Telnet.close" title="telnetlib.Telnet.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法会被调用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">telnetlib</span> <span class="kn">import</span> <span class="n">Telnet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Telnet</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span> <span class="k">as</span> <span class="n">tn</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">tn</span><span class="o">.</span><span class="n">interact</span><span class="p">()</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>添加了上下文管理器的支持</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-9"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc854.html"><strong>RFC 854</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc854.html]</span> - Telnet 协议规范</dt><dd><p>Telnet 协议的定义。</p>
</dd>
</dl>
</div>
<section id="telnet-objects">
<span id="id1"></span><h2>Telnet 对象</h2>
<p><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a> 实例有以下几种方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_until">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_until</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expected</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>读取直到遇到给定字节串 <em>expected</em> 或 <em>timeout</em> 秒已经过去。</p>
<p>当没有找到匹配时，返回可用的内容，也可能返回空字节。如果连接已关闭且没有可用的熟数据，将触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_all">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>读取数据，直到遇到 EOF；连接关闭前都会保持阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_some">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_some</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>在达到 EOF 前，读取至少一个字节的熟数据。如果命中 EOF，返回 <code class="docutils literal notranslate"><span class="pre">b''</span></code>。如果没有立即可用的数据，则阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_very_eager">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_very_eager</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>在不阻塞 I/O 的情况下读取所有的内容（eager）。</p>
<p>如果连接已关闭并且没有可用的熟数据，将会触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> 。如果没有熟数据可用返回 <code class="docutils literal notranslate"><span class="pre">b''</span></code>  。除非在一个 IAC 序列的中间，否则不要进行阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_eager">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_eager</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>读取现成的数据。</p>
<p>如果连接已关闭并且没有可用的熟数据，将会触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> 。如果没有熟数据可用返回 <code class="docutils literal notranslate"><span class="pre">b''</span></code>  。除非在一个 IAC 序列的中间，否则不要进行阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_lazy">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_lazy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>处理并返回已经在队列中的数据（lazy）。</p>
<p>如果连接已关闭并且没有可用的数据，将会触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> 。如果没有熟数据可用则返回 <code class="docutils literal notranslate"><span class="pre">b''</span></code> 。除非在一个 IAC 序列的中间，否则不要进行阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_very_lazy">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_very_lazy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回熟数据队列任何可用的数据（very lazy）。</p>
<p>如果连接已关闭并且没有可用的数据，将会触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> 。如果没有熟数据可用则返回 <code class="docutils literal notranslate"><span class="pre">b''</span></code> 。该方法永远不会阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.read_sb_data">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">read_sb_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回在 SB/SE 对之间收集的数据（子选项 begin/end）。当使用 <code class="docutils literal notranslate"><span class="pre">SE</span></code> 命令调用回调函数时，该回调函数应该访问这些数据。该方法永远不会阻塞。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.open">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>连接主机。第二个可选参数是端口号，默认为标准 Telnet 端口（23）。可选参数 <em>timeout</em> 指定一个以秒为单位的超时时间用于像连接尝试这样的阻塞操作（如果没有指定，将使用全局默认超时设置）。</p>
<p>不要尝试重新打开一个已经连接的实例。</p>
<p class="audit-hook">触发 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">telnetlib.Telnet.open</span></code> ，参数为 <code class="docutils literal notranslate"><span class="pre">self</span></code>，<code class="docutils literal notranslate"><span class="pre">host</span></code>，<code class="docutils literal notranslate"><span class="pre">port</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.msg">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">msg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>当调试级别 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 0 时打印一条调试信息。如果存在额外参数，则它们会被替换在使用标准字符串格式化操作符的信息中。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.set_debuglevel">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">set_debuglevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">debuglevel</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>设置调试级别。<em>debuglevel</em> 的值越高，得到的调试输出越多（在 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> ）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.close">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>关闭连接对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.get_socket">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">get_socket</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回内部使用的套接字对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.fileno">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">fileno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回内部使用的套接字对象的文件描述符。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.write">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>向套接字写入一个字节字符串，将所有 IAC 字符加倍。如果连接被阻塞，这可能也会阻塞。如果连接关闭可能触发 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。</p>
<p class="audit-hook">触发 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">telnetlib.Telnet.write</span></code> ，参数为 <code class="docutils literal notranslate"><span class="pre">self</span></code>，<code class="docutils literal notranslate"><span class="pre">buffer</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>曾经该函数抛出 <a class="reference internal" href="socket.xhtml#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>，现在这是 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.interact">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">interact</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>交互函数，模拟一个非常笨拙的 Telnet 客户端。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.mt_interact">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">mt_interact</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>多线程版的 <a class="reference internal" href="#telnetlib.Telnet.interact" title="telnetlib.Telnet.interact"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interact()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.expect">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">expect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>一直读取，直到匹配列表中的某个正则表达式。</p>
<p>第一个参数是一个正则表达式列表，可以是已编译的 (<a class="reference internal" href="re.xhtml#re-objects"><span class="std std-ref">正则表达式对象</span></a>)，也可以是未编译的 (字节串)。 第二个可选参数是超时，单位是秒；默认一直阻塞。</p>
<p>返回一个包含三个元素的元组：列表中的第一个匹配的正则表达式的索引；返回的匹配对象；包括匹配在内的读取过的字节。</p>
<p>如果找到了文件的结尾且没有字节被读取，触发 <a class="reference internal" href="exceptions.xhtml#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>。否则，当没有匹配时,返回 <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">None,</span> <span class="pre">data)</span></code>，其中 <em>data</em> 是到目前为止接受到的字节（如果发生超时，则可能是空字节）。</p>
<p>如果一个正则表达式以贪婪匹配结束（例如 <code class="docutils literal notranslate"><span class="pre">.*</span></code>），或者多个表达式可以匹配同一个输出，则结果是不确定的，可能取决于 I/O 计时。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="telnetlib.Telnet.set_option_negotiation_callback">
<span class="sig-prename descclassname"><span class="pre">Telnet.</span></span><span class="sig-name descname"><span class="pre">set_option_negotiation_callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>每次在输入流上读取 telnet 选项时，这个带有如下参数的 <em>callback</em> （如果设置了）会被调用： callback(telnet socket, command (DO/DONT/WILL/WONT), option)。telnetlib 之后不会再执行其它操作。</p>
</dd></dl>

</section>
<section id="telnet-example">
<span id="id2"></span><h2>Telnet 示例</h2>
<p>一个简单的说明性典型用法例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">telnetlib</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span>
<span class="n">user</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter your remote account: &quot;</span><span class="p">)</span>
<span class="n">password</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getpass</span><span class="p">()</span>

<span class="n">tn</span> <span class="o">=</span> <span class="n">telnetlib</span><span class="o">.</span><span class="n">Telnet</span><span class="p">(</span><span class="n">HOST</span><span class="p">)</span>

<span class="n">tn</span><span class="o">.</span><span class="n">read_until</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;login: &quot;</span><span class="p">)</span>
<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">password</span><span class="p">:</span>
    <span class="n">tn</span><span class="o">.</span><span class="n">read_until</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Password: &quot;</span><span class="p">)</span>
    <span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">password</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ls</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;exit</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">read_all</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>