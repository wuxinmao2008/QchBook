<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="内置异常" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/exceptions.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="在 Python 中，所有异常必须为一个派生自 BaseException 的类的实例。 在带有提及一个特定类的 except 子句的 try 语句中，该子句也会处理任何派生自该类的异常类（但不处理 它 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。 本章中列出的内置异常可由解释器或内置函数来生成。 除非另有说明，它们都会具有一个提示导致错误详..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="在 Python 中，所有异常必须为一个派生自 BaseException 的类的实例。 在带有提及一个特定类的 except 子句的 try 语句中，该子句也会处理任何派生自该类的异常类（但不处理 它 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。 本章中列出的内置异常可由解释器或内置函数来生成。 除非另有说明，它们都会具有一个提示导致错误详..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>内置异常</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/exceptions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="built-in-exceptions">
<span id="bltin-exceptions"></span><h1>内置异常</h1>
<p id="index-0">在 Python 中，所有异常必须为一个派生自 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseException</span></code></a> 的类的实例。 在带有提及一个特定类的 <a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 子句的 <a class="reference internal" href="../reference/compound_stmts.xhtml#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p>
<p id="index-1">本章中列出的内置异常可由解释器或内置函数来生成。 除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释该错误码的字符串）。 关联值通常会作为参数被传给异常类的构造器。</p>
<p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p>
<p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 类或它的某个子类而不是从 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a class="reference internal" href="../tutorial/errors.xhtml#tut-userexceptions"><span class="std std-ref">用户自定义异常</span></a> 部分查看。</p>
<section id="exception-context">
<h2>异常上下文</h2>
<p id="index-2">异常对象上的三个属性提供了有关引发异常所在上下文的信息：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="BaseException.__context__">
<span class="sig-prename descclassname"><span class="pre">BaseException.</span></span><span class="sig-name descname"><span class="pre">__context__</span></span></dt>
<dt class="sig sig-object py" id="BaseException.__cause__">
<span class="sig-prename descclassname"><span class="pre">BaseException.</span></span><span class="sig-name descname"><span class="pre">__cause__</span></span></dt>
<dt class="sig sig-object py" id="BaseException.__suppress_context__">
<span class="sig-prename descclassname"><span class="pre">BaseException.</span></span><span class="sig-name descname"><span class="pre">__suppress_context__</span></span></dt>
<dd><p>当有其他异常已经被处理的情况下又引发一个新异常的时候，新异常的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> 属性会被自动设为已经被处理的异常。 异常可以在使用了 <a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 或 <a class="reference internal" href="../reference/compound_stmts.xhtml#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句，或者 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句的时候被处理。</p>
<p>这个隐式异常上下文可以通过使用 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> 配合 <a class="reference internal" href="../reference/simple_stmts.xhtml#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 来补充一个显式的原因:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="n">new_exc</span> <span class="kn">from</span> <span class="nn">original_exc</span>
</pre></div>
</div>
<p>跟在 <a class="reference internal" href="../reference/simple_stmts.xhtml#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 之后的表达式必须为一个异常或 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 它将在所引发的异常上被设为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code>。 设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 还会隐式地将 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__suppress_context__</span></code> 属性设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，这样使用 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">new_exc</span> <span class="pre">from</span> <span class="pre">None</span></code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a class="reference internal" href="#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 转换为 <a class="reference internal" href="#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>)，同时让旧异常在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> 中保持可用以便在调试时执行内省。</p>
<p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 中的显式串连异常如果存在将总是显示。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> 中的隐式串连异常仅在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> 为 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 且 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__suppress_context__</span></code> 为假值时显示。</p>
<p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p>
</dd></dl>

</section>
<section id="inheriting-from-built-in-exceptions">
<h2>从内置异常继承</h2>
<p>用户代码可以创建继承自某个异常类型的子类。 建议每次仅子类化一个异常类型以避免多个基类处理 <code class="docutils literal notranslate"><span class="pre">args</span></code> 属性的不同方式，以及内存布局不兼容可能导致的冲突。</p>
<div class="impl-detail compound">
<p><strong>CPython 实现细节：</strong> 大多数内置异常都用 C 实现以保证运行效率，参见: <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Objects/exceptions.c">Objects/exceptions.c</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Objects/exceptions.c]</span>。 其中一些具有自定义内存布局，这使得创建继承自多个异常类型的子类成为不可能。 一个类型的内存布局属于实现细节并可能随着 Python 版本升级而改变，导致在未来可能产生新的冲突。 因此，建议完全避免子类化多个异常类型。</p>
</div>
</section>
<section id="base-classes">
<h2>基类</h2>
<p>下列异常主要被用作其他异常的基类。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="BaseException">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BaseException</span></span></dt>
<dd><p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>)。 如果在此类的实例上调用 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="BaseException.args">
<span class="sig-name descname"><span class="pre">args</span></span></dt>
<dd><p>传给异常构造器的参数元组。 某些内置异常 (例如 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BaseException.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tb</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此方法会将 <em>tb</em> 设为新的异常回溯信息并返回异常对象。 它在 <span class="target" id="index-21"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a><span class="link-target"> [https://peps.python.org/pep-3134/]</span> 的异常链特性可用之前更为常用。 下面的例子演示了我们如何将一个 <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> 实例转换为 <code class="docutils literal notranslate"><span class="pre">OtherException</span></code> 实例而保留回溯信息。  异常一旦被引发，当前帧会被推至 <code class="docutils literal notranslate"><span class="pre">OtherException</span></code> 的回溯栈顶端，就像当我们允许原始 <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> 被传播给调用方时它的回溯栈将会发生的情形一样。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">SomeException</span><span class="p">:</span>
    <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span><span class="o">.</span><span class="n">__traceback__</span>
    <span class="k">raise</span> <span class="n">OtherException</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="BaseException.__traceback__">
<span class="sig-name descname"><span class="pre">__traceback__</span></span></dt>
<dd><p>保存关联到该异常的 <a class="reference internal" href="../reference/datamodel.xhtml#traceback-objects"><span class="std std-ref">回溯对象</span></a> 的可写字段。 另请参阅: <a class="reference internal" href="../reference/simple_stmts.xhtml#raise"><span class="std std-ref">raise 语句</span></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BaseException.add_note">
<span class="sig-name descname"><span class="pre">add_note</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">note</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将字符串 <code class="docutils literal notranslate"><span class="pre">note</span></code> 添加到在异常字符串之后的标准回溯中显示的注释中。 如果 <code class="docutils literal notranslate"><span class="pre">note</span></code> 不是一个字符串则会引发 <a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="BaseException.__notes__">
<span class="sig-name descname"><span class="pre">__notes__</span></span></dt>
<dd><p>由此异常的注释组成的列表，它是通过 <a class="reference internal" href="#BaseException.add_note" title="BaseException.add_note"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_note()</span></code></a> 添加的。 该属性是在调用 <a class="reference internal" href="#BaseException.add_note" title="BaseException.add_note"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_note()</span></code></a> 时创建的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="Exception">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Exception</span></span></dt>
<dd><p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ArithmeticError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ArithmeticError</span></span></dt>
<dd><p>此基类用于派生针对各种算术类错误而引发的内置异常: <a class="reference internal" href="#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>, <a class="reference internal" href="#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>, <a class="reference internal" href="#FloatingPointError" title="FloatingPointError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatingPointError</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="BufferError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BufferError</span></span></dt>
<dd><p>当与 <a class="reference internal" href="../c-api/buffer.xhtml#bufferobjects"><span class="std std-ref">缓冲区</span></a> 相关的操作无法执行时将被引发。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="LookupError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LookupError</span></span></dt>
<dd><p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a class="reference internal" href="#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>, <a class="reference internal" href="#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>。 这可以通过 <a class="reference internal" href="codecs.xhtml#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.lookup()</span></code></a> 来直接引发。</p>
</dd></dl>

</section>
<section id="concrete-exceptions">
<h2>具体异常</h2>
<p>以下异常属于经常被引发的异常。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="AssertionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AssertionError</span></span></dt>
<dd><p id="index-4">当 <a class="reference internal" href="../reference/simple_stmts.xhtml#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 语句失败时将被引发。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="AttributeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AttributeError</span></span></dt>
<dd><p>当属性引用 (参见 <a class="reference internal" href="../reference/expressions.xhtml#attribute-references"><span class="std std-ref">属性引用</span></a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。）</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">obj</span></code> 属性可以使用构造器的仅限关键字参数来设置。 它们如果被设置则分别代表要尝试访问的属性名称以及所访问的该属性的对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">obj</span></code> 属性。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="EOFError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EOFError</span></span></dt>
<dd><p>当 <a class="reference internal" href="functions.xhtml#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code class="xref py py-meth docutils literal notranslate"><span class="pre">io.IOBase.read()</span></code> 和 <a class="reference internal" href="io.xhtml#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">io.IOBase.readline()</span></code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="FloatingPointError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FloatingPointError</span></span></dt>
<dd><p>目前未被使用。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="GeneratorExit">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GeneratorExit</span></span></dt>
<dd><p>当一个 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">generator</span></a> 或 <a class="reference internal" href="../glossary.xhtml#term-coroutine"><span class="xref std std-term">coroutine</span></a> 被关闭时将被引发；参见 <a class="reference internal" href="../reference/expressions.xhtml#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generator.close()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#coroutine.close" title="coroutine.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coroutine.close()</span></code></a>。 它直接继承自 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 而不是 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>，因为从技术上来说它并不是一个错误。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ImportError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ImportError</span></span></dt>
<dd><p>当 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> 中的 &quot;from list&quot; 存在无法找到的名称时也会被引发。</p>
<p>可选的 <em>name</em> 和 <em>path</em> 仅限关键字参数设置相应的属性：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ImportError.name">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>尝试导入的模块的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ImportError.path">
<span class="sig-name descname"><span class="pre">path</span></span></dt>
<dd><p>指向任何触发异常的文件的路径。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>添加了 <a class="reference internal" href="#ImportError.name" title="ImportError.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> 与 <a class="reference internal" href="#ImportError.path" title="ImportError.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 属性。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ModuleNotFoundError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ModuleNotFoundError</span></span></dt>
<dd><p><a class="reference internal" href="#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 的子类，当一个模块无法被定位时将由 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 引发。 当在 <a class="reference internal" href="sys.xhtml#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中找到 <code class="docutils literal notranslate"><span class="pre">None</span></code> 时也会被引发。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="IndexError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IndexError</span></span></dt>
<dd><p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 会被引发。）</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="KeyError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">KeyError</span></span></dt>
<dd><p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="KeyboardInterrupt">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">KeyboardInterrupt</span></span></dt>
<dd><p>当用户按下中断键 (通常为 <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> 或 <kbd class="kbd docutils literal notranslate">Delete</kbd>) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 以确保不会被处理 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的代码意外捕获，这样可以避免退出解释器。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>捕获 <a class="reference internal" href="#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 需要特别考虑。 因为它可能会在不可预知的点位被引发，在某些情况下，它可能使运行中的程序陷入不一致的状态。 通常最好是让 <a class="reference internal" href="#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 尽快结束程序或者完全避免引发它。 (参见 <a class="reference internal" href="signal.xhtml#handlers-and-exceptions"><span class="std std-ref">有关信号处理器和异常的注释</span></a>。)</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="MemoryError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MemoryError</span></span></dt>
<dd><p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="NameError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NameError</span></span></dt>
<dd><p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 属性可以使用构造器的仅限关键字参数来设置。 它如果被设置则代表要尝试访问的变量名称。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 属性。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="NotImplementedError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NotImplementedError</span></span></dt>
<dd><p>此异常派生自 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重写该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>它不应当用来表示一个运算符或方法根本不能被支持 -- 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-data docutils literal notranslate"><span class="pre">None</span></code></a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code> 和 <a class="reference internal" href="constants.xhtml#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> 不能互换，尽管它们的名称和用途相似。有关何时使用的详细信息，请参阅 <code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code> 。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="OSError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">OSError</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">OSError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">errno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strerror</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">winerror</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">filename2</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p id="index-5">此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 &quot;文件未找到&quot; 或 &quot;磁盘已满&quot; 等（不包括非法参数类型或其他偶然性错误）。</p>
<p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。 为了能向下兼容，如果传入了三个参数，则 <a class="reference internal" href="#BaseException.args" title="BaseException.args"><code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p>
<p>构造器实际返回的往往是 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的某个子类，如下文 <a class="reference internal" href="#os-exceptions">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a class="reference internal" href="#OSError.errno" title="OSError.errno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno</span></code></a> 值。 此行为仅在直接或通过别名来构造 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 时发生，并且在子类化时不会被继承。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="OSError.errno">
<span class="sig-name descname"><span class="pre">errno</span></span></dt>
<dd><p>来自于 C 变量 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> 的数字错误码。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="OSError.winerror">
<span class="sig-name descname"><span class="pre">winerror</span></span></dt>
<dd><p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a class="reference internal" href="#OSError.errno" title="OSError.errno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno</span></code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。</p>
<p>在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a class="reference internal" href="#OSError.errno" title="OSError.errno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno</span></code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a class="reference internal" href="#OSError.winerror" title="OSError.winerror"><code class="xref py py-attr docutils literal notranslate"><span class="pre">winerror</span></code></a> 属性将不存在。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="OSError.strerror">
<span class="sig-name descname"><span class="pre">strerror</span></span></dt>
<dd><p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">perror()</span></code> 来格式化，在 Windows 中则是由 <code class="xref c c-func docutils literal notranslate"><span class="pre">FormatMessage()</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="OSError.filename">
<span class="sig-name descname"><span class="pre">filename</span></span></dt>
<dt class="sig sig-object py" id="OSError.filename2">
<span class="sig-name descname"><span class="pre">filename2</span></span></dt>
<dd><p>对于与文件系统路径有关 (例如 <a class="reference internal" href="functions.xhtml#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 或 <a class="reference internal" href="os.xhtml#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.unlink()</span></code></a>) 的异常，<a class="reference internal" href="#OSError.filename" title="OSError.filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a class="reference internal" href="os.xhtml#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a>)，<a class="reference internal" href="#OSError.filename2" title="OSError.filename2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">filename2</span></code></a> 将是传给函数的第二个文件名。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span><a class="reference internal" href="#EnvironmentError" title="EnvironmentError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EnvironmentError</span></code></a>, <a class="reference internal" href="#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>, <a class="reference internal" href="#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>, <a class="reference internal" href="socket.xhtml#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>, <a class="reference internal" href="select.xhtml#select.error" title="select.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">select.error</span></code></a> 与 <code class="xref py py-exc docutils literal notranslate"><span class="pre">mmap.error</span></code> 已被合并到 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>，构造器可能返回其中一个子类。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span><a class="reference internal" href="#OSError.filename" title="OSError.filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code></a> 属性现在是传给函数的原始文件名，而不是基于 <a class="reference internal" href="../glossary.xhtml#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a> 进行编码或解码之后的名称。 此外，还添加了 <em>filename2</em> 构造器参数和属性。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="OverflowError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">OverflowError</span></span></dt>
<dd><p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a class="reference internal" href="#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="RecursionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RecursionError</span></span></dt>
<dd><p>此异常派生自 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a class="reference internal" href="sys.xhtml#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code></a>) 时被引发。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span>在此之前将只引发 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ReferenceError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ReferenceError</span></span></dt>
<dd><p>此异常将在使用 <a class="reference internal" href="weakref.xhtml#weakref.proxy" title="weakref.proxy"><code class="xref py py-func docutils literal notranslate"><span class="pre">weakref.proxy()</span></code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a class="reference internal" href="weakref.xhtml#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="RuntimeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RuntimeError</span></span></dt>
<dd><p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="StopIteration">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StopIteration</span></span></dt>
<dd><p>由内置函数 <a class="reference internal" href="functions.xhtml#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 和 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 的 <a class="reference internal" href="stdtypes.xhtml#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法所引发，用来表示该迭代器不能产生下一项。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="StopIteration.value">
<span class="sig-name descname"><span class="pre">value</span></span></dt>
<dd><p>该异常对象只有一个属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code>，它在构造该异常时作为参数给出，默认值为 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。</p>
</dd></dl>

<p>当一个 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">generator</span></a> 或 <a class="reference internal" href="../glossary.xhtml#term-coroutine"><span class="xref std std-term">coroutine</span></a> 函数返回时，将引发一个新的 <a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 实例，函数返回的值将被用作异常构造器的 <a class="reference internal" href="#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> 形参。</p>
<p>如果某个生成器代码直接或间接地引发了 <a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，它会被转换为 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> (并将 <a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 保留为导致新异常的原因)。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>添加了 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性及其被生成器函数用作返回值的功能。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>引入了通过 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generator_stop</span></code> 来实现 RuntimeError 转换，参见 <span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-0479/"><strong>PEP 479</strong></a><span class="link-target"> [https://peps.python.org/pep-0479/]</span>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>默认对所有代码启用 <span class="target" id="index-23"></span><a class="pep reference external" href="https://peps.python.org/pep-0479/"><strong>PEP 479</strong></a><span class="link-target"> [https://peps.python.org/pep-0479/]</span>: 在生成器中引发的 <a class="reference internal" href="#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 错误将被转换为 <a class="reference internal" href="#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="StopAsyncIteration">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StopAsyncIteration</span></span></dt>
<dd><p>必须由一个 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> 对象的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> 方法来引发以停止迭代操作。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="SyntaxError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SyntaxError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">details</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>当解析器遇到语法错误时引发。 这可以发生在 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句，对内置函数 <a class="reference internal" href="functions.xhtml#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, <a class="reference internal" href="functions.xhtml#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 或 <a class="reference internal" href="functions.xhtml#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。</p>
<p>异常实例的 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获取。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="SyntaxError.filename">
<span class="sig-name descname"><span class="pre">filename</span></span></dt>
<dd><p>发生语法错误所在文件的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SyntaxError.lineno">
<span class="sig-name descname"><span class="pre">lineno</span></span></dt>
<dd><p>发生错误所在文件中的行号。  行号索引从 1 开始：文件中首行的 <code class="docutils literal notranslate"><span class="pre">lineno</span></code> 为 1。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SyntaxError.offset">
<span class="sig-name descname"><span class="pre">offset</span></span></dt>
<dd><p>发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 为 1。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SyntaxError.text">
<span class="sig-name descname"><span class="pre">text</span></span></dt>
<dd><p>错误所涉及的源代码文本。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SyntaxError.end_lineno">
<span class="sig-name descname"><span class="pre">end_lineno</span></span></dt>
<dd><p>发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 <code class="docutils literal notranslate"><span class="pre">lineno</span></code> 为 1。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SyntaxError.end_offset">
<span class="sig-name descname"><span class="pre">end_offset</span></span></dt>
<dd><p>发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 为 1。</p>
</dd></dl>

<p>对于 f-字符串字段中的错误，消息会带有 &quot;f-string: &quot; 前缀并且其位置是基于替换表达式构建的文本中的位置。 例如，编译 f'Bad {a b} field' 将产生这样的 args 属性: ('f-string: ...', ('', 1, 2, '(a b)n', 1, 5))。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <a class="reference internal" href="#SyntaxError.end_lineno" title="SyntaxError.end_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code></a> 和 <a class="reference internal" href="#SyntaxError.end_offset" title="SyntaxError.end_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_offset</span></code></a> 属性。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="IndentationError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IndentationError</span></span></dt>
<dd><p>与不正确的缩进相关的语法错误的基类。 这是 <a class="reference internal" href="#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="TabError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TabError</span></span></dt>
<dd><p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a class="reference internal" href="#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndentationError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="SystemError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SystemError</span></span></dt>
<dd><p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。</p>
<p>你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code class="docutils literal notranslate"><span class="pre">sys.version</span></code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="SystemExit">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SystemExit</span></span></dt>
<dd><p>此异常由 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 函数引发。 它继承自 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 而不是 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 以确保不会被处理 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">exit()</span></code> 函数）；如果该值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。</p>
<p>对 <a class="reference internal" href="sys.xhtml#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a class="reference internal" href="../reference/compound_stmts.xhtml#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句的 <a class="reference internal" href="../reference/compound_stmts.xhtml#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a class="reference internal" href="os.xhtml#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 之后的子进程中）则可使用 <a class="reference internal" href="os.xhtml#os._exit" title="os._exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">os._exit()</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="SystemExit.code">
<span class="sig-name descname"><span class="pre">code</span></span></dt>
<dd><p>传给构造器的退出状态码或错误信息（默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。）</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="TypeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TypeError</span></span></dt>
<dd><p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。</p>
<p>此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a class="reference internal" href="#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
<p>传入参数的类型错误 (例如在要求 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 时却传入了 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) 应当导致 <a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a class="reference internal" href="#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UnboundLocalError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnboundLocalError</span></span></dt>
<dd><p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a class="reference internal" href="#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UnicodeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnicodeError</span></span></dt>
<dd><p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a class="reference internal" href="#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 的一个子类。</p>
<p><a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> 具有一些描述编码或解码错误的属性。 例如 <code class="docutils literal notranslate"><span class="pre">err.object[err.start:err.end]</span></code> 会给出导致编解码器失败的特定无效输入。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="UnicodeError.encoding">
<span class="sig-name descname"><span class="pre">encoding</span></span></dt>
<dd><p>引发错误的编码名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="UnicodeError.reason">
<span class="sig-name descname"><span class="pre">reason</span></span></dt>
<dd><p>描述特定编解码器错误的字符串。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="UnicodeError.object">
<span class="sig-name descname"><span class="pre">object</span></span></dt>
<dd><p>编解码器试图要编码或解码的对象。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="UnicodeError.start">
<span class="sig-name descname"><span class="pre">start</span></span></dt>
<dd><p><a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object</span></code></a> 中无效数据的开始位置索引。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="UnicodeError.end">
<span class="sig-name descname"><span class="pre">end</span></span></dt>
<dd><p><a class="reference internal" href="functions.xhtml#object" title="object"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object</span></code></a> 中无效数据的末尾位置索引（不含）。</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UnicodeEncodeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnicodeEncodeError</span></span></dt>
<dd><p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UnicodeDecodeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnicodeDecodeError</span></span></dt>
<dd><p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UnicodeTranslateError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnicodeTranslateError</span></span></dt>
<dd><p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a class="reference internal" href="#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ValueError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ValueError</span></span></dt>
<dd><p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a class="reference internal" href="#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 来描述时将被引发。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ZeroDivisionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroDivisionError</span></span></dt>
<dd><p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p>
</dd></dl>

<p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="EnvironmentError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EnvironmentError</span></span></dt>
<dd></dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="IOError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IOError</span></span></dt>
<dd></dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="WindowsError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">WindowsError</span></span></dt>
<dd><p>限在 Windows 中可用。</p>
</dd></dl>

<section id="os-exceptions">
<h3>OS 异常</h3>
<p>下列异常均为 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的子类，它们将根据系统错误代码被引发。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="BlockingIOError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BlockingIOError</span></span></dt>
<dd><p>当一个操作将在设置为非阻塞操作的对象（例如套接字）上发生阻塞时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.EAGAIN" title="errno.EAGAIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">EAGAIN</span></code></a>, <a class="reference internal" href="errno.xhtml#errno.EALREADY" title="errno.EALREADY"><code class="xref py py-const docutils literal notranslate"><span class="pre">EALREADY</span></code></a>, <a class="reference internal" href="errno.xhtml#errno.EWOULDBLOCK" title="errno.EWOULDBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">EWOULDBLOCK</span></code></a> 和 <a class="reference internal" href="errno.xhtml#errno.EINPROGRESS" title="errno.EINPROGRESS"><code class="xref py py-const docutils literal notranslate"><span class="pre">EINPROGRESS</span></code></a>。</p>
<p>除了 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 已有的属性，<a class="reference internal" href="#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> 还有一个额外属性：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="BlockingIOError.characters_written">
<span class="sig-name descname"><span class="pre">characters_written</span></span></dt>
<dd><p>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a class="reference internal" href="io.xhtml#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块的带缓冲 I/O 类时此属性可用。</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ChildProcessError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ChildProcessError</span></span></dt>
<dd><p>当一个子进程上的操作失败时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ECHILD" title="errno.ECHILD"><code class="xref py py-const docutils literal notranslate"><span class="pre">ECHILD</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ConnectionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ConnectionError</span></span></dt>
<dd><p>与连接相关问题的基类。</p>
<p>其子类有 <a class="reference internal" href="#BrokenPipeError" title="BrokenPipeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenPipeError</span></code></a>, <a class="reference internal" href="#ConnectionAbortedError" title="ConnectionAbortedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionAbortedError</span></code></a>, <a class="reference internal" href="#ConnectionRefusedError" title="ConnectionRefusedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionRefusedError</span></code></a> 和 <a class="reference internal" href="#ConnectionResetError" title="ConnectionResetError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionResetError</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="BrokenPipeError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrokenPipeError</span></span></dt>
<dd><p><a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionError</span></code></a> 的子类，当试图写入一个管道而其另一端已关闭，或者试图写入一个套接字而其已关闭写入时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.EPIPE" title="errno.EPIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">EPIPE</span></code></a> 和 <a class="reference internal" href="errno.xhtml#errno.ESHUTDOWN" title="errno.ESHUTDOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ESHUTDOWN</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ConnectionAbortedError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ConnectionAbortedError</span></span></dt>
<dd><p><a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionError</span></code></a> 的子类，当一个连接尝试被对端中止时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ECONNABORTED" title="errno.ECONNABORTED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ECONNABORTED</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ConnectionRefusedError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ConnectionRefusedError</span></span></dt>
<dd><p><a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionError</span></code></a> 的子类，当一个连接尝试被对端拒绝时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ECONNREFUSED" title="errno.ECONNREFUSED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ECONNREFUSED</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ConnectionResetError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ConnectionResetError</span></span></dt>
<dd><p><a class="reference internal" href="#ConnectionError" title="ConnectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ConnectionError</span></code></a> 的子类，当一个连接尝试被对端重置时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ECONNRESET" title="errno.ECONNRESET"><code class="xref py py-const docutils literal notranslate"><span class="pre">ECONNRESET</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="FileExistsError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FileExistsError</span></span></dt>
<dd><p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.EEXIST" title="errno.EEXIST"><code class="xref py py-const docutils literal notranslate"><span class="pre">EEXIST</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="FileNotFoundError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FileNotFoundError</span></span></dt>
<dd><p>当所请求的文件或目录不存在时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ENOENT" title="errno.ENOENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">ENOENT</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="InterruptedError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">InterruptedError</span></span></dt>
<dd><p>当一个系统调用被传入的信号中断时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.EINTR" title="errno.EINTR"><code class="xref py py-const docutils literal notranslate"><span class="pre">EINTR</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <span class="target" id="index-24"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a><span class="link-target"> [https://peps.python.org/pep-0475/]</span>) 而不是引发 <a class="reference internal" href="#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="IsADirectoryError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IsADirectoryError</span></span></dt>
<dd><p>当请求对一个目录执行文件操作 (如 <a class="reference internal" href="os.xhtml#os.remove" title="os.remove"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.remove()</span></code></a>) 时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.EISDIR" title="errno.EISDIR"><code class="xref py py-const docutils literal notranslate"><span class="pre">EISDIR</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="NotADirectoryError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NotADirectoryError</span></span></dt>
<dd><p>当请求对一个非目录执行目录操作 (如 <a class="reference internal" href="os.xhtml#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a>) 时将被引发。 在大多数 POSIX 平台上，它还可能在某个操作试图将一个非目录作为目录打开或遍历时被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ENOTDIR" title="errno.ENOTDIR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ENOTDIR</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="PermissionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PermissionError</span></span></dt>
<dd><p>当在没有足够访问权限的情况下试图运行某个操作时将被引发 —— 例如文件系统权限。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.EACCES" title="errno.EACCES"><code class="xref py py-const docutils literal notranslate"><span class="pre">EACCES</span></code></a>, <a class="reference internal" href="errno.xhtml#errno.EPERM" title="errno.EPERM"><code class="xref py py-const docutils literal notranslate"><span class="pre">EPERM</span></code></a> 和 <a class="reference internal" href="errno.xhtml#errno.ENOTCAPABLE" title="errno.ENOTCAPABLE"><code class="xref py py-const docutils literal notranslate"><span class="pre">ENOTCAPABLE</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11.1 版本发生变更: </span>WASI 的 <a class="reference internal" href="errno.xhtml#errno.ENOTCAPABLE" title="errno.ENOTCAPABLE"><code class="xref py py-const docutils literal notranslate"><span class="pre">ENOTCAPABLE</span></code></a> 现在被映射至 <a class="reference internal" href="#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ProcessLookupError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ProcessLookupError</span></span></dt>
<dd><p>当给定的进程不存在时将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ESRCH" title="errno.ESRCH"><code class="xref py py-const docutils literal notranslate"><span class="pre">ESRCH</span></code></a>。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="TimeoutError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TimeoutError</span></span></dt>
<dd><p>当一个系统函数在系统层级发生超时的情况下将被引发。 对应于 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> <a class="reference internal" href="errno.xhtml#errno.ETIMEDOUT" title="errno.ETIMEDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">ETIMEDOUT</span></code></a>。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3: </span>添加了以上所有 <a class="reference internal" href="#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的子类。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><span class="target" id="index-25"></span><a class="pep reference external" href="https://peps.python.org/pep-3151/"><strong>PEP 3151</strong></a><span class="link-target"> [https://peps.python.org/pep-3151/]</span> - 重写 OS 和 IO 异常的层次结构</p>
</div>
</section>
</section>
<section id="warnings">
<span id="warning-categories-as-exceptions"></span><h2>警告</h2>
<p>下列异常被用作警告类别；请参阅 <a class="reference internal" href="warnings.xhtml#warning-categories"><span class="std std-ref">警告类别</span></a> 文档了解详情。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="Warning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Warning</span></span></dt>
<dd><p>警告类别的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UserWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UserWarning</span></span></dt>
<dd><p>用户代码所产生警告的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="DeprecationWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">DeprecationWarning</span></span></dt>
<dd><p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p>
<p>会被默认警告过滤器忽略，在 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块中的情况除外 (<span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0565/"><strong>PEP 565</strong></a><span class="link-target"> [https://peps.python.org/pep-0565/]</span>)。 启用 <a class="reference internal" href="devmode.xhtml#devmode"><span class="std std-ref">Python 开发模式</span></a> 时会显示此警告。</p>
<p>这个弃用政策是在 <span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0387/"><strong>PEP 387</strong></a><span class="link-target"> [https://peps.python.org/pep-0387/]</span> 中描述的。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="PendingDeprecationWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PendingDeprecationWarning</span></span></dt>
<dd><p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。</p>
<p>这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a class="reference internal" href="#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。</p>
<p>会被默认警告过滤器忽略。 启用 <a class="reference internal" href="devmode.xhtml#devmode"><span class="std std-ref">Python 开发模式</span></a> 时会显示此警告。</p>
<p>这个弃用政策是在 <span class="target" id="index-28"></span><a class="pep reference external" href="https://peps.python.org/pep-0387/"><strong>PEP 387</strong></a><span class="link-target"> [https://peps.python.org/pep-0387/]</span> 中描述的。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="SyntaxWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SyntaxWarning</span></span></dt>
<dd><p>与模糊的语法相关的警告的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="RuntimeWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RuntimeWarning</span></span></dt>
<dd><p>与模糊的运行时行为相关的警告的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="FutureWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FutureWarning</span></span></dt>
<dd><p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ImportWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ImportWarning</span></span></dt>
<dd><p>与在模块导入中可能的错误相关的警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 <a class="reference internal" href="devmode.xhtml#devmode"><span class="std std-ref">Python 开发模式</span></a> 时会显示此警告。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="UnicodeWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnicodeWarning</span></span></dt>
<dd><p>与 Unicode 相关的警告的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="EncodingWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EncodingWarning</span></span></dt>
<dd><p>与编码格式相关的警告的基类。</p>
<p>请参阅 <a class="reference internal" href="io.xhtml#io-encoding-warning"><span class="std std-ref">选择性的 EncodingWarning</span></a> 来了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="BytesWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BytesWarning</span></span></dt>
<dd><p>与 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 相关的警告的基类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ResourceWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ResourceWarning</span></span></dt>
<dd><p>资源使用相关警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 <a class="reference internal" href="devmode.xhtml#devmode"><span class="std std-ref">Python 开发模式</span></a> 时会显示此警告。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="exception-groups">
<span id="lib-exception-groups"></span><h2>异常组</h2>
<p>下列异常是在有必要引发多个不相关联的异常时使用的。 它们是异常层级结构的一部分因此它们可以像所有其他异常一样通过 <a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 来处理。 此外，它们还可被 <a class="reference internal" href="../reference/compound_stmts.xhtml#except-star"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except*</span></code></a> 所识别，此语法将基于所包含异常的类型来匹配其子分组。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="ExceptionGroup">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExceptionGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="BaseExceptionGroup">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BaseExceptionGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这两个异常类型都将多个异常包装在序列 <code class="docutils literal notranslate"><span class="pre">excs</span></code> 中。 <code class="docutils literal notranslate"><span class="pre">msg</span></code> 形参必须为一个字符串。 这两个类之间的区别在于 <a class="reference internal" href="#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> 扩展了 <a class="reference internal" href="#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 并且它可以包装任何异常，而 <a class="reference internal" href="#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 则扩展了 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 并且它只能包装 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的子类。 这样的设计是为了使得 <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception</span></code> 只捕获 <a class="reference internal" href="#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 而不捕获 <a class="reference internal" href="#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a>。</p>
<p><a class="reference internal" href="#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> 构造器返回一个 <a class="reference internal" href="#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 而不是 <a class="reference internal" href="#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a>，如果所包含的全部异常都是 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的实例的话，因此它可以被用来制造自动化的选择。 在另一方面，<a class="reference internal" href="#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 构造器则会引发 <a class="reference internal" href="#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，如果所包含的任何异常不是 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的子类的话。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="BaseExceptionGroup.message">
<span class="sig-name descname"><span class="pre">message</span></span></dt>
<dd><p>传给构造器的 <code class="docutils literal notranslate"><span class="pre">msg</span></code> 参数。 这是一个只读属性。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="BaseExceptionGroup.exceptions">
<span class="sig-name descname"><span class="pre">exceptions</span></span></dt>
<dd><p>传给构造器的 <code class="docutils literal notranslate"><span class="pre">excs</span></code> 序列中的由异常组成的元组。 这是一个只读属性。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BaseExceptionGroup.subgroup">
<span class="sig-name descname"><span class="pre">subgroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个只包含来自当前组的匹配 <em>condition</em> 的异常的异常组，或者如果结果为空则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>condition 参数可以是一个接受异常并为应当纳入子分组的异常返回真值的函数，或者也可以是一个异常类型或一个由异常类型组成的元组，用来通过与 <code class="docutils literal notranslate"><span class="pre">except</span></code> 子句所用的相同检测来检测是否匹配。</p>
<p>当前异常的嵌套结构会在结果中保留，就如其 <a class="reference internal" href="#BaseExceptionGroup.message" title="BaseExceptionGroup.message"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code></a>, <a class="reference internal" href="#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a>, <a class="reference internal" href="#BaseException.__cause__" title="BaseException.__cause__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code></a>, <a class="reference internal" href="#BaseException.__context__" title="BaseException.__context__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code></a> 和 <a class="reference internal" href="#BaseException.__notes__" title="BaseException.__notes__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__notes__</span></code></a> 字段的值一样。 空的嵌套组会在结果中被略去。</p>
<p>条件检测会针对嵌套异常组中的所有异常执行，包括最高层级的和任何嵌套的异常组。 如果针对此类异常组的条件为真值，它将被完整包括在结果中。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BaseExceptionGroup.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">condition</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#BaseExceptionGroup.subgroup" title="BaseExceptionGroup.subgroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgroup()</span></code></a>，但将返回 <code class="docutils literal notranslate"><span class="pre">(match,</span> <span class="pre">rest)</span></code> 对，其中 <code class="docutils literal notranslate"><span class="pre">match</span></code> 为 <code class="docutils literal notranslate"><span class="pre">subgroup(condition)</span></code> 而 <code class="docutils literal notranslate"><span class="pre">rest</span></code> 为剩余的非匹配部分。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="BaseExceptionGroup.derive">
<span class="sig-name descname"><span class="pre">derive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">excs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个具有相同 <a class="reference internal" href="#BaseExceptionGroup.message" title="BaseExceptionGroup.message"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code></a> 的异常组，但会将异常包装在 <code class="docutils literal notranslate"><span class="pre">excs</span></code> 中。</p>
<p>此方法是由 <a class="reference internal" href="#BaseExceptionGroup.subgroup" title="BaseExceptionGroup.subgroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgroup()</span></code></a> 和 <a class="reference internal" href="#BaseExceptionGroup.split" title="BaseExceptionGroup.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> 使用的。 子类需要重写它以便让 <a class="reference internal" href="#BaseExceptionGroup.subgroup" title="BaseExceptionGroup.subgroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgroup()</span></code></a> 和 <a class="reference internal" href="#BaseExceptionGroup.split" title="BaseExceptionGroup.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> 返回相应子类的实例而不是 <a class="reference internal" href="#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a>。</p>
<p><a class="reference internal" href="#BaseExceptionGroup.subgroup" title="BaseExceptionGroup.subgroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subgroup()</span></code></a> 和 <a class="reference internal" href="#BaseExceptionGroup.split" title="BaseExceptionGroup.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> 会从原始异常组拷贝 <a class="reference internal" href="#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a>, <a class="reference internal" href="#BaseException.__cause__" title="BaseException.__cause__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code></a>, <a class="reference internal" href="#BaseException.__context__" title="BaseException.__context__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code></a> 和 <a class="reference internal" href="#BaseException.__notes__" title="BaseException.__notes__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__notes__</span></code></a> 字段到 <a class="reference internal" href="#BaseExceptionGroup.derive" title="BaseExceptionGroup.derive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">derive()</span></code></a> 所返回的异常组，这样这些字段就不需要被 <a class="reference internal" href="#BaseExceptionGroup.derive" title="BaseExceptionGroup.derive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">derive()</span></code></a> 更新。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyGroup</span><span class="p">(</span><span class="n">ExceptionGroup</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">derive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">MyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">excs</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">MyGroup</span><span class="p">(</span><span class="s2">&quot;eg&quot;</span><span class="p">,</span> <span class="p">[</span><span class="ne">ValueError</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="ne">TypeError</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">add_note</span><span class="p">(</span><span class="s2">&quot;a note&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">__context__</span> <span class="o">=</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;context&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cause&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">raise</span> <span class="n">e</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">exc</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exc</span><span class="p">,</span> <span class="n">exc</span><span class="o">.</span><span class="n">__context__</span><span class="p">,</span> <span class="n">exc</span><span class="o">.</span><span class="n">__cause__</span><span class="p">,</span> <span class="n">exc</span><span class="o">.</span><span class="n">__notes__</span>
<span class="go">(MyGroup(&#39;eg&#39;, [ValueError(1), TypeError(2)]), Exception(&#39;context&#39;), Exception(&#39;cause&#39;), [&#39;a note&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">__context__</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">__cause__</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">__notes__</span>
<span class="go">(MyGroup(&#39;eg&#39;, [ValueError(1)]), Exception(&#39;context&#39;), Exception(&#39;cause&#39;), [&#39;a note&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rest</span><span class="p">,</span> <span class="n">rest</span><span class="o">.</span><span class="n">__context__</span><span class="p">,</span> <span class="n">rest</span><span class="o">.</span><span class="n">__cause__</span><span class="p">,</span> <span class="n">rest</span><span class="o">.</span><span class="n">__notes__</span>
<span class="go">(MyGroup(&#39;eg&#39;, [TypeError(2)]), Exception(&#39;context&#39;), Exception(&#39;cause&#39;), [&#39;a note&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span> <span class="ow">is</span> <span class="n">match</span><span class="o">.</span><span class="n">__traceback__</span> <span class="ow">is</span> <span class="n">rest</span><span class="o">.</span><span class="n">__traceback__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<p>请注意 <a class="reference internal" href="#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> 定义了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>，因此需要不同构造器签名的子类必须重写该方法而不是 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>。 例如，下面定义了一个接受 exit_code 并根据它来构造分组消息的异常组子类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Errors</span><span class="p">(</span><span class="n">ExceptionGroup</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">):</span>
      <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Errors</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;exit code: </span><span class="si">{</span><span class="n">exit_code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">exit_code</span> <span class="o">=</span> <span class="n">exit_code</span>
      <span class="k">return</span> <span class="bp">self</span>

   <span class="k">def</span> <span class="nf">derive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excs</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Errors</span><span class="p">(</span><span class="n">excs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_code</span><span class="p">)</span>
</pre></div>
</div>
<p>类似于 <a class="reference internal" href="#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a>，任何 <a class="reference internal" href="#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> 的子类也是 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的子类，只能包装 <a class="reference internal" href="#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的实例。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</section>
<section id="exception-hierarchy">
<h2>异常层次结构</h2>
<p>内置异常的类层级结构如下：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>BaseException
 ├── BaseExceptionGroup
 ├── GeneratorExit
 ├── KeyboardInterrupt
 ├── SystemExit
 └── Exception
      ├── ArithmeticError
      │    ├── FloatingPointError
      │    ├── OverflowError
      │    └── ZeroDivisionError
      ├── AssertionError
      ├── AttributeError
      ├── BufferError
      ├── EOFError
      ├── ExceptionGroup [BaseExceptionGroup]
      ├── ImportError
      │    └── ModuleNotFoundError
      ├── LookupError
      │    ├── IndexError
      │    └── KeyError
      ├── MemoryError
      ├── NameError
      │    └── UnboundLocalError
      ├── OSError
      │    ├── BlockingIOError
      │    ├── ChildProcessError
      │    ├── ConnectionError
      │    │    ├── BrokenPipeError
      │    │    ├── ConnectionAbortedError
      │    │    ├── ConnectionRefusedError
      │    │    └── ConnectionResetError
      │    ├── FileExistsError
      │    ├── FileNotFoundError
      │    ├── InterruptedError
      │    ├── IsADirectoryError
      │    ├── NotADirectoryError
      │    ├── PermissionError
      │    ├── ProcessLookupError
      │    └── TimeoutError
      ├── ReferenceError
      ├── RuntimeError
      │    ├── NotImplementedError
      │    └── RecursionError
      ├── StopAsyncIteration
      ├── StopIteration
      ├── SyntaxError
      │    └── IndentationError
      │         └── TabError
      ├── SystemError
      ├── TypeError
      ├── ValueError
      │    └── UnicodeError
      │         ├── UnicodeDecodeError
      │         ├── UnicodeEncodeError
      │         └── UnicodeTranslateError
      └── Warning
           ├── BytesWarning
           ├── DeprecationWarning
           ├── EncodingWarning
           ├── FutureWarning
           ├── ImportWarning
           ├── PendingDeprecationWarning
           ├── ResourceWarning
           ├── RuntimeWarning
           ├── SyntaxWarning
           ├── UnicodeWarning
           └── UserWarning
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>