<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="email.policy: 策略对象" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/email.policy.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/email/policy.py[https://github.com/python/cpython/tree/3.12/Lib/email/policy.py] email 的主要焦点是按照各种电子邮件和 MIME RFC 的描述来处理电子邮件消息。 但是电子邮件消息的基本格式（一个由名称加冒号加值的标头字段构成的区块，后面再加一个空白行和任意的‘消息体’）是在电子邮件领域..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码: Lib/email/policy.py[https://github.com/python/cpython/tree/3.12/Lib/email/policy.py] email 的主要焦点是按照各种电子邮件和 MIME RFC 的描述来处理电子邮件消息。 但是电子邮件消息的基本格式（一个由名称加冒号加值的标头字段构成的区块，后面再加一个空白行和任意的‘消息体’）是在电子邮件领域..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>email.policy: 策略对象</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/email.policy.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-email.policy">
<span id="email-policy-policy-objects"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.policy</span></code>: 策略对象</h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/email/policy.py">Lib/email/policy.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/email/policy.py]</span></p>
<hr class="docutils" />
<p><a class="reference internal" href="email.xhtml#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 的主要焦点是按照各种电子邮件和 MIME RFC 的描述来处理电子邮件消息。 但是电子邮件消息的基本格式（一个由名称加冒号加值的标头字段构成的区块，后面再加一个空白行和任意的‘消息体’）是在电子邮件领域以外也获得应用的格式。 这些应用的规则有些与主要电子邮件 RFC 十分接近，有些则很不相同。 即使是操作电子邮件，有时也可能需要打破严格的 RFC 规则，例如生成可与某些并不遵循标准的电子邮件服务器互联的电子邮件，或者是实现希望应用某些破坏标准的操作方式的扩展。</p>
<p>Policy 对象给予 email 包处理这些不同用例的灵活性。</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 对象封装了一组属性和方法用来在使用期间控制 email 包中各个组件的行为。 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例可以被传给 email 包中的多个类和方法以更改它们的默认行为。 可设置的值及其默认值如下所述。</p>
<p>在 email 包中的所有类会使用一个默认的策略。 对于所有 <a class="reference internal" href="email.parser.xhtml#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 类及相关的便捷函数，还有对于 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 类来说，它是 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a> 策略，通过其对应的预定义实例 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a> 来使用。 这个策略提供了与 Python3.3 版之前的 email 包的完全向下兼容性（在某些情况下，也包括对缺陷的兼容性）。</p>
<p>传给 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 的 <em>policy</em> 关键字的默认值是 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 策略，表示为其预定义的实例 <a class="reference internal" href="#email.policy.default" title="email.policy.default"><code class="xref py py-data docutils literal notranslate"><span class="pre">default</span></code></a>。</p>
<p>在创建 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 或 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象时，它需要一个策略。 如果消息是由 <a class="reference internal" href="email.parser.xhtml#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 创建的，则传给该解析器的策略将是它所创建的消息所使用的策略。 如果消息是由程序创建的，则该策略可以在创建它的时候指定。 当消息被传递给 <a class="reference internal" href="email.generator.xhtml#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">generator</span></code></a> 时，生成器默认会使用来自该消息的策略，但你也可以将指定的策略传递给生成器，这将覆盖存储在消息对象上的策略。</p>
<p><a class="reference internal" href="email.parser.xhtml#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> 类和解析器便捷函数的 <em>policy</em> 关键字的默认值在未来的 Python 版本中 <strong>将会改变</strong>。 因此在调用任何 <a class="reference internal" href="email.parser.xhtml#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 模块所描述的类和函数时你应当 <strong>总是显式地指定你想要使用的策略</strong>。</p>
<p>本文档的第一部分介绍了 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 的特性，它是一个 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>，定义了所有策略对象包括 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a> 的共有特性。 这些特性包括一些由 email 包内部调用的特定钩子方法，自定义策略可以重写这些方法以获得不同行为。 第二部分描述了实体类 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 和 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>，它们分别实现了提供标准行为和向下兼容行为与特性的钩子。</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例是不可变的，但它们可以被克隆，接受与类构造器一致的关键字参数并返回一个新的 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例，新实例是原实例的副本，但具有被改变的指定属性。</p>
<p>例如，以下代码可以被用来从一个 Unix 系统的磁盘文件中读取电子邮件消息并将其传递给系统的 <code class="docutils literal notranslate"><span class="pre">sendmail</span></code> 程序:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="kn">import</span> <span class="n">message_from_binary_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">BytesGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="kn">import</span> <span class="n">policy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mymsg.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">msg</span> <span class="o">=</span> <span class="n">message_from_binary_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;sendmail&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;To&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>这里我们让 <a class="reference internal" href="email.generator.xhtml#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> 在创建要送入 <code class="docutils literal notranslate"><span class="pre">sendmail's</span></code> <code class="docutils literal notranslate"><span class="pre">stdin</span></code> 的二进制字串时使用符合 RFC 的行分隔字符，默认的策略将会使用 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 行分隔符。</p>
<p>某些 email 包的方法接受一个 <em>policy</em> 关键字参数，允许为该方法覆盖原有策略。 例如，以下代码使用了来自之前示例的 <em>msg</em> 对象的 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 方法并使用其运行所在平台的本机行分隔符将消息写入一个文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;converted.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">as_bytes</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)))</span>
<span class="go">17</span>
</pre></div>
</div>
<p>Policy 对象也可使用加法运算符进行组合来产生一个新策略对象，其设置是被加总对象的非默认值的组合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compat_SMTP</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">raise_on_defect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict_SMTP</span> <span class="o">=</span> <span class="n">compat_SMTP</span> <span class="o">+</span> <span class="n">compat_strict</span>
</pre></div>
</div>
<p>此运算不满足交换律；也就是说对象的添加顺序很重要。 见以下演示:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">policy100</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">policy80</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy100</span> <span class="o">+</span> <span class="n">policy80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy80</span> <span class="o">+</span> <span class="n">policy100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">100</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="email.policy.Policy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">Policy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这是所有策略类的 <a class="reference internal" href="../glossary.xhtml#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>。 它提供了一些简单方法的默认实现，以及不可变特征属性，<a class="reference internal" href="#email.policy.Policy.clone" title="email.policy.Policy.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> 方法以及构造器语义的实现。</p>
<p>可以向策略类的构造器传入各种关键字参数。 可以指定的参数是该类的任何非方法特征属性，以及实体类的任何额外非方法特征属性。 在构造器中指定的值将覆盖相应属性的默认值。</p>
<p>这个类定义了下列特征属性，因此下列值可以被传给任何策略类的构造器:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Policy.max_line_length">
<span class="sig-name descname"><span class="pre">max_line_length</span></span></dt>
<dd><p>序列化输出中任何行的最大长度，不计入行字符的末尾。 默认值为 78，基于 <span class="target" id="index-20"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc5322.html]</span>。 值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 表示完全没有行包装。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Policy.linesep">
<span class="sig-name descname"><span class="pre">linesep</span></span></dt>
<dd><p>用来在序列化输出中确定行的字符串。 默认值为 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 因为这是 Python 所使用的内部行结束符规范，但 RFC 的要求是 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Policy.cte_type">
<span class="sig-name descname"><span class="pre">cte_type</span></span></dt>
<dd><p>控制可能要求使用的内容传输编码格式类型。 可能的值包括:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">7bit</span></code></p></td>
<td><p>所有数据必须为 &quot;纯 7 比特位&quot; (仅 ASCII)。 这意味着在必要情况下数据将使用可打印引用形式或 base64 编码格式进行编码。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">8bit</span></code></p></td>
<td><p>数据不会被限制为纯 7 比特位。 标头中的数据仍要求仅 ASCII 因此将被编码（参阅下文的 <a class="reference internal" href="#email.policy.Policy.fold_binary" title="email.policy.Policy.fold_binary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold_binary()</span></code></a> 和 <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> 了解例外情况），但消息体部分可能使用 <code class="docutils literal notranslate"><span class="pre">8bit</span></code> CTE。</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 值为 <code class="docutils literal notranslate"><span class="pre">8bit</span></code> 仅适用于 <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">Generator</span></code>，因为字符串不能包含二进制数据。 如果 <code class="docutils literal notranslate"><span class="pre">Generator</span></code> 运行于指定了 <code class="docutils literal notranslate"><span class="pre">cte_type=8bit</span></code> 的策略，它的行为将与 <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 为 <code class="docutils literal notranslate"><span class="pre">7bit</span></code> 相同。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Policy.raise_on_defect">
<span class="sig-name descname"><span class="pre">raise_on_defect</span></span></dt>
<dd><p>如为 <a class="reference internal" href="constants.xhtml#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，则遇到的任何缺陷都将引发错误。 如为 <a class="reference internal" href="constants.xhtml#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (默认值)，则缺陷将被传递给 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a> 方法。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Policy.mangle_from_">
<span class="sig-name descname"><span class="pre">mangle_from_</span></span></dt>
<dd><p>如为 <a class="reference internal" href="constants.xhtml#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，则消息体中以 <em>&quot;From &quot;</em> 开头的行会通过在其前面放一个 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 来进行转义。 当消息被生成器执行序列化时会使用此形参。 默认值t: <a class="reference internal" href="constants.xhtml#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Policy.message_factory">
<span class="sig-name descname"><span class="pre">message_factory</span></span></dt>
<dd><p>用来构造新的空消息对象的工厂函数。 在构建消息时由解析器使用。 默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在此情况下会使用 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<p>下列 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 方法是由使用 email 库的代码来调用以创建具有自室外设置的策略实例:</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例，其属性与当前实例具有相同的值，除非是那些由关键字参数给出了新值的属性。</p>
</dd></dl>

<p>其余的 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 方法是由 email 包代码来调用的，而不应当被使用 email 包的应用程序所调用。 自定义的策略必须实现所有这些方法。</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.handle_defect">
<span class="sig-name descname"><span class="pre">handle_defect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defect</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>处理在 <em>obj</em> 上发现的 <em>defect</em>。 当 email 包调用此方法时，<em>defect</em> 将总是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code> 的一个子类。</p>
<p>默认实现会检查 <a class="reference internal" href="#email.policy.Policy.raise_on_defect" title="email.policy.Policy.raise_on_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">raise_on_defect</span></code></a> 旗标。 如果其为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则 <em>defect</em> 会被作为异常来引发。 如果其为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (默认值)，则 <em>obj</em> 和 <em>defect</em> 会被传递给 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.register_defect">
<span class="sig-name descname"><span class="pre">register_defect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defect</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在 <em>obj</em> 上注册一个 <em>defect</em>。 在 email 包中，<em>defect</em> 将总是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code> 的一个子类。</p>
<p>默认实现会调用 <em>obj</em> 的 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 属性的 <code class="docutils literal notranslate"><span class="pre">append</span></code> 方法。 当 email 包调用 <a class="reference internal" href="#email.policy.Policy.handle_defect" title="email.policy.Policy.handle_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">handle_defect</span></code></a> 时，<em>obj</em> 通常将具有一个带 <code class="docutils literal notranslate"><span class="pre">append</span></code> 方法的 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 属性。 配合 email 包使用的自定义对象类型（例如自定义的 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 对象）也应当提供这样的属性，否则在被解析消息中的缺陷将引发非预期的错误。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.header_max_count">
<span class="sig-name descname"><span class="pre">header_max_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回名为 <em>name</em> 的标头的最大允许数量。</p>
<p>当添加一个标头到 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 或 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象时被调用。 如果返回值不为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>，并且已有的名称为 <em>name</em> 的标头数量大于等于所返回的值，则会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">Message.__setitem__</span></code> 的默认行为是将值添加到标头列表，因此很容易不知情地创建重复的标头。 此方法允许在程序中限制可以被添加到 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中的特定标头的实例数量。 （解析器不会考虑此限制，它将忠实地产生被解析消息中存在的任意数量的标头。）</p>
<p>默认实现对于所有标头名称都返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.header_source_parse">
<span class="sig-name descname"><span class="pre">header_source_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sourcelines</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>email 包调用此方法时将传入一个字符串列表，其中每个字符串以在被解析源中找到的行分隔符结束。 第一行包括字段标头名称和分隔符。 源中的所有空白符都会被保留。 此方法应当返回 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 元组以保存至 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中来代表被解析的标头。</p>
<p>如果一个实现希望保持与现有 email 包策略的兼容性，则 <em>name</em> 应当为保留大小写形式的名称（所有字符直至 '<code class="docutils literal notranslate"><span class="pre">:</span></code>' 分隔符），而 <em>value</em> 应当为展开后的值（移除所有行分隔符，但空白符保持不变），并移除开头的空白符。</p>
<p><em>sourcelines</em> 可以包含经替代转义的二进制数据。</p>
<p>此方法没有默认实现</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.header_store_parse">
<span class="sig-name descname"><span class="pre">header_store_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>当一个应用通过程序代码修改 <code class="docutils literal notranslate"><span class="pre">Message</span></code> (而不是由解析器创建 <code class="docutils literal notranslate"><span class="pre">Message</span></code>) 时，email 包会调用此方法并附带应用程序所提供的名称和值。 此方法应当返回 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 元组以保存至 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中用来表示标头。</p>
<p>如果一个实现希望保持与现有 email 包策略的兼容性，则 <em>name</em> 和 <em>value</em> 应当为字符串或字符串的子类，它们不会修改在参数中传入的内容。</p>
<p>此方法没有默认实现</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.header_fetch_parse">
<span class="sig-name descname"><span class="pre">header_fetch_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>当标头被应用程序所请求时，email 包会调用此方法并附带当前保存在 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中的 <em>name</em> 和 <em>value</em>，并且无论此方法返回什么它都会被回传给应用程序作为被提取标头的值。 请注意可能会有多个相同名称的标头被保存在 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中；此方法会将指定标头的名称和值返回给应用程序。</p>
<p><em>value</em> 可能包含经替代转义的二进制数据。 此方法所返回的值应当没有经替代转义的二进制数据。</p>
<p>此方法没有默认实现</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.fold">
<span class="sig-name descname"><span class="pre">fold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>email 包调用此方法时会附带当前保存在 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中的给定标头的 <em>name</em> 和 <em>value</em>。 此方法应当返回一个代表该标头的（根据策略设置）通过处理 <em>name</em> 和 <em>value</em> 并在适当位置插入 <a class="reference internal" href="#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linesep</span></code></a> 字符来正确地“折叠”的字符串。 请参阅 <span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc5322.html]</span> 了解有关折叠电子邮件标头的规则的讨论。</p>
<p><em>value</em> 可能包含经替代转义的二进制数据。 此方法所返回的字符串应当没有经替代转义的二进制数据。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Policy.fold_binary">
<span class="sig-name descname"><span class="pre">fold_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#email.policy.Policy.fold" title="email.policy.Policy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a> 类似，不同之处在于返回的值应当为字节串对象而非字符串。</p>
<p><em>value</em> 可能包含经替代转义的二进制数据。 这些数据可以在被返回的字节串对象中被转换回二进制数据。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="email.policy.EmailPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">EmailPolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这个实体 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 提供了完全遵循当前电子邮件 RFC 的行为。 这包括 (但不限于) <span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc5322.html]</span>, <span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2047.html"><strong>RFC 2047</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2047.html]</span> 以及当前的各种 MIME RFC。</p>
<p>此策略添加了新的标头解析和折叠算法。 标头不是简单的字符串，而是带有依赖于字段类型的属性的 <code class="docutils literal notranslate"><span class="pre">str</span></code> 的子类。 这个解析和折叠算法完整实现了 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2047.html"><strong>RFC 2047</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2047.html]</span> 和 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc5322.html]</span>。</p>
<p><a class="reference internal" href="#email.policy.Policy.message_factory" title="email.policy.Policy.message_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message_factory</span></code></a> 属性的默认值为 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>。</p>
<p>除了上面列出的适用于所有策略的可设置属性，此策略还添加了下列额外属性:</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6: </span><a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.utf8">
<span class="sig-name descname"><span class="pre">utf8</span></span></dt>
<dd><p>如为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则遵循 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc5322.html]</span>，通过编码为“已编码字”来支持标头中的非 ASCII 字符。 如为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则遵循 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6532.html"><strong>RFC 6532</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc6532.html]</span> 并对标头使用 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 编码格式。 以此方式格式化的消息可被传递给支持 <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> 扩展 (<span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6531.html"><strong>RFC 6531</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc6531.html]</span>) 的 SMTP 服务器。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.refold_source">
<span class="sig-name descname"><span class="pre">refold_source</span></span></dt>
<dd><p>如果 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 对象中标头的值源自 <a class="reference internal" href="email.parser.xhtml#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> (而非由程序设置)，此属性会表明当将消息转换回序列化形式时是否应当由生成器来重新折叠该值。 可能的值如下:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">none</span></code></p></td>
<td><p>所有源值使用原始折叠</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>具有任何长度超过 <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> 的行的源值将被折叠</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">all</span></code></p></td>
<td><p>所有值会被重新折叠。</p></td>
</tr>
</tbody>
</table>
<p>默认值为 <code class="docutils literal notranslate"><span class="pre">long</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.header_factory">
<span class="sig-name descname"><span class="pre">header_factory</span></span></dt>
<dd><p>该可调用对象接受两个参数，<code class="docutils literal notranslate"><span class="pre">name</span></code> 和 <code class="docutils literal notranslate"><span class="pre">value</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">name</span></code> 为标头字段名而 <code class="docutils literal notranslate"><span class="pre">value</span></code> 为展开后的标头字段值，并返回一个表示该标头的字符串子类。 已提供的默认 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code> (参见 <a class="reference internal" href="email.headerregistry.xhtml#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>) 支持对各种地址和日期 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc5322.html]</span> 标头字段类型及主要 MIME 标头字段类型的自定义解析。 未来还将添加对其他自定义解析的支持。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.content_manager">
<span class="sig-name descname"><span class="pre">content_manager</span></span></dt>
<dd><p>此对象至少有两个方法: get_content 和 set_content。 当一个 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象的 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> 或 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 方法被调用时，它会调用此对象的相应方法，将消息对象作为其第一个参数，并将传给它的任何参数或关键字作为附加参数传入。 默认情况下 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> 会被设为 <a class="reference internal" href="email.contentmanager.xhtml#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code class="xref py py-data docutils literal notranslate"><span class="pre">raw_data_manager</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<p>这个类提供了下列对 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 的抽象方法的具体实现:</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.header_max_count">
<span class="sig-name descname"><span class="pre">header_max_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回用来表示具有给定名称的标头的专用类的 <a class="reference internal" href="email.headerregistry.xhtml#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_count</span></code></a> 属性的值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.header_source_parse">
<span class="sig-name descname"><span class="pre">header_source_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sourcelines</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此名称会被作为到 '<code class="docutils literal notranslate"><span class="pre">:</span></code>' 止的所有内容来解析。 该值是通过从第一行的剩余部分去除前导空格，再将所有后续行连接到一起，并去除所有末尾回车符或换行符来确定的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.header_store_parse">
<span class="sig-name descname"><span class="pre">header_store_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>name 将会被原样返回。 如果输入值具有 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性并可在忽略大小写的情况下匹配 <em>name</em>，则 value 也会被原样返回。 在其他情况下 <em>name</em> 和 <em>value</em> 会被传递给 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>，并将结果标头对象作为值返回。 在此情况下如果输入值包含 CR 或 LF 字符则会引发 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.header_fetch_parse">
<span class="sig-name descname"><span class="pre">header_fetch_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果值具有 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性，它会被原样返回。 在其他情况下 <em>name</em> 和移除了所有 CR 和 LF 字符的 <em>value</em> 会被传递给 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>，并返回结果标头对象。 任何经替代转义的字节串会被转换为 unicode 未知字符字形。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.fold">
<span class="sig-name descname"><span class="pre">fold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>标头折叠是由 <a class="reference internal" href="#email.policy.EmailPolicy.refold_source" title="email.policy.EmailPolicy.refold_source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">refold_source</span></code></a> 策略设置来控制的。 当且仅当一个值没有 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性（具有 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性就意味着它是某种标头对象）它才会被当作是“源值”。 如果一个原值需要按照策略来重新折叠，则会通过将 <em>name</em> 和去除了所有 CR 和 LF 字符的 <em>value</em> 传递给 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code> 来将其转换为标头对象。 标头对象的折叠是通过调用其 <code class="docutils literal notranslate"><span class="pre">fold</span></code> 方法并附带当前策略来完成的。</p>
<p>源值会使用 <a class="reference internal" href="stdtypes.xhtml#str.splitlines" title="str.splitlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">splitlines()</span></code></a> 来拆分成多行。 如果该值不被重新折叠，则会使用策略中的 <code class="docutils literal notranslate"><span class="pre">linesep</span></code> 重新合并这些行并将其返回。 例外的是包含非 ascii 二进制数据的行。 在此情况下无论 <code class="docutils literal notranslate"><span class="pre">refold_source</span></code> 如何设置该值都会被重新折叠，这会导致二进制数据使用 <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 字符集进行 CTE 编码。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.EmailPolicy.fold_binary">
<span class="sig-name descname"><span class="pre">fold_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">7bit</span></code> 则与 <a class="reference internal" href="#email.policy.EmailPolicy.fold" title="email.policy.EmailPolicy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a> 类似，不同之处在于返回的值是字节串。</p>
<p>如果 <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">8bit</span></code>，则将非 ASCII 二进制数据转换回字节串。 带有二进制数据的标头不会被重新折叠，无论 <code class="docutils literal notranslate"><span class="pre">refold_header</span></code> 设置如何，因为无法知晓该二进制数据是由单字节字符还是多字节字符组成的。</p>
</dd></dl>

</dd></dl>

<p>以下 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 的实例提供了适用于特定应用领域的默认值。 请注意在未来这些实例（特别是 <code class="docutils literal notranslate"><span class="pre">HTTP</span></code> 实例）的行为可能会被调整以便更严格地遵循与其领域相关的 RFC。</p>
<dl class="py data">
<dt class="sig sig-object py" id="email.policy.default">
<span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">default</span></span></dt>
<dd><p>一个未改变任何默认值的 <code class="docutils literal notranslate"><span class="pre">EmailPolicy</span></code> 实例。 此策略使用标准的 Python <code class="docutils literal notranslate"><span class="pre">\n</span></code> 行结束符而非遵循 RFC 的 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="email.policy.SMTP">
<span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">SMTP</span></span></dt>
<dd><p>适用于按照符合电子邮件 RFC 的方式来序列化消息。 与 <code class="docutils literal notranslate"><span class="pre">default</span></code> 类似，但 <code class="docutils literal notranslate"><span class="pre">linesep</span></code> 被设为遵循 RFC 的 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="email.policy.SMTPUTF8">
<span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">SMTPUTF8</span></span></dt>
<dd><p>与 <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> 类似但是 <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 适用于在不使用标头内已编码字的情况下对消息进行序列化。 如果发送方或接收方地址具有非 ASCII 字符则应当只被用于 SMTP 传输  (<a class="reference internal" href="smtplib.xhtml#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smtplib.SMTP.send_message()</span></code></a> 方法会自动如此处理)。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="email.policy.HTTP">
<span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">HTTP</span></span></dt>
<dd><p>适用于序列化标头以在 HTTP 通信中使用。 与 <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> 类似但是 <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> 被设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (无限制)。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="email.policy.strict">
<span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">strict</span></span></dt>
<dd><p>便捷实例。 与 <code class="docutils literal notranslate"><span class="pre">default</span></code> 类似但是 <code class="docutils literal notranslate"><span class="pre">raise_on_defect</span></code> 被设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 这样可以允许通过以下写法来严格地设置任何策略:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">somepolicy</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">strict</span>
</pre></div>
</div>
</dd></dl>

<p>因为所有这些 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicies</span></code></a>，email 包的高效 API 相比 Python 3.2 API 发生了以下几方面变化:</p>
<ul class="simple">
<li><p>在 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 中设置标头将使得该标头被解析并创建一个标头对象。</p></li>
<li><p>从 <a class="reference internal" href="email.compat32-message.xhtml#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 提取标头将使得该标头被解析并创建和返回一个标头对象。</p></li>
<li><p>任何标头对象或任何由于策略设置而被重新折叠的标头都会使用一种完全实现了 RFC 折叠算法的算法来进行折叠，包括知道在休息需要并允许已编码字。</p></li>
</ul>
<p>从应用程序的视角来看，这意味着任何通过 <a class="reference internal" href="email.message.xhtml#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 获得的标头都是具有附加属性的标头对象，其字符串值都是该标头的完全解码后的 unicode 值。 类似地，可以使用 unicode 对象为一个标头赋予新的值，或创建一个新的标头对象，并且该策略将负责把该 unicode 字符串转换为正确的 RFC 已编码形式。</p>
<p>标头对象及其属性的描述见 <a class="reference internal" href="email.headerregistry.xhtml#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="email.policy.Compat32">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">Compat32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这个实体 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 为向下兼容策略。 它复制了 Python 3.2 中 email 包的行为。 <a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 模块还定义了该类的一个实例 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>，用来作为默认策略。 因此 email 包的默认行为会保持与 Python 3.2 的兼容性。</p>
<p>下列属性具有与 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 默认值不同的值:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="email.policy.Compat32.mangle_from_">
<span class="sig-name descname"><span class="pre">mangle_from_</span></span></dt>
<dd><p>默认值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<p>这个类提供了下列对 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 的抽象方法的具体实现:</p>
<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Compat32.header_source_parse">
<span class="sig-name descname"><span class="pre">header_source_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sourcelines</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此名称会被作为到 '<code class="docutils literal notranslate"><span class="pre">:</span></code>' 止的所有内容来解析。 该值是通过从第一行的剩余部分去除前导空格，再将所有后续行连接到一起，并去除所有末尾回车符或换行符来确定的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Compat32.header_store_parse">
<span class="sig-name descname"><span class="pre">header_store_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>name 和 value 会被原样返回。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Compat32.header_fetch_parse">
<span class="sig-name descname"><span class="pre">header_fetch_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 value 包含二进制数据，则会使用 <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 字符集来将其转换为 <a class="reference internal" href="email.header.xhtml#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 对象。 在其他情况下它会被原样返回。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Compat32.fold">
<span class="sig-name descname"><span class="pre">fold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>标头会使用 <a class="reference internal" href="email.header.xhtml#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 折叠算法进行折叠，该算法保留 value 中现有的换行，并将每个结果行的长度折叠至 <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>。 非 ASCII 二进制数据会使用 <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 字符串进行 CTE 编码。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="email.policy.Compat32.fold_binary">
<span class="sig-name descname"><span class="pre">fold_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>标头会使用 <a class="reference internal" href="email.header.xhtml#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 折叠算法进行折叠，该算法保留 value 中现有的换行，并将每个结果行的长度折叠至 <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>。 如果 <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 为 <code class="docutils literal notranslate"><span class="pre">7bit</span></code>，则非 ascii 二进制数据会使用 <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 字符集进行 CTE 编码。 在其他情况下则会使用原始的源标头，这将保留其现有的换行和所包含的任何（不符合 RFC 的）二进制数据。</p>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="email.policy.compat32">
<span class="sig-prename descclassname"><span class="pre">email.policy.</span></span><span class="sig-name descname"><span class="pre">compat32</span></span></dt>
<dd><p><a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a> 的实例，提供与 Python 3.2 中的 email 包行为的向下兼容性。</p>
</dd></dl>

<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>最初在 3.3 中作为 <a class="reference internal" href="../glossary.xhtml#term-provisional-package"><span class="xref std std-term">暂定特性</span></a> 添加。</p>
</aside>
</aside>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>