<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="sqlite3 --- DB-API 2.0 interface for SQLite databases" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/sqlite3.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/sqlite3/[https://github.com/python/cpython/tree/3.12/Lib/sqlite3/] SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/sqlite3/[https://github.com/python/cpython/tree/3.12/Lib/sqlite3/] SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>sqlite3 --- DB-API 2.0 interface for SQLite databases</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/sqlite3.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-sqlite3">
<span id="sqlite3-db-api-2-0-interface-for-sqlite-databases"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> --- DB-API 2.0 interface for SQLite databases</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/sqlite3/">Lib/sqlite3/</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/sqlite3/]</span></p>
<p id="sqlite3-intro">SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> module was written by Gerhard Häring.  It provides an SQL interface
compliant with the DB-API 2.0 specification described by <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span>, and
requires SQLite 3.7.15 or newer.</p>
<p>本文档包括了四个主要部分：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sqlite3-tutorial"><span class="std std-ref">教程</span></a> 将教你如何使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块。</p></li>
<li><p><a class="reference internal" href="#sqlite3-reference"><span class="std std-ref">参考</span></a> 描述了该模块定义的类与函数。</p></li>
<li><p><a class="reference internal" href="#sqlite3-howtos"><span class="std std-ref">常用方案指引</span></a> 详细介绍了如何处理一些特定的任务。</p></li>
<li><p><a class="reference internal" href="#sqlite3-explanation"><span class="std std-ref">说明</span></a> 提供了关于事务控制（transaction control）的更深一步的背景。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a></dt><dd><p>SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。</p>
</dd>
<dt><a class="reference external" href="https://www.w3schools.com/sql/">https://www.w3schools.com/sql/</a></dt><dd><p>学习 SQL 语法的教程、参考和例子。</p>
</dd>
<dt><span class="target" id="index-23"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> - DB-API 2.0 规范</dt><dd><p>PEP 由 Marc-André Lemburg 撰写。</p>
</dd>
</dl>
</div>
<section id="tutorial">
<span id="sqlite3-tutorial"></span><h2>教程</h2>
<p>在本篇教程中，你将会使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块的基本功能创建一个存储 Monty Python 的电影作品信息的数据库。本篇教程假定您在阅读前对于数据库的基本概念有所了解，例如 <a class="reference external" href="https://en.wikipedia.org/wiki/Cursor_(databases)">cursors</a><span class="link-target"> [https://en.wikipedia.org/wiki/Cursor_(databases)]</span>  与  <a class="reference external" href="https://en.wikipedia.org/wiki/Database_transaction">transactions</a><span class="link-target"> [https://en.wikipedia.org/wiki/Database_transaction]</span>  。</p>
<p>首先，我们需要创建一个新的数据库并打开一个数据库连接以允许 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 通过它来动作。 调用 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqlite3.connect()</span></code></a> 来创建与当前工作目录下 <code class="file docutils literal notranslate"><span class="pre">tutorial.db</span></code> 数据库的连接，如果它不存在则会隐式地创建它:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;tutorial.db&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的代码中，返回的 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象 <code class="docutils literal notranslate"><span class="pre">con</span></code> 代表一个与在磁盘上的数据库（on-disk databse）的连接。</p>
<p>为了执行 SQL 语句并且从 SQL 查询中取得结果，我们需要使用游标 (cursor) 。在下面的代码中，我们调用函数 <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">con.cursor()</span></code></a> 创建了一个游标 (<a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a>) ：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
</pre></div>
</div>
<p>通过上面的操作，我们已经得到了与数据库的连接 (connection) 与游标 (cursor) ，现在我们便可以在数据库中创建一张名为 <code class="docutils literal notranslate"><span class="pre">movie</span></code> 的表了，它包括电影名 （title，在下方代码中对应“title”）、上映年份（release year，在下方代码中对应“year”）以及电影评分（review score，在下方代码中对应“score”）这三列。在本篇教程中，出于简洁的考虑，我们在创建表的 SQL 语句声明中只列出表头名 (column names) ，而没有像一般的 SQL 语句那样同时声明数据列的对应数据类型 —— 这一点得益于 SQLite 的 <a class="reference external" href="https://www.sqlite.org/flextypegood.html">flexible typing</a><span class="link-target"> [https://www.sqlite.org/flextypegood.html]</span> 特性，它使得我们在使用 SQLite 时，指明数据类型这一项工作时可选的。如下面的代码所示，我们通过调用函数 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cur.excute(...)</span></code></a> 执行创建表格的 <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> 语句：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE movie(title, year, score)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以通过查询 SQLite 内置的 <code class="docutils literal notranslate"><span class="pre">sqlite_matser</span></code> 表以验证新表是否已经创建，本例中，此时该表应该已经包括了一条 <code class="docutils literal notranslate"><span class="pre">movie</span></code> 的表定义（更多内容请参考 <a class="reference external" href="https://www.sqlite.org/schematab.html">The Schema Table</a><span class="link-target"> [https://www.sqlite.org/schematab.html]</span> ）。下面的代码将通过调用函数 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cur.excute(...)</span></code></a> 执行查询，把结果赋给 <code class="docutils literal notranslate"><span class="pre">res</span></code> ，而后调用 <a class="reference internal" href="#sqlite3.Cursor.fetchone" title="sqlite3.Cursor.fetchone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">res.fetchone()</span></code></a> 获取结果行：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM sqlite_master&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">(&#39;movie&#39;,)</span>
</pre></div>
</div>
<p>在上面的代码中，我们可以看到表格已经被创建，因为查询结果返回了一个包含表格名的元组 (<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) 。倘若我们在 <code class="docutils literal notranslate"><span class="pre">sqlite_master</span></code> 表中查询一个并不存在的表 <code class="docutils literal notranslate"><span class="pre">spam</span></code> ，那么 <code class="xref py py-meth docutils literal notranslate"><span class="pre">res.fetchone()</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> ：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM sqlite_master WHERE name=&#39;spam&#39;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>现在，让我们再次调用 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cur.execute(...)</span></code></a> 去添加由 SQL 字面量 (literals) 提供的两行数据：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    INSERT INTO movie VALUES</span>
<span class="s2">        (&#39;Monty Python and the Holy Grail&#39;, 1975, 8.2),</span>
<span class="s2">        (&#39;And Now for Something Completely Different&#39;, 1971, 7.5)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 语句将隐式地创建一个事务 (transaction) ，事务需要在将更改保存到数据库前提交（更多细节请参考 <a class="reference internal" href="#sqlite3-controlling-transactions"><span class="std std-ref">事务控制</span></a> ）。我们通过在一个连接对象（本例中为 <code class="docutils literal notranslate"><span class="pre">con</span></code>）上调用 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">con.commit()</span></code></a> 提交事务：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p>我们可以通过执行一个 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 查询以验证数据是否被正确地插入表中。下面的代码中，我们使用我们已经很熟悉的函数 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cur.execute(...)</span></code></a> 将查询结果赋给 <code class="docutils literal notranslate"><span class="pre">res</span></code> ，而后调用 <a class="reference internal" href="#sqlite3.Cursor.fetchall" title="sqlite3.Cursor.fetchall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">res.fetchall()</span></code></a> 返回所有的结果行：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT score FROM movie&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">[(8.2,), (7.5,)]</span>
</pre></div>
</div>
<p>上面的代码中，结果是一个包含了两个元组 (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>) 的列表 (<a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) ，其中每一个元组代表一个数据行，每个数据行都包括该行的 <code class="docutils literal notranslate"><span class="pre">score</span></code> 值。</p>
<p>现在，让我们调用 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cur.executemany(...)</span></code></a> 再插入三行数据：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;Monty Python Live at the Hollywood Bowl&quot;</span><span class="p">,</span> <span class="mi">1982</span><span class="p">,</span> <span class="mf">7.9</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Monty Python&#39;s The Meaning of Life&quot;</span><span class="p">,</span> <span class="mi">1983</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Monty Python&#39;s Life of Brian&quot;</span><span class="p">,</span> <span class="mi">1979</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO movie VALUES(?, ?, ?)&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># Remember to commit the transaction after executing INSERT.</span>
</pre></div>
</div>
<p>请注意，占位符 (placeholders) <code class="docutils literal notranslate"><span class="pre">?</span></code> 是用来在查询中绑定数据 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的。在绑定 Python 的值到 SQL 语句中时，请使用占位符取代格式化字符串 (<a class="reference internal" href="../tutorial/inputoutput.xhtml#tut-formatting"><span class="std std-ref">string formatting</span></a> ) 以避免 <a class="reference external" href="https://en.wikipedia.org/wiki/SQL_injection">SQL 注入攻击</a><span class="link-target"> [https://en.wikipedia.org/wiki/SQL_injection]</span> （更多细节请参见 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">如何在 SQL 查询中使用占位符来绑定值</span></a> ）。</p>
<p>同样的，我们可以通过执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 查询验证新的数据行是否已经插入表中，这一次我们将迭代查询的结果：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT year, title FROM movie ORDER BY year&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">(1971, &#39;And Now for Something Completely Different&#39;)</span>
<span class="go">(1975, &#39;Monty Python and the Holy Grail&#39;)</span>
<span class="go">(1979, &quot;Monty Python&#39;s Life of Brian&quot;)</span>
<span class="go">(1982, &#39;Monty Python Live at the Hollywood Bowl&#39;)</span>
<span class="go">(1983, &quot;Monty Python&#39;s The Meaning of Life&quot;)</span>
</pre></div>
</div>
<p>如上可见，每一行都是包括 <code class="docutils literal notranslate"><span class="pre">(year,title)</span></code> 这两个元素的元组 (<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> ) ，它与我们查询中选中的数据列相匹配。</p>
<p>最后，让我们先通过调用 <a class="reference internal" href="#sqlite3.Connection.close" title="sqlite3.Connection.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">con.close()</span></code></a> 关闭现存的与数据库的连接，而后打开一个新的连接、创建一个新的游标、执行一个新的查询以验证我们是否将数据库写入到了本地磁盘上：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;tutorial.db&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_cur</span> <span class="o">=</span> <span class="n">new_con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">new_cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT title, year FROM movie ORDER BY score DESC&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">title</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The highest scoring Monty Python movie is </span><span class="si">{</span><span class="n">title</span><span class="si">!r}</span><span class="s1">, released in </span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">The highest scoring Monty Python movie is &#39;Monty Python and the Holy Grail&#39;, released in 1975</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>现在您已经成功地使用模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 创建了一个 SQLite 数据库，并且学会了以多种方式往其中插入数据与检索值。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p>阅读 <a class="reference internal" href="#sqlite3-howtos"><span class="std std-ref">常用方案指引</span></a> 以获取更多信息：</p>
<ul>
<li><p><a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">如何在 SQL 查询中使用占位符来绑定值</span></a></p></li>
<li><p><a class="reference internal" href="#sqlite3-adapters"><span class="std std-ref">如何将自定义 Python 类型适配到 SQLite 值</span></a></p></li>
<li><p><a class="reference internal" href="#sqlite3-converters"><span class="std std-ref">如何将 SQLite 值转换为自定义 Python 类型</span></a></p></li>
<li><p><a class="reference internal" href="#sqlite3-connection-context-manager"><span class="std std-ref">如何使用连接上下文管理器</span></a></p></li>
<li><p><a class="reference internal" href="#sqlite3-howto-row-factory"><span class="std std-ref">如何创建并使用行工厂对象</span></a></p></li>
</ul>
</li>
<li><p>参阅 <a class="reference internal" href="#sqlite3-explanation"><span class="std std-ref">说明</span></a> 以获取关于事务控制的更深一步的背景。</p></li>
</ul>
</div>
</section>
<section id="reference">
<span id="sqlite3-reference"></span><h2>参考</h2>
<section id="module-functions">
<span id="sqlite3-module-functions"></span><span id="sqlite3-module-contents"></span><h3>模块函数</h3>
<dl class="py function">
<dt class="sig sig-object py" id="sqlite3.connect">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">database</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detect_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isolation_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEFERRED'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_same_thread</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">sqlite3.Connection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cached_statements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autocommit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">sqlite3.LEGACY_TRANSACTION_CONTROL</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>打开一个与 SQLite 数据库的连接。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>database</strong> (<a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">path-like object</span></a>) -- 要撕开的数据库文件的路径。 你可以传入 <code class="docutils literal notranslate"><span class="pre">&quot;:memory:&quot;</span></code> 来创建一个 <a class="reference external" href="https://sqlite.org/inmemorydb.html">仅存在于内存中的 SQLite 数据库</a><span class="link-target"> [https://sqlite.org/inmemorydb.html]</span>，并打开它的一个连接。</p></li>
<li><p><strong>timeout</strong> (<a class="reference internal" href="functions.xhtml#float" title="float"><em>float</em></a>) -- 当一个表被锁定时连接在最终引发 <a class="reference internal" href="#sqlite3.OperationalError" title="sqlite3.OperationalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OperationalError</span></code></a> 之前应该等待多少秒。 如果另一个链接开启了一个事务来修改一个表，该表将被锁定直到该事务完成提交。 默认值为五秒。</p></li>
<li><p><strong>detect_types</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 控制是否以及如何使用由 <a class="reference internal" href="#sqlite3.register_converter" title="sqlite3.register_converter"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_converter()</span></code></a> 注册的转换器将并非由 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">SQLite 原生支持的</span></a> 数据类型转换为 Python 类型。 将它设置为 <a class="reference internal" href="#sqlite3.PARSE_DECLTYPES" title="sqlite3.PARSE_DECLTYPES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_DECLTYPES</span></code></a> 和 <a class="reference internal" href="#sqlite3.PARSE_COLNAMES" title="sqlite3.PARSE_COLNAMES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_COLNAMES</span></code></a> 的任意组合 (使用 <code class="docutils literal notranslate"><span class="pre">|</span></code>，即按位或) 来启动它。 如果两个旗标都被设置则列名将优先于声明的类型。 即使设置了 <em>detect_types</em>，依然无法对生成的字段 (例如 <code class="docutils literal notranslate"><span class="pre">max(data)</span></code>) 进行类型检测；此时它将改为返回 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。 当使用默认值 (<code class="docutils literal notranslate"><span class="pre">0</span></code>) 时，类型检测将被禁用。</p></li>
<li><p><strong>isolation_level</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a><em> | </em><em>None</em>) -- 控制旧式的事务处理行为。 更多信息请参阅 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.isolation_level</span></code></a> 和 <a class="reference internal" href="#sqlite3-transaction-control-isolation-level"><span class="std std-ref">通过 isolation_level 属性进行事务控制</span></a>。 可以为 <code class="docutils literal notranslate"><span class="pre">&quot;DEFERRED&quot;</span></code> (默认值)、<code class="docutils literal notranslate"><span class="pre">&quot;EXCLUSIVE&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;IMMEDIATE&quot;</span></code>；或者为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 表示禁止隐式地开启事务。 除非 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.autocommit</span></code></a> 设为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-const docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a> (默认值) 否则没有任何影响。</p></li>
<li><p><strong>check_same_thread</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 如果为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (默认)，则 <a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProgrammingError</span></code></a> 将在数据库连接被它的创建者以外的线程使用时被引发。 如果为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则连接可以在多个线程中被访问；写入操作需要由用户者进行序列化以避免数据损坏。 请参阅 <a class="reference internal" href="#sqlite3.threadsafety" title="sqlite3.threadsafety"><code class="xref py py-attr docutils literal notranslate"><span class="pre">threadsafety</span></code></a> 了解详情。</p></li>
<li><p><strong>factory</strong> (<a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><em>Connection</em></a>) -- 如果您不想使用默认的 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 类创建连接，那么您可以通过传入一个自定义的 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 类的子类给该参数以创建连接。</p></li>
<li><p><strong>cached_statements</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 该参数指明 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块应该为该连接进行内部缓存的语句 (statements) 数量。默认情况下，它的值为128。</p></li>
<li><p><strong>uri</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 如果将该参数的值设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，参数 <em>database</em> 将会被解释为一个由文件路径与可选的查询字符串组成的 <abbr title="Uniform Resource Identifier">URI</abbr> 链接。链接的前缀协议部分 (schema part) <em>必需</em> 是 <code class="docutils literal notranslate"><span class="pre">&quot;file:&quot;</span></code> ，后面的文件路径可以是相对路径或绝对路径。查询字符串允许向 SQLite 传递参数，以实现不同的 <a class="reference internal" href="#sqlite3-uri-tricks"><span class="std std-ref">如何使用 SQLite URI</span></a>。</p></li>
<li><p><strong>autocommit</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 控制 <span class="target" id="index-24"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> 事务处理行为。 更多信息参见 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.autocommit</span></code></a> 和 <a class="reference internal" href="#sqlite3-transaction-control-autocommit"><span class="std std-ref">通过 autocommit 属性进行事务控制</span></a>。 <em>autocommit</em> 目前默认值为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-const docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a>。 在未来的 Python 版本中默认值将变为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><em>Connection</em></a></p>
</dd>
</dl>
<p class="audit-hook">使用它将引发一个附带参数 <code class="docutils literal notranslate"><span class="pre">database</span></code> 的 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件 (auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">sqlite3.connect</span></code> 。</p>
<p class="audit-hook">使用它将引发一个附带参数 <code class="docutils literal notranslate"><span class="pre">connection_handle</span></code> 的 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">sqlite3.connect/handle</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>增加了 <em>uri</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><em>database</em> 现在可以是一个 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">path-like object</span></a> 对象了，而不仅仅是字符串。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">sqlite3.connect/handle</span></code> 审计事件。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>增加了 <em>autocommit</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlite3.complete_statement">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">complete_statement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">statement</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果传入的字符串语句 (statement) 看起来像是包括一条或多条完整的 SQL 语句，那么该函数将返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。请注意，除了检查未封闭的字符串字面 (unclosed string literals) 以及语句是否以分号结束外，它不会执行任何的语法检查 (syntactic verification) 与语法解析 (synatatic parsing) 。</p>
<p>例如:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqlite3</span><span class="o">.</span><span class="n">complete_statement</span><span class="p">(</span><span class="s2">&quot;SELECT foo FROM bar;&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqlite3</span><span class="o">.</span><span class="n">complete_statement</span><span class="p">(</span><span class="s2">&quot;SELECT foo&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>该函数可能在这样的情形下非常有用：在通过命令行 (command-line) 输入数据时，可使用该函数判断输入文本是否可以构成一个完成的 SQL 语句，或者判断在调用函数 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 前是否还需要额外的输入。</p>
<p>请参阅 <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/sqlite3/__main__.py">Lib/sqlite3/__main__.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/sqlite3/__main__.py]</span> 中的 <code class="xref py py-func docutils literal notranslate"><span class="pre">runsource()</span></code> 了解实际使用情况。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlite3.enable_callback_tracebacks">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">enable_callback_tracebacks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flag</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>是否启用回调回溯 (callback tracebacks) 。默认情况下，在 SQLite 中，您不会在用户定义的函数、聚合函数 (aggregates) 、转换函数 (converters) 、验证回调函数 (authorizer callbacks) 等中得到任何回溯信息。如果您想调试它们，您可以在将形式参数 <em>flag</em> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的情况下调用该函数。之后您便可以从 <a class="reference internal" href="sys.xhtml#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 的回调中得到回溯信息。使用 <code class="docutils literal notranslate"><span class="pre">False</span></code> 将再次禁用该功能。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>用户自定义函数回调中的错误将被记录为不可引发的异常。 请使用 <a class="reference internal" href="sys.xhtml#sys.unraisablehook" title="sys.unraisablehook"><code class="xref py py-func docutils literal notranslate"><span class="pre">不可引发的钩子处理器</span></code></a> 执行对失败回调的内省。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlite3.register_adapter">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">register_adapter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adapter</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>注册 <em>adapter</em> <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> 以将 Python 类型 <em>type</em> 适配为一个 SQLite 类型。 该适配器在调用时会传入一个 <em>type</em> 类型的 Python 对象作为其唯一参数，并且必须返回一个 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">SQLite 原生支持的类型</span></a> 的值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sqlite3.register_converter">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">register_converter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">converter</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>注册 <em>converter</em> <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> 以将 <em>typename</em> 类型的 SQLite 对象转换为一个特定类型的 Python 对象。转换器会针对所有类型为 <em>typename</em> 的 SQLite 值发起调用；它会传递一个 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象并且应该返回一个所需的 Python 类型的对象。 请参阅 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 的 <em>detect_types</em> 形参了解有关类型检测工作方式的详情。</p>
<p>注：<em>typename</em> 以及您在查询中使用的类型名是不大小写敏感的。</p>
</dd></dl>

</section>
<section id="module-constants">
<span id="sqlite3-module-constants"></span><h3>模块常量</h3>
<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.LEGACY_TRANSACTION_CONTROL">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></span></dt>
<dd><p>将 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 设为该常量以选择旧式（Python 3.12 之前）事务控制行为。 更多信息请参阅 <a class="reference internal" href="#sqlite3-transaction-control-isolation-level"><span class="std std-ref">通过 isolation_level 属性进行事务控制</span></a>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.PARSE_COLNAMES">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">PARSE_COLNAMES</span></span></dt>
<dd><p>将这个旗标值传递给 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 的 <em>detect_types</em> 形参，以使用从查询列名解析的类型名作为转换器字典键来查找转换器函数。类型名称必须用方括号（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）括起来。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="ss">&quot;p [point]&quot;</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">look</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">converter</span><span class="w"> </span><span class="ss">&quot;point&quot;</span>
</pre></div>
</div>
<p>此旗标可以使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> （位或）运算符与 <a class="reference internal" href="#sqlite3.PARSE_DECLTYPES" title="sqlite3.PARSE_DECLTYPES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_DECLTYPES</span></code></a> 组合。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.PARSE_DECLTYPES">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">PARSE_DECLTYPES</span></span></dt>
<dd><p>将这个旗标值传递给 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 的 <em>detect_types</em> 形参，以使用创建数据库表时为每列声明的类型的查找转换器函数。<code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 将使用声明类型的第一个单词作为转换字典键来查找转换函数。例如：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">test</span><span class="p">(</span>
<span class="w">   </span><span class="n">i</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">look</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">converter</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="ss">&quot;integer&quot;</span>
<span class="w">   </span><span class="n">p</span><span class="w"> </span><span class="n">point</span><span class="p">,</span><span class="w">                </span><span class="o">!</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">look</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">converter</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="ss">&quot;point&quot;</span>
<span class="w">   </span><span class="n">n</span><span class="w"> </span><span class="nb">number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">look</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">converter</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="ss">&quot;number&quot;</span>
<span class="w"> </span><span class="p">)</span>
</pre></div>
</div>
<p>此旗标可以使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> （位或）运算符与 <a class="reference internal" href="#sqlite3.PARSE_COLNAMES" title="sqlite3.PARSE_COLNAMES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_COLNAMES</span></code></a> 组合。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.SQLITE_OK">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_OK</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DENY">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DENY</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_IGNORE">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_IGNORE</span></span></dt>
<dd><p>应当由传给 <a class="reference internal" href="#sqlite3.Connection.set_authorizer" title="sqlite3.Connection.set_authorizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.set_authorizer()</span></code></a> 的 <em>authorizer_callback</em> <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> 返回的旗标，用于指明是否:</p>
<ul class="simple">
<li><p>访问被允许（<code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_OK</span></code>）。</p></li>
<li><p>SQL语句伴异常的执行失败（<code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_DENY</span></code>）。</p></li>
<li><p>该列应被视为NULL（<code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_IGNORE</span></code>）。</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.apilevel">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">apilevel</span></span></dt>
<dd><p>指明所支持的 DB-API 级别的字符串常量。 根据 DB-API 的需要设置。 硬编码为 <code class="docutils literal notranslate"><span class="pre">&quot;2.0&quot;</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.paramstyle">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">paramstyle</span></span></dt>
<dd><p>指明 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块所预期的形参标记格式化类型。 根据 DB-API 的需要设置。 硬编码为 <code class="docutils literal notranslate"><span class="pre">&quot;qmark&quot;</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">named</span></code> DB-API 形参风格也受到支持。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.sqlite_version">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">sqlite_version</span></span></dt>
<dd><p>以 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">字符串</span></code></a> 表示的运行时 SQLite 库版本号。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.sqlite_version_info">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">sqlite_version_info</span></span></dt>
<dd><p>以 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">整数</span></code></a> <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 表示的运行时. SQLite 库版本号。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.threadsafety">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">threadsafety</span></span></dt>
<dd><p>DB-API 2.0 所要求的整数常量，指明 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块支持的线程安全级别。 该属性将基于编译下层 SQLite 库所使用的默认 <a class="reference external" href="https://sqlite.org/threadsafe.html">线程模式</a><span class="link-target"> [https://sqlite.org/threadsafe.html]</span> 来设置。 SQLite 的线程模式有:</p>
<ol class="arabic simple">
<li><p><strong>Single-thread</strong>: 在此模式下，所有的互斥都被禁用并且 SQLite 同时在多个线程中使用将是不安全的。</p></li>
<li><p><strong>Multi-thread</strong>: 在此模式下，只要单个数据库连接没有被同时用于两个或多个线程之中 SQLite 就可以安全地被多个线程所使用。</p></li>
<li><p><strong>Serialized</strong>: 在序列化模式下，SQLite 可以安全地被多个线程所使用而没有额外的限制。</p></li>
</ol>
<p>从 SQLite 线程模式到 DB-API 2.0 线程安全级别的映射关系如下:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SQLite 线程模式</p></th>
<th class="head"><p><a class="reference external" href="https://peps.python.org/pep-0249/#threadsafety">threadsafety</a><span class="link-target"> [https://peps.python.org/pep-0249/#threadsafety]</span></p></th>
<th class="head"><p><a class="reference external" href="https://sqlite.org/compile.html#threadsafe">SQLITE_THREADSAFE</a><span class="link-target"> [https://sqlite.org/compile.html#threadsafe]</span></p></th>
<th class="head"><p>DB-API 2.0 含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>single-thread</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>各个线程不能共享模块</p></td>
</tr>
<tr class="row-odd"><td><p>multi-thread</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>线程可以共享模块，但不能共享连接</p></td>
</tr>
<tr class="row-even"><td><p>serialized</p></td>
<td><p>3</p></td>
<td><p>1</p></td>
<td><p>线程可以共享模块、连接和游标Threads may share the module, connections and cursors</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>动态设置 <em>threadsafety</em> 而不是将其硬编码为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.version">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">version</span></span></dt>
<dd><p>此模块 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">字符串</span></code></a> 形式的版本号。 这不是 SQLite 库的版本号。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.12 版起不建议使用，将在 3.14 版中移除: </span>这个常量原本是用于反映 <code class="docutils literal notranslate"><span class="pre">pysqlite</span></code> 包的版本号，它是一个用于对 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 进行上游修改的第三方库。 如今它已不具任何意义或实用价值。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="sqlite3.version_info">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">version_info</span></span></dt>
<dd><p>此模块 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">整数</span></code></a> <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 形式的版本号。 这不是 SQLite 库的版本号。library.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.12 版起不建议使用，将在 3.14 版中移除: </span>这个常量原本是用于反映 <code class="docutils literal notranslate"><span class="pre">pysqlite</span></code> 包的版本号，它是一个用于对 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 进行上游修改的第三方库。 如今它已不具任何意义或实用价值。</p>
</div>
</dd></dl>

<dl class="py data" id="sqlite3-dbconfig-constants">
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_DEFENSIVE">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_DEFENSIVE</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_DQS_DDL">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_DQS_DDL</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_DQS_DML">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_DQS_DML</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_ENABLE_FKEY">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_ENABLE_FKEY</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_ENABLE_QPSG">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_ENABLE_QPSG</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_ENABLE_TRIGGER">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_ENABLE_TRIGGER</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_ENABLE_VIEW">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_ENABLE_VIEW</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_RESET_DATABASE">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_RESET_DATABASE</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_TRIGGER_EQP">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_TRIGGER_EQP</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_TRUSTED_SCHEMA">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_TRUSTED_SCHEMA</span></span></dt>
<dt class="sig sig-object py" id="sqlite3.SQLITE_DBCONFIG_WRITABLE_SCHEMA">
<span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">SQLITE_DBCONFIG_WRITABLE_SCHEMA</span></span></dt>
<dd><p>这些常量被用于 <a class="reference internal" href="#sqlite3.Connection.setconfig" title="sqlite3.Connection.setconfig"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.setconfig()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection.getconfig" title="sqlite3.Connection.getconfig"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getconfig()</span></code></a> 方法。</p>
<p>这些常量的可用性会根据 Python 编译时使用的 SQLite 版本而发生变化。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html">https://www.sqlite.org/c3ref/c_dbconfig_defensive.html</a></dt><dd><p>SQLite 文档：数据库连接配置选项</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
<section id="connection-objects">
<span id="sqlite3-connection-objects"></span><h3>连接对象</h3>
<dl class="py class">
<dt class="sig sig-object py" id="sqlite3.Connection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">Connection</span></span></dt>
<dd><p>每个打开的 SQLite 数据库均以 <code class="docutils literal notranslate"><span class="pre">Connection</span></code> 对象来表示，这种对象是使用 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqlite3.connect()</span></code></a> 创建的。 它们的主要目的是创建 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象，以及 <a class="reference internal" href="#sqlite3-controlling-transactions"><span class="std std-ref">事务控制</span></a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sqlite3-connection-shortcuts"><span class="std std-ref">如何使用连接快捷方法</span></a></p></li>
<li><p><a class="reference internal" href="#sqlite3-connection-context-manager"><span class="std std-ref">如何使用连接上下文管理器</span></a></p></li>
</ul>
</div>
<p>SQLite 数据库连接对象有如下的属性和方法：</p>
<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.cursor">
<span class="sig-name descname"><span class="pre">cursor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Cursor</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建并返回 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象。 cursor 方法接受一个可选参数 <em>factory</em>。 如果提供了这个参数，它必须是一个 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> 并且返回 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 或其子类的实例。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.blobopen">
<span class="sig-name descname"><span class="pre">blobopen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'main'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>打开一个已有的 <abbr>BLOB（二进制大型对象）</abbr> <a class="reference internal" href="#sqlite3.Blob" title="sqlite3.Blob"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blob</span></code></a> 句柄。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>table</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 二进制大对象 blob 所在表的名称。</p></li>
<li><p><strong>column</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 二进制大对象 blob 所在表的列名。</p></li>
<li><p><strong>row</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 二进制大对象 blob 所在的列名。</p></li>
<li><p><strong>readonly</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 如果 blob 应当不带写入权限打开则设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 二进制大对象 blob 所在的数据库名。 默认为 <code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code>。</p></li>
</ul>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#sqlite3.OperationalError" title="sqlite3.OperationalError"><strong>OperationalError</strong></a> -- 当尝试打开 <code class="docutils literal notranslate"><span class="pre">WITHOUT</span> <span class="pre">ROWID</span></code> 的表中的某个 blob 时。</p>
</dd>
<dt class="field-odd">返回类型<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#sqlite3.Blob" title="sqlite3.Blob">Blob</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>blob 的大小无法使用 <a class="reference internal" href="#sqlite3.Blob" title="sqlite3.Blob"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blob</span></code></a> 类来修改。 可使用 SQL 函数 <code class="docutils literal notranslate"><span class="pre">zeroblob</span></code> 来创建固定大小的 blob。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.commit">
<span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>向数据库提交任何待处理事务。 如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，或者没有已开启的事务，则此方法不会做任何操作。 如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则如果有一个待处理事务被此方法提交则会隐式地开启一个新事务。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.rollback">
<span class="sig-name descname"><span class="pre">rollback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>回滚到任何待处理事务的起始位置。 如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，或者没有已开启的事务，则此方法不会做任何操作。 如果:attr:<cite>!autocommit</cite> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则如果此方法回滚了一个待处理事务则会隐式地开启一个新事务。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>关闭数据库连接。 如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则任何待处理事务都会被隐式地回滚。 如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a>，则不会执行隐式的事务控制。 请确保在关闭之前 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a> 以避免丢失待处理的更改。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sql</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象，并在其上使用给出的 <em>sql</em> 和 <em>parameters</em> 调用 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>。 返回新的游标对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.executemany">
<span class="sig-name descname"><span class="pre">executemany</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sql</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象，并在其上使用给出的 <em>sql</em> 和 <em>parameters</em> 调用 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a>。 返回新的游标对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.executescript">
<span class="sig-name descname"><span class="pre">executescript</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sql_script</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象，并在其上使用给出的 <em>sql_script</em> 调用 <a class="reference internal" href="#sqlite3.Cursor.executescript" title="sqlite3.Cursor.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a>。 返回新的游标对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.create_function">
<span class="sig-name descname"><span class="pre">create_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">narg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deterministic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建或移除用户定义的 SQL 函数。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- SQL 函数的名称。</p></li>
<li><p><strong>narg</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- SQL 函数可接受的参数数量，如果是 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，则该函数可以接受任意数量的参数。</p></li>
<li><p><strong>func</strong> (<a class="reference internal" href="../glossary.xhtml#term-callback"><span class="xref std std-term">callback</span></a> | None) -- 当该 SQL 函数被发起调用时将会调用的 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a>。 该可调用对象必须返回 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">一个 SQLite 原生支持的类型</span></a>。 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将移除现有的 SQL 函数。</p></li>
<li><p><strong>deterministic</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 如为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，创建的 SQL 函数将被标记为 <a class="reference external" href="https://sqlite.org/deterministic.html">deterministic</a><span class="link-target"> [https://sqlite.org/deterministic.html]</span>，这允许 SQLite 执行额外的优化。</p></li>
</ul>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#sqlite3.NotSupportedError" title="sqlite3.NotSupportedError"><strong>NotSupportedError</strong></a> -- If <em>deterministic</em> is used with SQLite versions older than 3.8.3.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>deterministic</em> 形参。</p>
</div>
<p>示例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">md5sum</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span><span class="s2">&quot;md5&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">md5sum</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT md5(?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,)):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">(&#39;acbd18db4cc2f85cedef654fccc4a4d8&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.create_aggregate">
<span class="sig-name descname"><span class="pre">create_aggregate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_arg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate_class</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建或移除用户自定义的 SQL 聚合函数。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- SQL 聚合函数的名称。</p></li>
<li><p><strong>n_arg</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- SQL 聚合函数可接受的参数数量。 如为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，则可以接受任意数量的参数。</p></li>
<li><p><strong>aggregate_class</strong> (<a class="reference internal" href="../glossary.xhtml#term-class"><span class="xref std std-term">class</span></a> | None) -- 一个类必须实现下列方法:  * <code class="docutils literal notranslate"><span class="pre">step()</span></code>: 向聚合添加一行。 * <code class="docutils literal notranslate"><span class="pre">finalize()</span></code>: 将聚合的最终结果作为 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">一个 SQLite 原生支持的类型</span></a> 返回。 <code class="docutils literal notranslate"><span class="pre">step()</span></code> 方法需要接受的参数数量是由 <em>n_arg</em> 控制的。 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将移除现有的 SQL 聚合函数。</p></li>
</ul>
</dd>
</dl>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySum</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">create_aggregate</span><span class="p">(</span><span class="s2">&quot;mysum&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MySum</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE test(i)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test(i) VALUES(1)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test(i) VALUES(2)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT mysum(i) FROM test&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.create_window_function">
<span class="sig-name descname"><span class="pre">create_window_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate_class</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建或移除用户定义的聚合窗口函数。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 要创建或移除的 SQL 聚合窗口函数的名称。</p></li>
<li><p><strong>num_params</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- SQL 聚合窗口函数可接受的参数数量。 如为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，则可以接受任意数量的参数。</p></li>
<li><p><strong>aggregate_class</strong> (<a class="reference internal" href="../glossary.xhtml#term-class"><span class="xref std std-term">class</span></a> | None) -- 一个必须实现下列方法的类:  * <code class="docutils literal notranslate"><span class="pre">step()</span></code>: 向当前窗口添加一行。 * <code class="docutils literal notranslate"><span class="pre">value()</span></code>: 返回聚合的当前值。 * <code class="docutils literal notranslate"><span class="pre">inverse()</span></code>: 从当前窗口移除一行。 * <code class="docutils literal notranslate"><span class="pre">finalize()</span></code>: 将聚合的最终结果作为 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">一个 SQLite 原生支持的类型</span></a> 返回。 <code class="docutils literal notranslate"><span class="pre">step()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">value()</span></code> 方法需要接受的参数数量是由 <em>num_params</em> 控制的。 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将移除现有的 SQL 聚合窗口函数。</p></li>
</ul>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#sqlite3.NotSupportedError" title="sqlite3.NotSupportedError"><strong>NotSupportedError</strong></a> -- 如果在早于 SQLite 3.25.0，不支持聚合窗口函数的版本上使用。</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc</span>
<span class="k">class</span> <span class="nc">WindowSumInt</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a row to the current window.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current value of the aggregate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a row from the current window.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the final value of the aggregate.</span>

<span class="sd">        Any clean-up actions should be placed here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>


<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE test(x, y)&quot;</span><span class="p">)</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test VALUES(?, ?)&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">create_window_function</span><span class="p">(</span><span class="s2">&quot;sumint&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">WindowSumInt</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    SELECT x, sumint(y) OVER (</span>
<span class="s2">        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</span>
<span class="s2">    ) AS sum_y</span>
<span class="s2">    FROM test ORDER BY x</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.create_collation">
<span class="sig-name descname"><span class="pre">create_collation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>使用排序函数 <em>callable</em> 创建一个名为 <em>name</em> 的排序规则。 <em>callable</em> 被传递给两个 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">字符串</span></code></a> 参数，并且它应该返回一个 <a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">整数</span></code></a>。</p>
<ul class="simple">
<li><p>如果前者的排序高于后者则为 <code class="docutils literal notranslate"><span class="pre">1</span></code></p></li>
<li><p>如果前者的排序低于于后者则为 <code class="docutils literal notranslate"><span class="pre">-1</span></code></p></li>
<li><p>如果它们的顺序相同则为 <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
</ul>
<p>下面的例子显示了一个反向排序的排序方法:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">collate_reverse</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">string1</span> <span class="o">==</span> <span class="n">string2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">string1</span> <span class="o">&lt;</span> <span class="n">string2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">create_collation</span><span class="p">(</span><span class="s2">&quot;reverse&quot;</span><span class="p">,</span> <span class="n">collate_reverse</span><span class="p">)</span>

<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE test(x)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test(x) VALUES(?)&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,)])</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT x FROM test ORDER BY x COLLATE reverse&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>通过将 <em>callable</em> 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 来移除一个排序规则函数。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>排序规则的名称可以包含任意 Unicode 字符。 在之前，只允许 ASCII 字符。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.interrupt">
<span class="sig-name descname"><span class="pre">interrupt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>从其他的线程调用此方法以中止可能正在连接上执行的任何查询。 被中止的查询将引发 <a class="reference internal" href="#sqlite3.OperationalError" title="sqlite3.OperationalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OperationalError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.set_authorizer">
<span class="sig-name descname"><span class="pre">set_authorizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">authorizer_callback</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>注册 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> <em>authorizer_callback</em> 用于在每次尝试访问数据库中表的某一列时发起调用。 该回调应当返回 <a class="reference internal" href="#sqlite3.SQLITE_OK" title="sqlite3.SQLITE_OK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_OK</span></code></a>、<a class="reference internal" href="#sqlite3.SQLITE_DENY" title="sqlite3.SQLITE_DENY"><code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_DENY</span></code></a> 或 <a class="reference internal" href="#sqlite3.SQLITE_IGNORE" title="sqlite3.SQLITE_IGNORE"><code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_IGNORE</span></code></a> 中的一个以提示下层 SQLite 库应当如何处理对该列的访问。</p>
<p>该回调的第一个参数指明哪种操作将被授权。 第二个和第三个参数根据第一个参数的具体值将为传给操作的参数或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 第四个参数如果适用则为数据库名称（&quot;main&quot;, &quot;temp&quot; 等）。 第五个参数是负责尝试访问的最内层触发器或视图的名称或者如果该尝试访问是直接来自输入的 SQL 代码的话则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>请参阅 SQLite 文档了解第一个参数可能的值以及依赖于第一个参数的第二个和第三个参数的含义。 所有必需的常量均在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块中可用。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为 <em>authorizer_callback</em> 传入将禁用授权回调。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加对使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 禁用授权回调的支持。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.set_progress_handler">
<span class="sig-name descname"><span class="pre">set_progress_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">progress_handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>注册 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> <em>progress_handler</em> 以针对 SQLite 虚拟机的每 <em>n</em> 条指令发起调用。 如果你想要在长时间运行的操作，例如更新 GUI 期间获得来自 SQLite 的调用这将很有用处。</p>
<p>如果你想清除任何先前安装的进度处理器，可在调用该方法时传入 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为 <em>progress_handler</em>。</p>
<p>从处理函数返回非零值将终止当前正在执行的查询并导致它引发 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.set_trace_callback">
<span class="sig-name descname"><span class="pre">set_trace_callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace_callback</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>注册 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a> <em>trace_callback</em> 以针对 SQLite 后端实际执行的每条 SQL 语句发起调用。</p>
<p>传给该回调的唯一参数是被执行的语句 (作为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>)。 回调的返回值将被忽略。 请注意后端不仅会运行传给 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Cursor.execute()</span></code></a> 方法的语句。 其他来源还包括 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块的 <a class="reference internal" href="#sqlite3-controlling-transactions"><span class="std std-ref">事务管理</span></a> 以及在当前数据库中定义的触发器的执行。</p>
<p>传入 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为 <em>trace_callback</em> 将禁用追踪回调。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在跟踪回调中产生的异常不会被传播。作为开发和调试的辅助手段，使用 <a class="reference internal" href="#sqlite3.enable_callback_tracebacks" title="sqlite3.enable_callback_tracebacks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enable_callback_tracebacks()</span></code></a> 来启用打印跟踪回调中产生的异常的回调。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.enable_load_extension">
<span class="sig-name descname"><span class="pre">enable_load_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enabled</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>enabled</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 则允许 SQLite 从共享库加载 SQLite 扩展；否则，不允许加载 SQLite 扩展。 SQLite 扩展可以定义新的函数、聚合或全新的虚拟表实现。 一个知名的扩展是与随同 SQLite 一起分发的全文搜索扩展。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在默认情况下 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块的构建没有附带可加载扩展支持，因为某些平台（主要是 macOS）上的 SQLite 库在编译时未启用此特性。 要获得可加载扩展支持，你必须将 <a class="reference internal" href="../using/configure.xhtml#cmdoption-enable-loadable-sqlite-extensions"><code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-loadable-sqlite-extensions</span></code></a> 选项传给 <strong class="program">configure</strong>。</p>
</div>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">sqlite3.enable_load_extension</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">connection</span></code>, <code class="docutils literal notranslate"><span class="pre">enabled</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">sqlite3.enable_load_extension</span></code> 审计事件。</p>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">enable_load_extension</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Load the fulltext search extension</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select load_extension(&#39;./fts3.so&#39;)&quot;</span><span class="p">)</span>

<span class="c1"># alternatively you can load the extension using an API call:</span>
<span class="c1"># con.load_extension(&quot;./fts3.so&quot;)</span>

<span class="c1"># disable extension loading again</span>
<span class="n">con</span><span class="o">.</span><span class="n">enable_load_extension</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># example from SQLite wiki</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    INSERT INTO recipe (name, ingredients) VALUES(&#39;broccoli stew&#39;, &#39;broccoli peppers cheese tomatoes&#39;);</span>
<span class="s2">    INSERT INTO recipe (name, ingredients) VALUES(&#39;pumpkin stew&#39;, &#39;pumpkin onions garlic celery&#39;);</span>
<span class="s2">    INSERT INTO recipe (name, ingredients) VALUES(&#39;broccoli pie&#39;, &#39;broccoli cheese onions flour&#39;);</span>
<span class="s2">    INSERT INTO recipe (name, ingredients) VALUES(&#39;pumpkin pie&#39;, &#39;pumpkin sugar flour butter&#39;);</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT rowid, name, ingredients FROM recipe WHERE name MATCH &#39;pie&#39;&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.load_extension">
<span class="sig-name descname"><span class="pre">load_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entrypoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从共享库加载 SQLite 扩展。 请在调用此方法前通过 <a class="reference internal" href="#sqlite3.Connection.enable_load_extension" title="sqlite3.Connection.enable_load_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enable_load_extension()</span></code></a> 来启用扩展加载。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- SQLite 扩展的路径。</p></li>
<li><p><strong>entrypoint</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a><em> | </em><em>None</em>) -- 入口点名称。 如果为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (默认值)，SQLite 将自行生成入口点名称；请参阅 SQLite 文档 <a class="reference external" href="https://www.sqlite.org/loadext.html#loading_an_extension">Loading an Extension</a><span class="link-target"> [https://www.sqlite.org/loadext.html#loading_an_extension]</span> 了解详情。</p></li>
</ul>
</dd>
</dl>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">sqlite3.load_extension</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">connection</span></code>, <code class="docutils literal notranslate"><span class="pre">path</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">sqlite3.load_extension</span></code> 审计事件。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>增加了 <em>entrypoint</em> 形参。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.iterdump">
<span class="sig-name descname"><span class="pre">iterdump</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">iterator</span></a> 用来将数据库转储为 SQL 源代码。 在保存内存数据库以便将来恢复时很有用处。 类似于 <strong class="program">sqlite3</strong> shell 中的 <code class="docutils literal notranslate"><span class="pre">.dump</span></code> 命令。</p>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert file example.db to SQL dump file dump.sql</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;dump.sql&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">iterdump</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#sqlite3-howto-encoding"><span class="std std-ref">如何处理非 UTF-8 文本编码格式</span></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.backup">
<span class="sig-name descname"><span class="pre">backup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'main'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sleep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.250</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建 SQLite 数据库的备份。</p>
<p>即使数据库是通过其他客户端访问或通过同一连接并发访问也是有效的。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><em>Connection</em></a>) -- 用于保存备份的数据库连接。</p></li>
<li><p><strong>pages</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 每次要拷贝的页数。 如果小于等于 <code class="docutils literal notranslate"><span class="pre">0</span></code>，则一次性拷贝整个数据库。 默认为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p></li>
<li><p><strong>progress</strong> (<a class="reference internal" href="../glossary.xhtml#term-callback"><span class="xref std std-term">callback</span></a> | None) -- 如果设为一个 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a>，它将针对每次备份迭代附带三个整数参数被发起调用：上次迭代的状态 <em>status</em>，待拷贝的剩余页数 <em>remaining</em>，以及总页数 <em>total</em>。 默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 要备份的数据库名称。 可能为代表主数据库的 <code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code> (默认值)，代表临时数据库的 <code class="docutils literal notranslate"><span class="pre">&quot;temp&quot;</span></code>，或者使用 <code class="docutils literal notranslate"><span class="pre">ATTACH</span> <span class="pre">DATABASE</span></code> SQL 语句所附加的自定义数据库名称。</p></li>
<li><p><strong>sleep</strong> (<a class="reference internal" href="functions.xhtml#float" title="float"><em>float</em></a>) -- 连续尝试备份剩余页所要间隔的休眠秒数。</p></li>
</ul>
</dd>
</dl>
<p>示例 1，将现有数据库拷贝至另一个数据库:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">progress</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Copied </span><span class="si">{</span><span class="n">total</span><span class="o">-</span><span class="n">remaining</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">total</span><span class="si">}</span><span class="s1"> pages...&#39;</span><span class="p">)</span>

<span class="n">src</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;backup.db&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">dst</span><span class="p">:</span>
    <span class="n">src</span><span class="o">.</span><span class="n">backup</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">pages</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="n">progress</span><span class="p">)</span>
<span class="n">dst</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">src</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>示例 2，将现有数据库拷贝至一个临时副本:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">src</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;:memory:&#39;</span><span class="p">)</span>
<span class="n">src</span><span class="o">.</span><span class="n">backup</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
<span class="n">dst</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">src</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#sqlite3-howto-encoding"><span class="std std-ref">如何处理非 UTF-8 文本编码格式</span></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.getlimit">
<span class="sig-name descname"><span class="pre">getlimit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">category</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>获取一个连接的运行时限制。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>category</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 要查询的 <a class="reference external" href="https://www.sqlite.org/c3ref/c_limit_attached.html">SQLite limit category</a><span class="link-target"> [https://www.sqlite.org/c3ref/c_limit_attached.html]</span>。</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="functions.xhtml#int" title="int">int</a></p>
</dd>
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><strong>ProgrammingError</strong></a> -- 如果 <em>category</em> 不能被下层的 SQLite 库所识别。</p>
</dd>
</dl>
<p>示例，查询 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> <code class="docutils literal notranslate"><span class="pre">con</span></code> 上一条 SQL 语句的最大长度（默认值为 1000000000）:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">getlimit</span><span class="p">(</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">SQLITE_LIMIT_SQL_LENGTH</span><span class="p">)</span>
<span class="go">1000000000</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.setlimit">
<span class="sig-name descname"><span class="pre">setlimit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">category</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>设置连接运行时限制。 如果试图将限制提高到超出强制上界则会静默地截短到强制上界。 无论限制值是否被修改，都将返回之前的限制值。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>category</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 要设置的 <a class="reference external" href="https://www.sqlite.org/c3ref/c_limit_attached.html">SQLite limit category</a><span class="link-target"> [https://www.sqlite.org/c3ref/c_limit_attached.html]</span>。</p></li>
<li><p><strong>limit</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 新的限制值。 如为负值，当前限制将保持不变。</p></li>
</ul>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="functions.xhtml#int" title="int">int</a></p>
</dd>
<dt class="field-odd">抛出<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><strong>ProgrammingError</strong></a> -- 如果 <em>category</em> 不能被下层的 SQLite 库所识别。</p>
</dd>
</dl>
<p>示例，将 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> <code class="docutils literal notranslate"><span class="pre">con</span></code> 上附加的数据库数量限制为 1（默认限制为 10）:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">setlimit</span><span class="p">(</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">SQLITE_LIMIT_ATTACHED</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">getlimit</span><span class="p">(</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">SQLITE_LIMIT_ATTACHED</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.getconfig">
<span class="sig-name descname"><span class="pre">getconfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>查询一个布尔类型的连接配置选项。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>op</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 一个 <a class="reference internal" href="#sqlite3-dbconfig-constants"><span class="std std-ref">SQLITE_DBCONFIG 代码</span></a>。</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="functions.xhtml#bool" title="bool">bool</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.setconfig">
<span class="sig-name descname"><span class="pre">setconfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>设置一个布尔类型的连接配置选项。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 一个 <a class="reference internal" href="#sqlite3-dbconfig-constants"><span class="std std-ref">SQLITE_DBCONFIG 代码</span></a>。</p></li>
<li><p><strong>enable</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 如果该配置选项应当启用则为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (默认值)；如果应当禁用则为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.serialize">
<span class="sig-name descname"><span class="pre">serialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'main'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个数据库序列化为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。 对于普通的磁盘数据库文件，序列化就是磁盘文件的一个副本。 对于内存数据库或“临时”数据库，序列化就是当数据库备份到磁盘时要写入到磁盘的相同字节序列。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 要序列化的数据库名称。 默认为 <code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code>。</p>
</dd>
<dt class="field-even">返回类型<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes">bytes</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此方法仅在下层 SQLite 库具有序列化 API 时可用。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Connection.deserialize">
<span class="sig-name descname"><span class="pre">deserialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'main'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个 <a class="reference internal" href="#sqlite3.Connection.serialize" title="sqlite3.Connection.serialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">已序列化的</span></code></a> 数据库反序列化至 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>。 此方法将导致数据库连接从 <em>name</em> 数据库断开，并基于包含在 <em>data</em> 中的序列化数据将 <em>name</em> 作为内存数据库重新打开。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><em>bytes</em></a>) -- 已序列化的数据库。</p></li>
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 反序列化的目标数据库名称。 默认为 <code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code>。</p></li>
</ul>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><a class="reference internal" href="#sqlite3.OperationalError" title="sqlite3.OperationalError"><strong>OperationalError</strong></a> -- 如果当前数据库连接正在执行读取事务或备份操作。</p></li>
<li><p><a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><strong>DatabaseError</strong></a> -- 如果 <em>data</em> 不包含有效的 SQLite 数据库。</p></li>
<li><p><a class="reference internal" href="exceptions.xhtml#OverflowError" title="OverflowError"><strong>OverflowError</strong></a> -- 如果 <a class="reference internal" href="functions.xhtml#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len(data)</span></code></a> 大于 <code class="docutils literal notranslate"><span class="pre">2**63</span> <span class="pre">-</span> <span class="pre">1</span></code>。</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此方法仅在下层的 SQLite 库具有反序列化 API 时可用。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Connection.autocommit">
<span class="sig-name descname"><span class="pre">autocommit</span></span></dt>
<dd><p>该属性控制符合 <span class="target" id="index-25"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> 的事务行为。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code> 有三个可用的值:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: 选择符合 <span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> 的事务行为，即 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 将保证总是开启一个事务。 使用 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection.rollback" title="sqlite3.Connection.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollback()</span></code></a> 来关闭事务。</p>
<p>这是 <code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code> 推荐的取值。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: 使用 SQLite 的 <a class="reference external" href="https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions">autocommit mode</a><span class="link-target"> [https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions]</span>。 在此模式下 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection.rollback" title="sqlite3.Connection.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollback()</span></code></a> 将没有任何效果。</p></li>
<li><p><a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a>: Python 3.12 之前 (不符合 <span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span>) 的事务控制。 请参阅 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 了解详情。</p>
<p>这是 <code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code> 当前的默认值。</p>
</li>
</ul>
<p>将 <code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code> 更改为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 将开启一个新事务，而将其更改为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 将提交任何待处理事务。</p>
<p>详情参见 <a class="reference internal" href="#sqlite3-transaction-control-autocommit"><span class="std std-ref">通过 autocommit 属性进行事务控制</span></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>除非 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a> 否则 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 属性将不起作用。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Connection.in_transaction">
<span class="sig-name descname"><span class="pre">in_transaction</span></span></dt>
<dd><p>这个只读属性对应于低层级的 SQLite <a class="reference external" href="https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions">autocommit mode</a><span class="link-target"> [https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions]</span>。</p>
<p>如果一个事务处于活动状态（有未提交的更改）则为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Connection.isolation_level">
<span class="sig-name descname"><span class="pre">isolation_level</span></span></dt>
<dd><p>控制 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 的 <a class="reference internal" href="#sqlite3-transaction-control-isolation-level"><span class="std std-ref">旧式事务处理模式</span></a>。 如果设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则绝不会隐式地开启事务。如果设为 <code class="docutils literal notranslate"><span class="pre">&quot;DEFERRED&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;IMMEDIATE&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;EXCLUSIVE&quot;</span></code> 中的一个，对应于下层的 <a class="reference external" href="https://www.sqlite.org/lang_transaction.html#deferred_immediate_and_exclusive_transactions">SQLite transaction behaviour</a><span class="link-target"> [https://www.sqlite.org/lang_transaction.html#deferred_immediate_and_exclusive_transactions]</span>，会执行 <a class="reference internal" href="#sqlite3-transaction-control-isolation-level"><span class="std std-ref">隐式事务管理</span></a>。</p>
<p>如果未被 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 的 <em>isolation_level</em> 形参覆盖，则默认为 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>，这是 <code class="docutils literal notranslate"><span class="pre">&quot;DEFERRED&quot;</span></code> 的一个别名。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>建议使用 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 来控制事务处理而不是使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code>。 除非 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 设为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a> (默认值) 否则 <code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code> 将不起作用。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Connection.row_factory">
<span class="sig-name descname"><span class="pre">row_factory</span></span></dt>
<dd><p>针对从该连接创建的 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象的初始 <a class="reference internal" href="#sqlite3.Cursor.row_factory" title="sqlite3.Cursor.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a>。 为该属性赋值不会影响属于该连接的现有游标的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code>，只影响新的游标。 默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，表示将每一行作为 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 返回。</p>
<p>详情参见 <a class="reference internal" href="#sqlite3-howto-row-factory"><span class="std std-ref">如何创建并使用行工厂对象</span></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Connection.text_factory">
<span class="sig-name descname"><span class="pre">text_factory</span></span></dt>
<dd><p>一个接受 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 形参并返回其文本表示形式的 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a>。 该可调用对象将针对数据类型为 <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> 的 SQLite 值发起调用。 在默认情况下，该属性将被设为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。</p>
<p>请参阅 <a class="reference internal" href="#sqlite3-howto-encoding"><span class="std std-ref">如何处理非 UTF-8 文本编码格式</span></a> 了解详情。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Connection.total_changes">
<span class="sig-name descname"><span class="pre">total_changes</span></span></dt>
<dd><p>返回自打开数据库连接以来已修改、插入或删除的数据库行的总数。</p>
</dd></dl>

</dd></dl>

</section>
<section id="cursor-objects">
<span id="sqlite3-cursor-objects"></span><h3>游标对象</h3>
<blockquote>
<div><p>一个代表被用于执行 SQL 语句，并管理获取操作的上下文的 <a class="reference external" href="https://en.wikipedia.org/wiki/Cursor_(databases)">database cursor</a><span class="link-target"> [https://en.wikipedia.org/wiki/Cursor_(databases)]</span> 的 <code class="docutils literal notranslate"><span class="pre">Cursor</span></code> 对象。 游标对象是使用 <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.cursor()</span></code></a>，或是通过使用任何 <a class="reference internal" href="#sqlite3-connection-shortcuts"><span class="std std-ref">连接快捷方法</span></a> 来创建的。</p>
<p>Cursor 对象属于 <a class="reference internal" href="../glossary.xhtml#term-iterator"><span class="xref std std-term">迭代器</span></a>，这意味着如果你通过 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 来执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 查询，你可以简单地迭代游标来获取结果行:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT t FROM data&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="sqlite3.Cursor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">Cursor</span></span></dt>
<dd><p><a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 游标实例具有以下属性和方法。</p>
<dl class="py method" id="index-7">
<span id="index-6"></span><dt class="sig sig-object py" id="sqlite3.Cursor.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sql</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>执行一条 SQL 语句，可以选择使用 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">占位符</span></a> 来绑定 Python 值。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sql</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 一条 SQL 语句。</p></li>
<li><p><strong>parameters</strong> (<a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> | <a class="reference internal" href="../glossary.xhtml#term-sequence"><span class="xref std std-term">sequence</span></a>) -- 要绑定到 <em>sql</em> 中占位符的 Python 值。 如果使用命名占位符则会使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>。 如果使用非命名占位符则会使用 <span class="xref std std-term">sequence</span>。 参见 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">如何在 SQL 查询中使用占位符来绑定值</span></a>。</p></li>
</ul>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><strong>ProgrammingError</strong></a> -- 如果 <em>sql</em> 包含多条 SQL 语句。</p>
</dd>
</dl>
<p>如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a>，<a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，<em>sql</em> 为一条 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>, <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code>, <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> 或 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 语句，并且没有开启事务，则会在执行 <em>sql</em> 之前隐式地开启事务。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.12 版起不建议使用，将在 3.14 版中移除: </span>如果使用了 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">命名占位符</span></a> 并且 <em>parameters</em> 是一个序列而非 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 则会发出 <a class="reference internal" href="exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。 从 Python 3.14 起，将改为引发 <a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProgrammingError</span></code></a>。</p>
</div>
<p>使用 <a class="reference internal" href="#sqlite3.Cursor.executescript" title="sqlite3.Cursor.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a> 来执行多条 SQL 语句。statements.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.executemany">
<span class="sig-name descname"><span class="pre">executemany</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sql</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>对于 <em>parameters</em> 中的每一项，重复执行 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">参数化的</span></a> <abbr title="Data Manipulation Language">DML</abbr> SQL 语句 <em>sql</em>。</p>
<p>使用与 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 相同的隐式事务处理。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sql</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 一条 SQL DML 语句。</p></li>
<li><p><strong>parameters</strong> (<a class="reference internal" href="../glossary.xhtml#term-iterable"><span class="xref std std-term">iterable</span></a>) -- 一个用来绑定到 <em>sql</em> 中的占位符的形参的 <span class="xref std std-term">iterable</span>。 参见 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">如何在 SQL 查询中使用占位符来绑定值</span></a>。</p></li>
</ul>
</dd>
<dt class="field-even">抛出<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><strong>ProgrammingError</strong></a> -- 如果 <em>sql</em> 包含多条 SQL 语句，或者不属于 DML 语句。</p>
</dd>
</dl>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;row1&quot;</span><span class="p">,),</span>
    <span class="p">(</span><span class="s2">&quot;row2&quot;</span><span class="p">,),</span>
<span class="p">]</span>
<span class="c1"># cur is an sqlite3.Cursor object</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO data VALUES(?)&quot;</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>任何结果行都将被丢弃，包括带有 <a class="reference external" href="https://www.sqlite.org/lang_returning.html">RETURNING 子句</a><span class="link-target"> [https://www.sqlite.org/lang_returning.html]</span> 的 DML 语句。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">从 3.12 版起不建议使用，将在 3.14 版中移除: </span>如果使用了 <a class="reference internal" href="#sqlite3-placeholders"><span class="std std-ref">命名占位符</span></a> 并且 <em>parameters</em> 中的每个条目都是序列而非 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 则会发出 <a class="reference internal" href="exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。 从 Python 3.14 起，将改为引发 <a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProgrammingError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.executescript">
<span class="sig-name descname"><span class="pre">executescript</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sql_script</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>执行 <em>sql_script</em> 中的 SQL 语句。 如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a> 并且存在待处理的事务，则首先隐式执行一条 <code class="docutils literal notranslate"><span class="pre">COMMIT</span></code> 语句。 不会执行其他隐式事务控制；任何事务控制都必须添加至 <em>sql_script</em>。</p>
<p><em>sql_script</em> 必须为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">字符串</span></code></a>。</p>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># cur is an sqlite3.Cursor object</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    BEGIN;</span>
<span class="s2">    CREATE TABLE person(firstname, lastname, age);</span>
<span class="s2">    CREATE TABLE book(title, author, published);</span>
<span class="s2">    CREATE TABLE publisher(name, address);</span>
<span class="s2">    COMMIT;</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.fetchone">
<span class="sig-name descname"><span class="pre">fetchone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>如果 <a class="reference internal" href="#sqlite3.Cursor.row_factory" title="sqlite3.Cursor.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则将下一行查询结果集作为 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 返回。 否则，将其传给指定的行工厂函数并返回函数结果。 如果没有更多可用数据则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.fetchmany">
<span class="sig-name descname"><span class="pre">fetchmany</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cursor.arraysize</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将下一个多行查询结果集作为 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 返回。 如果没有更多可用行时则返回一个空列表。</p>
<p>每次调用要获取的行数是由 <em>size</em> 形参指定的。 如果未指定 <em>size</em>，则由 <a class="reference internal" href="#sqlite3.Cursor.arraysize" title="sqlite3.Cursor.arraysize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">arraysize</span></code></a> 确定要获取的行数。 如果可用的行少于 <em>size</em>，则返回可用的行数。</p>
<p>请注意 <em>size</em> 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 <em>size</em> 形参，则最好在从一个 <a class="reference internal" href="#sqlite3.Cursor.fetchmany" title="sqlite3.Cursor.fetchmany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchmany()</span></code></a> 调用到下一个调用之间保持相同的值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.fetchall">
<span class="sig-name descname"><span class="pre">fetchall</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>将全部（剩余的）查询结果行作为 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 返回。 如果没有可用的行则返回空列表。 请注意 <a class="reference internal" href="#sqlite3.Cursor.arraysize" title="sqlite3.Cursor.arraysize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">arraysize</span></code></a> 属性可能会影响此操作的性能。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>立即关闭 cursor（而不是在当 <code class="docutils literal notranslate"><span class="pre">__del__</span></code> 被调用的时候）。</p>
<p>从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 <a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProgrammingError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.setinputsizes">
<span class="sig-name descname"><span class="pre">setinputsizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>DB-API 要求的方法。 在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 不做任何事情。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Cursor.setoutputsize">
<span class="sig-name descname"><span class="pre">setoutputsize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>DB-API 要求的方法。 在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 不做任何事情。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Cursor.arraysize">
<span class="sig-name descname"><span class="pre">arraysize</span></span></dt>
<dd><p>用于控制 <a class="reference internal" href="#sqlite3.Cursor.fetchmany" title="sqlite3.Cursor.fetchmany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchmany()</span></code></a> 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Cursor.connection">
<span class="sig-name descname"><span class="pre">connection</span></span></dt>
<dd><p>提供属于该游标的 SQLite <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 的只读属性。 通过调用 <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">con.cursor()</span></code></a> 创建的 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象将具有一个指向 <em>con</em> 的 <a class="reference internal" href="#sqlite3.Cursor.connection" title="sqlite3.Cursor.connection"><code class="xref py py-attr docutils literal notranslate"><span class="pre">connection</span></code></a> 属性:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur</span><span class="o">.</span><span class="n">connection</span> <span class="o">==</span> <span class="n">con</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Cursor.description">
<span class="sig-name descname"><span class="pre">description</span></span></dt>
<dd><p>提供上一次查询的列名称的只读属性。 为了与 Python DB API 保持兼容，它会为每个列返回一个 7 元组，每个元组的最后六个条目均为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>对于没有任何匹配行的 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 语句同样会设置该属性。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Cursor.lastrowid">
<span class="sig-name descname"><span class="pre">lastrowid</span></span></dt>
<dd><p>提供上一次插入的行的行 ID 的只读属性。 它只会在使用 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 方法的 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 或 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 语句成功后被更新。 对于其他语句，则在 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a> 或 <a class="reference internal" href="#sqlite3.Cursor.executescript" title="sqlite3.Cursor.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a>，或者如果插入失败，<code class="docutils literal notranslate"><span class="pre">lastrowid</span></code> 的值将保持不变。 <code class="docutils literal notranslate"><span class="pre">lastrowid</span></code> 的初始值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对 <code class="docutils literal notranslate"><span class="pre">WITHOUT</span> <span class="pre">ROWID</span></code> 表的插入不被记录。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 语句的支持。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Cursor.rowcount">
<span class="sig-name descname"><span class="pre">rowcount</span></span></dt>
<dd><p>提供 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>, <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code>, <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> 和 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 语句所修改行数的只读属性；对于其他语句则为 <code class="docutils literal notranslate"><span class="pre">-1</span></code>，包括 <abbr title="Common Table Expression">CTE</abbr> 查询。 只有 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a> 方法会在语句运行完成后更新此属性。 这意味着任何结果行都必须按顺序被提取以使 <code class="xref py py-attr docutils literal notranslate"><span class="pre">rowcount</span></code> 获得更新。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Cursor.row_factory">
<span class="sig-name descname"><span class="pre">row_factory</span></span></dt>
<dd><p>控制从该 <code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code> 获取的行的表示形式。 如为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，一行将表示为一个 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>。可设置形式包括 <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Row</span></code></a>；或者接受两个参数的 <a class="reference internal" href="../glossary.xhtml#term-callable"><span class="xref std std-term">callable</span></a>，一个 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象和由行内所有值组成的 <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>，以及返回代表一个 SQLite 行的自定义对象。</p>
<p>默认为当 <code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code> 被创建时设置的 <a class="reference internal" href="#sqlite3.Connection.row_factory" title="sqlite3.Connection.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.row_factory</span></code></a>。 对该属性赋值不会影响父连接的 <a class="reference internal" href="#sqlite3.Connection.row_factory" title="sqlite3.Connection.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.row_factory</span></code></a>。</p>
<p>详情参见 <a class="reference internal" href="#sqlite3-howto-row-factory"><span class="std std-ref">如何创建并使用行工厂对象</span></a>。</p>
</dd></dl>

</dd></dl>

</section>
<section id="row-objects">
<span id="sqlite3-row-objects"></span><span id="sqlite3-columns-by-name"></span><h3>Row 对象</h3>
<dl class="py class">
<dt class="sig sig-object py" id="sqlite3.Row">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">Row</span></span></dt>
<dd><p>一个被用作 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象的高度优化的 <a class="reference internal" href="#sqlite3.Connection.row_factory" title="sqlite3.Connection.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a> 的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 实例。 它支持迭代、相等性检测、<a class="reference internal" href="functions.xhtml#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 以及基于列名称的 <a class="reference internal" href="../glossary.xhtml#term-mapping"><span class="xref std std-term">mapping</span></a> 访问和数字序列。</p>
<p>两个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 对象如果具有相同的列名称和值则比较结果相等。</p>
<p>详情参见 <a class="reference internal" href="#sqlite3-howto-row-factory"><span class="std std-ref">如何创建并使用行工厂对象</span></a>。</p>
<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Row.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>在一次查询之后，立即将由列名称组成的 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 作为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">字符串</span></code></a> 返回，它是 <a class="reference internal" href="#sqlite3.Cursor.description" title="sqlite3.Cursor.description"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Cursor.description</span></code></a> 中每个元组的第一个成员。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>添加了对切片操作的支持。</p>
</div>
</dd></dl>

</section>
<section id="blob-objects">
<span id="sqlite3-blob-objects"></span><h3>Blob 对象</h3>
<dl class="py class">
<dt class="sig sig-object py" id="sqlite3.Blob">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">Blob</span></span></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<p><a class="reference internal" href="#sqlite3.Blob" title="sqlite3.Blob"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blob</span></code></a> 实例是可以读写 SQLite <abbr title="Binary Large OBject">BLOB</abbr> 数据的 <a class="reference internal" href="../glossary.xhtml#term-file-like-object"><span class="xref std std-term">file-like object</span></a>。 调用 <a class="reference internal" href="functions.xhtml#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len(blob)</span></code></a> 可得到 blob 的大小（字节数）。 请使用索引和 <a class="reference internal" href="../glossary.xhtml#term-slice"><span class="xref std std-term">切片</span></a> 来直接访问 blob 数据。</p>
<p>将 <a class="reference internal" href="#sqlite3.Blob" title="sqlite3.Blob"><code class="xref py py-class docutils literal notranslate"><span class="pre">Blob</span></code></a> 作为 <a class="reference internal" href="../glossary.xhtml#term-context-manager"><span class="xref std std-term">context manager</span></a> 使用以确保使用结束后 blob 句柄自动关闭。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE test(blob_col blob)&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test(blob_col) VALUES(zeroblob(13))&quot;</span><span class="p">)</span>

<span class="c1"># Write to our blob, using two write operations:</span>
<span class="k">with</span> <span class="n">con</span><span class="o">.</span><span class="n">blobopen</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;blob_col&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">blob</span><span class="p">:</span>
    <span class="n">blob</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;hello, &quot;</span><span class="p">)</span>
    <span class="n">blob</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;world.&quot;</span><span class="p">)</span>
    <span class="c1"># Modify the first and last bytes of our blob</span>
    <span class="n">blob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>
    <span class="n">blob</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">)</span>

<span class="c1"># Read the contents of our blob</span>
<span class="k">with</span> <span class="n">con</span><span class="o">.</span><span class="n">blobopen</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;blob_col&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">blob</span><span class="p">:</span>
    <span class="n">greeting</span> <span class="o">=</span> <span class="n">blob</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>  <span class="c1"># outputs &quot;b&#39;Hello, world!&#39;&quot;</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Blob.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>关闭 blob。</p>
<p>从这一时刻起该 blob 将不再可用。 如果再尝试用该 blob 执行任何操作将引发 <a class="reference internal" href="#sqlite3.Error" title="sqlite3.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">Error</span></code></a> (或其子类) 异常。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Blob.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从 blob 的当前偏移位置读取 <em>length</em> 个字节的数据。 如果到达了 blob 的末尾，则将返回 <abbr title="End of File">EOF</abbr> 之前的数据。 当未指定 <em>length</em>，或指定负值时，<a class="reference internal" href="#sqlite3.Blob.read" title="sqlite3.Blob.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 将读取至 blob 的末尾。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Blob.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在 blob 的当前偏移位置上写入 <em>data</em>。 此函数不能改变 blob 的长度。 写入数据超出 blob 的末尾将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Blob.tell">
<span class="sig-name descname"><span class="pre">tell</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回 blob 的当前访问位置。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sqlite3.Blob.seek">
<span class="sig-name descname"><span class="pre">seek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">os.SEEK_SET</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 Blob 的当前访问位置设为 <em>offset</em>。 <em>origin</em> 参数默认为 <a class="reference internal" href="os.xhtml#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.SEEK_SET</span></code></a> (blob 的绝对位置)。 <em>origin</em> 的其他值包括 <a class="reference internal" href="os.xhtml#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.SEEK_CUR</span></code></a> （相对于当前位置寻址) 和 <a class="reference internal" href="os.xhtml#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.SEEK_END</span></code></a> (相对于 blob 末尾寻址)。</p>
</dd></dl>

</dd></dl>

</section>
<section id="prepareprotocol-objects">
<h3>PrepareProtocol 对象</h3>
<dl class="py class">
<dt class="sig sig-object py" id="sqlite3.PrepareProtocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">PrepareProtocol</span></span></dt>
<dd><p>PrepareProtocol 类型的唯一目的是作为 <span class="target" id="index-28"></span><a class="pep reference external" href="https://peps.python.org/pep-0246/"><strong>PEP 246</strong></a><span class="link-target"> [https://peps.python.org/pep-0246/]</span> 风格的适配协议让对象能够 <a class="reference internal" href="#sqlite3-conform"><span class="std std-ref">将自身适配</span></a> 为 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">原生 SQLite 类型</span></a>。</p>
</dd></dl>

</section>
<section id="exceptions">
<span id="sqlite3-exceptions"></span><h3>异常</h3>
<p>异常层次是由 DB-API 2.0 (<span class="target" id="index-29"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span>) 定义的。</p>
<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.Warning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">Warning</span></span></dt>
<dd><p>目前此异常不会被 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块引发，但可能会被使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 的应用程序引发，例如当一个用户自定义的函数在插入操作中截断了数据时。 <code class="docutils literal notranslate"><span class="pre">Warning</span></code> 是 <a class="reference internal" href="exceptions.xhtml#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.Error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">Error</span></span></dt>
<dd><p>本模块中其他异常的基类。使用它来捕捉所有的错误，只需一条 <a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 语句。 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 是 <a class="reference internal" href="exceptions.xhtml#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 的子类。</p>
<p>如果异常是产生于 SQLite 库的内部，则以下两个属性将被添加到该异常:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Error.sqlite_errorcode">
<span class="sig-name descname"><span class="pre">sqlite_errorcode</span></span></dt>
<dd><p>来自 <a class="reference external" href="https://sqlite.org/rescode.html">SQLite API</a><span class="link-target"> [https://sqlite.org/rescode.html]</span> 的数字错误代码</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sqlite3.Error.sqlite_errorname">
<span class="sig-name descname"><span class="pre">sqlite_errorname</span></span></dt>
<dd><p>来自 <a class="reference external" href="https://sqlite.org/rescode.html">SQLite API</a><span class="link-target"> [https://sqlite.org/rescode.html]</span> 的数字错误代码符号名称</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.InterfaceError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">InterfaceError</span></span></dt>
<dd><p>因错误使用低层级 SQLite C API 而引发的异常，换句话说，如果此异常被引发，则可能表明 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块中存在错误。 <code class="docutils literal notranslate"><span class="pre">InterfaceError</span></code> 是 <a class="reference internal" href="#sqlite3.Error" title="sqlite3.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.DatabaseError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">DatabaseError</span></span></dt>
<dd><p>对与数据库有关的错误引发的异常。它作为几种数据库错误的基础异常。它只通过专门的子类隐式引发。 <code class="docutils literal notranslate"><span class="pre">DatabaseError</span></code> 是 <a class="reference internal" href="#sqlite3.Error" title="sqlite3.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.DataError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">DataError</span></span></dt>
<dd><p>由于处理的数据有问题而产生的异常，比如数字值超出范围，字符串太长。 <code class="docutils literal notranslate"><span class="pre">DataError</span></code> 是 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 的子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.OperationalError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">OperationalError</span></span></dt>
<dd><p>与数据库操作有关的错误而引发的异常，不一定在程序员的控制之下。例如，数据库路径没有找到，或者一个事务无法被处理。 <code class="docutils literal notranslate"><span class="pre">OperationalError</span></code> 是 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 的子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.IntegrityError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">IntegrityError</span></span></dt>
<dd><p>当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 的子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.InternalError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">InternalError</span></span></dt>
<dd><p>当 SQLite 遇到一个内部错误时引发的异常。如果它被引发，可能表明运行中的 SQLite 库有问题。  <code class="docutils literal notranslate"><span class="pre">InternalError</span></code> 是 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 的子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.ProgrammingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">ProgrammingError</span></span></dt>
<dd><p>针对 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> API 编程错误引发的异常，例如向查询提供错误数量的绑定，或试图在已关闭的 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 上执行操作。 <code class="docutils literal notranslate"><span class="pre">ProgrammingError</span></code> 是 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 的一个子类。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="sqlite3.NotSupportedError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sqlite3.</span></span><span class="sig-name descname"><span class="pre">NotSupportedError</span></span></dt>
<dd><p>在下层的 SQLite 库不支持某个方法或数据库 API 的情况下引发的异常。 例如，在 <a class="reference internal" href="#sqlite3.Connection.create_function" title="sqlite3.Connection.create_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_function()</span></code></a> 中把 <em>deterministic</em> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，而下层的 SQLite 库不支持确定性函数的时候。 <code class="docutils literal notranslate"><span class="pre">NotSupportedError</span></code> 是 <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> 的一个子类。</p>
</dd></dl>

</section>
<section id="sqlite-and-python-types">
<span id="sqlite3-types"></span><h3>SQLite 与 Python 类型</h3>
<p>SQLite 原生支持如下的类型： <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，<code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>，<code class="docutils literal notranslate"><span class="pre">REAL</span></code>，<code class="docutils literal notranslate"><span class="pre">TEXT</span></code>，<code class="docutils literal notranslate"><span class="pre">BLOB</span></code>。</p>
<p>因此可以将以下Python类型发送到SQLite而不会出现任何问题：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Python 类型</p></th>
<th class="head"><p>SQLite 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXT</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BLOB</span></code></p></td>
</tr>
</tbody>
</table>
<p>这是SQLite类型默认转换为Python类型的方式：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SQLite 类型</p></th>
<th class="head"><p>Python 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p></td>
<td><p><a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REAL</span></code></p></td>
<td><p><a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TEXT</span></code></p></td>
<td><p>取决于 <a class="reference internal" href="#sqlite3.Connection.text_factory" title="sqlite3.Connection.text_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">text_factory</span></code></a> , 默认为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">BLOB</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></p></td>
</tr>
</tbody>
</table>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块的类型系统可通过两种方式来扩展：你可以通过 <a class="reference internal" href="#sqlite3-adapters"><span class="std std-ref">对象适配器</span></a> 将额外的 Python 类型保存在 SQLite 数据库中，你也可以让 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块通过 <a class="reference internal" href="#sqlite3-converters"><span class="std std-ref">转换器</span></a> 将 SQLite 类型转换为不同的 Python 类型。types via.</p>
</section>
<section id="default-adapters-and-converters-deprecated">
<span id="sqlite3-default-converters"></span><h3>默认适配器和转换器（已弃用）</h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>自 Python 3.12 起，默认适配器和转换器已被弃用。取而代之的是使用 <a class="reference internal" href="#sqlite3-adapter-converter-recipes"><span class="std std-ref">适配器和转换器范例程序</span></a> ，并根据您的需要定制它们。</p>
</div>
<p>弃用的默认适配器和转换器包括：</p>
<ul class="simple">
<li><p>将 <a class="reference internal" href="datetime.xhtml#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 对象转换为 <a class="reference external" href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a><span class="link-target"> [https://en.wikipedia.org/wiki/ISO_8601]</span> 格式 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">字符串</span></code></a> 的适配器。</p></li>
<li><p>将 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 对象转换为 ISO 8601 格式字符串的适配器。</p></li>
<li><p>从 <a class="reference internal" href="#sqlite3-converters"><span class="std std-ref">已声明的</span></a> &quot;date&quot; 类型到 <a class="reference internal" href="datetime.xhtml#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 对象的转换器。</p></li>
<li><p>将已声明的 &quot;timestamp&quot; 类型转成 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 对象的转换器。 小数部分将截断至 6 位（微秒精度）。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>默认的 &quot;时间戳&quot; 转换器忽略了数据库中的 UTC 偏移，总是返回一个原生的 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 对象。要在时间戳中保留 UTC 偏移，可以不使用转换器，或者用 <a class="reference internal" href="#sqlite3.register_converter" title="sqlite3.register_converter"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_converter()</span></code></a> 注册一个偏移感知的转换器。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用.</span></p>
</div>
</section>
<section id="command-line-interface">
<span id="sqlite3-cli"></span><h3>命令行接口</h3>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块可以作为脚本发起调用，使用解释器的 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 开关选项，以提供一个简单的 SQLite shell。 参数签名如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">sqlite3</span> <span class="p">[</span><span class="o">-</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">]</span> <span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="p">[</span><span class="n">sql</span><span class="p">]</span>
</pre></div>
</div>
<p>输入 <code class="docutils literal notranslate"><span class="pre">.quit</span></code> 或 CTRL-D 退出 shell。</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-python-m-sqlite3-h-v-filename-sql-h">
<span id="cmdoption-python-m-sqlite3-h-v-filename-sql-help"></span><span class="sig-name descname"><span class="pre">-h</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--help</span></span><span class="sig-prename descclassname"></span></dt>
<dd><p>打印 CLI 帮助。</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-python-m-sqlite3-h-v-filename-sql-v">
<span id="cmdoption-python-m-sqlite3-h-v-filename-sql-version"></span><span class="sig-name descname"><span class="pre">-v</span></span><span class="sig-prename descclassname"></span><span class="sig-prename descclassname"><span class="pre">,</span> </span><span class="sig-name descname"><span class="pre">--version</span></span><span class="sig-prename descclassname"></span></dt>
<dd><p>打印下层 SQLite 库版本。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</section>
</section>
<section id="how-to-guides">
<span id="sqlite3-howtos"></span><h2>常用方案指引</h2>
<section id="how-to-use-placeholders-to-bind-values-in-sql-queries">
<span id="sqlite3-placeholders"></span><h3>如何在 SQL 查询中使用占位符来绑定值</h3>
<p>SQL 操作通常会需要使用来自 Python 变量的值。 不过，请谨慎使用 Python 的字符串操作来拼装查询，因为这样易受 <a class="reference external" href="https://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a><span class="link-target"> [https://en.wikipedia.org/wiki/SQL_injection]</span>。 例如，攻击者可以简单地添加结束单引号并注入 <code class="docutils literal notranslate"><span class="pre">OR</span> <span class="pre">TRUE</span></code> 来选择所有的行:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Never do this -- insecure!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symbol</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="go">&#39; OR TRUE; --</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM stocks WHERE symbol = &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
<span class="go">SELECT * FROM stocks WHERE symbol = &#39;&#39; OR TRUE; --&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
</pre></div>
</div>
<p>请改用 DB-API 的形参替换。 要将变量插入到查询字符串中，可在字符串中使用占位符，并通过将实际值作为游标的 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 方法的第二个参数以由多个值组成的 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 形式提供给查询来替换它们。</p>
<p>SQL 语句可以使用两种占位符之一：问号占位符（问号风格）或命名占位符（命名风格）。 对于问号风格，<em>parameters</em> 要是一个长度必须与占位符的数量相匹配的 <a class="reference internal" href="../glossary.xhtml#term-sequence"><span class="xref std std-term">sequence</span></a>，否则将引发 <a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProgrammingError</span></code></a>。 对于命名风格，<em>parameters</em> 必须是 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> （或其子类）的实例，它必须包含与所有命名参数相对应的键；任何额外的条目都将被忽略。 下面是一个同时使用这两种风格的示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE lang(name, first_appeared)&quot;</span><span class="p">)</span>

<span class="c1"># This is the named style used with executemany():</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">1972</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Fortran&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">1957</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">1991</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Go&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">2009</span><span class="p">},</span>
<span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO lang VALUES(:name, :year)&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># This is the qmark style used in a SELECT query:</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1972</span><span class="p">,)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM lang WHERE first_appeared = ?&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><span class="target" id="index-30"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> 数字占位符已经 <em>不再</em> 被支持。 如果使用，它们将被解读为命名占位符。</p>
</div>
</section>
<section id="how-to-adapt-custom-python-types-to-sqlite-values">
<span id="sqlite3-adapters"></span><h3>如何将自定义 Python 类型适配到 SQLite 值</h3>
<p>SQLite 仅支持一个原生数据类型的有限集。 要在 SQLite 数据库中存储自定义 Python 类型，请将它们 <em>适配</em> 到 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">SQLite 原生可识别的 Python 类型</span></a> 之一。</p>
<p>有两种方式可将 Python 对象适配到 SQLite 类型：让你的对象自行适配，或是使用 <em>适配器可调用对象</em>。 后者将优先于前者发挥作用。 对于导出自定义类型的库，启用该类型的自行适配可能更为合理。 而作为一名应用程序开发者，通过注册自定义适配器函数进行直接控制可能更为合理。</p>
<section id="how-to-write-adaptable-objects">
<span id="sqlite3-conform"></span><h4>如何编写可适配对象</h4>
<p>假设我们有一个代表笛卡尔坐标系中的坐标值对 <code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code>，<code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 的类，该坐标值在数据库中将存储为一个文本字符串。 这可以通过添加一个返回已适配值的 <code class="docutils literal notranslate"><span class="pre">__conform__(self,</span> <span class="pre">protocol)</span></code> 方法来实现。 传给 <em>protocol</em> 的对象将为 <a class="reference internal" href="#sqlite3.PrepareProtocol" title="sqlite3.PrepareProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrepareProtocol</span></code></a> 类型。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__conform__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">PrepareProtocol</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2</span><span class="p">),))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="how-to-register-adapter-callables">
<h4>如何注册适配器可调用对象</h4>
<p>另一种可能的方式是创建一个将 Python 对象转换为 SQLite 兼容类型的函数。 随后可使用 <a class="reference internal" href="#sqlite3.register_adapter" title="sqlite3.register_adapter"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_adapter()</span></code></a> 来注册该函数。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">adapt_point</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">adapt_point</span><span class="p">)</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">),))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="how-to-convert-sqlite-values-to-custom-python-types">
<span id="sqlite3-converters"></span><h3>如何将 SQLite 值转换为自定义 Python 类型</h3>
<p>编写适配器使你可以将 <em>from</em> 自定义 Python 类型转换为 <em>to</em> SQLite 值。 为了能将 <em>from</em> SQLite 值转换为 <em>to</em> 自定义 Python 类型，我们可使用 <em>converters</em>。</p>
<p>让我们回到 <code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code> 类。 我们以以分号分隔的字符串形式在 SQLite 中存储了 x 和 y 坐标值。</p>
<p>首先，我们将定义一个转换器函数，它接受这样的字符串作为形参并根据该参数构造一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code> 对象。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>转换器函数 <strong>总是</strong> 接受传入一个 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象，无论下层的 SQLite 数据类型是什么。</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convert_point</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>我们现在需要告诉 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 何时应当转换一个给定的 SQLite 值。 这是在连接到一个数据库时完成的，使用 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 的 <em>detect_types</em> 形参。 有三个选项:</p>
<ul class="simple">
<li><p>隐式: 将 <em>detect_types</em> 设为 <a class="reference internal" href="#sqlite3.PARSE_DECLTYPES" title="sqlite3.PARSE_DECLTYPES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_DECLTYPES</span></code></a></p></li>
<li><p>显式: 将 <em>detect_types</em> 设为 <a class="reference internal" href="#sqlite3.PARSE_COLNAMES" title="sqlite3.PARSE_COLNAMES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_COLNAMES</span></code></a></p></li>
<li><p>同时: 将 <em>detect_types</em> 设为 <code class="docutils literal notranslate"><span class="pre">sqlite3.PARSE_DECLTYPES</span> <span class="pre">|</span> <span class="pre">sqlite3.PARSE_COLNAMES</span></code>。 列名的优先级高于声明的类型。</p></li>
</ul>
<p>下面的示例演示了隐式和显式的方法:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Point(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="k">def</span> <span class="nf">adapt_point</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">convert_point</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Register the adapter and converter</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">adapt_point</span><span class="p">)</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_converter</span><span class="p">(</span><span class="s2">&quot;point&quot;</span><span class="p">,</span> <span class="n">convert_point</span><span class="p">)</span>

<span class="c1"># 1) Parse using declared types</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">,</span> <span class="n">detect_types</span><span class="o">=</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_DECLTYPES</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE test(p point)&quot;</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test(p) VALUES(?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,))</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT p FROM test&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with declared types:&quot;</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># 2) Parse using column names</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">,</span> <span class="n">detect_types</span><span class="o">=</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_COLNAMES</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE test(p)&quot;</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO test(p) VALUES(?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,))</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT p AS &quot;p [point]&quot; FROM test&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with column names:&quot;</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="adapter-and-converter-recipes">
<span id="sqlite3-adapter-converter-recipes"></span><h3>适配器和转换器范例程序</h3>
<p>本小节显示了通用适配器和转换器的范例程序。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">def</span> <span class="nf">adapt_date_iso</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adapt datetime.date to ISO 8601 date.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">adapt_datetime_iso</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adapt datetime.datetime to timezone-naive ISO 8601 date.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">adapt_datetime_epoch</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adapt datetime.datetime to Unix timestamp.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">timestamp</span><span class="p">())</span>

<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">adapt_date_iso</span><span class="p">)</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">adapt_datetime_iso</span><span class="p">)</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">adapt_datetime_epoch</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convert_date</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert ISO 8601 date to datetime.date object.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">convert_datetime</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert ISO 8601 datetime to datetime.datetime object.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">convert_timestamp</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert Unix epoch timestamp to datetime.datetime object.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_converter</span><span class="p">(</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="n">convert_date</span><span class="p">)</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_converter</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="n">convert_datetime</span><span class="p">)</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_converter</span><span class="p">(</span><span class="s2">&quot;timestamp&quot;</span><span class="p">,</span> <span class="n">convert_timestamp</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="how-to-use-connection-shortcut-methods">
<span id="sqlite3-connection-shortcuts"></span><h3>如何使用连接快捷方法</h3>
<p>通过使用 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 类的 <a class="reference internal" href="#sqlite3.Connection.execute" title="sqlite3.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>, <a class="reference internal" href="#sqlite3.Connection.executemany" title="sqlite3.Connection.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a> 与 <a class="reference internal" href="#sqlite3.Connection.executescript" title="sqlite3.Connection.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a> 方法，您可以简化您的代码，因为无需再显式创建 （通常是多余的） <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象。此时 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 对象会被隐式创建并且由这些快捷方法返回。这样一来，您仅需在 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象上调用一次方法就可以执行 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 语句，并对其进行迭代。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create and fill the table.</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE lang(name, first_appeared)&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;C++&quot;</span><span class="p">,</span> <span class="mi">1985</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Objective-C&quot;</span><span class="p">,</span> <span class="mi">1984</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">con</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;INSERT INTO lang(name, first_appeared) VALUES(?, ?)&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Print the table contents</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT name, first_appeared FROM lang&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I just deleted&quot;</span><span class="p">,</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;DELETE FROM lang&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rowcount</span><span class="p">,</span> <span class="s2">&quot;rows&quot;</span><span class="p">)</span>

<span class="c1"># close() is not a shortcut method and it&#39;s not called automatically;</span>
<span class="c1"># the connection object should be closed manually</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="how-to-use-the-connection-context-manager">
<span id="sqlite3-connection-context-manager"></span><h3>如何使用连接上下文管理器</h3>
<p><a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象可被用作上下文管理器以便在离开上下文管理器代码块时自动提交或回滚开启的事务。 如果 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句体无异常地结束，事务将被提交。 如果提交失败，或者如果 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句体引发了未捕获的异常，则事务将被回滚。 如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则会在提交或回滚后隐式地开启一个新事务。</p>
<p>如果在离开 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句体时没有开启的事务，或者如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则上下文管理器将不做任何操作。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>上下文管理器既不会隐式开启新事务也不会关闭连接。 如果你需要关闭上下文管理器，请考虑使用 <a class="reference internal" href="contextlib.xhtml#contextlib.closing" title="contextlib.closing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contextlib.closing()</span></code></a>。</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR UNIQUE)&quot;</span><span class="p">)</span>

<span class="c1"># Successful, con.commit() is called automatically afterwards</span>
<span class="k">with</span> <span class="n">con</span><span class="p">:</span>
    <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO lang(name) VALUES(?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Python&quot;</span><span class="p">,))</span>

<span class="c1"># con.rollback() is called after the with block finishes with an exception,</span>
<span class="c1"># the exception is still raised and must be caught</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">con</span><span class="p">:</span>
        <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO lang(name) VALUES(?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Python&quot;</span><span class="p">,))</span>
<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;couldn&#39;t add Python twice&quot;</span><span class="p">)</span>

<span class="c1"># Connection object used as context manager only commits or rollbacks transactions,</span>
<span class="c1"># so the connection object should be closed manually</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="how-to-work-with-sqlite-uris">
<span id="sqlite3-uri-tricks"></span><h3>如何使用 SQLite URI</h3>
<p>一些有用的 URI 技巧包括:</p>
<ul class="simple">
<li><p>以只读模式打开一个数据库:</p></li>
</ul>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;file:tutorial.db?mode=ro&quot;</span><span class="p">,</span> <span class="n">uri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE readonly(data)&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">OperationalError</span>: <span class="n">attempt to write a readonly database</span>
</pre></div>
</div>
<ul class="simple">
<li><p>如果一个数据库尚不存在则不会隐式地新建数据库；如果无法新建数据库则将引发 <a class="reference internal" href="#sqlite3.OperationalError" title="sqlite3.OperationalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OperationalError</span></code></a>:</p></li>
</ul>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;file:nosuchdb.db?mode=rw&quot;</span><span class="p">,</span> <span class="n">uri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">OperationalError</span>: <span class="n">unable to open database file</span>
</pre></div>
</div>
<ul class="simple">
<li><p>创建一个名为 shared 的内存数据库:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">db</span> <span class="o">=</span> <span class="s2">&quot;file:mem1?mode=memory&amp;cache=shared&quot;</span>
<span class="n">con1</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">uri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">con2</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">uri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">con1</span><span class="p">:</span>
    <span class="n">con1</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE shared(data)&quot;</span><span class="p">)</span>
    <span class="n">con1</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO shared VALUES(28)&quot;</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">con2</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT data FROM shared&quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">res</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">28</span><span class="p">,)</span>

<span class="n">con1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">con2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>关于此特性的更多信息，包括可用的形参列表，可以在 <a class="reference external" href="https://www.sqlite.org/uri.html">SQLite URI documentation</a><span class="link-target"> [https://www.sqlite.org/uri.html]</span> 中找到。</p>
</section>
<section id="how-to-create-and-use-row-factories">
<span id="sqlite3-howto-row-factory"></span><h3>如何创建并使用行工厂对象</h3>
<p>在默认情况下，<code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 会以 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 来表示每一行。 如果 <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> 不适合你的需求，你可以使用 <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Row</span></code></a> 类或自定义的 <a class="reference internal" href="#sqlite3.Cursor.row_factory" title="sqlite3.Cursor.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a>。</p>
<p>虽然 <code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code> 同时作为 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 的属性存在，但推荐设置 <a class="reference internal" href="#sqlite3.Connection.row_factory" title="sqlite3.Connection.row_factory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection.row_factory</span></code></a>，这样在该连接上创建的所有游标都将使用同一个行工厂对象。</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 提供了针对列的序列方式和大小写不敏感的名称方式访问，具有优于 <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> 的最小化内存开销和性能影响。 要使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 作为行工厂对象，请将其赋值给 <code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code> 属性:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>
</pre></div>
</div>
<p>现在查询将返回 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 对象:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT &#39;Earth&#39; AS name, 6378 AS radius&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;name&#39;, &#39;radius&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c1"># Access by index.</span>
<span class="go">&#39;Earth&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>    <span class="c1"># Access by name.</span>
<span class="go">&#39;Earth&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;RADIUS&quot;</span><span class="p">]</span>  <span class="c1"># Column names are case-insensitive.</span>
<span class="go">6378</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">FROM</span></code> 子句可以在 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 语句中省略，像在上面的示例中那样。 在这种情况下，SQLite 将返回单独的行，其中的列由表达式来定义，例如使用字面量并给出相应的别名 <code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">AS</span> <span class="pre">alias</span></code>。</p>
</div>
<p>你可以创建自定义 <a class="reference internal" href="#sqlite3.Cursor.row_factory" title="sqlite3.Cursor.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a> 用来返回 <a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 形式的行，将列名映射到相应的值。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dict_factory</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">row</span><span class="p">)}</span>
</pre></div>
</div>
<p>使用它，现在查询将返回 <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> 而不是 <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">dict_factory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT 1 AS a, 2 AS b&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>以下行工厂函数将返回一个 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="k">def</span> <span class="nf">namedtuple_factory</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple_factory()</span></code> 可以像下面这样使用:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">namedtuple_factory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT 1 AS a, 2 AS b&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">Row(a=1, b=2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Indexed access.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="o">.</span><span class="n">b</span>   <span class="c1"># Attribute access.</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>经过一些调整，上面的范例程序可以被适配为使用 <a class="reference internal" href="dataclasses.xhtml#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataclass</span></code></a>，或任何其他自定义类，而不是 <a class="reference internal" href="collections.xhtml#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">namedtuple</span></code></a>。</p>
</section>
<section id="how-to-handle-non-utf-8-text-encodings">
<span id="sqlite3-howto-encoding"></span><h3>如何处理非 UTF-8 文本编码格式</h3>
<p>在默认情况下，<code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 使用 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 来适配 <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> 数据类型的 SQLite 值。 这对 UTF-8 编码的文本来说很适用，但对于其他编码格式和无效的 UTF-8 来说则可能出错。 你可以使用自定义的 <a class="reference internal" href="#sqlite3.Connection.text_factory" title="sqlite3.Connection.text_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">text_factory</span></code></a> 来处理这种情况。</p>
<p>由于 SQLite 的 <a class="reference external" href="https://www.sqlite.org/flextypegood.html">flexible typing</a><span class="link-target"> [https://www.sqlite.org/flextypegood.html]</span>，遇到包含非 UTF-8 编码格式的 <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> 数据类型甚至任意数据的表字段的情况并不少见。 作为演示，让我们假定有一个使用 ISO-8859-2 (Latin-2) 编码的文本的数据库，例如一个捷克语-英语字典条目的表。 假定我们现在有一个 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 实例 <code class="xref py py-data docutils literal notranslate"><span class="pre">con</span></code> 已连接到这个数据库，我们将可以使用这个 <a class="reference internal" href="#sqlite3.Connection.text_factory" title="sqlite3.Connection.text_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">text_factory</span></code></a> 来解码使用 Latin-2 编码的文本：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">text_factory</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;latin2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>对于存储在 <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> 表字段中的无效 UTF-8 或任意数据，你可以使用以下技巧，借用自 <a class="reference internal" href="../howto/unicode.xhtml#unicode-howto"><span class="std std-ref">Unicode 指南</span></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">text_factory</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;surrogateescape&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 模块 API 不支持包含替代符的字符串。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../howto/unicode.xhtml#unicode-howto"><span class="std std-ref">Unicode 指南</span></a></p>
</div>
</section>
</section>
<section id="explanation">
<span id="sqlite3-explanation"></span><h2>说明</h2>
<section id="transaction-control">
<span id="sqlite3-controlling-transactions"></span><span id="sqlite3-transaction-control"></span><h3>事务控制</h3>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 提供了多个方法来控制在何时以及怎样控制数据库事务的开启和关闭。 推荐使用 <a class="reference internal" href="#sqlite3-transaction-control-autocommit"><span class="std std-ref">通过 autocommit 属性进行事务控制</span></a> ，而 <a class="reference internal" href="#sqlite3-transaction-control-isolation-level"><span class="std std-ref">通过 isolation_level 属性进行事务控制</span></a> 则保留了 Python 3.12 之前的行为。</p>
<section id="transaction-control-via-the-autocommit-attribute">
<span id="sqlite3-transaction-control-autocommit"></span><h4>通过 <code class="docutils literal notranslate"><span class="pre">autocommit</span></code> 属性进行事务控制</h4>
<p>控制事务行为的推荐方式是通过 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.autocommit</span></code></a> 属性，最好是使用 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 的 <em>autocommit</em> 形参来设置该属性。</p>
<p>建议将 <em>autocommit</em> 设为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，表示使用兼容 <span class="target" id="index-31"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> 的事务控制。 这意味着：</p>
<ul class="simple">
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 会确保事务始终处于开启状态，因此 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 、<a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.commit()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection.rollback" title="sqlite3.Connection.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.rollback()</span></code></a> 将隐式地开启一个新事务（对于后两者，在关闭待处理事务后会立即执行）。 开启事务时 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 会使用 <code class="docutils literal notranslate"><span class="pre">BEGIN</span> <span class="pre">DEFERRED</span></code> 语句。</p></li>
<li><p>事务应当显式地使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code> 执行提交。</p></li>
<li><p>事务应当显式地使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">rollback()</span></code> 执行回滚。</p></li>
<li><p>如果数据库执行 <a class="reference internal" href="#sqlite3.Connection.close" title="sqlite3.Connection.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 时有待处理的更改则会隐式地执行回滚。</p></li>
</ul>
<p>将 <em>autocommit</em> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 以启用 SQLite 的 <a class="reference external" href="https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions">autocommit mode</a><span class="link-target"> [https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions]</span>。 在此模式下，<a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.commit()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection.rollback" title="sqlite3.Connection.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.rollback()</span></code></a> 将没有任何作用。 请注意 SQLite 的自动提交模式与兼容 <span class="target" id="index-32"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a><span class="link-target"> [https://peps.python.org/pep-0249/]</span> 的 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.autocommit</span></code></a> 属性不同；请使用 <a class="reference internal" href="#sqlite3.Connection.in_transaction" title="sqlite3.Connection.in_transaction"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.in_transaction</span></code></a> 查询底层的 SQLite 自动提交模式。</p>
<p>将 <em>autocommit</em> 设为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a> 以将事务控制行为保留给 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.isolation_level</span></code></a> 属性。 更多信息参见 <a class="reference internal" href="#sqlite3-transaction-control-isolation-level"><span class="std std-ref">通过 isolation_level 属性进行事务控制</span></a>。</p>
</section>
<section id="transaction-control-via-the-isolation-level-attribute">
<span id="sqlite3-transaction-control-isolation-level"></span><h4>通过 <code class="docutils literal notranslate"><span class="pre">isolation_level</span></code> 属性进行事务控制</h4>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>推荐的控制事务方式是通过 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 属性。 参见 <a class="reference internal" href="#sqlite3-transaction-control-autocommit"><span class="std std-ref">通过 autocommit 属性进行事务控制</span></a>。</p>
</div>
<p>如果 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.autocommit</span></code></a> 被设为 <a class="reference internal" href="#sqlite3.LEGACY_TRANSACTION_CONTROL" title="sqlite3.LEGACY_TRANSACTION_CONTROL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LEGACY_TRANSACTION_CONTROL</span></code></a> (默认值)，则事务行为由 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connection.isolation_level</span></code></a> 属性控制。 否则，<code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code> 将没有任何作用。</p>
<p>如果连接的属性 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，新的事务会在 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a> 执行 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>, <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code>, <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> 或 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 语句之前隐式地开启；对于其他语句，则不会执行隐式的事务处理。 可分别使用 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a> 和 <a class="reference internal" href="#sqlite3.Connection.rollback" title="sqlite3.Connection.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollback()</span></code></a> 方法提交和回滚未应用的事务。 你可以通过 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 属性来选择下层的 <a class="reference external" href="https://www.sqlite.org/lang_transaction.html#deferred_immediate_and_exclusive_transactions">SQLite transaction behaviour</a><span class="link-target"> [https://www.sqlite.org/lang_transaction.html#deferred_immediate_and_exclusive_transactions]</span> — 也就是说，<code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 是否要隐式地执行以及执行何种类型的 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 语句</p>
<p>如果 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 被设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则完全不会隐式地开启任何事务。 这将使下层 SQLite 库处于 <a class="reference external" href="https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions">自动提交模式</a><span class="link-target"> [https://www.sqlite.org/lang_transaction.html#implicit_versus_explicit_transactions]</span>，但也允许用户使用显式 SQL 语句执行他们自己的事务处理。 下层 SQLite 库的自动提交模式可使用 <a class="reference internal" href="#sqlite3.Connection.in_transaction" title="sqlite3.Connection.in_transaction"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_transaction</span></code></a> 属性来查询。</p>
<p><a class="reference internal" href="#sqlite3.Cursor.executescript" title="sqlite3.Cursor.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a> 方法会在执行给定的 SQL 脚本之前隐式地提交任何挂起的事务，无论 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 的值是什么。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>在以前 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 会在 DDL 语句之前隐式地提交已开启的事务。 现存则不会再这样做。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在推荐的控制事务方式是通过 <a class="reference internal" href="#sqlite3.Connection.autocommit" title="sqlite3.Connection.autocommit"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autocommit</span></code></a> 属性。</p>
</div>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>