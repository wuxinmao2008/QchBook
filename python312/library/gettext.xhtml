<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="gettext --- 多语种国际化服务" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/gettext.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/gettext.py[https://github.com/python/cpython/tree/3.12/Lib/gettext.py] gettext 模块为 Python 模块和应用程序提供国际化 (Internationalization, I18N) 和本地化 (Localization, L10N) 服务。它同时支持 GNU gettext 消息编目 API ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/gettext.py[https://github.com/python/cpython/tree/3.12/Lib/gettext.py] gettext 模块为 Python 模块和应用程序提供国际化 (Internationalization, I18N) 和本地化 (Localization, L10N) 服务。它同时支持 GNU gettext 消息编目 API ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>gettext --- 多语种国际化服务</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/gettext.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-gettext">
<span id="gettext-multilingual-internationalization-services"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code> --- 多语种国际化服务</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/gettext.py">Lib/gettext.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/gettext.py]</span></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 模块为 Python 模块和应用程序提供国际化 (Internationalization, I18N) 和本地化 (Localization, L10N) 服务。它同时支持 GNU <strong class="program">gettext</strong> 消息编目 API 和更高级的、基于类的 API，后者可能更适合于 Python 文件。下方描述的接口允许用户使用一种自然语言编写模块和应用程序消息，并提供翻译后的消息编目，以便在不同的自然语言下运行。</p>
<p>同时还给出一些本地化 Python 模块及应用程序的小技巧。</p>
<section id="gnu-gettext-api">
<h2>GNU <strong class="program">gettext</strong> API</h2>
<p>模块 <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 定义了下列  API，这与 <strong class="program">gettext</strong> API 类似。如果你使用该 API，将会对整个应用程序产生全局的影响。如果你的应用程序支持多语种，而语言选择取决于用户的语言环境设置，这通常正是你所想要的。而如果你正在本地化某个 Python 模块，或者你的应用程序需要在运行时切换语言，相反你或许想用基于类的API。</p>
<dl class="py function">
<dt class="sig sig-object py" id="gettext.bindtextdomain">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">bindtextdomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localedir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <em>domain</em> 绑定到本地目录 <em>localedir</em>。 更具体地来说，模块 <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 将使用路径 (在 Unix 系统中):  <code class="file docutils literal notranslate"><em><span class="pre">localedir</span></em><span class="pre">/</span><em><span class="pre">language</span></em><span class="pre">/LC_MESSAGES/</span><em><span class="pre">domain</span></em><span class="pre">.mo</span></code> 查找二进制 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件，此处对应地查找 <em>language</em> 的位置是环境变量 <span class="target" id="index-20"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LANGUAGE</span></code>, <span class="target" id="index-21"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LC_ALL</span></code>, <span class="target" id="index-22"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LC_MESSAGES</span></code> 和 <span class="target" id="index-23"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LANG</span></code> 中。</p>
<p>如果遗漏了 <em>localedir</em> 或者设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，那么将返回当前 <em>domain</em> 所绑定的值 <a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.textdomain">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">textdomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>修改或查询当前的全局域。如果 <em>domain</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则返回当前的全局域，不为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 则将全局域设置为 <em>domain</em>，并返回它。</p>
</dd></dl>

<dl class="py function" id="index-4">
<dt class="sig sig-object py" id="gettext.gettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">gettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回 <em>message</em> 的本地化翻译，依据当前的全局域、语言和语言区域目录。 本函数在局部命名空间中通常包含别名 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> (参见下面的示例)。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.dgettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">dgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#gettext.gettext" title="gettext.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a> 类似，但在指定的 <em>domain</em> 中查找 message。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.ngettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">ngettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#gettext.gettext" title="gettext.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a> 类似，但考虑了复数形式。如果找到了翻译，则将 <em>n</em> 代入复数公式，然后返回得出的消息（某些语言具有两种以上的复数形式）。如果未找到翻译，则 <em>n</em> 为 1 时返回 <em>singular</em>，为其他数时返回 <em>plural</em>。</p>
<p>复数公式取自编目头文件。它是 C 或 Python 表达式，有一个自变量 <em>n</em>，该表达式计算的是所需复数形式在编目中的索引号。关于在 <code class="file docutils literal notranslate"><span class="pre">.po</span></code> 文件中使用的确切语法和各种语言的公式，请参阅 <a class="reference external" href="https://www.gnu.org/software/gettext/manual/gettext.html">GNU gettext 文档</a><span class="link-target"> [https://www.gnu.org/software/gettext/manual/gettext.html]</span> 。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.dngettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">dngettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与 <a class="reference internal" href="#gettext.ngettext" title="gettext.ngettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">ngettext()</span></code></a> 类似，但在指定的 <em>domain</em> 中查找 message。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.pgettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">pgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.dpgettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">dpgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.npgettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">npgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.dnpgettext">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">dnpgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>与前缀中没有 <code class="docutils literal notranslate"><span class="pre">p</span></code> 的相应函数类似（即 <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext()</span></code></a>, <a class="reference internal" href="#gettext.dgettext" title="gettext.dgettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">dgettext()</span></code></a>, <a class="reference internal" href="#gettext.ngettext" title="gettext.ngettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">ngettext()</span></code></a>, <a class="reference internal" href="#gettext.dngettext" title="gettext.dngettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">dngettext()</span></code></a> ），但是仅翻译给定的 message <em>context</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<p>请注意 GNU <strong class="program">gettext</strong> 还定义了一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">dcgettext()</span></code> 方法，但它被认为并不实用因此目前尚未实现它。</p>
<p>这是该 API 的典型用法示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">gettext</span><span class="o">.</span><span class="n">bindtextdomain</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/my/language/directory&#39;</span><span class="p">)</span>
<span class="n">gettext</span><span class="o">.</span><span class="n">textdomain</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">gettext</span>
<span class="c1"># ...</span>
<span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;This is a translatable string.&#39;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="class-based-api">
<h2>基于类的 API</h2>
<p>与 GNU <strong class="program">gettext</strong> API 相比，<a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 模块的基于类的API 提供了更多的灵活性和便利性。 这是本地化 Python 应用程序和模块的推荐方式。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code> 定义了一个 <a class="reference internal" href="#gettext.GNUTranslations" title="gettext.GNUTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">GNUTranslations</span></code></a> 类，它实现了对 GNU <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 格式文件的解析，并且具有用于返回字符串的方法。 本类的实例也可以将自身作为函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 安装到内置命名空间中。</p>
<dl class="py function">
<dt class="sig sig-object py" id="gettext.find">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localedir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">languages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>本函数实现了标准的 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件搜索算法。它接受一个 <em>domain</em>，它与 <a class="reference internal" href="#gettext.textdomain" title="gettext.textdomain"><code class="xref py py-func docutils literal notranslate"><span class="pre">textdomain()</span></code></a> 接受的域相同。可选参数 <em>localedir</em> 与 <a class="reference internal" href="#gettext.bindtextdomain" title="gettext.bindtextdomain"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindtextdomain()</span></code></a> 中的相同。可选参数 <em>languages</em> 是多条字符串的列表，其中每条字符串都是一种语言代码。</p>
<p>如果没有传入 <em>localedir</em>，则使用默认的系统语言环境目录。 <a class="footnote-reference brackets" href="#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> 如果没有传入 <em>languages</em>，则搜索以下环境变量：<span class="target" id="index-24"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LANGUAGE</span></code>、<span class="target" id="index-25"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LC_ALL</span></code>、<span class="target" id="index-26"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LC_MESSAGES</span></code> 和 <span class="target" id="index-27"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LANG</span></code>。从这些变量返回的第一个非空值将用作 <em>languages</em> 变量。环境变量应包含一个语言列表，由冒号分隔，该列表会被按冒号拆分，以产生所需的语言代码字符串列表。</p>
<p><a class="reference internal" href="#gettext.find" title="gettext.find"><code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code></a> 将扩展并规范化 language，然后遍历它们，搜索由这些组件构建的现有文件:</p>
<p><code class="file docutils literal notranslate"><em><span class="pre">localedir</span></em><span class="pre">/</span><em><span class="pre">language</span></em><span class="pre">/LC_MESSAGES/</span><em><span class="pre">domain</span></em><span class="pre">.mo</span></code></p>
<p><a class="reference internal" href="#gettext.find" title="gettext.find"><code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code></a> 返回找到类似的第一个文件名。如果找不到这样的文件，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。如果传入了 <em>all</em>，它将返回一个列表，包含所有文件名，并按它们在语言列表或环境变量中出现的顺序排列。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.translation">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localedir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">languages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>根据 <em>domain</em>, <em>localedir</em> 和 <em>languages</em> 返回一个 <code class="docutils literal notranslate"><span class="pre">*Translations</span></code> 实例，它们将首先被传给 <a class="reference internal" href="#gettext.find" title="gettext.find"><code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code></a> 以获取由所关联的 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件路径组成的列表。 具有相同 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件名的实例会被缓存。 如果提供了 <em>class_</em> 则它将是被实例化的类，否则将是 <a class="reference internal" href="#gettext.GNUTranslations" title="gettext.GNUTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">GNUTranslations</span></code></a>。 该类的构造器必须接受一个 <a class="reference internal" href="../glossary.xhtml#term-file-object"><span class="xref std std-term">file object</span></a> 参数。</p>
<p>如果找到多个文件，后找到的文件将用作先前文件的替补。为了设置替补，将使用 <a class="reference internal" href="copy.xhtml#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> 从缓存中克隆每个 translation 对象。实际的实例数据仍在缓存中共享。</p>
<p>如果 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件未找到，且 <em>fallback</em> 为 false（默认值），则本函数引发 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常，如果 <em>fallback</em> 为 true，则返回一个 <a class="reference internal" href="#gettext.NullTranslations" title="gettext.NullTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullTranslations</span></code></a> 实例。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>过去触发的 <a class="reference internal" href="exceptions.xhtml#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>，现在是 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><em>codeset</em> 形参已被移除。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gettext.install">
<span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">install</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localedir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这将在 Python 的内置命名空间中安装 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 函数，基于传给 <a class="reference internal" href="#gettext.translation" title="gettext.translation"><code class="xref py py-func docutils literal notranslate"><span class="pre">translation()</span></code></a> 函数的 <em>domain</em> 和 <em>localedir</em>。</p>
<p><em>names</em> 参数的信息请参阅 translation 对象的 <a class="reference internal" href="#gettext.NullTranslations.install" title="gettext.NullTranslations.install"><code class="xref py py-meth docutils literal notranslate"><span class="pre">install()</span></code></a> 方法的描述。</p>
<p>如下所示，通常是将字符串包裹在对 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 函数的调用中，以标记应用程序中待翻译的字符串，就像这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;This string will be translated.&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>为了方便，可将 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 函数安装在 Python 的内置命名空间中，这样就可以在应用程序的所有模块中轻松地访问它。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><em>names</em> 现在是仅限关键字形参。</p>
</div>
</dd></dl>

<section id="the-nulltranslations-class">
<h3><a class="reference internal" href="#gettext.NullTranslations" title="gettext.NullTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullTranslations</span></code></a> 类</h3>
<p>translation 类实际实现的是，将原始源文件消息字符串转换为已翻译的消息字符串。所有 translation 类使用的基类为 <a class="reference internal" href="#gettext.NullTranslations" title="gettext.NullTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullTranslations</span></code></a>，它提供了基本的接口，可用于编写自己定制的 translation 类。以下是 <code class="xref py py-class docutils literal notranslate"><span class="pre">NullTranslations</span></code> 的方法：</p>
<dl class="py class">
<dt class="sig sig-object py" id="gettext.NullTranslations">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">NullTranslations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>接受一个可选参数 <a class="reference internal" href="../glossary.xhtml#term-file-object"><span class="xref std std-term">文件对象</span></a> <em>fp</em>，该参数会被基类忽略。初始化由派生类设置的 &quot;protected&quot; （受保护的）实例变量 <em>_info</em> 和 <em>_charset</em>，与 <em>_fallback</em> 类似，但它是通过 <a class="reference internal" href="#gettext.NullTranslations.add_fallback" title="gettext.NullTranslations.add_fallback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_fallback()</span></code></a> 来设置的。如果 <em>fp</em> 不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，就会调用 <code class="docutils literal notranslate"><span class="pre">self._parse(fp)</span></code>。</p>
<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations._parse">
<span class="sig-name descname"><span class="pre">_parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在基类中没有操作，本方法接受文件对象 <em>fp</em>，从该文件读取数据，用来初始化消息编目。如果你手头的消息编目文件的格式不受支持，则应重写本方法来解析你的格式。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.add_fallback">
<span class="sig-name descname"><span class="pre">add_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fallback</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>添加 <em>fallback</em> 为当前 translation 对象的替补对象。如果 translation 对象无法为指定消息提供翻译，则应向替补查询。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.gettext">
<span class="sig-name descname"><span class="pre">gettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果设置了替补，则转发 <code class="xref py py-meth docutils literal notranslate"><span class="pre">gettext()</span></code> 给替补。否则返回 <em>message</em>。在派生类中被重写。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.ngettext">
<span class="sig-name descname"><span class="pre">ngettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果设置了替补，则转发 <code class="xref py py-meth docutils literal notranslate"><span class="pre">ngettext()</span></code> 给替补。否则，<em>n</em> 为 1 时返回 <em>singular</em>，为其他时返回 <em>plural</em>。在派生类中被重写。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.pgettext">
<span class="sig-name descname"><span class="pre">pgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果设置了替补，则转发 <a class="reference internal" href="#gettext.pgettext" title="gettext.pgettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pgettext()</span></code></a> 给替补。否则返回已翻译的消息。在派生类中被重写。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.npgettext">
<span class="sig-name descname"><span class="pre">npgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果设置了替补，则转发 <a class="reference internal" href="#gettext.npgettext" title="gettext.npgettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">npgettext()</span></code></a> 给替补。否则返回已翻译的消息。在派生类中被重写。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.info">
<span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个包含在消息编目文件中找到的元数据的字典。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.charset">
<span class="sig-name descname"><span class="pre">charset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回消息编目文件的编码。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.NullTranslations.install">
<span class="sig-name descname"><span class="pre">install</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>本方法将 <a class="reference internal" href="#gettext.NullTranslations.gettext" title="gettext.NullTranslations.gettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettext()</span></code></a> 安装至内建命名空间，并绑定为 <code class="docutils literal notranslate"><span class="pre">_</span></code>。</p>
<p>如果给出了 <em>names</em> 形参，则它必须是一个包含除 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 外需要在内置命名空间中安装的函数的名称的序列。 受支持的名称有 <code class="docutils literal notranslate"><span class="pre">'gettext'</span></code>, <code class="docutils literal notranslate"><span class="pre">'ngettext'</span></code>, <code class="docutils literal notranslate"><span class="pre">'pgettext'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'npgettext'</span></code>。</p>
<p>请注意这只是将 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 函数提供给应用程序的一种方式，尽管也是最方便的方式。 由于它会全局性地影响整个应用程序，特别是内置命名空间，因此本地化的模块绝不应安装 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code>。 作为替代，它们应使用以下代码使 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 可用于它们的模块:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="s1">&#39;mymodule&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gettext</span>
</pre></div>
</div>
<p>这样只把 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 放在模块的全局命名空间中所以只会影响该模块内的调用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>添加了 <code class="docutils literal notranslate"><span class="pre">'pgettext'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'npgettext'</span></code>。</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="the-gnutranslations-class">
<h3><a class="reference internal" href="#gettext.GNUTranslations" title="gettext.GNUTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">GNUTranslations</span></code></a> 类</h3>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code> 模块提供了一个派生自 <a class="reference internal" href="#gettext.NullTranslations" title="gettext.NullTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullTranslations</span></code></a> 的附加类: <a class="reference internal" href="#gettext.GNUTranslations" title="gettext.GNUTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">GNUTranslations</span></code></a>。 该类重写了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_parse()</span></code> 以同时支持以大端序和小端序格式读取 GNU <strong class="program">gettext</strong> 格式的 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件。</p>
<p><a class="reference internal" href="#gettext.GNUTranslations" title="gettext.GNUTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">GNUTranslations</span></code></a> 会从翻译编目中解析可选的元数据。 根据惯例 GNU <strong class="program">gettext</strong> 会以空字符串翻译的形式包括元数据。 该元数据使用 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc822.html"><strong>RFC 822</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc822.html]</span> 风格的 <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code> 对，并且应当包含 <code class="docutils literal notranslate"><span class="pre">Project-Id-Version</span></code> 键。 如果找到了 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 键，则将使用 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 属性来初始化 &quot;protected&quot; <code class="xref py py-attr docutils literal notranslate"><span class="pre">_charset</span></code> 实例变量，如未找到则默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果指定了 charset 编码格式，则从编目中读取的所有消息 ID 和消息字符串都将使用该编码格式转换为 Unicode，否则会设定使用 ASCII。</p>
<p>由于消息 ID 也是以 Unicode 字符串的形式读取的，因此所有 <code class="docutils literal notranslate"><span class="pre">*gettext()</span></code> 方法都会假定消息 ID 为 Unicode字符串，而不是字节串。</p>
<p>整个键/值对集合将被放入一个字典并设置为 &quot;protected&quot; <code class="xref py py-attr docutils literal notranslate"><span class="pre">_info</span></code> 实例变量。</p>
<p>如果 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件的魔法值 (magic number) 无效，或遇到意外的主版本号，或在读取文件时发生其他问题，则实例化 <a class="reference internal" href="#gettext.GNUTranslations" title="gettext.GNUTranslations"><code class="xref py py-class docutils literal notranslate"><span class="pre">GNUTranslations</span></code></a> 类会引发 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="gettext.GNUTranslations">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">gettext.</span></span><span class="sig-name descname"><span class="pre">GNUTranslations</span></span></dt>
<dd><p>下列方法是根据基类实现重写的：</p>
<dl class="py method">
<dt class="sig sig-object py" id="gettext.GNUTranslations.gettext">
<span class="sig-name descname"><span class="pre">gettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在编目中查找 <em>message</em> ID，并以 Unicode 字符串形式返回相应的消息字符串。如果在编目中没有 <em>message</em> ID 条目，且配置了替补，则查找请求将被转发到替补的 <a class="reference internal" href="#gettext.NullTranslations.gettext" title="gettext.NullTranslations.gettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettext()</span></code></a> 方法。否则，返回 <em>message</em> ID。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.GNUTranslations.ngettext">
<span class="sig-name descname"><span class="pre">ngettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>查找消息 ID 的复数形式。<em>singular</em> 用作消息 ID，用于在编目中查找，同时 <em>n</em> 用于确定使用哪种复数形式。返回的消息字符串是 Unicode 字符串。</p>
<p>如果在编目中没有找到消息 ID，且配置了替补，则查找请求将被转发到替补的 <a class="reference internal" href="#gettext.NullTranslations.ngettext" title="gettext.NullTranslations.ngettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ngettext()</span></code></a> 方法。否则，当 <em>n</em> 为 1 时返回 <em>singular</em>，其他情况返回 <em>plural</em>。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
<span class="n">cat</span> <span class="o">=</span> <span class="n">GNUTranslations</span><span class="p">(</span><span class="n">somefile</span><span class="p">)</span>
<span class="n">message</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">ngettext</span><span class="p">(</span>
    <span class="s1">&#39;There is </span><span class="si">%(num)d</span><span class="s1"> file in this directory&#39;</span><span class="p">,</span>
    <span class="s1">&#39;There are </span><span class="si">%(num)d</span><span class="s1"> files in this directory&#39;</span><span class="p">,</span>
    <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;num&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.GNUTranslations.pgettext">
<span class="sig-name descname"><span class="pre">pgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在编目中查找 <em>context</em> 和 <em>message</em> ID，并以 Unicode 字符串形式返回相应的消息字符串。如果在编目中没有 <em>message</em> ID 和 <em>context</em> 条目，且配置了替补，则查找请求将被转发到替补的 <a class="reference internal" href="#gettext.pgettext" title="gettext.pgettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pgettext()</span></code></a> 方法。否则，返回 <em>message</em> ID。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="gettext.GNUTranslations.npgettext">
<span class="sig-name descname"><span class="pre">npgettext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plural</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>查找消息 ID 的复数形式。<em>singular</em> 用作消息 ID，用于在编目中查找，同时 <em>n</em> 用于确定使用哪种复数形式。</p>
<p>如果在编目中没有找到 <em>context</em> 对应的消息 ID，且配置了替补，则查找请求将被转发到替补的 <a class="reference internal" href="#gettext.npgettext" title="gettext.npgettext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">npgettext()</span></code></a> 方法。否则，当 <em>n</em> 为 1 时返回 <em>singular</em>，其他情况返回 <em>plural</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="solaris-message-catalog-support">
<h3>Solaris 消息编目支持</h3>
<p>Solaris 操作系统定义了自己的二进制 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件格式，但由于找不到该格式的文档，因此目前不支持该格式。</p>
</section>
<section id="the-catalog-constructor">
<h3>编目构造器</h3>
<p id="index-10">GNOME 用的 <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 模块是 James Henstridge 写的版本，但该版本的 API 略有不同。它文档中的用法是:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">cat</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">Catalog</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">localedir</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">gettext</span>
<span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>为了与此模块的旧版本兼容，函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">Catalog()</span></code> 是上述 <a class="reference internal" href="#gettext.translation" title="gettext.translation"><code class="xref py py-func docutils literal notranslate"><span class="pre">translation()</span></code></a> 函数的别名。</p>
<p>本模块与 Henstridge 的模块有一个区别：他的编目对象支持通过映射 API 进行访问，但是该特性似乎从未使用过，因此目前不支持该特性。</p>
</section>
</section>
<section id="internationalizing-your-programs-and-modules">
<span id="i18n-howto"></span><h2>国际化 (I18N) 你的程序和模块</h2>
<p>国际化 (I18N) 是指使程序可切换多种语言的操作。本地化 (L10N) 是指程序的适配能力，一旦程序被国际化，就能适配当地的语言和文化习惯。为了向 Python 程序提供不同语言的消息，需要执行以下步骤：</p>
<ol class="arabic simple">
<li><p>准备程序或模块，将可翻译的字符串特别标记起来</p></li>
<li><p>在已标记的文件上运行一套工具，用来生成原始消息编目</p></li>
<li><p>创建消息编目的不同语言的翻译</p></li>
<li><p>使用 <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 模块，以便正确翻译消息字符串</p></li>
</ol>
<p>为了准备代码以实现 I18N，你需要查看文件中的所有字符串。 任何需要翻译的字符串都应在 <code class="docutils literal notranslate"><span class="pre">_('...')</span></code> 中包含它来进行标记 --- 即调用函数  <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-func docutils literal notranslate"><span class="pre">_</span></code></a>。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;mylog.txt&#39;</span>
<span class="n">message</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;writing a log message&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>在这个例子中，字符串 <code class="docutils literal notranslate"><span class="pre">'writing</span> <span class="pre">a</span> <span class="pre">log</span> <span class="pre">message'</span></code> 被标记为待翻译，而字符串 <code class="docutils literal notranslate"><span class="pre">'mylog.txt'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> 没有被标记。</p>
<p>有一些工具可以将待翻译的字符串提取出来。 原版的 GNU <strong class="program">gettext</strong> 仅支持 C 或 C++ 源代码，但其扩展版 <strong class="program">xgettext</strong> 可以扫描多种语言的代码，包括 Python 在内，来找出标记为可翻译的字符串。 <a class="reference external" href="https://babel.pocoo.org/">Babel</a><span class="link-target"> [https://babel.pocoo.org/]</span> 是一个包括了可用于提取并编译消息编目的 <code class="file docutils literal notranslate"><span class="pre">pybabel</span></code> 脚本的 Python 国际化库。 François Pinard 的 <strong class="program">xpot</strong> 程序也能完成类似的工作并可在他的 <a class="reference external" href="https://github.com/pinard/po-utils">po-utils 包</a><span class="link-target"> [https://github.com/pinard/po-utils]</span> 中获取。</p>
<p>（Python 还包括了这些程序的纯 Python 版本，称为 <strong class="program">pygettext.py</strong> 和 <strong class="program">msgfmt.py</strong>，某些 Python 发行版已经安装了它们。<strong class="program">pygettext.py</strong> 类似于 <strong class="program">xgettext</strong>，但只能理解 Python 源代码，无法处理诸如 C 或 C++ 的其他编程语言。<strong class="program">pygettext.py</strong> 支持的命令行界面类似于 <strong class="program">xgettext</strong>，查看其详细用法请运行 <code class="docutils literal notranslate"><span class="pre">pygettext.py</span> <span class="pre">--help</span></code>。<strong class="program">msgfmt.py</strong> 与 GNU <strong class="program">msgfmt</strong> 是二进制兼容的。有了这两个程序，可以不需要 GNU <strong class="program">gettext</strong> 包来国际化 Python 应用程序。）</p>
<p><strong class="program">xgettext</strong>、<strong class="program">pygettext</strong> 或类似工具生成的 <code class="file docutils literal notranslate"><span class="pre">.po</span></code> 文件就是消息编目。它们是结构化的人类可读文件，包含源代码中所有被标记的字符串，以及这些字符串的翻译的占位符。</p>
<p>然后把这些 <code class="file docutils literal notranslate"><span class="pre">.po</span></code> 文件的副本交给各个人工译者，他们为所支持的每种自然语言编写翻译。译者以 <code class="file docutils literal notranslate"><span class="pre">&lt;语言名称&gt;.po</span></code> 文件的形式发送回翻译完的某个语言的版本，将该文件用 <strong class="program">msgfmt</strong> 程序编译为机器可读的 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 二进制编目文件。<a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 模块使用 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件在运行时进行实际的翻译处理。</p>
<p>如何在代码中使用 <a class="reference internal" href="#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 模块取决于国际化单个模块还是整个应用程序。接下来的两节将讨论每种情况。</p>
<section id="localizing-your-module">
<h3>本地化你的模块</h3>
<p>如果要本地化模块，则切忌进行全局性的更改，如更改内建命名空间。不应使用 GNU <strong class="program">gettext</strong> API，而应使用基于类的 API。</p>
<p>假设你的模块叫做 &quot;spam&quot;，并且该模块的各种自然语言翻译 <code class="file docutils literal notranslate"><span class="pre">.mo</span></code> 文件存放于 <code class="file docutils literal notranslate"><span class="pre">/usr/share/locale</span></code>，为 GNU <strong class="program">gettext</strong> 格式。以下内容应放在模块顶部:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;/usr/share/locale&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">gettext</span>
</pre></div>
</div>
</section>
<section id="localizing-your-application">
<h3>本地化你的应用程序</h3>
<p>如果你正在本地化你的应用程序，你可以将 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 函数全局安装到内置命名空间中，通常位于应用程序的主驱动文件内。 这样将让你的应用程序专属的所有文件都可以使用 <code class="docutils literal notranslate"><span class="pre">_('...')</span></code> 而无需在每个文件中显示安装它。</p>
<p>最简单的情况，就只需将以下代码添加到应用程序的主程序文件中:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">gettext</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果需要设置语言环境目录，可以将其传递给 <a class="reference internal" href="#gettext.install" title="gettext.install"><code class="xref py py-func docutils literal notranslate"><span class="pre">install()</span></code></a> 函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">gettext</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">,</span> <span class="s1">&#39;/usr/share/locale&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="changing-languages-on-the-fly">
<h3>即时更改语言</h3>
<p>如果程序需要同时支持多种语言，则可能需要创建多个翻译实例，然后在它们之间进行显式切换，如下所示:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gettext</span>

<span class="n">lang1</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">,</span> <span class="n">languages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;en&#39;</span><span class="p">])</span>
<span class="n">lang2</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">,</span> <span class="n">languages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fr&#39;</span><span class="p">])</span>
<span class="n">lang3</span> <span class="o">=</span> <span class="n">gettext</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="s1">&#39;myapplication&#39;</span><span class="p">,</span> <span class="n">languages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;de&#39;</span><span class="p">])</span>

<span class="c1"># start by using language1</span>
<span class="n">lang1</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>

<span class="c1"># ... time goes by, user selects language 2</span>
<span class="n">lang2</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>

<span class="c1"># ... more time goes by, user selects language 3</span>
<span class="n">lang3</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="deferred-translations">
<h3>延迟翻译</h3>
<p>在大多数代码中，字符串会在编写位置进行翻译。但偶尔需要将字符串标记为待翻译，实际翻译却推迟到后面。一个典型的例子是:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mollusk&#39;</span><span class="p">,</span>
           <span class="s1">&#39;albatross&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rat&#39;</span><span class="p">,</span>
           <span class="s1">&#39;penguin&#39;</span><span class="p">,</span>
           <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="p">]</span>
<span class="c1"># ...</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>此处希望将 <code class="docutils literal notranslate"><span class="pre">animals</span></code> 列表中的字符串标记为可翻译，但不希望在打印之前对它们进行翻译。</p>
<p>这是处理该情况的一种方式:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">message</span><span class="p">):</span> <span class="k">return</span> <span class="n">message</span>

<span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;mollusk&#39;</span><span class="p">),</span>
           <span class="n">_</span><span class="p">(</span><span class="s1">&#39;albatross&#39;</span><span class="p">),</span>
           <span class="n">_</span><span class="p">(</span><span class="s1">&#39;rat&#39;</span><span class="p">),</span>
           <span class="n">_</span><span class="p">(</span><span class="s1">&#39;penguin&#39;</span><span class="p">),</span>
           <span class="n">_</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">),</span> <span class="p">]</span>

<span class="k">del</span> <span class="n">_</span>

<span class="c1"># ...</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>这样做是因为 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 的虚定义只是简单地原样返回字符串。 并且这个虚定义将临时覆盖内置命名空间中任何的 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 定义（直到 <a class="reference internal" href="../reference/simple_stmts.xhtml#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 命令）。 但是如果之前你在局部命名空间中已有 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 的定义，则需要特别注意。</p>
<p>请注意在第二次使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 时将不会认为“a”可以由 <strong class="program">gettext</strong> 程序去翻译，因为该形参不是字符串字面值。</p>
<p>解决该问题的另一种方法是下面这个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">N_</span><span class="p">(</span><span class="n">message</span><span class="p">):</span> <span class="k">return</span> <span class="n">message</span>

<span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="n">N_</span><span class="p">(</span><span class="s1">&#39;mollusk&#39;</span><span class="p">),</span>
           <span class="n">N_</span><span class="p">(</span><span class="s1">&#39;albatross&#39;</span><span class="p">),</span>
           <span class="n">N_</span><span class="p">(</span><span class="s1">&#39;rat&#39;</span><span class="p">),</span>
           <span class="n">N_</span><span class="p">(</span><span class="s1">&#39;penguin&#39;</span><span class="p">),</span>
           <span class="n">N_</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">),</span> <span class="p">]</span>

<span class="c1"># ...</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>在这种情况下，你用函数  <code class="xref py py-func docutils literal notranslate"><span class="pre">N_()</span></code> 来标记可翻译的字符串，它与 <code class="xref py py-func docutils literal notranslate"><span class="pre">_()</span></code> 的任何定义都不会冲突。 不过，你需要让你的消息提取程序寻找用 <code class="xref py py-func docutils literal notranslate"><span class="pre">N_()</span></code> 标记的可翻译字符串。 <strong class="program">xgettext</strong>, <strong class="program">pygettext</strong>, <code class="docutils literal notranslate"><span class="pre">pybabel</span> <span class="pre">extract</span></code> 和 <strong class="program">xpot</strong> 都通过使用 <code class="xref std std-option docutils literal notranslate"><span class="pre">-k</span></code> 命令行开关来支持此功能。 这里选择用 <code class="xref py py-func docutils literal notranslate"><span class="pre">N_()</span></code> 完全是任意的；它也可以简单地改为 <code class="xref py py-func docutils literal notranslate"><span class="pre">MarkThisStringForTranslation()</span></code>。</p>
</section>
</section>
<section id="acknowledgements">
<h2>致谢</h2>
<p>以下人员为创建此模块贡献了代码、反馈、设计建议、早期实现和宝贵的经验：</p>
<ul class="simple">
<li><p>Peter Funk</p></li>
<li><p>James Henstridge</p></li>
<li><p>Juan David Ibáñez Palomar</p></li>
<li><p>Marc-André Lemburg</p></li>
<li><p>Martin von Löwis</p></li>
<li><p>François Pinard</p></li>
<li><p>Barry Warsaw</p></li>
<li><p>Gustavo Niemeyer</p></li>
</ul>
<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>默认的语言区域目录取决于具体系统；例如，在 Red Hat Linux 上为 <code class="file docutils literal notranslate"><span class="pre">/usr/share/locale</span></code>，但在 Solaris 上则为 <code class="file docutils literal notranslate"><span class="pre">/usr/lib/locale</span></code>。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code> 模块没有试图支持这些依赖于系统的默认值；而是默认设为 <code class="file docutils literal notranslate"><em><span class="pre">sys.base_prefix</span></em><span class="pre">/share/locale</span></code> (参见 <a class="reference internal" href="sys.xhtml#sys.base_prefix" title="sys.base_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.base_prefix</span></code></a>)。 基于上述原因，最好每次都在程序启动时调用 <a class="reference internal" href="#gettext.bindtextdomain" title="gettext.bindtextdomain"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindtextdomain()</span></code></a> 并附带一个显式的绝对路径。</p>
</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>参阅上方 <a class="reference internal" href="#gettext.bindtextdomain" title="gettext.bindtextdomain"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindtextdomain()</span></code></a> 的脚注。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>