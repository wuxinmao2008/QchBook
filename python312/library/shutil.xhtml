<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="shutil --- High-level file operations" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/shutil.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/shutil.py[https://github.com/python/cpython/tree/3.12/Lib/shutil.py] shutil 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 os 模块。 目录和文件操作: 依赖于具体平台的高效拷贝操作: 从 Python 3.8 开始，所有涉及文..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/shutil.py[https://github.com/python/cpython/tree/3.12/Lib/shutil.py] shutil 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 os 模块。 目录和文件操作: 依赖于具体平台的高效拷贝操作: 从 Python 3.8 开始，所有涉及文..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>shutil --- High-level file operations</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/shutil.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-shutil">
<span id="shutil-high-level-file-operations"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code> --- High-level file operations</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/shutil.py">Lib/shutil.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/shutil.py]</span></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 <a class="reference internal" href="os.xhtml#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>即便是高阶文件拷贝函数 (<a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy()</span></code></a>, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy2()</span></code></a>) 也无法拷贝所有的文件元数据。</p>
<p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p>
</div>
<section id="directory-and-files-operations">
<span id="file-operations"></span><h2>目录和文件操作</h2>
<dl class="py function">
<dt class="sig sig-object py" id="shutil.copyfileobj">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copyfileobj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsrc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdst</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>将 <a class="reference internal" href="../glossary.xhtml#term-file-object"><span class="xref std std-term">文件型对象</span></a> <em>fsrc</em> 的内容拷贝到文件型对象 <em>fdst</em>。 如果给出了整数值 <em>length</em>，即为缓冲区大小。 特别地，<em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；在默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，只有从当前文件位置到文件末尾的内容会被拷贝。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.copyfile">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copyfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">follow_symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将名为 <em>src</em> 的文件的内容（不带元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 均为 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">数据型对象</span></a> 或字符串形式的路径名。</p>
<p><em>dst</em> 必须是完整的目标文件名；对于接受目标目录路径的拷贝请参见 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <a class="reference internal" href="#shutil.SameFileError" title="shutil.SameFileError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SameFileError</span></code></a>。</p>
<p>目标位置必须是可写的；否则将引发 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copyfile</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>曾经是引发 <a class="reference internal" href="exceptions.xhtml#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a> 而不是 <a class="reference internal" href="exceptions.xhtml#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>引发 <a class="reference internal" href="#shutil.SameFileError" title="shutil.SameFileError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SameFileError</span></code></a> 而不是 <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a>。 由于前者是后者的子类，此改变是向后兼容的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">依赖于具体平台的高效拷贝操作</span></a> 一节。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="shutil.SameFileError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">SameFileError</span></span></dt>
<dd><p>此异常会在 <a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a> 中的源和目标为同一文件时被引发。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.copymode">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copymode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">follow_symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将权限位从 <em>src</em> 拷贝到 <em>dst</em>。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">路径型对象</span></a> 或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，则 <a class="reference internal" href="#shutil.copymode" title="shutil.copymode"><code class="xref py py-func docutils literal notranslate"><span class="pre">copymode()</span></code></a> 将尝试修改 <em>dst</em> 本身的模式（而不是它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 了解详情。 如果 <a class="reference internal" href="#shutil.copymode" title="shutil.copymode"><code class="xref py py-func docutils literal notranslate"><span class="pre">copymode()</span></code></a> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copymode</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>加入 <em>follow_symlinks</em> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.copystat">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copystat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">follow_symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将权限位、最近访问时间、最近修改时间和旗标从 <em>src</em> 拷贝到 <em>dst</em>。 在 Linux 上，<a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">路径型对象</span></a> 或字符串形式的路径名。</p>
<p>如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">os.chmod</span> <span class="pre">in</span> <span class="pre">os.supports_follow_symlinks</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 可以修改符号链接的权限位。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">os.utime</span> <span class="pre">in</span> <span class="pre">os.supports_follow_symlinks</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 可以修改符号链接的最近访问和修改时间。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">os.chflags</span> <span class="pre">in</span> <span class="pre">os.supports_follow_symlinks</span></code> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 可以修改符号链接的旗标。 (<code class="docutils literal notranslate"><span class="pre">os.chflags</span></code> 不是在所有平台上均可用。)</p></li>
</ul>
<p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 将尽量拷贝所有内容。 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 一定不会返回失败信息。</p>
<p>更多信息请参阅 <a class="reference internal" href="os.xhtml#os.supports_follow_symlinks" title="os.supports_follow_symlinks"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.supports_follow_symlinks</span></code></a>。</p>
</div>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copystat</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.copy">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">follow_symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 应为 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">路径类对象</span></a> 或字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em> 中。  如果 <em>dst</em> 指定了一个已存在的文件，它将被替换。 返回新创建文件所对应的路径。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。</p>
<p><a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a> 会拷贝文件数据和文件的权限模式 (参见 <a class="reference internal" href="os.xhtml#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.chmod()</span></code></a>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copyfile</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copymode</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">依赖于具体平台的高效拷贝操作</span></a> 一节。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.copy2">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copy2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">follow_symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>，区别在于 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 还会尝试保留文件的元数据。</p>
<p>当 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 为符号链接时，<a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 将尽量保留所有元数据，<a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 一定不会由于无法保留文件元数据而引发异常。</p>
<p><a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 会使用 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 来拷贝文件元数据。 请参阅 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 了解有关修改符号链接元数据的平台支持的更多信息。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copyfile</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copystat</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">依赖于具体平台的高效拷贝操作</span></a> 一节。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.ignore_patterns">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">ignore_patterns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">patterns</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这个工厂函数会创建一个函数，它可被用作 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.copytree">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">copytree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">copy2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_dangling_symlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirs_exist_ok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>递归地将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 所需的包含 <em>dst</em> 的中间目录在默认情况下也将被创建。</p>
<p>目录的权限和时间会通过 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a> 来拷贝，单个文件则会使用 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 来拷贝。</p>
<p>如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。</p>
<p>当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a> 异常中的被引发错误列表。 如果你希望屏蔽此异常则可以将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <a class="reference internal" href="os.xhtml#os.symlink" title="os.symlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.symlink()</span></code></a> 的平台上将不起作用。</p>
<p>如果给出了 <em>ignore</em>，它必须是一个可调用对象，该对象将接受 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 所访问的目录以及 <a class="reference internal" href="os.xhtml#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> 所返回的目录内容列表作为其参数。 由于 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 是递归地被调用的，<em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <a class="reference internal" href="#shutil.ignore_patterns" title="shutil.ignore_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_patterns()</span></code></a> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。</p>
<p>如果发生了（一个或多个）异常，将引发一个附带原因列表的 <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a>。</p>
<p>如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a> 将被使用，但任何支持同样签名（与 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a> 一致）都可以使用。</p>
<p>如果 <em>dirs_exist_ok</em> 为（默认的）假值且 <em>dst</em> 已存在，则会引发 <a class="reference internal" href="exceptions.xhtml#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a>。 如果 <em>dirs_exist_ok</em> 为真值，则如果拷贝操作遇到已存在的目录时将继续执行，并且在 <em>dst</em> 目录树中的文件将被 <em>src</em> 目录树中对应的文件所覆盖。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copytree</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽目标不存在的符号链接。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">依赖于具体平台的高效拷贝操作</span></a> 一节。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>dirs_exist_ok</em> 形参。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.rmtree">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">rmtree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onerror</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onexc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir_fd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p id="index-1">删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，则删除失败导致的错误将被忽略；如果为假值或被省略，则此类错误将通过调用由 <em>onexc</em> 或 <em>onerror</em> 所指定的处理器来处理，或者如果此参数被省略，异常将被传播给调用方。</p>
<p>本函数支持 <a class="reference internal" href="os.xhtml#dir-fd"><span class="std std-ref">基于目录描述符的相对路径</span></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在支持必要的基于 fd 的函数的平台上，默认会使用 <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a> 的可防御符号链接攻击的版本。 在其他平台上，<a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <a class="reference internal" href="#shutil.rmtree.avoids_symlink_attacks" title="shutil.rmtree.avoids_symlink_attacks"><code class="xref py py-data docutils literal notranslate"><span class="pre">rmtree.avoids_symlink_attacks</span></code></a> 函数属性来确定此类情况具体是哪一些。</p>
</div>
<p>如果提供了 <em>onexc</em>，它必须为接受三个形参的可调用对象: <em>function</em>, <em>path</em> 和 <em>excinfo</em>。</p>
<p>第一个形参 <em>function</em> 是引发异常的函数；它依赖于具体的平台和实现。 第二个形参 <em>path</em> 将为传递给 <em>function</em> 的路径名称。 第三个形参 <em>excinfo</em> 是被引发的异常。 由 <em>onexc</em> 所引发的异常将不会被捕获。</p>
<p>已弃用的 <em>onerror</em> 与 <em>onexc</em> 类似，区别在于它接受的第三个形参是从 <a class="reference internal" href="sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的元组。</p>
<p class="audit-hook">引发了个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.rmtree</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">path</span></code>, <code class="docutils literal notranslate"><span class="pre">dir_fd</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>添加了一个防御符号链接攻击的版本，如果平台支持基于 fd 的函数就会被使用。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>在 Windows 上将不会再在移除连接之前删除目录连接中的内容。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>添加了 <em>dir_fd</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>增加了 <em>onexc</em> 形参，弃用了 <em>onerror</em>。</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="shutil.rmtree.avoids_symlink_attacks">
<span class="sig-prename descclassname"><span class="pre">rmtree.</span></span><span class="sig-name descname"><span class="pre">avoids_symlink_attacks</span></span></dt>
<dd><p>指明当前平台和实现是否提供防御符号链接攻击的 <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a> 版本。 目前它仅在平台支持基于 fd 的目录访问函数时才返回真值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.move">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">move</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">copy2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>递归地将一个文件或目录 (<em>src</em>) 移到另一位置并返回目标位置。</p>
<p>如果 <em>dst</em> 为已存在的目录或指向目录的符号链接，则 <em>src</em> 将被移到该目录中。 目标路径在该目录中不能已存在。</p>
<p>如果 <em>dst</em> 已存在但不是一个目录，则它可能会被覆盖，具体取决于 <a class="reference internal" href="os.xhtml#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a> 的语义。</p>
<p>如果目标是在当前文件系统中，则会使用 <a class="reference internal" href="os.xhtml#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a>。 在其他情况下，则使用 <em>copy_function</em> 将 <em>src</em> 拷贝至目标然后移除它。 对于符号链接，则将创建一个指向 <em>src</em> 目标的新符号链接作为目标位置而 <em>src</em> 将被移除。</p>
<p>如果给出了 <em>copy_function</em>，则它必须为接受两个参数 <em>src</em> 和目标位置的可调用对象，并将在 <a class="reference internal" href="os.xhtml#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a> 无法使用时被用来将 <em>src</em> 拷贝到目标位置。 如果源是一个目录，则会调用 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>，并向它传入 <em>copy_function</em>。 默认的 <em>copy_function</em> 是 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>。 使用 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a> 作为 <em>copy_function</em> 将允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.move</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong class="program">mv</strong> 的行为。 现在会返回 <em>dst</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>增加了 <em>copy_function</em> 关键字参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">依赖于具体平台的高效拷贝操作</span></a> 一节。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>接受一个 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">path-like object</span></a> 作为 <em>src</em> 和 <em>dst</em>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.disk_usage">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">disk_usage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回给定路径的磁盘使用统计数据，形式为一个 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Unix 文件系统中，<em>path</em> 必须指向一个 <strong>已挂载</strong> 文件系统分区中的路径。 在这些平台上，CPython 不会尝试从未挂载的文件系统中获取磁盘使用信息。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>在 Windows 上，<em>path</em> 现在可以是一个文件或目录。</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: Unix, Windows。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.chown">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">chown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。</p>
<p><em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。</p>
<p>另请参阅下层的函数 <a class="reference internal" href="os.xhtml#os.chown" title="os.chown"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.chown()</span></code></a>。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.chown</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">path</span></code>, <code class="docutils literal notranslate"><span class="pre">user</span></code>, <code class="docutils literal notranslate"><span class="pre">group</span></code>。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: Unix。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.which">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">which</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cmd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">os.F_OK</span> <span class="pre">|</span> <span class="pre">os.X_OK</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p><em>mode</em> 是一个传递给 <a class="reference internal" href="os.xhtml#os.access" title="os.access"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.access()</span></code></a> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。</p>
<p>当未指定 <em>path</em> 时，将会使用 <a class="reference internal" href="os.xhtml#os.environ" title="os.environ"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.environ()</span></code></a> 的结果，返回 &quot;PATH&quot; 值或回退为 <a class="reference internal" href="os.xhtml#os.defpath" title="os.defpath"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.defpath</span></code></a>。</p>
<p>在 Windows 上，如果 <em>mode</em> 不包括 <code class="docutils literal notranslate"><span class="pre">os.X_OK</span></code> 则会将当前目录添加到 <em>path</em> 中。 当 <em>mode</em> 包括 <code class="docutils literal notranslate"><span class="pre">os.X_OK</span></code> 时，则将通过 Windows API <code class="docutils literal notranslate"><span class="pre">NeedCurrentDirectoryForExePathW</span></code> 来确定当前目录是否应当添加到 <em>path</em> 中。 要避免在当前工作目录下查找可执行文件：可设置 <code class="docutils literal notranslate"><span class="pre">NoDefaultCurrentDirectoryInExePath</span></code> 环境变量。</p>
<p>在 Windows 上，还会使用 <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code> 变量来查找尚未包括某个扩展名的命令。 举例来说，如果你调用 <code class="docutils literal notranslate"><span class="pre">shutil.which(&quot;python&quot;)</span></code>，<a class="reference internal" href="#shutil.which" title="shutil.which"><code class="xref py py-func docutils literal notranslate"><span class="pre">which()</span></code></a> 将搜索 <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code> 以获知应当在 <em>path</em> 中查找 <code class="docutils literal notranslate"><span class="pre">python.exe</span></code>。 例如，在 Windows 上:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="go">&#39;C:\\Python33\\python.EXE&#39;</span>
</pre></div>
</div>
<p>这也适用于当 <em>cmd</em> 是一个包含目录组成部分路径的情况:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="s2">&quot;C:</span><span class="se">\\</span><span class="s2">Python33</span><span class="se">\\</span><span class="s2">python&quot;</span><span class="p">)</span>
<span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Python33</span><span class="se">\\</span><span class="s1">python.EXE&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>现在可以接受 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型。 如果 <em>cmd</em> 的类型为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>，结果的类型也将为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>在 Windows 上，如果 <em>mode</em> 包括 <code class="docutils literal notranslate"><span class="pre">os.X_OK</span></code> 且 WinAPI <code class="docutils literal notranslate"><span class="pre">NeedCurrentDirectoryForExePathW(cmd)</span></code> 为假值则不会再将当前目录添加到搜索路径中，否则即使当前目录已经在搜索路径中仍会再次添加它；现在 <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code> 即使当 <em>cmd</em> 包括目录组成部分或以 <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code> 中的扩展名结束时仍然会被使用；并且没有扩展名的文件名现在也能被找到。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12.1 版本发生变更: </span>在 Windows 上，如果 <em>mode</em> 包括 <code class="docutils literal notranslate"><span class="pre">os.X_OK</span></code>，则带有 <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code> 中的扩展名的可执行文件将优先于不包含匹配的扩展名的可执行文件。 这将带来更接近于 Python 3.11 的行为。</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="shutil.Error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">Error</span></span></dt>
<dd><p>此异常会收集在多文件操作期间所引发的异常。 对于 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p>
</dd></dl>

<section id="platform-dependent-efficient-copy-operations">
<span id="shutil-platform-dependent-efficient-copy-operations"></span><h3>依赖于具体平台的高效拷贝操作</h3>
<p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a>, <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>, <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 以及 <a class="reference internal" href="#shutil.move" title="shutil.move"><code class="xref py py-func docutils literal notranslate"><span class="pre">move()</span></code></a>) 将会使用平台专属的 &quot;fast-copy&quot; 系统调用以便更高效地拷贝文件 (参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33671">bpo-33671</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33671]</span>)。 &quot;fast-copy&quot; 意味着拷贝操作将发生于内核之中，避免像在 &quot;<code class="docutils literal notranslate"><span class="pre">outfd.write(infd.read())</span></code>&quot; 中那样使用 Python 用户空间的缓冲区。</p>
<p>在 macOS 上将会使用 <a class="reference external" href="http://www.manpagez.com/man/3/copyfile/">fcopyfile</a><span class="link-target"> [http://www.manpagez.com/man/3/copyfile/]</span> 来拷贝文件内容（不含元数据）。</p>
<p>在 Linux 上将会使用 <a class="reference internal" href="os.xhtml#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a>。</p>
<p>在 Windows 上 <a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfile()</span></code></a> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <a class="reference internal" href="stdtypes.xhtml#memoryview" title="memoryview"><code class="xref py py-func docutils literal notranslate"><span class="pre">memoryview()</span></code></a> 的 <a class="reference internal" href="#shutil.copyfileobj" title="shutil.copyfileobj"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfileobj()</span></code></a> 变种形式。</p>
<p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <a class="reference internal" href="#shutil.copyfileobj" title="shutil.copyfileobj"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfileobj()</span></code></a> 函数。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更.</span></p>
</div>
</section>
<section id="copytree-example">
<span id="shutil-copytree-example"></span><h3>copytree 示例</h3>
<p>一个使用 <a class="reference internal" href="#shutil.ignore_patterns" title="shutil.ignore_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_patterns()</span></code></a> 辅助函数的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">copytree</span><span class="p">,</span> <span class="n">ignore_patterns</span>

<span class="n">copytree</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore_patterns</span><span class="p">(</span><span class="s1">&#39;*.pyc&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp*&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>这将会拷贝除 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件和以 <code class="docutils literal notranslate"><span class="pre">tmp</span></code> 打头的文件或目录以外的所有条目.</p>
<p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">copytree</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">_logpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Working in </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[]</span>   <span class="c1"># nothing will be ignored</span>

<span class="n">copytree</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">_logpath</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="rmtree-example">
<span id="shutil-rmtree-example"></span><h3>rmtree 示例</h3>
<p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onexc 回调函数来清除只读属性并再次尝试删除。 任何后续的失败都将被传播。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">stat</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<span class="k">def</span> <span class="nf">remove_readonly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
    <span class="s2">&quot;Clear the readonly bit and reattempt the removal&quot;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IWRITE</span><span class="p">)</span>
    <span class="n">func</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">onexc</span><span class="o">=</span><span class="n">remove_readonly</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="archiving-operations">
<span id="id1"></span><h2>归档操作</h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>添加了对 <em>xztar</em> 格式的支持。</p>
</div>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a class="reference internal" href="zipfile.xhtml#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 和 <a class="reference internal" href="tarfile.xhtml#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块。</p>
<dl class="py function">
<dt class="sig sig-object py" id="shutil.make_archive">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">make_archive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">root_dir</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">base_dir</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">dry_run</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。</p>
<p><em>base_name</em> 是要创建的文件的名称，包括路径，去除任何格式专属的扩展名。</p>
<p><em>format</em> 是归档格式：为 &quot;zip&quot; (如果 <a class="reference internal" href="zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块可用), &quot;tar&quot;, &quot;gztar&quot; (如果 <a class="reference internal" href="zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块可用), &quot;bztar&quot; (如果 <a class="reference internal" href="bz2.xhtml#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 模块可用) 或 &quot;xztar&quot; (如果 <a class="reference internal" href="lzma.xhtml#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 模块可用) 中的一个。</p>
<p><em>root_dir</em> 是一个目录，它将作为归档文件的根目录，归档中的所有路径都将是它的相对路径；例如，我们通常会在创建归档之前用 chdir 命令切换到 <em>root_dir</em>。</p>
<p><em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档中所有文件和目录共有的路径前缀。 <em>base_dir</em> 必须相对于 <em>root_dir</em> 给出。 请参阅 <a class="reference internal" href="#shutil-archiving-example-with-basedir"><span class="std std-ref">使用 base_dir 的归档程序示例</span></a> 了解如何同时使用 <em>base_dir</em> 和 <em>root_dir</em>。</p>
<p><em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。</p>
<p>如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。</p>
<p><em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。</p>
<p><em>logger</em> 必须是一个兼容 <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a><span class="link-target"> [https://peps.python.org/pep-0282/]</span> 的对象，通常为 <a class="reference internal" href="logging.xhtml#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> 的实例。</p>
<p><em>verbose</em> 参数已不再使用并进入弃用状态。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.make_archive</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">base_name</span></code>, <code class="docutils literal notranslate"><span class="pre">format</span></code>, <code class="docutils literal notranslate"><span class="pre">root_dir</span></code>, <code class="docutils literal notranslate"><span class="pre">base_dir</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此函数在通过 <a class="reference internal" href="#shutil.register_archive_format" title="shutil.register_archive_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_archive_format()</span></code></a> 注册的自定义归档程序不支持 <em>root_dir</em> 参数时时不是线程安全的。 在这种情况下它会临时改变进程的当前工作目录到 <em>root_dir</em> 来执行归档操作。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>现在对于通过 <code class="docutils literal notranslate"><span class="pre">format=&quot;tar&quot;</span></code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10.6 版本发生变更: </span>目前此函数在创建标准 <code class="docutils literal notranslate"><span class="pre">.zip</span></code> 和 tar 归档文件期间会确保是线程安全的。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.get_archive_formats">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">get_archive_formats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">description)</span></code>。</p>
<p>默认情况下 <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 提供以下格式:</p>
<ul class="simple">
<li><p><em>zip</em>: ZIP 文件（如果 <a class="reference internal" href="zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块可用）。</p></li>
<li><p><em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。</p></li>
<li><p><em>gztar</em>: gzip 压缩的 tar 文件（如果 <a class="reference internal" href="zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块可用）。</p></li>
<li><p><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a class="reference internal" href="bz2.xhtml#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 模块可用）。</p></li>
<li><p><em>xztar</em>: xz 压缩的 tar 文件（如果 <a class="reference internal" href="lzma.xhtml#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 模块可用）。</p></li>
</ul>
<p>你可以通过使用 <a class="reference internal" href="#shutil.register_archive_format" title="shutil.register_archive_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_archive_format()</span></code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.register_archive_format">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">register_archive_format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">extra_args</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">description</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>为 <em>name</em> 格式注册一个归档器。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a class="reference internal" href="os.xhtml#os.curdir" title="os.curdir"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.curdir</span></code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_archive()</span></code></a> 传入的参数一致)。</p>
<p>如果 <em>function</em> 将自定义属性 <code class="docutils literal notranslate"><span class="pre">function.supports_root_dir</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则会以关键字参数形式传递 <em>root_dir</em> 参数。 否则进程的当前工作目录将在调用 <em>function</em> 之前被临时更改为 <em>root_dir</em>。 在此情况下 <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_archive()</span></code></a> 将不是线程安全的。</p>
<p>如果给出了 <em>extra_args</em>，则其应为一个 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。</p>
<p><em>description</em> 由 <a class="reference internal" href="#shutil.get_archive_formats" title="shutil.get_archive_formats"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_archive_formats()</span></code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>增加了对支持 <em>root_dir</em> 参数的函数的支持。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.unregister_archive_format">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">unregister_archive_format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从支持的格式中移除归档格式 <em>name</em>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.unpack_archive">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">unpack_archive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">extract_dir</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。</p>
<p><em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。</p>
<p><em>format</em> 是归档格式：应为 &quot;zip&quot;, &quot;tar&quot;, &quot;gztar&quot;, &quot;bztar&quot; 或 &quot;xztar&quot; 之一。 或者任何通过 <a class="reference internal" href="#shutil.register_unpack_format" title="shutil.register_unpack_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_unpack_format()</span></code></a> 注册的其他格式。 如果未提供，<a class="reference internal" href="#shutil.unpack_archive" title="shutil.unpack_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack_archive()</span></code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>仅限关键字参数 <em>filter</em> 将被传给下层的解包函数。 对于 zip 文件，<em>filter</em> 将不被接受。 对于 tar 文件，推荐将其设为 <code class="docutils literal notranslate"><span class="pre">'data'</span></code>，除非使用了 tar 专属的特征且为 UNIX 类文件系统。 （请参阅 <a class="reference internal" href="tarfile.xhtml#tarfile-extraction-filter"><span class="std std-ref">解压缩过滤器</span></a> 了解详情。） <code class="docutils literal notranslate"><span class="pre">'data'</span></code> 将在 Python 3.14 中成为 tar 文件的默认过滤器。</p>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.unpack_archive</span></code> 附带参数 <code class="docutils literal notranslate"><span class="pre">filename</span></code>, <code class="docutils literal notranslate"><span class="pre">extract_dir</span></code>, <code class="docutils literal notranslate"><span class="pre">format</span></code>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>绝不要未经预先检验就从不可靠的源中提取归档文件。 这样有可能会在 <em>extract_dir</em> 参数所指定的路径之外创建文件，例如某些成员具有以 &quot;/&quot; 打头的绝对路径文件名或是以两个点号 &quot;..&quot; 打头的文件名。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>接受一个 <a class="reference internal" href="../glossary.xhtml#term-path-like-object"><span class="xref std std-term">path-like object</span></a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>增加了 <em>filter</em> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.register_unpack_format">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">register_unpack_format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">extra_args</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">description</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code class="docutils literal notranslate"><span class="pre">.zip</span></code>。</p>
<p><em>function</em> 是将被用于解包归档的可调用对象。 该可调用对象将接受:</p>
<ul class="simple">
<li><p>归档的路径，为位置参数;</p></li>
<li><p>归档要提取到的目录，为位置参数;</p></li>
<li><p>可选的 <em>filter</em> 关键字参数，如果有提供给 <a class="reference internal" href="#shutil.unpack_archive" title="shutil.unpack_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack_archive()</span></code></a> 的话;</p></li>
<li><p>额外的关键字参数，由 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 元组组成的序列 <em>extra_args</em> 指明。</p></li>
</ul>
<p>可以提供 <em>description</em> 来描述该格式，它将被 <a class="reference internal" href="#shutil.get_unpack_formats" title="shutil.get_unpack_formats"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_unpack_formats()</span></code></a> 返回。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.unregister_unpack_format">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">unregister_unpack_format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="shutil.get_unpack_formats">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">get_unpack_formats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">extensions,</span> <span class="pre">description)</span></code>。</p>
<p>默认情况下 <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 提供以下格式:</p>
<ul class="simple">
<li><p><em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。</p></li>
<li><p><em>tar</em>: 未压缩的 tar 文件。</p></li>
<li><p><em>gztar</em>: gzip 压缩的 tar 文件（如果 <a class="reference internal" href="zlib.xhtml#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块可用）。</p></li>
<li><p><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a class="reference internal" href="bz2.xhtml#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 模块可用）。</p></li>
<li><p><em>xztar</em>: xz 压缩的 tar 文件（如果 <a class="reference internal" href="lzma.xhtml#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 模块可用）。</p></li>
</ul>
<p>你可以通过使用 <a class="reference internal" href="#shutil.register_unpack_format" title="shutil.register_unpack_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_unpack_format()</span></code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
</dd></dl>

<section id="archiving-example">
<span id="shutil-archiving-example"></span><h3>归档程序示例</h3>
<p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code class="file docutils literal notranslate"><span class="pre">.ssh</span></code> 目录下的所有文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">make_archive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">archive_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;myarchive&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;.ssh&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_archive</span><span class="p">(</span><span class="n">archive_name</span><span class="p">,</span> <span class="s1">&#39;gztar&#39;</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">)</span>
<span class="go">&#39;/Users/tarek/myarchive.tar.gz&#39;</span>
</pre></div>
</div>
<p>结果归档文件中包含有:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tar<span class="w"> </span>-tzvf<span class="w"> </span>/Users/tarek/myarchive.tar.gz
<span class="go">drwx------ tarek/staff       0 2010-02-01 16:23:40 ./</span>
<span class="go">-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys</span>
<span class="go">-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config</span>
<span class="go">-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa</span>
<span class="go">-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub</span>
<span class="go">-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa</span>
<span class="go">-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub</span>
<span class="go">-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts</span>
</pre></div>
</div>
</section>
<section id="archiving-example-with-base-dir">
<span id="shutil-archiving-example-with-basedir"></span><h3>使用 <em>base_dir</em> 的归档程序示例</h3>
<p>在这个例子中，与 <a class="reference internal" href="#shutil-archiving-example">上面的例子</a> 类似，我们演示了如何使用 <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_archive()</span></code></a>，但这次是使用 <em>base_dir</em>。 我们现在具有如下的目录结构:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tree<span class="w"> </span>tmp
<span class="go">tmp</span>
<span class="go">└── root</span>
<span class="go">    └── structure</span>
<span class="go">        ├── content</span>
<span class="go">            └── please_add.txt</span>
<span class="go">        └── do_not_add.txt</span>
</pre></div>
</div>
<p>在最终的归档中，应当会包括 <code class="file docutils literal notranslate"><span class="pre">please_add.txt</span></code>，但不应当包括 <code class="file docutils literal notranslate"><span class="pre">do_not_add.txt</span></code>。 因此我们使用以下代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">make_archive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">archive_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;myarchive&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_archive</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">archive_name</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;tar&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">root_dir</span><span class="o">=</span><span class="s1">&#39;tmp/root&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">base_dir</span><span class="o">=</span><span class="s1">&#39;structure/content&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&#39;/Users/tarek/my_archive.tar&#39;</span>
</pre></div>
</div>
<p>列出结果归档中的文件我们将会得到:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>-m<span class="w"> </span>tarfile<span class="w"> </span>-l<span class="w"> </span>/Users/tarek/myarchive.tar
<span class="go">structure/content/</span>
<span class="go">structure/content/please_add.txt</span>
</pre></div>
</div>
</section>
</section>
<section id="querying-the-size-of-the-output-terminal">
<h2>查询输出终端的尺寸</h2>
<dl class="py function">
<dt class="sig sig-object py" id="shutil.get_terminal_size">
<span class="sig-prename descclassname"><span class="pre">shutil.</span></span><span class="sig-name descname"><span class="pre">get_terminal_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(columns,</span> <span class="pre">lines)</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>获取终端窗口的尺寸。</p>
<p>对于两个维度中的每一个，会分别检查环境变量 <code class="docutils literal notranslate"><span class="pre">COLUMNS</span></code> 和 <code class="docutils literal notranslate"><span class="pre">LINES</span></code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p>
<p>如果未定义 <code class="docutils literal notranslate"><span class="pre">COLUMNS</span></code> 或 <code class="docutils literal notranslate"><span class="pre">LINES</span></code>，这是通常的情况，则连接到 <a class="reference internal" href="sys.xhtml#sys.__stdout__" title="sys.__stdout__"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.__stdout__</span></code></a> 的终端将通过发起调用 <a class="reference internal" href="os.xhtml#os.get_terminal_size" title="os.get_terminal_size"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_terminal_size()</span></code></a> 被查询。</p>
<p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 形参中给出的值。 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">(80,</span> <span class="pre">24)</span></code>，这是许多终端模拟器所使用的默认尺寸。</p>
<p>返回的值是一个 <a class="reference internal" href="os.xhtml#os.terminal_size" title="os.terminal_size"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.terminal_size</span></code></a> 类型的具名元组。</p>
<p>另请参阅: The Single UNIX Specification, Version 2, <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003">Other Environment Variables</a><span class="link-target"> [https://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003]</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>如果 <a class="reference internal" href="os.xhtml#os.get_terminal_size" title="os.get_terminal_size"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_terminal_size()</span></code></a> 返回零值则 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 值也将被使用。</p>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>