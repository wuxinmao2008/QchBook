<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="logging --- Python 的日志记录工具" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/logging.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/logging/__init__.py[https://github.com/python/cpython/tree/3.12/Lib/logging/__init__.py] Important: 此页面仅包含 API 参考信息。教程信息和更多高级用法的讨论，请参阅 基础教程, 进阶教程, 日志记录操作手册. 这个模块为应用与库实现了灵活的事件日志系统的函数与类。 使用标..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/logging/__init__.py[https://github.com/python/cpython/tree/3.12/Lib/logging/__init__.py] Important: 此页面仅包含 API 参考信息。教程信息和更多高级用法的讨论，请参阅 基础教程, 进阶教程, 日志记录操作手册. 这个模块为应用与库实现了灵活的事件日志系统的函数与类。 使用标..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>logging --- Python 的日志记录工具</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/logging.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-logging">
<span id="logging-logging-facility-for-python"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> --- Python 的日志记录工具</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/logging/__init__.py">Lib/logging/__init__.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/logging/__init__.py]</span></p>
<aside class="sidebar" id="index-0">
<p class="sidebar-title">Important</p>
<p>此页面仅包含 API 参考信息。教程信息和更多高级用法的讨论，请参阅</p>
<ul class="simple">
<li><p><a class="reference internal" href="../howto/logging.xhtml#logging-basic-tutorial"><span class="std std-ref">基础教程</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging.xhtml#logging-advanced-tutorial"><span class="std std-ref">进阶教程</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging-cookbook.xhtml#logging-cookbook"><span class="std std-ref">日志记录操作手册</span></a></p></li>
</ul>
</aside>
<hr class="docutils" />
<p>这个模块为应用与库实现了灵活的事件日志系统的函数与类。</p>
<p>使用标准库提供的 logging API 最主要的好处是，所有的 Python 模块都可能参与日志输出，包括你自己的日志消息和第三方模块的日志消息。</p>
<p>这是一个惯例用法的简单示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># myapp.py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">mylib</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;myapp.log&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Started&#39;</span><span class="p">)</span>
    <span class="n">mylib</span><span class="o">.</span><span class="n">do_something</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># mylib.py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">do_something</span><span class="p">():</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Doing something&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你运行 <em>myapp.py</em> ，你应该在 <em>myapp.log</em> 中看到：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INFO:__main__:Started
INFO:mylib:Doing something
INFO:__main__:Finished
</pre></div>
</div>
<p>这种惯常用法的一个关键特性在于大部分代码都是简单地通过 <code class="docutils literal notranslate"><span class="pre">getLogger(__name__)</span></code> 创建一个模块级别的日志记录器，并使用该日志记录器来完成任何需要的日志记录。 这样既简洁明了，又能根据需要对下游代码进行细粒度的控制。 记录到模块级日志记录器的消息会被转发给更高级别模块的日志记录器的处理器，一直到最高层级的日志记录器既根日志记录器；这种方式被称为分级日志记录。</p>
<p>要使日志记录有用，就需要对其进行配置：为每个日志记录器设置级别和目标，还可能改变特定模块的日志记录方式，通常是基于命令行参数或应用配置来实现。 在大多数情况下，如上文所述，只有根日志记录器需要如此配置，因为所有在模块层级上的低级别日志记录器最终都会将消息转发给它的处理器。 <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> 提供了一种配置根日志记录器的快捷方式，它可以处理多种应用场景。</p>
<p>这个模块提供许多强大而灵活的功能。如果对 logging 不太熟悉， 掌握它最好的方式就是查看它对应的教程（<strong>详见右侧的链接</strong>）。</p>
<p>该模块定义的基础类，以及它们的属性和方法都在下面的小节中列出。</p>
<ul class="simple">
<li><p>记录器暴露了应用程序代码直接使用的接口。</p></li>
<li><p>处理器将日志记录（由记录器创建）发送到适当的目标。</p></li>
<li><p>过滤器提供了更细粒度的功能，用于确定要输出的日志记录。</p></li>
<li><p>格式器指定最终输出中日志记录的样式。</p></li>
</ul>
<section id="logger-objects">
<span id="logger"></span><h2>记录器对象</h2>
<p>记录器有以下的属性和方法。注意 <em>永远</em> 不要直接实例化记录器，应当通过模块级别的函数 <code class="docutils literal notranslate"><span class="pre">logging.getLogger(name)</span></code> 。多次使用相同的名字调用 <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogger()</span></code></a> 会一直返回相同的 Logger 对象的引用。</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> is potentially a period-separated hierarchical value, like
<code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> (though it could also be just plain <code class="docutils literal notranslate"><span class="pre">foo</span></code>, for example).
Loggers that are further down in the hierarchical list are children of loggers
higher up in the list.  For example, given a logger with a name of <code class="docutils literal notranslate"><span class="pre">foo</span></code>,
loggers with names of <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>, and <code class="docutils literal notranslate"><span class="pre">foo.bam</span></code> are all
descendants of <code class="docutils literal notranslate"><span class="pre">foo</span></code>.  In addition, all loggers are descendants of the root
logger. The logger name hierarchy is analogous to the Python package hierarchy,
and identical to it if you organise your loggers on a per-module basis using
the recommended construction <code class="docutils literal notranslate"><span class="pre">logging.getLogger(__name__)</span></code>.  That's because
in a module, <code class="docutils literal notranslate"><span class="pre">__name__</span></code> is the module's name in the Python package namespace.</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Logger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Logger</span></span></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.name">
<span class="sig-name descname"><span class="pre">name</span></span></dt>
<dd><p>这是日志记录器的名称，也是传给 <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogger()</span></code></a> 用以获取日志记录器的值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>该属性应当被视为是只读的。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.level">
<span class="sig-name descname"><span class="pre">level</span></span></dt>
<dd><p>该日志记录器的阈值，由 <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 方法设置。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>请不要直接设置该值 —— 应当始终使用 <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a>，它会检查传入的级别。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.parent">
<span class="sig-name descname"><span class="pre">parent</span></span></dt>
<dd><p>此日志记录器的父日志记录器。它可能会根据命名空间层次结构中更高日志记录器的实例化而发生变化。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>该值应被视为只读 。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span></dt>
<dd><p>如果这个属性为真，记录到这个记录器的事件除了会发送到此记录器的所有处理程序外，还会传递给更高级别（祖先）记录器的处理器，此外任何关联到这个记录器的处理器。消息会直接传递给祖先记录器的处理器 —— 不考虑祖先记录器的级别和过滤器。</p>
<p>如果为假，记录消息将不会传递给当前记录器的祖先记录器的处理器。</p>
<p>举例说明：如果名为 <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> 的记录器的传播属性求值为真，则任何通过调用诸如 <code class="docutils literal notranslate"><span class="pre">logging.getLogger('A.B.C').error(...)</span></code> 之类的方法记录到 <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> 的事件，在第一次被传递到 <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> 上附加的处理器后，将[取决于传递该记录器的级别和过滤器设置]依次传递给附加到名为 <code class="docutils literal notranslate"><span class="pre">A.B</span></code>，<code class="docutils literal notranslate"><span class="pre">A</span></code> 的记录器和根记录器的所有处理器。如果 <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code>、<code class="docutils literal notranslate"><span class="pre">A.B</span></code>、<code class="docutils literal notranslate"><span class="pre">A</span></code> 组成的链中，任一记录器的 <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 属性设置为假，那么这将是最后一个其处理器会收到事件的记录器，此后传播在该点停止。</p>
<p>构造器将这个属性初始化为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你将一个处理器附加到一个记录器 <em>和</em> 其一个或多个祖先记录器，它可能发出多次相同的记录。通常，您不需要将一个处理器附加到一个以上的记录器上 —— 如果您将它附加到记录器层次结构中最高的适当记录器上，则它将看到所有后代记录器记录的所有事件，前提是它们的传播设置保留为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。一种常见的方案是仅将处理器附加到根记录器，通过传播来处理其余部分。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.handlers">
<span class="sig-name descname"><span class="pre">handlers</span></span></dt>
<dd><p>直接连接到此记录器的处理程序列表实例。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>该属性应被视为只读 ；通常通过 <a class="reference internal" href="#logging.Logger.addHandler" title="logging.Logger.addHandler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addHandler()</span></code></a> 和 <a class="reference internal" href="#logging.Logger.removeHandler" title="logging.Logger.removeHandler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removeHandler()</span></code></a> 方法进行更改，它们使用锁来确保线程安全的操作。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.disabled">
<span class="sig-name descname"><span class="pre">disabled</span></span></dt>
<dd><p>该属性禁用对任何事件的处理。初始化程序将其设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code> ，只有日志配置代码才能更改。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>该属性应当被视为是只读的。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.setLevel">
<span class="sig-name descname"><span class="pre">setLevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>给记录器设置阈值为 <em>level</em> 。日志等级小于 <em>level</em> 会被忽略。严重性为 <em>level</em> 或更高的日志消息将由该记录器的任何一个或多个处理器发出，除非将处理器的级别设置为比 <em>level</em> 更高的级别。</p>
<p>创建记录器时，级别默认设置为 <a class="reference internal" href="#logging.NOTSET" title="logging.NOTSET"><code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code></a> （当记录器是根记录器时，将处理所有消息；如果记录器不是根记录器，则将委托给父级）。请注意，根记录器的默认级别为 <a class="reference internal" href="#logging.WARNING" title="logging.WARNING"><code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code></a> 。</p>
<p>委派给父级的意思是如果一个记录器的级别设置为 NOTSET，将遍历其祖先记录器，直到找到级别不是 NOTSET 的记录器，或者到根记录器为止。</p>
<p>如果发现某个父级的级别不是 NOTSET ，那么该父级的级别将被视为发起搜索的记录器的有效级别，并用于确定如何处理日志事件。</p>
<p>如果搜索到达根记录器，并且其级别为 NOTSET，则将处理所有消息。否则，将使用根记录器的级别作为有效级别。</p>
<p>参见 <a class="reference internal" href="#levels"><span class="std std-ref">日志级别</span></a> 级别列表。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>现在 <em>level</em> 参数可以接受形如 'INFO' 的级别字符串表示形式，以代替形如 <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code></a> 的整数常量。 但是请注意，级别在内部存储为整数，并且 <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a> 和 <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a> 等方法的传入/返回值也为整数。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.isEnabledFor">
<span class="sig-name descname"><span class="pre">isEnabledFor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>指示此记录器是否将处理级别为 <em>level</em> 的消息。此方法首先检查由 <code class="docutils literal notranslate"><span class="pre">logging.disable(level)</span></code> 设置的模块级的级别，然后检查由 <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a> 确定的记录器的有效级别。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.getEffectiveLevel">
<span class="sig-name descname"><span class="pre">getEffectiveLevel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>指示此记录器的有效级别。如果通过 <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 设置了除 <a class="reference internal" href="#logging.NOTSET" title="logging.NOTSET"><code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code></a> 以外的值，则返回该值。否则，将层次结构遍历到根，直到找到除 <a class="reference internal" href="#logging.NOTSET" title="logging.NOTSET"><code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code></a> 以外的其他值，然后返回该值。返回的值是一个整数，通常为 <a class="reference internal" href="#logging.DEBUG" title="logging.DEBUG"><code class="xref py py-const docutils literal notranslate"><span class="pre">logging.DEBUG</span></code></a>、 <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code></a> 等等。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.getChild">
<span class="sig-name descname"><span class="pre">getChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回由后缀确定的该记录器的后代记录器。 因此，<code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc').getChild('def.ghi')</span></code> 与 <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc.def.ghi')</span></code> 将返回相同的记录器。 这是一个便捷方法，当使用如 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 而不是字符串字面值命名父记录器时很有用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.getChildren">
<span class="sig-name descname"><span class="pre">getChildren</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回由该日志记录器的直接下级日志记录器组成的集合。 举例来说 <code class="docutils literal notranslate"><span class="pre">logging.getLogger().getChildren()</span></code> 将返回包含名为 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 的日志记录器的集合，但名为 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 的日志记录器则不会包括在集合中。 类似地，<code class="docutils literal notranslate"><span class="pre">logging.getLogger('foo').getChildren()</span></code> 将返回包括名为 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 的日志记录器的集合，但不会包括名为 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 的日志记录器。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <a class="reference internal" href="#logging.DEBUG" title="logging.DEBUG"><code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code></a> 级别的消息。 <em>msg</em> 是消息格式字符串，而 <em>args</em> 是用于字符串格式化操作合并到 <em>msg</em> 的参数。（请注意，这意味着您可以在格式字符串中使用关键字以及单个字典参数。）当未提供 <em>args</em> 时，不会对 <em>msg</em> 执行 ％ 格式化操作。</p>
<p>在 <em>kwargs</em> 中会检查四个关键字参数： <em>exc_info</em> ，<em>stack_info</em> ，<em>stacklevel</em> 和 <em>extra</em> 。</p>
<p>如果 <em>exc_info</em> 的求值结果不为 false ，则它将异常信息添加到日志消息中。如果提供了一个异常元组（按照 <a class="reference internal" href="sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的格式）或一个异常实例，则它将被使用；否则，调用 <a class="reference internal" href="sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 以获取异常信息。</p>
<p>第二个可选关键字参数是 <em>stack_info</em>，默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。如果为  True，则将堆栈信息添加到日志消息中，包括实际的日志调用。请注意，这与通过指定 <em>exc_info</em> 显示的堆栈信息不同：前者是从堆栈底部到当前线程中的日志记录调用的堆栈帧，而后者是在搜索异常处理程序时，跟踪异常而打开的堆栈帧的信息。</p>
<p>您可以独立于 <em>exc_info</em> 来指定 <em>stack_info</em>，例如，即使在未引发任何异常的情况下，也可以显示如何到达代码中的特定点。堆栈帧在标题行之后打印：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>这模仿了显示异常帧时所使用的 <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> 。</p>
<p>第三个可选关键字参数是 <em>stacklevel</em> ，默认为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。如果大于 1 ，则在为日志记录事件创建的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 中计算行号和函数名时，将跳过相应数量的堆栈帧。可以在记录帮助器时使用它，以便记录的函数名称，文件名和行号不是帮助器的函数/方法的信息，而是其调用方的信息。此参数是 <a class="reference internal" href="warnings.xhtml#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块中的同名等效参数。</p>
<p>第四个关键字参数是 <em>extra</em> ，传递一个字典，该字典用于填充为日志记录事件创建的、带有用户自定义属性的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 中的 __dict__ 。然后可以按照需求使用这些自定义属性。例如，可以将它们合并到已记录的消息中：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(clientip)-15s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;tcpserver&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>输出类似于</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p>在The keys in the dictionary passed in <em>extra</em> 传入的字典的键不应与日志系统所使用的键相冲突。 （请参阅 <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 属性</span></a> 一节了解有关日志系统所使用的键的更多信息。）</p>
<p>如果在已记录的消息中使用这些属性，则需要格外小心。例如，在上面的示例中，<a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 已设置了格式字符串，其在 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 的属性字典中键值为 “clientip” 和 “user”。如果缺少这些内容，则将不会记录该消息，因为会引发字符串格式化异常。因此，在这种情况下，您始终需要使用 <em>extra</em> 字典传递这些键。</p>
<p>尽管这可能很烦人，但此功能旨在用于特殊情况，例如在多个上下文中执行相同代码的多线程服务器，并且出现的有趣条件取决于此上下文（例如在上面的示例中就是远程客户端IP地址和已验证用户名）。在这种情况下，很可能将专门的 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 与特定的 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 一起使用。</p>
<p>如果没有处理器附加到这个记录器（或者它的任何父辈记录器，考虑到相关的 <a class="reference internal" href="#logging.Logger.propagate" title="logging.Logger.propagate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Logger.propagate</span></code></a> 属性），消息将被发送到设置在 <a class="reference internal" href="#logging.lastResort" title="logging.lastResort"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lastResort</span></code></a> 的处理器。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <em>stack_info</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span><em>exc_info</em> 参数现在可以接受异常实例。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>stacklevel</em> 参数。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.info">
<span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code></a> 级别的消息。参数解释同 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.warning">
<span class="sig-name descname"><span class="pre">warning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <a class="reference internal" href="#logging.WARNING" title="logging.WARNING"><code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code></a> 级别的消息。参数解释同 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>There is an obsolete method <code class="docutils literal notranslate"><span class="pre">warn</span></code> which is functionally
identical to <code class="docutils literal notranslate"><span class="pre">warning</span></code>. As <code class="docutils literal notranslate"><span class="pre">warn</span></code> is deprecated, please do not use
it - use <code class="docutils literal notranslate"><span class="pre">warning</span></code> instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.error">
<span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <a class="reference internal" href="#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code></a> 级别的消息。参数解释同 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.critical">
<span class="sig-name descname"><span class="pre">critical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <a class="reference internal" href="#logging.CRITICAL" title="logging.CRITICAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code></a> 级别的消息。参数解释同 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <em>level</em> 整数代表的级别的消息。参数解释同 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.exception">
<span class="sig-name descname"><span class="pre">exception</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在此记录器上记录 <a class="reference internal" href="#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code></a> 级别的消息。参数解释同 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>。异常信息将添加到日志消息中。仅应从异常处理程序中调用此方法。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.addFilter">
<span class="sig-name descname"><span class="pre">addFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将指定的过滤器 <em>filter</em> 添加到此记录器。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.removeFilter">
<span class="sig-name descname"><span class="pre">removeFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从此记录器中删除指定的过滤器 <em>filter</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将此记录器的过滤器应用于记录，如果记录能被处理则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。过滤器会被依次使用，直到其中一个返回假值为止。如果它们都不返回假值，则记录将被处理（传递给处理器）。如果返回任一为假值，则不会对该记录做进一步处理。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.addHandler">
<span class="sig-name descname"><span class="pre">addHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdlr</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将指定的处理器 <em>hdlr</em> 添加到此记录器。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.removeHandler">
<span class="sig-name descname"><span class="pre">removeHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdlr</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从此记录器中删除指定的处理器 <em>hdlr</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.findCaller">
<span class="sig-name descname"><span class="pre">findCaller</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stack_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stacklevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>查找调用源的文件名和行号，以 文件名，行号，函数名称和堆栈信息 4元素元组的形式返回。堆栈信息将返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，除非 <em>stack_info</em> 为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<p><em>stacklevel</em> 参数用于调用 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> 和其他 API。如果大于 1，则多余部分将用于跳过堆栈帧，然后再确定要返回的值。当从帮助器/包装器代码调用日志记录 API 时，这通常很有用，以便事件日志中的信息不是来自帮助器/包装器代码，而是来自调用它的代码。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.handle">
<span class="sig-name descname"><span class="pre">handle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通过将记录传递给与此记录器及其祖先关联的所有处理器来处理（直到某个 <em>propagate</em> 值为 false）。此方法用于从套接字接收的未序列化的以及在本地创建的记录。使用 <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 进行记录器级别过滤。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.makeRecord">
<span class="sig-name descname"><span class="pre">makeRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这是一种工厂方法，可以在子类中对其进行重写以创建专门的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.hasHandlers">
<span class="sig-name descname"><span class="pre">hasHandlers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>检查此记录器是否配置了任何处理器。通过在此记录器及其记录器层次结构中的父级中查找处理器完成此操作。如果找到处理器则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。只要找到 “propagate” 属性设置为假值的记录器，该方法就会停止搜索层次结构 —— 其将是最后一个检查处理器是否存在的记录器。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>现在可以对处理器进行序列化和反序列化。</p>
</div>
</dd></dl>

</section>
<section id="logging-levels">
<span id="levels"></span><h2>日志级别</h2>
<p>日志记录级别的数值在下表中给出。如果你想要定义自己的级别，并且需要它们具有相对于预定义级别的特定值，那么这你可能对以下内容感兴趣。如果你定义具有相同数值的级别，它将覆盖预定义的值；预定义的名称将失效。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>级别</p></th>
<th class="head"><p>数值</p></th>
<th class="head"><p>何种含义 / 何时使用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="logging.NOTSET">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">NOTSET</span></span></dt>
<dd></dd></dl>

</td>
<td><p>0</p></td>
<td><p>当在日志记录器上设置时，表示将查询上级日志记录器以确定生效的级别。 如果仍被解析为 <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code>，则会记录所有事件。 在处理器上设置时，所有事件都将被处理。</p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="logging.DEBUG">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">DEBUG</span></span></dt>
<dd></dd></dl>

</td>
<td><p>10</p></td>
<td><p>详细的信息，通常只有试图诊断问题的开发人员才会感兴趣。</p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="logging.INFO">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">INFO</span></span></dt>
<dd></dd></dl>

</td>
<td><p>20</p></td>
<td><p>确认程序按预期运行。</p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="logging.WARNING">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">WARNING</span></span></dt>
<dd></dd></dl>

</td>
<td><p>30</p></td>
<td><p>表明发生了意外情况，或近期有可能发生问题（例如‘磁盘空间不足’）。 软件仍会按预期工作。</p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="logging.ERROR">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">ERROR</span></span></dt>
<dd></dd></dl>

</td>
<td><p>40</p></td>
<td><p>由于严重的问题，程序的某些功能已经不能正常执行</p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="logging.CRITICAL">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">CRITICAL</span></span></dt>
<dd></dd></dl>

</td>
<td><p>50</p></td>
<td><p>严重的错误，表明程序已不能继续执行</p></td>
</tr>
</tbody>
</table>
</section>
<section id="handler-objects">
<span id="handler"></span><h2>处理器对象</h2>
<p>处理器具有以下属性和方法。 请注意 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 不可直接实例化；该类是被作为更有用的子类的基类。 不过，子类中的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法需要调用 <a class="reference internal" href="#logging.Handler.__init__" title="logging.Handler.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Handler.__init__()</span></code></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Handler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Handler</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">NOTSET</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>初始化 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 实例时，需要设置它的级别，将过滤列表置为空，并且创建锁（通过 <a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a> ）来序列化对 I/O 的访问。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.createLock">
<span class="sig-name descname"><span class="pre">createLock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>初始化一个线程锁，用来序列化对底层的 I/O 功能的访问，底层的 I/O 功能可能不是线程安全的。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.acquire">
<span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>获取由 <a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a> 创建的线程锁。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>释放由 <a class="reference internal" href="#logging.Handler.acquire" title="logging.Handler.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> 获取的线程锁。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.setLevel">
<span class="sig-name descname"><span class="pre">setLevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>给处理器设置阈值为 <em>level</em> 。日志级别小于 <em>level</em> 将被忽略。创建处理器时，日志级别被设置为 <a class="reference internal" href="#logging.NOTSET" title="logging.NOTSET"><code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code></a> （所有的消息都会被处理）。</p>
<p>参见 <a class="reference internal" href="#levels"><span class="std std-ref">日志级别</span></a> 级别列表。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span><em>level</em> 形参现在接受像 'INFO' 这样的字符串形式的级别表达方式，也可以使用像 <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code></a> 这样的整数常量。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.setFormatter">
<span class="sig-name descname"><span class="pre">setFormatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将此处理器的 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 设置为 <em>fmt</em>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.addFilter">
<span class="sig-name descname"><span class="pre">addFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将指定的过滤器 <em>filter</em> 添加到此处理器。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.removeFilter">
<span class="sig-name descname"><span class="pre">removeFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从此处理器中删除指定的过滤器 <em>filter</em> 。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将此处理器的过滤器应用于记录，在要处理记录时返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。依次查询过滤器，直到其中一个返回假值为止。如果它们都不返回假值，则将发出记录。如果返回一个假值，则处理器将不会发出记录。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.flush">
<span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>确保所有日志记录从缓存输出。此版本不执行任何操作，并且应由子类实现。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>回收处理器使用的所有资源。此版本不输出，但从内部处理器列表中删除处理器，内部处理器在 <a class="reference internal" href="#logging.shutdown" title="logging.shutdown"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutdown()</span></code></a> 被调用时关闭 。子类应确保从重写的 <a class="reference internal" href="#logging.Handler.close" title="logging.Handler.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法中调用此方法。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.handle">
<span class="sig-name descname"><span class="pre">handle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>经已添加到处理器的过滤器过滤后，有条件地发出指定的日志记录。用获取/释放 I/O 线程锁包装了记录的实际发出行为。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.handleError">
<span class="sig-name descname"><span class="pre">handleError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此方法应当在 <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 调用期间遇到异常时从处理器中调用。 如果模块级属性 <a class="reference internal" href="#logging.raiseExceptions" title="logging.raiseExceptions"><code class="xref py py-data docutils literal notranslate"><span class="pre">raiseExceptions</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则异常将被静默地忽略。 这是大多数情况下日志系统所需要的 —— 大多数用户不会关心日志系统中的错误，他们对应用程序错误更感兴趣。 但是，你可以根据需要将其替换为自定义处理器。 指定的记录是发生异常时正在处理的记录。  (<a class="reference internal" href="#logging.raiseExceptions" title="logging.raiseExceptions"><code class="xref py py-data docutils literal notranslate"><span class="pre">raiseExceptions</span></code></a> 的默认值是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，因为这在开发过程中更有用处）。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果设置了格式器则用其对记录进行格式化。否则，使用模块的默认格式器。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.emit">
<span class="sig-name descname"><span class="pre">emit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>执行实际记录给定日志记录所需的操作。这个版本应由子类实现，因此这里直接引发 <a class="reference internal" href="exceptions.xhtml#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 异常。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>此方法会在获得一个处理器层级的锁之后被调用，在此方法返回之后锁将被释放。 当你重写此方法时，请注意在调用任何可能执行锁定操作的日志记录 API 的其他部分的方法时务必小心谨慎，因为这可能会导致死锁。 具体来说:</p>
<ul class="simple">
<li><p>日志记录配置 API 会获取模块层级锁，然后还会在配置处理器时获取处理器层级锁。</p></li>
<li><p>许多日志记录 API 都会锁定模块级锁。 如果这样的 API 在此方法中被调用，则它可能会在另一个线程执行配置调用时导致死锁，因为那个线程将试图在处理器级锁 <em>之前</em> 获取模块级锁，而这个线程将试图在处理器级锁 <em>之后</em> 获取模块级锁（因为在此方法中，处理器级锁已经被获取了）。</p></li>
</ul>
</div>
</dd></dl>

</dd></dl>

<p>有关作为标准随附的处理器列表，请参见 <a class="reference internal" href="logging.handlers.xhtml#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a>。</p>
</section>
<section id="formatter-objects">
<span id="id1"></span><h2>格式器对象</h2>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Formatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Formatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datefmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'%'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defaults</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>负责将一个 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 转换为可供人类或外部系统解读的输出字符串。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fmt</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 用于日志记录整体输出的给定 <em>style</em> 形式的格式字符串。 可用的映射键将从 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 对象的 <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 属性</span></a> 中提取。 如果未指定，则将使用 <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code>，即已记录的日志消息。</p></li>
<li><p><strong>datefmt</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 用于日志记录输出的日期/时间部分的给定 <em>style</em> 形式的格式字符串。 如果未指定，则将使用 <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> 中描述的默认值。</p></li>
<li><p><strong>style</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 可以是 <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">'{'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'$'</span></code> 之一并决定格式字符串将如何与数据合并: 使用 <a class="reference internal" href="stdtypes.xhtml#old-string-formatting"><span class="std std-ref">printf 风格的字符串格式化</span></a> (<code class="docutils literal notranslate"><span class="pre">%</span></code>), <a class="reference internal" href="stdtypes.xhtml#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">{</span></code>) 或 <a class="reference internal" href="string.xhtml#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> (<code class="docutils literal notranslate"><span class="pre">$</span></code>) 之一。 这将只应用于 <em>fmt</em> 和 <em>datefmt</em> (例如 <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'{message}'</span></code>)，而不会应用于传给日志记录方法的实际日志消息。 但是，也存在 <a class="reference internal" href="../howto/logging-cookbook.xhtml#formatting-styles"><span class="std std-ref">其他方式</span></a> 可以为日志消息使用 <code class="docutils literal notranslate"><span class="pre">{</span></code> 和 <code class="docutils literal notranslate"><span class="pre">$</span></code> 格式化。</p></li>
<li><p><strong>validate</strong> (<a class="reference internal" href="functions.xhtml#bool" title="bool"><em>bool</em></a>) -- 如果为 <code class="docutils literal notranslate"><span class="pre">True</span></code> (默认值)，则不正确或不匹配的 <em>fmt</em> 和 <em>style</em> 将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>；例如 <code class="docutils literal notranslate"><span class="pre">logging.Formatter('%(asctime)s</span> <span class="pre">-</span> <span class="pre">%(message)s',</span> <span class="pre">style='{')</span></code>。</p></li>
<li><p><strong>defaults</strong> (<a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><em>dict</em></a><em>[</em><a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a><em>, </em><em>Any</em><em>]</em>) -- 一个由在自定义字段中使用的默认值组成的字典。 例如 <code class="docutils literal notranslate"><span class="pre">logging.Formatter('%(ip)s</span> <span class="pre">%(message)s',</span> <span class="pre">defaults={&quot;ip&quot;:</span> <span class="pre">None})</span></code></p></li>
</ul>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <em>style</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>validate</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <em>defaults</em> 形参。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>记录的属性字典被用作字符串格式化操作的操作数。 返回结果字符串。 在格式化该字典之前，会执行几个预备步骤。 记录的 <em>message</em> 属性是用 <em>msg</em> % <em>args</em> 来计算的。 如果格式化字符串包含 <code class="docutils literal notranslate"><span class="pre">'(asctime)'</span></code>，则会调用 <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> 来格式化事件时间。 如果有异常信息，则使用 <a class="reference internal" href="#logging.Formatter.formatException" title="logging.Formatter.formatException"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatException()</span></code></a> 将其格式化并添加到消息中。 请注意已格式化的异常信息会缓存在 <em>exc_text</em> 属性中。 这很有用因为异常信息可以被 pickle 并通过网络发送，但是如果你有不止一个对异常信息进行定制的 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 子类则应当小心。 在这种情况下，你必须在一个格式化器完成格式化后清空缓存的值 (通过将 <em>exc_text</em> 属性设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)，以便下一个处理事件的格式化器不会使用缓存的值，而是重新计算它。</p>
<p>如果栈信息可用，它将被添加在异常信息之后，如有必要请使用 <a class="reference internal" href="#logging.Formatter.formatStack" title="logging.Formatter.formatStack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatStack()</span></code></a> 来转换它。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.formatTime">
<span class="sig-name descname"><span class="pre">formatTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datefmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此方法应由想要使用格式化时间的格式器中的 <a class="reference internal" href="functions.xhtml#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> 调用。可以在格式器中重写此方法以提供任何特定要求，但是基本行为如下：如果指定了 <em>datefmt</em> （字符串），则将其用于 <a class="reference internal" href="time.xhtml#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 来格式化记录的创建时间。否则，使用格式 '%Y-%m-%d %H:%M:%S,uuu'，其中 uuu 部分是毫秒值，其他字母根据 <a class="reference internal" href="time.xhtml#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 文档。这种时间格式的示例为 <code class="docutils literal notranslate"><span class="pre">2003-01-23</span> <span class="pre">00:29:50,411</span></code>。返回结果字符串。</p>
<p>此函数使用一个用户可配置函数将创建时间转换为元组。 默认情况下，使用 <a class="reference internal" href="time.xhtml#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a>；要为特定格式化程序实例更改此项，请将实例的 <code class="docutils literal notranslate"><span class="pre">converter</span></code> 属性设为具有与 <a class="reference internal" href="time.xhtml#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> 或 <a class="reference internal" href="time.xhtml#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.gmtime()</span></code></a> 相同签名的函数。 要为所有格式化程序更改此项，例如当你希望所有日志时间都显示为 GMT，请在 <code class="docutils literal notranslate"><span class="pre">Formatter</span></code> 类中设置 <code class="docutils literal notranslate"><span class="pre">converter</span></code> 属性。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>在之前版本中，默认格式是被硬编码的，例如这个例子: <code class="docutils literal notranslate"><span class="pre">2010-09-06</span> <span class="pre">22:38:15,292</span></code> 其中逗号之前的部分由 strptime 格式字符串 (<code class="docutils literal notranslate"><span class="pre">'%Y-%m-%d</span> <span class="pre">%H:%M:%S'</span></code>) 处理，而逗号之后的部分为毫秒值。 因为 strptime 没有表示毫秒的占位符，毫秒值使用了另外的格式字符串来添加 <code class="docutils literal notranslate"><span class="pre">'%s,%03d'</span></code> --- 这两个格式字符串代码都是硬编码在该方法中的。 经过修改，这些字符串被定义为类层级的属性，当需要时可以在实例层级上被重写。 属性的名称为 <code class="docutils literal notranslate"><span class="pre">default_time_format</span></code> (用于 strptime 格式字符串) 和 <code class="docutils literal notranslate"><span class="pre">default_msec_format</span></code> (用于添加毫秒值)。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">default_msec_format</span></code> 可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.formatException">
<span class="sig-name descname"><span class="pre">formatException</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exc_info</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将指定的异常信息（由 <a class="reference internal" href="sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的标准异常元组）格式化为字符串。默认实现只是使用了 <a class="reference internal" href="traceback.xhtml#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_exception()</span></code></a>。 结果字符串将被返回。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.formatStack">
<span class="sig-name descname"><span class="pre">formatStack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stack_info</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将指定的堆栈信息（由 <a class="reference internal" href="traceback.xhtml#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a> 返回的字符串，但移除末尾的换行符）格式化为字符串。 默认实现只是返回输入值。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="logging.BufferingFormatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">BufferingFormatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linefmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>适合用来在你想要格式化多条记录时进行子类化的格式化器。 你可以传入一个 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 实例用来格式化每一行（每一行对应一条记录）。 如果未被指定，则会使用默认的格式化器（仅输出事件消息）作为行格式化器。</p>
<dl class="py method">
<dt class="sig sig-object py" id="logging.BufferingFormatter.formatHeader">
<span class="sig-name descname"><span class="pre">formatHeader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">records</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>为 <em>records</em> 列表返回一个标头。 基本实现只是返回空字符串。 如果你想要指明特定行为则需要重写此方法，例如显示记录条数、标题或分隔行等。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.BufferingFormatter.formatFooter">
<span class="sig-name descname"><span class="pre">formatFooter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">records</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>为 <em>records</em> 列表返回一个结束标记。 基本实现只是返回空字符串。 如果你想要指明特定行为则需要重写此方法，例如显示记录条数或分隔行等。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.BufferingFormatter.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">records</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>为 <em>records</em> 列表返回已格式化文本。 基本实现在没有记录时只是返回空字符串；在其他情况下，它将返回标头、使用行格式化器执行格式化的每行记录以及结束标记。</p>
</dd></dl>

</dd></dl>

</section>
<section id="filter-objects">
<span id="filter"></span><h2>过滤器对象</h2>
<p><code class="docutils literal notranslate"><span class="pre">Filters</span></code> 可被 <code class="docutils literal notranslate"><span class="pre">Handlers</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Loggers</span></code> 用来实现比按层级提供更复杂的过滤操作。 基本过滤器类只允许低于日志记录器层级结构中低于特定层级的事件。 例如，一个用 'A.B' 初始化的过滤器将允许 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' 等日志记录器所记录的事件。 但 'A.BB', 'B.A.B' 等则不允许。 如果用空字符串初始化，则所有事件都会通过。</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Filter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> 类的实例。 如果指定了 <em>name</em>，则它将被用来为日志记录器命名，该类及其子类将通过该过滤器允许指定事件通过。 如果 <em>name</em> 为空字符串，则允许所有事件通过。</p>
<dl class="py method">
<dt class="sig sig-object py" id="logging.Filter.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>指定的记录是否会被写入日志？否则返回假值，是则返回真值。 过滤器可以原地修改日志记录或者返回完全不同的记录实例并在该事件未来的任何处理过程中用它来替代原始日志记录。</p>
</dd></dl>

</dd></dl>

<p>请注意关联到处理器的过滤器会在事件由处理器发出之前被查询，而关联到日志记录器的过滤器则会在有事件被记录的的任何时候（使用 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a> 等等）在将事件发送给处理器之前被查询。 这意味着由后代日志记录器生成的事件将不会被父代日志记录器的过滤器设置所过滤，除非该过滤器也已被应用于后代日志记录器。</p>
<p>你实际上不需要子类化 <code class="docutils literal notranslate"><span class="pre">Filter</span></code> ：你可以传入任何一个包含有相同语义的 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 方法的实例。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>你不需要创建专门的 <code class="docutils literal notranslate"><span class="pre">Filter</span></code> 类，或使用具有 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 方法的其他类：你可以使用一个函数（或其他可调用对象）作为过滤器。 过滤逻辑将检查过滤器对象是否具有 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 属性：如果有，就会将它当作是 <code class="docutils literal notranslate"><span class="pre">Filter</span></code> 并调用它的 <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 方法。 在其他情况下，则会将它当作是可调用对象并将记录作为唯一的形参进行调用。 返回值应当与 <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 的返回值相一致。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在你可以从过滤器返回一个 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例来替代日志记录而不是原地修改它。 这允许附加到特定 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 的过滤器在日志记录发出之前修改它，而不会对其他处理器产生附带影响。</p>
</div>
<p>尽管过滤器主要被用来构造比层级更复杂的规则以过滤记录，但它们可以查看由它们关联的处理器或记录器所处理的每条记录：当你想要执行统计特定记录器或处理器共处理了多少条记录，或是在所处理的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 中添加、修改或移除属性这样的任务时该特性将很有用处。 显然改变 LogRecord 时需要相当小心，但将上下文信息注入日志确实是被允许的 (参见 <a class="reference internal" href="../howto/logging-cookbook.xhtml#filters-contextual"><span class="std std-ref">使用过滤器传递上下文信息</span></a>)。</p>
</section>
<section id="logrecord-objects">
<span id="log-record"></span><h2>LogRecord 属性</h2>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例是每当有日志被记录时由 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 自动创建的，并且可通过 <a class="reference internal" href="#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> 手动创建（例如根据从网络接收的已封存事件创建）。</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.LogRecord">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">LogRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lineno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>包含与被记录的事件相关的所有信息。</p>
<p>主要信息是在 <em>msg</em> 中 <em>args</em> 传递的，它们使用 <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> 组合到一起以创建记录的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code> 属性。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 用于记录此 <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code> 所表示事件的记录器名称。 请注意 <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code> 中的记录器名称将始终为该值，即使它可能是由附加到不同（上级）日志记录器的处理器所发出的。</p></li>
<li><p><strong>level</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 日志记录事件的 <a class="reference internal" href="#levels"><span class="std std-ref">数字层级</span></a> (如 <code class="docutils literal notranslate"><span class="pre">10</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="docutils literal notranslate"><span class="pre">20</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">INFO</span></code> 等等)。 请注意这会转换为 LogRecord 的 <em>两个</em> 属性: <code class="xref py py-attr docutils literal notranslate"><span class="pre">levelno</span></code> 表示数字值而 <code class="xref py py-attr docutils literal notranslate"><span class="pre">levelname</span></code> 表示对应的层级名。</p></li>
<li><p><strong>pathname</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a>) -- 日志记录调用所在源文件的完整路径字符串。</p></li>
<li><p><strong>lineno</strong> (<a class="reference internal" href="functions.xhtml#int" title="int"><em>int</em></a>) -- 记录调用所在源文件中的行号。</p></li>
<li><p><strong>msg</strong> (<a class="reference internal" href="typing.xhtml#typing.Any" title="typing.Any"><em>Any</em></a>) -- 事件描述消息，这可以是一个带有 % 形式可变数据占位符的格式字符串，或是任意对象 (参见 <a class="reference internal" href="../howto/logging.xhtml#arbitrary-object-messages"><span class="std std-ref">使用任意对象作为消息</span></a>)。</p></li>
<li><p><strong>args</strong> (<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><em>tuple</em></a><em> | </em><a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><em>dict</em></a><em>[</em><a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a><em>, </em><a class="reference internal" href="typing.xhtml#typing.Any" title="typing.Any"><em>Any</em></a><em>]</em>) -- 要合并到 <em>msg</em> 参数以获得事件描述的可变数据。</p></li>
<li><p><strong>exc_info</strong> (<a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><em>tuple</em></a><em>[</em><a class="reference internal" href="functions.xhtml#type" title="type"><em>type</em></a><em>[</em><a class="reference internal" href="exceptions.xhtml#BaseException" title="BaseException"><em>BaseException</em></a><em>]</em><em>, </em><a class="reference internal" href="exceptions.xhtml#BaseException" title="BaseException"><em>BaseException</em></a><em>, </em><a class="reference internal" href="types.xhtml#types.TracebackType" title="types.TracebackType"><em>types.TracebackType</em></a><em>] </em><em>| </em><em>None</em>) -- 包含当前异常信息的异常元组，就如 <a class="reference internal" href="sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 所返回的，或者如果没有可用异常信息则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
<li><p><strong>func</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a><em> | </em><em>None</em>) -- 发起调用日志记录调用的函数或方法名称。</p></li>
<li><p><strong>sinfo</strong> (<a class="reference internal" href="stdtypes.xhtml#str" title="str"><em>str</em></a><em> | </em><em>None</em>) -- 一个文本字符串，表示当前线程中从堆栈底部直到日志记录调用的堆栈信息。</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="logging.LogRecord.getMessage">
<span class="sig-name descname"><span class="pre">getMessage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>在将 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例与任何用户提供的参数合并之后，返回此实例的消息。 如果用户提供给日志记录调用的消息参数不是字符串，则会在其上调用 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 以将它转换为字符串。 此方法允许将用户定义的类用作消息，类的 <code class="docutils literal notranslate"><span class="pre">__str__</span></code> 方法可以返回要使用的实际格式字符串。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>通过提供用于创建记录的工厂方法已使得 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 的创建更易于配置。 该工厂方法可使用 <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a> 和 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> （在此可查看工厂方法的签名）来设置。</p>
</div>
<p>在创建时可使用此功能将你自己的值注入 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>。 你可以使用以下模式:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">old_factory</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogRecordFactory</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">record_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">old_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">record</span><span class="o">.</span><span class="n">custom_attribute</span> <span class="o">=</span> <span class="mh">0xdecafbad</span>
    <span class="k">return</span> <span class="n">record</span>

<span class="n">logging</span><span class="o">.</span><span class="n">setLogRecordFactory</span><span class="p">(</span><span class="n">record_factory</span><span class="p">)</span>
</pre></div>
</div>
<p>通过此模式，多个工厂方法可以被链接起来，并且只要它们不重写彼此的属性或是在无意中覆盖了上面列出的标准属性，就不会发生意外。</p>
</dd></dl>

</section>
<section id="logrecord-attributes">
<span id="id2"></span><h2>LogRecord 属性</h2>
<p>LogRecord 具有许多属性，它们大多数来自于传递给构造器的形参。 （请注意 LogRecord 构造器形参与 LogRecord 属性的名称并不总是完全彼此对应的。） 这些属性可被用于将来自记录的数据合并到格式字符串中。 下面的表格（按字母顺序）列出了属性名称、它们的含义以及相应的 %-style 格式字符串内占位符。</p>
<p>如果是使用 {}-格式化（<a class="reference internal" href="stdtypes.xhtml#str.format" title="str.format"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.format()</span></code></a>），你可以将 <code class="docutils literal notranslate"><span class="pre">{attrname}</span></code> 用作格式字符串内的占位符。 如果是使用 $-格式化（<a class="reference internal" href="string.xhtml#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a>），则会使用 <code class="docutils literal notranslate"><span class="pre">${attrname}</span></code> 的形式。 当然在这两种情况下，都应当将 <code class="docutils literal notranslate"><span class="pre">attrname</span></code> 替换为你想要使用的实际属性名称。</p>
<p>在 {}-格式化的情况下，你可以在属性名称之后放置指定的格式化旗标，并用冒号来分隔。 例如：占位符 <code class="docutils literal notranslate"><span class="pre">{msecs:03.0f}</span></code> 会将毫秒值 <code class="docutils literal notranslate"><span class="pre">4</span></code> 格式化为 <code class="docutils literal notranslate"><span class="pre">004</span></code>。 有参看 <a class="reference internal" href="stdtypes.xhtml#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 文档了解你可以使用的选项的详情。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>属性名称</p></th>
<th class="head"><p>格式</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>args</p></td>
<td><p>此属性不需要用户进行格式化。</p></td>
<td><p>合并到 <code class="docutils literal notranslate"><span class="pre">msg</span></code> 以产生 <code class="docutils literal notranslate"><span class="pre">message</span></code> 的包含参数的元组，或是其中的值将被用于合并的字典（当只有一个参数且其类型为字典时）。</p></td>
</tr>
<tr class="row-odd"><td><p>asctime</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(asctime)s</span></code></p></td>
<td><p>表示人类易读的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 生成时间。 默认形式为 '2003-07-08 16:49:45,896' （逗号之后的数字为时间的毫秒部分）。</p></td>
</tr>
<tr class="row-even"><td><p>created</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(created)f</span></code></p></td>
<td><p>Time when the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> was created
(as returned by <a class="reference internal" href="time.xhtml#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a>).</p></td>
</tr>
<tr class="row-odd"><td><p>exc_info</p></td>
<td><p>此属性不需要用户进行格式化。</p></td>
<td><p>异常元组（例如 <code class="docutils literal notranslate"><span class="pre">sys.exc_info</span></code>）或者如未发生异常则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p>文件名</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(filename)s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pathname</span></code> 的文件名部分。</p></td>
</tr>
<tr class="row-odd"><td><p>funcName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(funcName)s</span></code></p></td>
<td><p>函数名包括调用日志记录.</p></td>
</tr>
<tr class="row-even"><td><p>levelname</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code></p></td>
<td><p>消息文本记录级别（<code class="docutils literal notranslate"><span class="pre">'DEBUG'</span></code>，<code class="docutils literal notranslate"><span class="pre">'INFO'</span></code>，<code class="docutils literal notranslate"><span class="pre">'WARNING'</span></code>，<code class="docutils literal notranslate"><span class="pre">'ERROR'</span></code>，<code class="docutils literal notranslate"><span class="pre">'CRITICAL'</span></code>）。</p></td>
</tr>
<tr class="row-odd"><td><p>levelno</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(levelno)s</span></code></p></td>
<td><p>消息数字的记录级别 (<a class="reference internal" href="#logging.DEBUG" title="logging.DEBUG"><code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code></a>, <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code></a>, <a class="reference internal" href="#logging.WARNING" title="logging.WARNING"><code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code></a>, <a class="reference internal" href="#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code></a>, <a class="reference internal" href="#logging.CRITICAL" title="logging.CRITICAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code></a>).</p></td>
</tr>
<tr class="row-even"><td><p>lineno</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(lineno)d</span></code></p></td>
<td><p>发出日志记录调用所在的源行号（如果可用）。</p></td>
</tr>
<tr class="row-odd"><td><p>message</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(message)s</span></code></p></td>
<td><p>记入日志的消息，即 <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> 的结果。 这是在发起调用 <a class="reference internal" href="#logging.Formatter.format" title="logging.Formatter.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Formatter.format()</span></code></a> 时设置的。</p></td>
</tr>
<tr class="row-even"><td><p>module</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(module)s</span></code></p></td>
<td><p>模块 (<code class="docutils literal notranslate"><span class="pre">filename</span></code> 的名称部分)。</p></td>
</tr>
<tr class="row-odd"><td><p>msecs</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(msecs)d</span></code></p></td>
<td><p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 被创建的时间的毫秒部分。</p></td>
</tr>
<tr class="row-even"><td><p>msg</p></td>
<td><p>此属性不需要用户进行格式化。</p></td>
<td><p>在原始日志记录调用中传入的格式字符串。 与 <code class="docutils literal notranslate"><span class="pre">args</span></code> 合并以产生 <code class="docutils literal notranslate"><span class="pre">message</span></code>，或是一个任意对象 (参见 <a class="reference internal" href="../howto/logging.xhtml#arbitrary-object-messages"><span class="std std-ref">使用任意对象作为消息</span></a>)。</p></td>
</tr>
<tr class="row-odd"><td><p>name</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(name)s</span></code></p></td>
<td><p>用于记录调用的日志记录器名称。</p></td>
</tr>
<tr class="row-even"><td><p>pathname</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(pathname)s</span></code></p></td>
<td><p>发出日志记录调用的源文件的完整路径名（如果可用）。</p></td>
</tr>
<tr class="row-odd"><td><p>process</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(process)d</span></code></p></td>
<td><p>进程ID（如果可用）</p></td>
</tr>
<tr class="row-even"><td><p>processName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(processName)s</span></code></p></td>
<td><p>进程名（如果可用）</p></td>
</tr>
<tr class="row-odd"><td><p>relativeCreated</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(relativeCreated)d</span></code></p></td>
<td><p>以毫秒数表示的 LogRecord 被创建的时间，即相对于 logging 模块被加载时间的差值。</p></td>
</tr>
<tr class="row-even"><td><p>stack_info</p></td>
<td><p>此属性不需要用户进行格式化。</p></td>
<td><p>当前线程中从堆栈底部起向上直到包括日志记录调用并引发创建当前记录堆栈帧创建的堆栈帧信息（如果可用）。</p></td>
</tr>
<tr class="row-odd"><td><p>thread</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(thread)d</span></code></p></td>
<td><p>线程ID（如果可用）</p></td>
</tr>
<tr class="row-even"><td><p>threadName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(threadName)s</span></code></p></td>
<td><p>线程名（如果可用）</p></td>
</tr>
<tr class="row-odd"><td><p>taskName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(taskName)s</span></code></p></td>
<td><p><a class="reference internal" href="asyncio-task.xhtml#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> 名称（如果可用）。</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span>添加了 <em>processName</em></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>添加了 <em>taskName</em>。</p>
</div>
</section>
<section id="loggeradapter-objects">
<span id="logger-adapter"></span><h2>LoggerAdapter 对象</h2>
<p><a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 实例会被用来方便地将上下文信息传入日志记录调用。 要获取用法示例，请参阅 <a class="reference internal" href="../howto/logging-cookbook.xhtml#context-info"><span class="std std-ref">添加上下文信息到你的日志记录输出</span></a> 部分。</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.LoggerAdapter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">LoggerAdapter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns an instance of <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> initialized with an
underlying <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> instance and a dict-like object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="logging.LoggerAdapter.process">
<span class="sig-name descname"><span class="pre">process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>修改传递给日志记录调用的消息和/或关键字参数以便插入上下文信息。 此实现接受以 <em>extra</em> 形式传给构造器的对象并使用 'extra' 键名将其加入 <em>kwargs</em>。 返回值为一个 (<em>msg</em>, <em>kwargs</em>) 元组，其包含（可能经过修改的）传入参数。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.LoggerAdapter.manager">
<span class="sig-name descname"><span class="pre">manager</span></span></dt>
<dd><p>在 <em>logger</em> 中委托给下层的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">manager`</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.LoggerAdapter._log">
<span class="sig-name descname"><span class="pre">_log</span></span></dt>
<dd><p>在 <em>logger</em> 中委托给下层的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_log`()</span></code> 方法。</p>
</dd></dl>

<p>在上述方法之外，<a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 还支持 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 的下列方法: <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.Logger.info" title="logging.Logger.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>，<a class="reference internal" href="#logging.Logger.warning" title="logging.Logger.warning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warning()</span></code></a>，<a class="reference internal" href="#logging.Logger.error" title="logging.Logger.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a>, <a class="reference internal" href="#logging.Logger.exception" title="logging.Logger.exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exception()</span></code></a>, <a class="reference internal" href="#logging.Logger.critical" title="logging.Logger.critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">critical()</span></code></a>，<a class="reference internal" href="#logging.Logger.log" title="logging.Logger.log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log()</span></code></a>，<a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>，<a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>，<a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 以及 <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a>。 这些方法具有与它们在 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 中的对应方法相同的签名，因此你可以互换使用这两种类型的实例。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span><a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 和 <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a> 方法已被添加到 <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a>。 这些方法会委托给下层的日志记录器。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>增加了 <code class="xref py py-attr docutils literal notranslate"><span class="pre">manager</span></code> 属性和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_log()</span></code> 方法，它们会委托给下层的日志记录器并允许适配器嵌套。</p>
</div>
</dd></dl>

</section>
<section id="thread-safety">
<h2>线程安全</h2>
<p>logging 模块的目标是使客户端不必执行任何特殊操作即可确保线程安全。 它通过使用线程锁来达成这个目标；用一个锁来序列化对模块共享数据的访问，并且每个处理程序也会创建一个锁来序列化对其下层 I/O 的访问。</p>
<p>如果你要使用 <a class="reference internal" href="signal.xhtml#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 模块来实现异步信号处理程序，则可能无法在这些处理程序中使用 logging。 这是因为 <a class="reference internal" href="threading.xhtml#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块中的锁实现并非总是可重入的，所以无法从此类信号处理程序发起调用。</p>
</section>
<section id="module-level-functions">
<h2>模块级函数</h2>
<p>在上述的类之外，还有一些模块级的函数。</p>
<dl class="py function">
<dt class="sig sig-object py" id="logging.getLogger">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return a logger with the specified name or, if name is <code class="docutils literal notranslate"><span class="pre">None</span></code>, return the
root logger of the hierarchy. If specified, the name is typically a
dot-separated hierarchical name like <em>'a'</em>, <em>'a.b'</em> or <em>'a.b.c.d'</em>. Choice
of these names is entirely up to the developer who is using logging, though
it is recommended that <code class="docutils literal notranslate"><span class="pre">__name__</span></code> be used unless you have a specific
reason for not doing that, as mentioned in <a class="reference internal" href="#logger"><span class="std std-ref">记录器对象</span></a>.</p>
<p>所有用给定的 name 对该函数的调用都将返回相同的日志记录器实例。 这意味着日志记录器实例不需要在应用的各部分间传递。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLoggerClass">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLoggerClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回标准的 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 类，或是最近传给 <a class="reference internal" href="#logging.setLoggerClass" title="logging.setLoggerClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLoggerClass()</span></code></a> 的类。 此函数可以从一个新的类定义中调用，以确保安装自定义的 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 类不会撤销其他代码已经应用的自定义操作。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLoggerClass</span><span class="p">()):</span>
    <span class="c1"># ... override behaviour here</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLogRecordFactory">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLogRecordFactory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个被用来创建 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 的可调用对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2: </span>此函数与 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> 一起提供，以允许开发者对表示日志记录事件的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 的构造有更好的控制。</p>
</div>
<p>请参阅 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> 了解有关如何调用该工厂方法的更多信息。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.debug">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>这是在根日志记录器上调用 <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.debug()</span></code></a> 的便捷函数。 其参数的处理方式与该方法中的描述完全一致。</p>
<p>唯一的区别在于如果根日志记录器没有处理器，则在根日志记录器上调用 <code class="docutils literal notranslate"><span class="pre">debug</span></code> 之前会先调用 <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a>。</p>
<p>对于非常简短的脚本或 <code class="docutils literal notranslate"><span class="pre">logging</span></code> 功能的快速演示，<code class="docutils literal notranslate"><span class="pre">debug</span></code> 和其他模块级函数可能会很方便。 不过，大多数程序都会想要仔细和显式地控制日志记录配置，所以应当更倾向于创建一个模块级的日志记录器并在其上调用 <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.debug()</span></code></a> (或其他特定级别的方法)，如本文档的开头所描述的那样。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.info">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在根日志记录器上记录一条 <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code></a> 级别的消息。 其他参数与行为均与 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> 的相同。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.warning">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">warning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在根日志记录器上记录一条 <a class="reference internal" href="#logging.WARNING" title="logging.WARNING"><code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code></a> 级别的消息。 其他参数与行为均与 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> 的相同。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有一个已过时方法 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 其功能与 <code class="docutils literal notranslate"><span class="pre">warning</span></code> 一致。 由于 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 已被弃用，请不要使用它 —— 而是改用 <code class="docutils literal notranslate"><span class="pre">warning</span></code>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.error">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在根日志记录器上记录一条 <a class="reference internal" href="#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code></a> 级别的消息。 其他参数与行为均与 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> 的相同。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.critical">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">critical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在根日志记录器上记录一条 <a class="reference internal" href="#logging.CRITICAL" title="logging.CRITICAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code></a> 级别的消息。 其他参数与行为均与 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> 的相同。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.exception">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">exception</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在根日志记录器上记录一条 <a class="reference internal" href="#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code></a> 级别的消息。 其他参数与行为均与 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> 的相同。 异常信息会被添加到日志记录消息中。 此函数应当仅从异常处理器中调用。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.log">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在根日志记录器上记录一条 <em>level</em> 级别的消息。 其他参数与行为均与 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a> 相同。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.disable">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">disable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">CRITICAL</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>为所有日志记录器提供重写的级别 <em>level</em>，其优先级高于日志记录器自己的级别。 当需要临时限制整个应用程序中的日志记录输出时，此功能会很有用。 它的效果是禁用所有重要程度为 <em>level</em> 及以下的日志记录调用，因此如果你附带 INFO 值调用它，则所有 INFO 和 DEBUG 事件就会被丢弃，而重要程度为 WARNING 以及上的事件将根据日志记录器的当前有效级别来处理。 如果 <code class="docutils literal notranslate"><span class="pre">logging.disable(logging.NOTSET)</span></code> 被调用，它将移除这个重写的级别，因此日志记录输出会再次取决于单个日志记录器的有效级别。</p>
<p>请注意如果你定义了任何高于 <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code> 的自定义日志级别（并不建议这样做），你就将无法沿用 <em>level</em> 形参的默认值，而必须显式地提供适当的值。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><em>level</em> 形参默认级别为 <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code>。 请参阅 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28524">bpo-28524</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28524]</span> 了解此项改变的更多细节。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.addLevelName">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">addLevelName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levelName</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在一个内部字典中关联级别 <em>level</em> 与文本 <em>levelName</em>，该字典会被用来将数字级别映射为文本表示形式，例如在 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 格式化消息的时候。 此函数也可被用来定义你自己的级别。 唯一的限制是自定义的所有级别必须使用此函数来注册，级别值必须为正整数并且其应随严重程度而递增。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果你考虑要定义你自己的级别，请参阅 <a class="reference internal" href="../howto/logging.xhtml#custom-levels"><span class="std std-ref">自定义级别</span></a> 部分。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLevelNamesMapping">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLevelNamesMapping</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个级别名到其对应日志记录级别的映射。 例如，字符串 &quot;CRITICAL&quot; 将映射到 <a class="reference internal" href="#logging.CRITICAL" title="logging.CRITICAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code></a>。 所返回的映射是从每个对此函数的调用的内部映射拷贝的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLevelName">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLevelName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回日志记录级别 <em>level</em> 的字符串表示。</p>
<p>如果 <em>level</em> 为预定义的级别 <a class="reference internal" href="#logging.CRITICAL" title="logging.CRITICAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code></a>, <a class="reference internal" href="#logging.ERROR" title="logging.ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code></a>, <a class="reference internal" href="#logging.WARNING" title="logging.WARNING"><code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code></a>, <a class="reference internal" href="#logging.INFO" title="logging.INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code></a> 或 <a class="reference internal" href="#logging.DEBUG" title="logging.DEBUG"><code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code></a> 之一则你会得到相应的字符串。 如果你使用 <a class="reference internal" href="#logging.addLevelName" title="logging.addLevelName"><code class="xref py py-func docutils literal notranslate"><span class="pre">addLevelName()</span></code></a> 将级别关联到名称则返回你为 <em>level</em> 所关联的名称。 如果传入了与已定义级别相对应的数字值，则返回对应的字符串表示。</p>
<p><em>level</em> 形参也接受级别的字符串表示例如 'INFO'。 在这种情况下，此函数将返回级别所对应的数字值。</p>
<p>如果未传入可匹配的数字或字符串值，则返回字符串 'Level %s' % level。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>级别在内部以整数表示（因为它们在日志记录逻辑中需要进行比较）。 此函数被用于在整数级别与通过 <code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code> 格式描述符方式在格式化日志输出中显示的级别名称之间进行相互的转换 (参见 <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 属性</span></a>)。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span>在早于 3.4 的 Python 版本中，此函数也可传入一个字符串形式的级别名称，并将返回对应的级别数字值。 此未记入文档的行为被视为是一个错误，并在 Python 3.4 中被移除，但又在 3.4.2 中被恢复以保持向下兼容性。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getHandlerByName">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getHandlerByName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>返回具有指定 <em>name</em> 的处理器，或者如果指定名称的处理器不存在则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getHandlerNames">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getHandlerNames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个由所有已知处理器名称组成的不可变集合。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.makeLogRecord">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">makeLogRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attrdict</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建并返回一个新的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例，实例属性由 <em>attrdict</em> 定义。 此函数适用于接受一个通过套接字传输的封存好的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 属性字典，并在接收端将其重建为一个 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.basicConfig">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">basicConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通过使用默认的 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 创建一个 <a class="reference internal" href="logging.handlers.xhtml#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> 并将其加入根日志记录器来为日志记录系统执行基本配置。 如果没有为根日志记录器定义处理器则 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-func docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.error" title="logging.error"><code class="xref py py-func docutils literal notranslate"><span class="pre">error()</span></code></a> 和 <a class="reference internal" href="#logging.critical" title="logging.critical"><code class="xref py py-func docutils literal notranslate"><span class="pre">critical()</span></code></a> 等函数将自动调用 <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a>。</p>
<p>如果根日志记录器已配置了处理器则此函数将不执行任何操作，除非关键字参数 <em>force</em> 被设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此函数应当在其他线程启动之前从主线程被调用。 在 2.7.1 和 3.2 之前的 Python 版本中，如果此函数从多个线程被调用，一个处理器（在极少的情况下）有可能被多次加入根日志记录器，导致非预期的结果例如日志中的消息出现重复。</p>
</div>
<p>支持以下关键字参数。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>格式</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>filename</em></p></td>
<td><p>使用指定的文件名创建一个 <a class="reference internal" href="logging.handlers.xhtml#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>，而不是 <a class="reference internal" href="logging.handlers.xhtml#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>。</p></td>
</tr>
<tr class="row-odd"><td><p><em>filemode</em></p></td>
<td><p>如果指定了 <em>filename</em>，则用此 <a class="reference internal" href="functions.xhtml#filemodes"><span class="std std-ref">模式</span></a> 打开该文件。 默认模式为 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><em>format</em></p></td>
<td><p>使用指定的格式字符串作为处理器。 默认为属性以冒号分隔的 <code class="docutils literal notranslate"><span class="pre">levelname</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code> 和 <code class="docutils literal notranslate"><span class="pre">message</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><em>datefmt</em></p></td>
<td><p>使用指定的日期/时间格式，与 <a class="reference internal" href="time.xhtml#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 所接受的格式相同。</p></td>
</tr>
<tr class="row-even"><td><p><em>style</em></p></td>
<td><p>如果指定了 <em>format</em>，将为格式字符串使用此风格。 <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">'{'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'$'</span></code> 分别对应于 <a class="reference internal" href="stdtypes.xhtml#old-string-formatting"><span class="std std-ref">printf 风格</span></a>, <a class="reference internal" href="stdtypes.xhtml#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 或 <a class="reference internal" href="string.xhtml#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a>。 默认为 <code class="docutils literal notranslate"><span class="pre">'%'</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><em>level</em></p></td>
<td><p>设置根记录器级别为指定的 <a class="reference internal" href="#levels"><span class="std std-ref">level</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><em>stream</em></p></td>
<td><p>使用指定的流初始化 <a class="reference internal" href="logging.handlers.xhtml#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>。 请注意此参数与 <em>filename</em> 不兼容 —— 如果两者同时存在，则会引发 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><em>handlers</em></p></td>
<td><p>如果指定，这应为一个包含要加入根日志记录器的已创建处理器的可迭代对象。 任何尚未设置格式描述符的处理器将被设置为在此函数中创建的默认格式描述符。 请注意此参数与 <em>filename</em> 或 <em>stream</em> 不兼容 —— 如果两者同时存在，则会引发 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><em>force</em></p></td>
<td><p>如果将此关键字参数指定为 true，则在执行其他参数指定的配置之前，将移除并关闭附加到根记录器的所有现有处理器。</p></td>
</tr>
<tr class="row-odd"><td><p><em>encoding</em></p></td>
<td><p>如果此关键字参数与 <em>filename</em> 一同被指定，则其值会在创建 <a class="reference internal" href="logging.handlers.xhtml#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> 时被使用，因而也会在打开输出文件时被使用。</p></td>
</tr>
<tr class="row-even"><td><p><em>errors</em></p></td>
<td><p>如果此关键字参数与 <em>filename</em> 一同被指定，则其值会在创建 <a class="reference internal" href="logging.handlers.xhtml#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> 时被使用，因而也会在打开输出文件时被使用。 如果未指定，则会使用值 'backslashreplace'。 请注意如果指定为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，它将被原样传给 <a class="reference internal" href="functions.xhtml#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>，这意味着它将会当作传入 'errors' 一样处理。</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <em>style</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>增加了 <em>handlers</em> 参数。 增加了额外的检查来捕获指定不兼容参数的情况 (例如同时指定 <em>handlers</em> 与 <em>stream</em>  或 <em>filename</em>，或者同时指定 <em>stream</em> 与 <em>filename</em>)。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>force</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>增加了 <em>encoding</em> 和 <em>errors</em> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.shutdown">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>通过刷新和关闭所有处理程序来通知日志记录系统执行有序停止。 此函数应当在应用退出时被调用并且在此调用之后不应再使用日志记录系统。</p>
<p>当 logging 模块被导入时，它会将此函数注册为退出处理程序 (参见 <a class="reference internal" href="atexit.xhtml#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>)，因此通常不需要手动执行该操作。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.setLoggerClass">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">setLoggerClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">klass</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通知日志记录系统在实例化日志记录器时使用 <em>klass</em> 类。 该类应当定义 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 使其只需要一个 name 参数，并且 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 应当调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.__init__()</span></code>。 此函数通常会在需要使用自定义日志记录器行为的应用程序实例化任何日志记录器之前被调用。 在此调用之后，在其他任何时候都不要直接使用该子类来实例化日志记录器：请继续使用 <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">logging.getLogger()</span></code></a> API 来获取你的日志记录器。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.setLogRecordFactory">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">setLogRecordFactory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>设置一个用来创建 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 的可调用对象。</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>factory</strong> -- 用来实例化日志记录的工厂可调用对象。</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2: </span>此函数与 <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a> 一起提供，以便允许开发者对如何构造表示日志记录事件的 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 有更好的控制。</p>
</div>
<p>可调用对象 factory 具有如下签名:</p>
<p><code class="docutils literal notranslate"><span class="pre">factory(name,</span> <span class="pre">level,</span> <span class="pre">fn,</span> <span class="pre">lno,</span> <span class="pre">msg,</span> <span class="pre">args,</span> <span class="pre">exc_info,</span> <span class="pre">func=None,</span> <span class="pre">sinfo=None,</span> <span class="pre">**kwargs)</span></code></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">name<span class="colon">:</span></dt>
<dd class="field-odd"><p>日志记录器名称</p>
</dd>
<dt class="field-even">level<span class="colon">:</span></dt>
<dd class="field-even"><p>日志记录级别（数字）。</p>
</dd>
<dt class="field-odd">fn<span class="colon">:</span></dt>
<dd class="field-odd"><p>进行日志记录调用的文件的完整路径名。</p>
</dd>
<dt class="field-even">lno<span class="colon">:</span></dt>
<dd class="field-even"><p>记录调用所在文件中的行号。</p>
</dd>
<dt class="field-odd">msg<span class="colon">:</span></dt>
<dd class="field-odd"><p>日志消息。</p>
</dd>
<dt class="field-even">args<span class="colon">:</span></dt>
<dd class="field-even"><p>日志记录消息的参数。</p>
</dd>
<dt class="field-odd">exc_info<span class="colon">:</span></dt>
<dd class="field-odd"><p>异常元组，或 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</dd>
<dt class="field-even">func<span class="colon">:</span></dt>
<dd class="field-even"><p>调用日志记录调用的函数或方法的名称。</p>
</dd>
<dt class="field-odd">sinfo<span class="colon">:</span></dt>
<dd class="field-odd"><p>与 <a class="reference internal" href="traceback.xhtml#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a> 所提供的类似的栈回溯信息，显示调用的层级结构。</p>
</dd>
<dt class="field-even">kwargs<span class="colon">:</span></dt>
<dd class="field-even"><p>其他关键字参数。</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</section>
<section id="module-level-attributes">
<h2>模块级属性</h2>
<dl class="py attribute">
<dt class="sig sig-object py" id="logging.lastResort">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">lastResort</span></span></dt>
<dd><p>通过此属性提供的“最后处理者”。 这是一个以 <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> 级别写入到 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 的 <a class="reference internal" href="logging.handlers.xhtml#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>，用于在没有任何日志记录配置的情况下处理日志记录事件。 最终结果就是将消息打印到 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>，这会替代先前形式为 &quot;no handlers could be found for logger XYZ&quot; 的错误消息。 如果出于某种原因你需要先前的行为，可将 <code class="docutils literal notranslate"><span class="pre">lastResort</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="logging.raiseExceptions">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">raiseExceptions</span></span></dt>
<dd><p>用于查看在处理过程中异常是否应当被传播。</p>
<p>默认值: <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<p>如果 <a class="reference internal" href="#logging.raiseExceptions" title="logging.raiseExceptions"><code class="xref py py-data docutils literal notranslate"><span class="pre">raiseExceptions</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则异常会被静默地忽略。 这大多数情况下是日志系统所需要的 —— 大多数用户不会关心日志系统中的错误，他们对应用程序错误更感兴趣。</p>
</dd></dl>

</section>
<section id="integration-with-the-warnings-module">
<h2>与警告模块集成</h2>
<p><a class="reference internal" href="#logging.captureWarnings" title="logging.captureWarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">captureWarnings()</span></code></a> 函数可用来将 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 和 <a class="reference internal" href="warnings.xhtml#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块集成。</p>
<dl class="py function">
<dt class="sig sig-object py" id="logging.captureWarnings">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">captureWarnings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capture</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此函数用于打开和关闭日志系统对警告的捕获。</p>
<p>如果 <em>capture</em> 是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则 <a class="reference internal" href="warnings.xhtml#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块发出的警告将重定向到日志记录系统。具体来说，将使用 <a class="reference internal" href="warnings.xhtml#warnings.formatwarning" title="warnings.formatwarning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.formatwarning()</span></code></a> 格式化警告信息，并将结果字符串使用 <a class="reference internal" href="#logging.WARNING" title="logging.WARNING"><code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code></a> 等级记录到名为 <code class="docutils literal notranslate"><span class="pre">'py.warnings'</span></code> 的记录器中。</p>
<p>如果 <em>capture</em> 是 <code class="docutils literal notranslate"><span class="pre">False</span></code>，则将停止将警告重定向到日志记录系统，并且将警告重定向到其原始目标（即在  <code class="docutils literal notranslate"><span class="pre">captureWarnings(True)</span></code>  调用之前的有效目标）。</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference internal" href="logging.config.xhtml#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> 模块</dt><dd><p>日志记录模块的配置 API 。</p>
</dd>
<dt><a class="reference internal" href="logging.handlers.xhtml#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 模块</dt><dd><p>日志记录模块附带的有用处理器。</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a><span class="link-target"> [https://peps.python.org/pep-0282/]</span> - Logging 系统</dt><dd><p>该提案描述了Python标准库中包含的这个特性。</p>
</dd>
<dt><a class="reference external" href="https://old.red-dove.com/python_logging.html">Original Python logging package</a><span class="link-target"> [https://old.red-dove.com/python_logging.html]</span></dt><dd><p>这是该 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包的原始来源。该站点提供的软件包版本适用于 Python 1.5.2、2.1.x 和 2.2.x，它们不被 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包含在标准库中。</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>