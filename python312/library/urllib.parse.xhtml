<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="urllib.parse --- Parse URLs into components" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/urllib.parse.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/urllib/parse.py[https://github.com/python/cpython/tree/3.12/Lib/urllib/parse.py] 该模块定义了一个标准接口，用于将统一资源定位符（URL）字符串拆分为不同部分（协议、网络位置、路径等），或将各个部分组合回 URL 字符串，并将“相对 URL”转换为基于给定的“基准 URL”的绝对 URL。 该模..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码: Lib/urllib/parse.py[https://github.com/python/cpython/tree/3.12/Lib/urllib/parse.py] 该模块定义了一个标准接口，用于将统一资源定位符（URL）字符串拆分为不同部分（协议、网络位置、路径等），或将各个部分组合回 URL 字符串，并将“相对 URL”转换为基于给定的“基准 URL”的绝对 URL。 该模..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>urllib.parse --- Parse URLs into components</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/urllib.parse.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-urllib.parse">
<span id="urllib-parse-parse-urls-into-components"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> --- Parse URLs into components</h1>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/urllib/parse.py">Lib/urllib/parse.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/urllib/parse.py]</span></p>
<hr class="docutils" id="index-0" />
<p>该模块定义了一个标准接口，用于将统一资源定位符（URL）字符串拆分为不同部分（协议、网络位置、路径等），或将各个部分组合回 URL 字符串，并将“相对 URL”转换为基于给定的“基准 URL”的绝对 URL。</p>
<p>该模块被设计为匹配针对相对统一资源定位符的因特网 RFC。 它支持下列 URL 类别: <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">ftp</span></code>, <code class="docutils literal notranslate"><span class="pre">gopher</span></code>, <code class="docutils literal notranslate"><span class="pre">hdl</span></code>, <code class="docutils literal notranslate"><span class="pre">http</span></code>, <code class="docutils literal notranslate"><span class="pre">https</span></code>, <code class="docutils literal notranslate"><span class="pre">imap</span></code>, <code class="docutils literal notranslate"><span class="pre">mailto</span></code>, <code class="docutils literal notranslate"><span class="pre">mms</span></code>, <code class="docutils literal notranslate"><span class="pre">news</span></code>, <code class="docutils literal notranslate"><span class="pre">nntp</span></code>, <code class="docutils literal notranslate"><span class="pre">prospero</span></code>, <code class="docutils literal notranslate"><span class="pre">rsync</span></code>, <code class="docutils literal notranslate"><span class="pre">rtsp</span></code>, <code class="docutils literal notranslate"><span class="pre">rtsps</span></code>, <code class="docutils literal notranslate"><span class="pre">rtspu</span></code>, <code class="docutils literal notranslate"><span class="pre">sftp</span></code>, <code class="docutils literal notranslate"><span class="pre">shttp</span></code>, <code class="docutils literal notranslate"><span class="pre">sip</span></code>, <code class="docutils literal notranslate"><span class="pre">sips</span></code>, <code class="docutils literal notranslate"><span class="pre">snews</span></code>, <code class="docutils literal notranslate"><span class="pre">svn</span></code>, <code class="docutils literal notranslate"><span class="pre">svn+ssh</span></code>, <code class="docutils literal notranslate"><span class="pre">telnet</span></code>, <code class="docutils literal notranslate"><span class="pre">wais</span></code>, <code class="docutils literal notranslate"><span class="pre">ws</span></code>, <code class="docutils literal notranslate"><span class="pre">wss</span></code>。</p>
<p><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> 模块定义的函数可分为两个主要门类: URL 解析和 URL 转码。 这些函数将在以下各节中详细说明。</p>
<p>This module's functions use the deprecated term <code class="docutils literal notranslate"><span class="pre">netloc</span></code> (or <code class="docutils literal notranslate"><span class="pre">net_loc</span></code>),
which was introduced in <span class="target" id="index-1"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc1808.html]</span>. However, this term has been obsoleted by
<span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc3986.html]</span>, which introduced the term <code class="docutils literal notranslate"><span class="pre">authority</span></code> as its replacement.
The use of <code class="docutils literal notranslate"><span class="pre">netloc</span></code> is continued for backward compatibility.</p>
<section id="url-parsing">
<h2>URL 解析</h2>
<p>URL 解析函数用于将一个 URL 字符串分割成其组成部分，或者将 URL 的多个部分组合成一个 URL 字符串。</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlparse">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">urlstring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_fragments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个 URL 解析为六个部分，返回一个包含 6 项的 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>。 这对应于 URL 的主要结构: <code class="docutils literal notranslate"><span class="pre">scheme://netloc/path;parameters?query#fragment</span></code>。 每个元组项均为字符串，可能为空字符串。 这些部分不会再被拆分为更小的部分（例如，netloc 将为单个字符串），并且 % 转义不会被扩展。 上面显示的分隔符不会出现在结果中，只有 <em>path</em> 部分的开头斜杠例外，它如果存在则会被保留。 例如:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;scheme://netloc/path;parameters?query#fragment&quot;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;scheme&#39;, netloc=&#39;netloc&#39;, path=&#39;/path;parameters&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;query&#39;, fragment=&#39;fragment&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;http://docs.python.org:80/3/library/urllib.parse.html?&quot;</span>
<span class="gp">... </span>             <span class="s2">&quot;highlight=params#url-parsing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span>
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;docs.python.org:80&#39;,</span>
<span class="go">            path=&#39;/3/library/urllib.parse.html&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;highlight=params&#39;, fragment=&#39;url-parsing&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">scheme</span>
<span class="go">&#39;http&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">netloc</span>
<span class="go">&#39;docs.python.org:80&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">hostname</span>
<span class="go">&#39;docs.python.org&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">port</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://docs.python.org:80/3/library/urllib.parse.html?highlight=params&#39;</span>
</pre></div>
</div>
<p>根据 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc1808.html]</span> 中的语法规范，urlparse 仅在 netloc 前面正确地附带了 '//' 的情况下才会识别它。 否则输入会被当作是一个相对 URL 因而以路径的组成部分开头。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;www.cwi.nl/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;help/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;help/Python.html&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<p><em>scheme</em> 参数给出了默认的协议，只有在 URL 未指定协议的情况下才会被使用。 它应该是与 <em>urlstring</em> 相同的类型（文本或字节串），除此之外默认值 <code class="docutils literal notranslate"><span class="pre">''</span></code> 也总是被允许，并会在适当情况下自动转换为 <code class="docutils literal notranslate"><span class="pre">b''</span></code>。</p>
<p>如果 <em>allow_fragments</em> 参数为假值，则片段标识符不会被识别。 它们会被解析为路径、参数或查询部分，在返回值中 <code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code> 会被设为空字符串。</p>
<p>返回值是一个 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>，这意味着它的条目可以通过索引或作为命名属性来访问，这些属性是：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>属性</p></th>
<th class="head"><p>索引</p></th>
<th class="head"><p>值</p></th>
<th class="head"><p>值（如果不存在）</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>URL 协议说明符</p></td>
<td><p><em>scheme</em> 参数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>网络位置部分</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>分层路径</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code></p></td>
<td><p>3</p></td>
<td><p>最后路径元素的参数</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>4</p></td>
<td><p>查询组件</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>5</p></td>
<td><p>片段标识符</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>用户名</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>密码</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>主机名（小写）</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>端口号为整数（如果存在）</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>如果在 URL 中指定了无效的端口，读取 <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> 属性将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 有关结果对象的更多信息请参阅 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">结构化解析结果</span></a> 一节。</p>
<p>在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 属性中不匹配的方括号将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 属性中的字符在 NFKC 规范化下（如 IDNA 编码格式所使用的）被分解成 <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">:</span></code> 则将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 如果在解析之前 URL 就被分解，则不会引发错误。</p>
<p>与所有具名元组的情况一样，该子类还有一些特别有用的附加方法和属性。 其中一个方法是 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code>。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code> 方法将返回一个新的 ParseResult 对象来将指定字段替换为新的值。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;http&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 不会执行验证。 请参阅 <a class="reference internal" href="#url-parsing-security"><span class="std std-ref">URL 解析安全</span></a> 了解详情。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>添加了IPv6 URL解析功能。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>会对所有 URL 协议解析片段（除非 <em>allow_fragment</em> 为假值），依据 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc3986.html]</span> 的规范。 在之前版本中，存在一个支持片段的协议允许名单。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>超范围的端口号现在会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，而不是返回 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>在 NFKC 规范化下会影响 netloc 解析的字符现在将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.parse_qs">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">parse_qs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_blank_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_parsing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&amp;'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>解析以字符串参数形式（类型为 <em class="mimetype">application/x-www-form-urlencoded</em> 的数据）给出的查询字符串。 返回字典形式的数据。 结果字典的键为唯一的查询变量名而值为每个变量名对应的值列表。</p>
<p>可选参数 <em>keep_blank_values</em> 是一个旗标，指明是否要将以百分号转码的空值作为空字符串处理。 真值表示空值应当被保留作为空字符串。 默认的假值表示空值会被忽略并将其视作未包括的值。</p>
<p>可选参数 <em>strict_parsing</em> 是一个旗标，指明要如何处理解析错误。 如为假值（默认），错误会被静默地忽略。 如为真值，错误会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
<p>可选的 <em>encoding</em> 和 <em>errors</em> 形参指定如何将以百分号编码的序列解码为 Unicode 字符，即作为 <a class="reference internal" href="stdtypes.xhtml#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 方法所接受的数据。</p>
<p>可选参数 <em>max_num_fields</em> 是要读取的最大字段数量的。 如果设置，则如果读取的字段超过 <em>max_num_fields</em> 会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>可选参数 <em>separator</em> 是用来分隔查询参数的符号。 默认为 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>。</p>
<p>使用 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 函数 (并将 <code class="docutils literal notranslate"><span class="pre">doseq</span></code> 形参设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>) 将这样的字典转换为查询字符串。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <em>encoding</em> 和 <em>errors</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>max_num_fields</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <em>separator</em> 形参，默认值为 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>。 Python 在早于 Python 3.10 的版本中允许使用 <code class="docutils literal notranslate"><span class="pre">;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 作为查询参数分隔符。 此设置已被改为只允许单个分隔符键，并以 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 作为默认的分隔符。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.parse_qsl">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">parse_qsl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_blank_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_parsing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&amp;'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>解析以字符串参数形式（类型为 <em class="mimetype">application/x-www-form-urlencoded</em> 的数据）给出的查询字符串。 数据以字段名和字段值对列表的形式返回。</p>
<p>可选参数 <em>keep_blank_values</em> 是一个旗标，指明是否要将以百分号转码的空值作为空字符串处理。 真值表示空值应当被保留作为空字符串。 默认的假值表示空值会被忽略并将其视作未包括的值。</p>
<p>可选参数 <em>strict_parsing</em> 是一个旗标，指明要如何处理解析错误。 如为假值（默认），错误会被静默地忽略。 如为真值，错误会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
<p>可选的 <em>encoding</em> 和 <em>errors</em> 形参指定如何将以百分号编码的序列解码为 Unicode 字符，即作为 <a class="reference internal" href="stdtypes.xhtml#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 方法所接受的数据。</p>
<p>可选参数 <em>max_num_fields</em> 是要读取的最大字段数量的。 如果设置，则如果读取的字段超过 <em>max_num_fields</em> 会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>可选参数 <em>separator</em> 是用来分隔查询参数的符号。 默认为 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>。</p>
<p>使用 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 函数将这样的名值对列表转换为查询字符串。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <em>encoding</em> 和 <em>errors</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>max_num_fields</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>增加了 <em>separator</em> 形参，默认值为 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>。 Python 在早于 Python 3.10 的版本中允许使用 <code class="docutils literal notranslate"><span class="pre">;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 作为查询参数分隔符。 此设置已被改为只允许单个分隔符键，并以 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 作为默认的分隔符。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlunparse">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlunparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parts</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>根据 <code class="docutils literal notranslate"><span class="pre">urlparse()</span></code> 所返回的元组来构造一个 URL。 <em>parts</em> 参数可以是任何包含六个条目的可迭代对象。 构造的结果可能是略有不同但保持等价的 URL，如果被解析的 URL 原本包含不必要的分隔符（例如，带有空查询的 <code class="docutils literal notranslate"><span class="pre">?</span></code>；RFC 已声明这是等价的）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlsplit">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">urlstring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_fragments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此函数类似于 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>，但不会拆分来自 URL 的参数。 此函数通常应当在需要允许将参数应用到 URL 的 <em>path</em> 部分的每个分节的较新的 URL 语法的情况下 (参见 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2396.html]</span>) 被用来代替 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>。 需要使用一个拆分函数来拆分路径分节和参数。 此函数将返回包含 5 个条目的 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">addressing</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">network</span> <span class="n">location</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span> <span class="n">identifier</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>返回值是一个 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>，它的条目可以通过索引或作为命名属性来访问:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>属性</p></th>
<th class="head"><p>索引</p></th>
<th class="head"><p>值</p></th>
<th class="head"><p>值（如果不存在）</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>URL 协议说明符</p></td>
<td><p><em>scheme</em> 参数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>网络位置部分</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>分层路径</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>3</p></td>
<td><p>查询组件</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>4</p></td>
<td><p>片段标识符</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>用户名</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>密码</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>主机名（小写）</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>端口号为整数（如果存在）</p></td>
<td><p><a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>如果在 URL 中指定了无效的端口，读取 <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> 属性将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 有关结果对象的更多信息请参阅 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">结构化解析结果</span></a> 一节。</p>
<p>在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 属性中不匹配的方括号将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 属性中的字符在 NFKC 规范化下（如 IDNA 编码格式所使用的）被分解成 <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">:</span></code> 则将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 如果在解析之前 URL 就被分解，则不会引发错误。</p>
<p>按照针对 RFC 3986 进行更新的 <a class="reference external" href="https://url.spec.whatwg.org/#concept-basic-url-parser">WHATWG spec</a><span class="link-target"> [https://url.spec.whatwg.org/#concept-basic-url-parser]</span>，打头的 C0 控制符和空格符将从 URL 中去除。 任意位置上的 <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code> 和制表符 <code class="docutils literal notranslate"><span class="pre">\t</span></code> 等字符也将从 URL 中去除。at any position.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 不会执行验证。 请参阅 <a class="reference internal" href="#url-parsing-security"><span class="std std-ref">URL 解析安全</span></a> 了解详情。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>超范围的端口号现在会引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，而不是返回 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>在 NFKC 规范化下会影响 netloc 解析的字符现在将引发 <a class="reference internal" href="exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>ASCII 换行符和制表符会从 URL 中被去除。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>打头的 WHATWG C0 控制符和空格符将从 URL 中去除。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlunsplit">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlunsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parts</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 所返回的元组中的元素合并为一个字符串形式的完整 URL。 <em>parts</em> 参数可以是任何包含五个条目的可迭代对象。 其结果可能是略有不同但保持等价的 URL，如果被解析的 URL 原本包含不必要的分隔符（例如，带有空查询的 ?；RFC 已声明这是等价的）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urljoin">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urljoin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_fragments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>通过合并一个 &quot;基准 URL&quot; (<em>base</em>) 和另一个 URL (<em>url</em>) 来构造一个完整 (&quot;absolute&quot;) URL。 在非正式情况下，这将使用基准 URL 的各部分，特别是地址协议、网络位置和 (一部分) 路径来提供相对 URL 中缺失的部分。 例如:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span> <span class="s1">&#39;FAQ.html&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.cwi.nl/%7Eguido/FAQ.html&#39;</span>
</pre></div>
</div>
<p><em>allow_fragments</em> 参数具有与 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 中的对应参数一致的含义与默认值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 <em>url</em> 为绝对 URL (即以 <code class="docutils literal notranslate"><span class="pre">//</span></code> 或 <code class="docutils literal notranslate"><span class="pre">scheme://</span></code> 打头)，则 <em>url</em> 的主机名和/或协议将出现在结果中。 例如:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;//www.python.org/</span><span class="si">%7E</span><span class="s1">guido&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.python.org/%7Eguido&#39;</span>
</pre></div>
</div>
<p>如果你不想要那样的行为，请使用 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 和 <a class="reference internal" href="#urllib.parse.urlunsplit" title="urllib.parse.urlunsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlunsplit()</span></code></a> 对 <em>url</em> 进行预处理，移除可能存在的 <em>scheme</em> 和 <em>netloc</em> 部分。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>更新行为以匹配 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc3986.html]</span> 中定义的语义。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urldefrag">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urldefrag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>如果 <em>url</em> 包含片段标识符，则返回不带片段标识符的 <em>url</em> 修改版本。 如果 <em>url</em> 中没有片段标识符，则返回未经修改的 <em>url</em> 和一个空字符串。</p>
<p>返回值是一个 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a>，它的条目可以通过索引或作为命名属性来访问:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>属性</p></th>
<th class="head"><p>索引</p></th>
<th class="head"><p>值</p></th>
<th class="head"><p>值（如果不存在）</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></p></td>
<td><p>0</p></td>
<td><p>不带片段的 URL</p></td>
<td><p>空字符串</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>1</p></td>
<td><p>片段标识符</p></td>
<td><p>空字符串</p></td>
</tr>
</tbody>
</table>
<p>请参阅 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">结构化解析结果</span></a> 一节了解有关结果对象的更多信息。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>结果为已构造好的对象而不是一个简单的 2 元组。-tuple.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unwrap">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>从已包装的 URL (即被格式化为 <code class="docutils literal notranslate"><span class="pre">&lt;URL:scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">URL:scheme://host/path</span></code> 或 <code class="docutils literal notranslate"><span class="pre">scheme://host/path</span></code> 的字符串) 中提取 URL。 如果 <em>url</em> 不是一个已包装的 URL，它将被原样返回。</p>
</dd></dl>

</section>
<section id="url-parsing-security">
<span id="id1"></span><h2>URL 解析安全</h2>
<p><a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 和 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> API 不会对输入进行 <strong>验证</strong>。 它们可能不会因其他应用程序认为不合法的输入而引发错误。 它们还可能在其他地方认为不是 URL 的输入上成功运行。 它们的目标是达成实际的功能而不是保持纯净。</p>
<p>他们在非正常的输入上可能不会引发异常，而是以空字符串的形式返回某些部分。 或者可能会包含某些不应包含的部分。</p>
<p>我们建议这些 API 的用户在任何使用的值具有安全意义的地方应用防御性代码。 在你的代码中进行某些验证之后再信任被返回的组件。 这个 <code class="docutils literal notranslate"><span class="pre">scheme</span></code> 合理吗？那个 <code class="docutils literal notranslate"><span class="pre">path</span></code> 正确吗？ 那个 <code class="docutils literal notranslate"><span class="pre">hostname</span></code> 是否存在怪异之处？等等。</p>
<p>一个 URL 由哪些内容组成并没有通用的良好定义。 不同应用程序有不同的需求和想要的约束。 举例来说现有的 <a class="reference external" href="https://url.spec.whatwg.org/#concept-basic-url-parser">WHATWG spec</a><span class="link-target"> [https://url.spec.whatwg.org/#concept-basic-url-parser]</span> 描述了面向用户的 Web 客户端如 Web 浏览器的需求。 而 <span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc3986.html]</span> 则更为一般化。 这些函数涵盖了这两种领域的某些部分，但称不上能兼容任何一种。 这些 API 和早于这两个标准的现有用户代码对于其他特定行为的期望使得我们对 API 行为的更改变得非常谨慎。</p>
</section>
<section id="parsing-ascii-encoded-bytes">
<span id="id2"></span><h2>解析ASCII编码字节</h2>
<p>这些 URL 解析函数最初设计只用于操作字符串。 但在实践中，它也能够操作经过正确转码和编码的 ASCII 字节序列形式的 URL。 相应地，此模块中的 URL 解析函数既可以操作 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象也可以操作 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象。</p>
<p>如果传入 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据，结果将只包含 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据。 如果传入 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 数据，则结果也将只包含 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 数据。</p>
<p>试图在单个函数调用中混用 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据和 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 数据将导致引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，而试图传入非 ASCII 字节值则将引发 <a class="reference internal" href="exceptions.xhtml#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>。</p>
<p>为了支持结果对象在 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 之间方便地转换，所有来自 URL 解析函数的返回值都会提供 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 方法 (当结果包含 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据) 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 方法 (当结果包含 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 数据)。 这些方法的签名与 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的对应方法相匹配 (不同之处在于其默认编码格式是 <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>)。 每个方法会输出包含相应类型的 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 数据 (对于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 方法) 或 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据 (对于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 方法) 的值。</p>
<p>对于某些需要在有可能不正确地转码的包含非 ASCII 数据的 URL 上进行操作的应用程序来说，在发起调用 URL 解析方法之前必须自行将字节串解码为字符。</p>
<p>在本节中描述的行为仅适用于 URL 解析函数。 URL 转码函数在产生和消耗字节序列时使用它们自己的规则，详情参见单独 URL 转码函数的文档。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>URL 解析函数现在接受 ASCII 编码的字节序列</p>
</div>
</section>
<section id="structured-parse-results">
<span id="urlparse-result-object"></span><h2>结构化解析结果</h2>
<p><a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 和 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 函数的结果对象是 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 类型的子类。 这些子类中增加了在那些函数的文档中列出的属性，之前小节中描述的编码和解码支持，以及一个附加方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.parse.urllib.parse.SplitResult.geturl">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.SplitResult.</span></span><span class="sig-name descname"><span class="pre">geturl</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>以字符串形式返回原始 URL 的重合并版本。 这可能与原始 URL 有所不同，例如协议的名称可能被正规化为小写字母、空的组成部分可能被丢弃。 特别地，空的参数、查询和片段标识符将会被移除。</p>
<p>对于 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 的结果，只有空的片段标识符会被移除。 对于 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 和 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 的结果，所有被记录的改变都会被应用到此方法所返回的 URL 上。</p>
<p>如果是通过原始的解析方法传回则此方法的结果会保持不变:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlsplit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;HTTP://www.Python.org/doc/#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>下面的类提供了当在 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 对象上操作时对结构化解析结果的实现:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.DefragResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">DefragResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 结果的实体类，包含有 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 方法会返回一个 <a class="reference internal" href="#urllib.parse.DefragResultBytes" title="urllib.parse.DefragResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResultBytes</span></code></a> 实例。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.ParseResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">ParseResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 结果的实体类，包含有 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 方法会返回一个 <a class="reference internal" href="#urllib.parse.ParseResultBytes" title="urllib.parse.ParseResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResultBytes</span></code></a> 实例。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.SplitResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">SplitResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 结果的实体类，包含有 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 数据。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 方法会返回一个 <a class="reference internal" href="#urllib.parse.SplitResultBytes" title="urllib.parse.SplitResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResultBytes</span></code></a> 实例。</p>
</dd></dl>

<p>下面的类提供了当在 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象上操作时对解析结果的实现:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.DefragResultBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">DefragResultBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 结果的实体类，包含有 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 数据。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 方法会返回一个 <a class="reference internal" href="#urllib.parse.DefragResult" title="urllib.parse.DefragResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResult</span></code></a> 实例。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.ParseResultBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">ParseResultBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 结果的实体类，包含有 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 数据。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 方法会返回一个 <a class="reference internal" href="#urllib.parse.ParseResult" title="urllib.parse.ParseResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResult</span></code></a> 实例。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.SplitResultBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">SplitResultBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用于 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 结果的实体类，包含有 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 数据。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 方法会返回一个 <a class="reference internal" href="#urllib.parse.SplitResult" title="urllib.parse.SplitResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResult</span></code></a> 实例。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="url-quoting">
<h2>URL 转码</h2>
<p>URL 转码函数的功能是接收程序数据并通过对特殊字符进行转码并正确编码非 ASCII 文本来将其转为可以安全地用作 URL 组成部分的形式。 它们还支持逆转此操作以便从作为 URL 组成部分的内容中重建原始数据，如果上述的 URL 解析函数还未覆盖此功能的话。</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.quote">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">quote</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>使用 <code class="samp docutils literal notranslate"><span class="pre">%</span><em><span class="pre">xx</span></em></code> 转义符替换 <em>string</em> 中的特殊字符。 字母、数字和 <code class="docutils literal notranslate"><span class="pre">'_.-~'</span></code> 等字符一定不会被转码。 在默认情况下，此函数只对 URL 的路径部分进行转码。 可选的 <em>safe</em> 形参额外指定不应被转码的 ASCII 字符 --- 其默认值为 <code class="docutils literal notranslate"><span class="pre">'/'</span></code>。</p>
<p><em>string</em> 可以是 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>从 <span class="target" id="index-34"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2396.html]</span> 迁移到 <span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc3986.html]</span> 以转码 URL 字符串。 &quot;~&quot; 现在已被包括在非保留字符集中。</p>
</div>
<p>可选的 <em>encoding</em> 和 <em>errors</em> 形参指明如何处理非 ASCII 字符，与 <a class="reference internal" href="stdtypes.xhtml#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 方法所接受的值一样。 <em>encoding</em> 默认为 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>。 <em>errors</em> 默认为 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>，表示不受支持的字符将引发 <a class="reference internal" href="exceptions.xhtml#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>。 如果 <em>string</em> 为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 则不可提供 <em>encoding</em> 和 <em>errors</em>，否则将引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>请注意 <code class="docutils literal notranslate"><span class="pre">quote(string,</span> <span class="pre">safe,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(string.encode(encoding,</span> <span class="pre">errors),</span> <span class="pre">safe)</span></code>。</p>
<p>例如: <code class="docutils literal notranslate"><span class="pre">quote('/El</span> <span class="pre">Niño/')</span></code> 将产生 <code class="docutils literal notranslate"><span class="pre">'/El%20Ni%C3%B1o/'</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.quote_plus">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">quote_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>，但还会使用加号来替换空格，如在构建放入 URL 的查询字符串时对于转码 HTML 表单值时所要求的那样。 原始字符串中的加号会被转义，除非它们已包括在 <em>safe</em> 中。 它也不会将 <em>safe</em> 的默认值设为 <code class="docutils literal notranslate"><span class="pre">'/'</span></code>。</p>
<p>例如: <code class="docutils literal notranslate"><span class="pre">quote_plus('/El</span> <span class="pre">Niño/')</span></code> 将产生 <code class="docutils literal notranslate"><span class="pre">'%2FEl+Ni%C3%B1o%2F'</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.quote_from_bytes">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">quote_from_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>，但是接受 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象而非 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，并且不执行从字符串到字节串的编码。</p>
<p>例如: <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(b'a&amp;\xef')</span></code> 将产生 <code class="docutils literal notranslate"><span class="pre">'a%26%EF'</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unquote">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unquote</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将 <code class="samp docutils literal notranslate"><span class="pre">%</span><em><span class="pre">xx</span></em></code> 转义符替换为等效的单字符。 可选的 <em>encoding</em> 和 <em>errors</em> 形参指定如何将以百分号编码的序列解码为 Unicode 字符，即 <a class="reference internal" href="stdtypes.xhtml#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 方法所接受的形式。</p>
<p><em>string</em> 可以是 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。</p>
<p><em>encoding</em> 默认为 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>。 <em>errors</em> 默认为 <code class="docutils literal notranslate"><span class="pre">'replace'</span></code>，表示无效的序列将被替换为占位字符。</p>
<p>例如: <code class="docutils literal notranslate"><span class="pre">unquote('/El%20Ni%C3%B1o/')</span></code> 将产生 <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span><em>string</em> 形参支持 bytes 和 str 对象（之前仅支持 str）。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unquote_plus">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unquote_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>类似于 <a class="reference internal" href="#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>，但还会将加号替换为空格，如反转码表单值所要求的。</p>
<p><em>string</em> 必须为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。</p>
<p>例如: <code class="docutils literal notranslate"><span class="pre">unquote_plus('/El+Ni%C3%B1o/')</span></code> 将产生 <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unquote_to_bytes">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unquote_to_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>用等价的单八位形式替换 <code class="samp docutils literal notranslate"><span class="pre">%</span><em><span class="pre">xx</span></em></code> 转义码，并返回一个 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。</p>
<p><em>string</em> 可以是 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象。</p>
<p>如果它是 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，则 <em>string</em> 中未转义的非 ASCII 字符会被编码为 UTF-8 字节串。</p>
<p>例如: <code class="docutils literal notranslate"><span class="pre">unquote_to_bytes('a%26%EF')</span></code> y将产生 <code class="docutils literal notranslate"><span class="pre">b'a&amp;\xef'</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlencode">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlencode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doseq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quote_via</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">quote_plus</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个包含有 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象的映射对象或二元组序列转换为以百分号编码的 ASCII 文本字符串。 如果所产生的字符串要被用作 <a class="reference internal" href="urllib.request.xhtml#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 函数的 POST 操作的 <em>data</em>，则它应当被编码为字节串，否则它将导致 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p>结果字符串是一系列 <code class="docutils literal notranslate"><span class="pre">key=value</span></code> 对，由 <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code> 字符进行分隔，其中 <em>key</em> 和 <em>value</em> 都已使用 <em>quote_via</em> 函数转码。 在默认情况下，会使用 <a class="reference internal" href="#urllib.parse.quote_plus" title="urllib.parse.quote_plus"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote_plus()</span></code></a> 来转码值，这意味着空格会被转码为 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 字符而 '/' 字符会被转码为 <code class="docutils literal notranslate"><span class="pre">%2F</span></code>，即遵循 GET 请求的标准 (<code class="docutils literal notranslate"><span class="pre">application/x-www-form-urlencoded</span></code>)。 另一个可以作为 <em>quote_via</em> 传入的替代函数是 <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>，它将把空格转码为 <code class="docutils literal notranslate"><span class="pre">%20</span></code> 并且不编码 '/' 字符。 为了最大程度地控制要转码的内容，请使用 <code class="docutils literal notranslate"><span class="pre">quote</span></code> 并指定 <em>safe</em> 的值。</p>
<p>当使用二元组序列作为 <em>query</em> 参数时，每个元组的第一个元素为键而第二个元素为值。 值元素本身也可以为一个序列，在那种情况下，如果可选的形参 <em>doseq</em> 的值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则每个键的值序列元素生成单个 <code class="docutils literal notranslate"><span class="pre">key=value</span></code> 对（以 <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code> 分隔）。 被编码的字符串中的参数顺序将与序列中的形参元素顺序相匹配。</p>
<p><em>safe</em>, <em>encoding</em> 和 <em>errors</em> 形参会被传递给 <em>quote_via</em> (<em>encoding</em> 和 <em>errors</em> 形参仅在查询元素为 <a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 时会被传递)。</p>
<p>为了反向执行这个编码过程，此模块提供了 <a class="reference internal" href="#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qs()</span></code></a> 和 <a class="reference internal" href="#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qsl()</span></code></a> 来将查询字符串解析为 Python 数据结构。</p>
<p>请参考 <a class="reference internal" href="urllib.request.xhtml#urllib-examples"><span class="std std-ref">urllib 示例</span></a> 来了解如何使用 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 方法来生成 URL 的查询字符串或 POST 请求的数据。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>查询支持字节和字符串对象。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>增加了 <em>quote_via</em> 形参。</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://url.spec.whatwg.org/">WHATWG</a><span class="link-target"> [https://url.spec.whatwg.org/]</span> -  URL 现有标准</dt><dd><p>定义 URL、域名、IP 地址、application/x-www-form-urlencoded 格式及其 API 的工作组。</p>
</dd>
<dt><span class="target" id="index-36"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc3986.html]</span> - 统一资源标识符</dt><dd><p>这是当前的标准 (STD66)。 任何对于 urllib.parse 模块的修改都必须遵循该标准。 某些偏离也可能会出现，这大都是出于向下兼容的目的以及特定的经常存在于各主要浏览器上的实际解析需求。</p>
</dd>
<dt><span class="target" id="index-37"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2732.html"><strong>RFC 2732</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2732.html]</span> - URL 中的 IPv6 Addresses 地址显示格式。</dt><dd><p>这指明了 IPv6 URL 的解析要求。</p>
</dd>
<dt><span class="target" id="index-38"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2396.html]</span> - 统一资源标识符（URI）：通用语法</dt><dd><p>描述统一资源名称 (URN) 和统一资源定位符 (URL) 通用语义要求的文档。</p>
</dd>
<dt><span class="target" id="index-39"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2368.html"><strong>RFC 2368</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2368.html]</span> - mailto URL 模式。</dt><dd><p>mailto URL 模式的解析要求。</p>
</dd>
<dt><span class="target" id="index-40"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc1808.html]</span> - 相对统一资源定位符</dt><dd><p>这个请求注释包括联结绝对和相对 URL 的规则，其中包括大量控制边界情况处理的 &quot;异常示例&quot;。</p>
</dd>
<dt><span class="target" id="index-41"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1738.html"><strong>RFC 1738</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc1738.html]</span> - 统一资源定位符 (URL)</dt><dd><p>这指明了绝对 URL 的正式语义和句法。</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>