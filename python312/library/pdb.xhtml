<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="pdb --- Python 的调试器" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/pdb.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/pdb.py[https://github.com/python/cpython/tree/3.12/Lib/pdb.py] pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。 调试器是可..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/pdb.py[https://github.com/python/cpython/tree/3.12/Lib/pdb.py] pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。 调试器是可..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>pdb --- Python 的调试器</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/pdb.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-pdb">
<span id="pdb-the-python-debugger"></span><span id="debugger"></span><h1><a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> --- Python 的调试器</h1>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/pdb.py">Lib/pdb.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/pdb.py]</span></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。</p>
<p id="index-1">调试器是可扩展的——调试器实际被定义为 <a class="reference internal" href="#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pdb</span></code></a> 类。该类目前没有文档，但通过阅读源码很容易理解它。扩展接口使用了 <a class="reference internal" href="bdb.xhtml#module-bdb" title="bdb: Debugger framework."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bdb</span></code></a> 和 <a class="reference internal" href="cmd.xhtml#module-cmd" title="cmd: Build line-oriented command interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmd</span></code></a> 模块。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt>模块 <a class="reference internal" href="faulthandler.xhtml#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a></dt><dd><p>用于在发生错误、超时或用户信号时显式地转储 Python 回溯信息。</p>
</dd>
<dt>模块 <a class="reference internal" href="traceback.xhtml#module-traceback" title="traceback: Print or retrieve a stack traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">traceback</span></code></a></dt><dd><p>提取、格式化和打印 Python 程序的栈回溯信息的标准接口。</p>
</dd>
</dl>
</div>
<p>中断进入调试器的典型用法是插入:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
</pre></div>
</div>
<p>或者:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">breakpoint</span><span class="p">()</span>
</pre></div>
</div>
<p>到你想进入调试器的位置，再运行程序。 然后你可以单步执行这条语句之后的代码，并使用 <a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">continue</span></code></a> 命令来关闭调试器继续运行。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>内置函数 <a class="reference internal" href="functions.xhtml#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a>，当以默认参数调用它时，可以用来代替 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">pdb;</span> <span class="pre">pdb.set_trace()</span></code>。</p>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="nb">breakpoint</span><span class="p">()</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">val</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> * 2 is </span><span class="si">{</span><span class="n">double</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>调试器的提示符为 <code class="docutils literal notranslate"><span class="pre">(Pdb)</span></code>，这指明你正处于调试模式下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="o">...</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="n">double</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">p</span> <span class="n">x</span>
<span class="mi">3</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="k">continue</span>
<span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="ow">is</span> <span class="mi">6</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>由 <a class="reference internal" href="readline.xhtml#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块实现的 Tab 补全可用于补全本模块的命令和命令的参数，例如，Tab 补全会提供当前的全局变量和局部变量，用作 <code class="docutils literal notranslate"><span class="pre">p</span></code> 命令的参数。</p>
</div>
<p>你还可以从命令行发起调用 <a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 来调试其他脚本。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">pdb</span> <span class="n">myscript</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>当作为模块发起调用时，如果被调试的程序异常退出则 pdb 将自动进入事后调试。 在事后调试之后（或程序正常退出之后），pdb 将重启程序。 自动重启会保留 pdb 的状态（如断点）并且在大多数情况下这比在退出程序的同时退出调试器更实用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">-c</span></code> 选项用来执行如同在 <code class="file docutils literal notranslate"><span class="pre">.pdbrc</span></code> 文件中给出的命令；参见 <a class="reference internal" href="#debugger-commands"><span class="std std-ref">调试器命令</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 选项用来以类似 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span></code> 的方式来执行模块。 就像一个脚本那样，调试器将在模块的第一行之前暂停执行。</p>
</div>
<p>在调试器控制下执行一条语句的典型用法如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdb</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">&quot;f(2)&quot;</span><span class="p">)</span>
<span class="go">&gt; &lt;string&gt;(1)&lt;module&gt;()</span>
<span class="go">(Pdb) continue</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>检查已崩溃程序的典型用法是:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pdb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">f</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdb</span><span class="o">.</span><span class="n">pm</span><span class="p">()</span>
<span class="go">&gt; &lt;stdin&gt;(2)f()</span>
<span class="go">(Pdb) p x</span>
<span class="go">0</span>
<span class="go">(Pdb)</span>
</pre></div>
</div>
<p>本模块定义了下列函数，每个函数进入调试器的方式略有不同：</p>
<dl class="py function">
<dt class="sig sig-object py" id="pdb.run">
<span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">statement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在调试器控制范围内执行 <em>statement</em> （以字符串或代码对象的形式提供）。调试器提示符会在执行代码前出现，你可以设置断点并键入 <a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">continue</span></code></a>，也可以使用 <a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">step</span></code></a> 或 <a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">next</span></code></a> 逐步执行语句（上述所有命令在后文有说明）。可选参数 <em>globals</em> 和 <em>locals</em> 指定代码执行环境，默认时使用 <a class="reference internal" href="__main__.xhtml#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 模块的字典。（请参阅内置函数 <a class="reference internal" href="functions.xhtml#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 或 <a class="reference internal" href="functions.xhtml#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的说明。）</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pdb.runeval">
<span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">runeval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expression</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在调试器控制下对 <em>expression</em> (以字符串或代码对象的形式给出) 求值。 当 <a class="reference internal" href="#pdb.runeval" title="pdb.runeval"><code class="xref py py-func docutils literal notranslate"><span class="pre">runeval()</span></code></a> 返回时，它将返回 <em>expression</em> 的值。 在其他方面此函数与 <a class="reference internal" href="#pdb.run" title="pdb.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 类似。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pdb.runcall">
<span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">runcall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>使用给定的参数调用 <em>function</em> （以函数或方法对象的形式提供，不能是字符串）。<a class="reference internal" href="#pdb.runcall" title="pdb.runcall"><code class="xref py py-func docutils literal notranslate"><span class="pre">runcall()</span></code></a> 返回的是所调用函数的返回值。调试器提示符将在进入函数后立即出现。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pdb.set_trace">
<span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">set_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>在调用本函数的堆栈帧处进入调试器。用于硬编码一个断点到程序中的固定点处，即使该代码不在调试状态（如断言失败时）。如果传入 <em>header</em>，它将在调试开始前被打印到控制台。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>仅关键字参数 <em>header</em>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pdb.post_mortem">
<span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">post_mortem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traceback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>进入 <em>traceback</em> 对象的事后调试。如果没有给定 <em>traceback</em>，默认使用当前正在处理的异常之一（默认时，必须存在正在处理的异常）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pdb.pm">
<span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">pm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Enter post-mortem debugging of the traceback found in
<a class="reference internal" href="sys.xhtml#sys.last_traceback" title="sys.last_traceback"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.last_traceback</span></code></a>.</p>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">run*</span></code> 函数和 <a class="reference internal" href="#pdb.set_trace" title="pdb.set_trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_trace()</span></code></a> 都是别名，用于实例化 <a class="reference internal" href="#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pdb</span></code></a> 类和调用同名方法。如果要使用其他功能，则必须自己执行以下操作：</p>
<dl class="py class">
<dt class="sig sig-object py" id="pdb.Pdb">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pdb.</span></span><span class="sig-name descname"><span class="pre">Pdb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">completekey</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tab'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nosigint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readrc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#pdb.Pdb" title="pdb.Pdb"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pdb</span></code></a> 是调试器类。</p>
<p><em>completekey</em>、<em>stdin</em> 和 <em>stdout</em> 参数都会传递给底层的 <a class="reference internal" href="cmd.xhtml#cmd.Cmd" title="cmd.Cmd"><code class="xref py py-class docutils literal notranslate"><span class="pre">cmd.Cmd</span></code></a> 类，请参考相应的描述。</p>
<p>如果给出 <em>skip</em> 参数，则它必须是一个迭代器，可以迭代出 glob-style 样式的模块名称。如果遇到匹配上述样式的模块，调试器将不会进入来自该模块的堆栈帧。 <a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>默认情况下，当发出 <a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">continue</span></code></a> 命令时，Pdb 将为 SIGINT 信号（信号当用户在控制台按 <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> 时发出的）设置一个处理器。 这使用户可以通过按 <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> 再次进入调试器。 如果你希望 Pdb 不要改变 SIGINT 处理器，请将 <em>nosigint</em> 设为真值。to true.</p>
<p><em>readrc</em> 参数默认为 true，它控制 Pdb 是否从文件系统加载 .pdbrc 文件。</p>
<p>启用跟踪且带有 <em>skip</em> 参数的调用示范:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span> <span class="n">pdb</span><span class="o">.</span><span class="n">Pdb</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;django.*&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
</pre></div>
</div>
<p class="audit-hook">引发一个 <a class="reference internal" href="sys.xhtml#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">pdb.Pdb</span></code>，没有附带参数。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.1 版本发生变更: </span>增加了 <em>skip</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <em>nosigint</em> 形参。 在之前版本中，pdb 绝不会设置 SIGINT 处理器。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span><em>readrc</em> 参数。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pdb.Pdb.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">statement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py" id="pdb.Pdb.runeval">
<span class="sig-name descname"><span class="pre">runeval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expression</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py" id="pdb.Pdb.runcall">
<span class="sig-name descname"><span class="pre">runcall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py" id="pdb.Pdb.set_trace">
<span class="sig-name descname"><span class="pre">set_trace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>请参阅上文解释同名函数的文档。</p>
</dd></dl>

</dd></dl>

<section id="debugger-commands">
<span id="id2"></span><h2>调试器命令</h2>
<p>下方列出的是调试器可接受的命令。如下所示，大多数命令可以缩写为一个或两个字母。如 <code class="docutils literal notranslate"><span class="pre">h(elp)</span></code> 表示可以输入 <code class="docutils literal notranslate"><span class="pre">h</span></code> 或 <code class="docutils literal notranslate"><span class="pre">help</span></code> 来输入帮助命令（但不能输入 <code class="docutils literal notranslate"><span class="pre">he</span></code> 或 <code class="docutils literal notranslate"><span class="pre">hel</span></code>，也不能是 <code class="docutils literal notranslate"><span class="pre">H</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Help</span></code> 或 <code class="docutils literal notranslate"><span class="pre">HELP</span></code>）。命令的参数必须用空格（空格符或制表符）分隔。在命令语法中，可选参数括在方括号 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) 中，使用时请勿输入方括号。命令语法中的选择项由竖线 (<code class="docutils literal notranslate"><span class="pre">|</span></code>) 分隔。</p>
<p>输入一个空白行将重复最后输入的命令。例外：如果最后一个命令是 <a class="reference internal" href="#pdbcommand-list"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">list</span></code></a> 命令，则会列出接下来的 11 行。</p>
<p>调试器无法识别的命令将被认为是 Python 语句，并在正在调试的程序的上下文中执行。Python 语句也可以用感叹号 (<code class="docutils literal notranslate"><span class="pre">!</span></code>) 作为前缀。这是检查正在调试的程序的强大方法，甚至可以修改变量或调用函数。当此类语句发生异常，将打印异常名称，但调试器的状态不会改变。</p>
<p>调试器支持 <a class="reference internal" href="#debugger-aliases"><span class="std std-ref">别名</span></a>。别名可以有参数，使得调试器对被检查的上下文有一定程度的适应性。</p>
<p>在一行中可以输入多条命令，以 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 分隔。 （不能使用单个 <code class="docutils literal notranslate"><span class="pre">;</span></code>，因为它已被用作传给 Python 解析器的一行中的多条命令的分隔符。） 命令切分所用的方式没有任何智能可言；输入总是会在第一个 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 对上被切分，即使它位于带引号的字符串中。 对于带有双分号的字符串可以使用隐式字符串拼接 <code class="docutils literal notranslate"><span class="pre">';'';'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;;&quot;&quot;;&quot;</span></code> 来变通处理。</p>
<p>要设置临时全局变量，请使用 <em>快捷变量</em>。 <em>快捷变量</em> 是名称以 <code class="docutils literal notranslate"><span class="pre">$</span></code> 打头的变量。 例如，<code class="docutils literal notranslate"><span class="pre">$foo</span> <span class="pre">=</span> <span class="pre">1</span></code> 将设置一个全局变量 <code class="docutils literal notranslate"><span class="pre">$foo</span></code> 供你在调试器会话中使用。 <em>快捷变量</em> 会在程序恢复执行时被清空因此它不大可能像使用普通变量如 <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span> <span class="pre">1</span></code> 那样影响到你的程序。</p>
<p>存在三个预设的 <em>快捷变量</em>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$_frame</span></code>: 你正在调试的当前帧</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_retval</span></code>: 当帧返回时的返回值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_exception</span></code>: 当帧引发异常时的异常值</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12: </span>Added the <em>convenience variable</em> feature.</p>
</div>
<p id="index-2">如果文件 <code class="file docutils literal notranslate"><span class="pre">.pdbrc</span></code> 存在于用户主目录或当前目录中，则它将以 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码格式被读入并执行，就像是在调试器提示符下被键入一样，不同之处在于空行和以 <code class="docutils literal notranslate"><span class="pre">#</span></code> 开头的行会被忽略。 这对于别名特别有用。 如果两个文件都存在，则会先读取主目录中的文件并且在那里定义的别名可以被本地文件所覆盖。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span><code class="file docutils literal notranslate"><span class="pre">.pdbrc</span></code> 现在可以包含继续调试的命令，如 <a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">continue</span></code></a> 或 <a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">next</span></code></a>。文件中的这些命令以前是无效的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><code class="file docutils literal notranslate"><span class="pre">.pdbrc</span></code> 现在将以 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 编码格式来读取。 在之前版本中，它是以系统语言区域编码格式来读取的。</p>
</div>
<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-help">
<span class="sig-name descname"><span class="pre">h(elp)</span></span><span class="sig-prename descclassname"> <span class="pre">[command]</span></span></dt>
<dd><p>不带参数时，显示可用的命令列表。参数为 <em>command</em> 时，打印有关该命令的帮助。<code class="docutils literal notranslate"><span class="pre">help</span> <span class="pre">pdb</span></code> 显示完整文档（即 <a class="reference internal" href="#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 模块的文档字符串）。由于 <em>command</em> 参数必须是标识符，因此要获取 <code class="docutils literal notranslate"><span class="pre">!</span></code> 的帮助必须输入 <code class="docutils literal notranslate"><span class="pre">help</span> <span class="pre">exec</span></code>。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-where">
<span class="sig-name descname"><span class="pre">w(here)</span></span></dt>
<dd><p>打印栈回溯，最新的帧位于底部。 有一个箭头 (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) 指明当前帧，该帧决定了大多数命令的上下文。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-down">
<span class="sig-name descname"><span class="pre">d(own)</span></span><span class="sig-prename descclassname"> <span class="pre">[count]</span></span></dt>
<dd><p>在堆栈回溯中，将当前帧向下移动 <em>count</em> 级（默认为 1 级，移向更新的帧）。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-up">
<span class="sig-name descname"><span class="pre">u(p)</span></span><span class="sig-prename descclassname"> <span class="pre">[count]</span></span></dt>
<dd><p>在堆栈回溯中，将当前帧向上移动 <em>count</em> 级（默认为 1 级，移向更老的帧）。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-break">
<span class="sig-name descname"><span class="pre">b(reak)</span></span><span class="sig-prename descclassname"> <span class="pre">[([filename:]lineno</span> <span class="pre">|</span> <span class="pre">function)</span> <span class="pre">[,</span> <span class="pre">condition]]</span></span></dt>
<dd><p>With a <em>lineno</em> argument, set a break there in the current file.  With a
<em>function</em> argument, set a break at the first executable statement within
that function.  The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that hasn't been loaded
yet).  The file is searched on <a class="reference internal" href="sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.  Note that each breakpoint
is assigned a number to which all the other breakpoint commands refer.</p>
<p>如果第二个参数存在，它应该是一个表达式，且它的计算值为 true 时断点才起作用。</p>
<p>如果不带参数执行，将列出所有中断，包括每个断点、命中该断点的次数、当前的忽略次数以及关联的条件（如果有）。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-tbreak">
<span class="sig-name descname"><span class="pre">tbreak</span></span><span class="sig-prename descclassname"> <span class="pre">[([filename:]lineno</span> <span class="pre">|</span> <span class="pre">function)</span> <span class="pre">[,</span> <span class="pre">condition]]</span></span></dt>
<dd><p>临时断点，在第一次命中时会自动删除。它的参数与 <a class="reference internal" href="#pdbcommand-break"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">break</span></code></a> 相同。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-clear">
<span class="sig-name descname"><span class="pre">cl(ear)</span></span><span class="sig-prename descclassname"> <span class="pre">[filename:lineno</span> <span class="pre">|</span> <span class="pre">bpnumber</span> <span class="pre">...]</span></span></dt>
<dd><p>如果参数是 <em>filename:lineno</em>，则清除此行上的所有断点。如果参数是空格分隔的断点编号列表，则清除这些断点。如果不带参数，则清除所有断点（但会先提示确认）。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-disable">
<span class="sig-name descname"><span class="pre">disable</span></span><span class="sig-prename descclassname"> <span class="pre">bpnumber</span> <span class="pre">[bpnumber</span> <span class="pre">...]</span></span></dt>
<dd><p>禁用断点，断点以空格分隔的断点编号列表给出。禁用断点表示它不会导致程序停止执行，但是与清除断点不同，禁用的断点将保留在断点列表中并且可以（重新）启用。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-enable">
<span class="sig-name descname"><span class="pre">enable</span></span><span class="sig-prename descclassname"> <span class="pre">bpnumber</span> <span class="pre">[bpnumber</span> <span class="pre">...]</span></span></dt>
<dd><p>启用指定的断点。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-ignore">
<span class="sig-name descname"><span class="pre">ignore</span></span><span class="sig-prename descclassname"> <span class="pre">bpnumber</span> <span class="pre">[count]</span></span></dt>
<dd><p>为指定的断点编号设置忽略次数。 如果省略 <em>count</em>，则忽略次数将设置为 0。 当忽略次数为零时断点将变为活动状态。 如果为非零值，则在每次到达断点且断点未禁用且关联条件取真值时 <em>count</em> 就像递减。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-condition">
<span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-prename descclassname"> <span class="pre">bpnumber</span> <span class="pre">[condition]</span></span></dt>
<dd><p>为断点设置一个新 <em>condition</em>，它是一个表达式，且它的计算值为 true 时断点才起作用。如果没有给出 <em>condition</em>，则删除现有条件，也就是将断点设为无条件。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-commands">
<span class="sig-name descname"><span class="pre">commands</span></span><span class="sig-prename descclassname"> <span class="pre">[bpnumber]</span></span></dt>
<dd><p>为编号是 <em>bpnumber</em> 的断点指定一系列命令。命令内容将显示在后续的几行中。输入仅包含 <code class="docutils literal notranslate"><span class="pre">end</span></code> 的行来结束命令列表。举个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">commands</span> <span class="mi">1</span>
<span class="p">(</span><span class="n">com</span><span class="p">)</span> <span class="n">p</span> <span class="n">some_variable</span>
<span class="p">(</span><span class="n">com</span><span class="p">)</span> <span class="n">end</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span>
</pre></div>
</div>
<p>要删除断点上的所有命令，请输入 <code class="docutils literal notranslate"><span class="pre">commands</span></code> 并立即以 <code class="docutils literal notranslate"><span class="pre">end</span></code> 结尾，也就是不指定任何命令。</p>
<p>如果不带 <em>bpnumber</em> 参数，<code class="docutils literal notranslate"><span class="pre">commands</span></code> 作用于最后一个被设置的断点。</p>
<p>可以为断点指定命令来重新启动程序。只需使用 <a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">continue</span></code></a> 或 <a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">step</span></code></a> 命令或其他可以继续运行程序的命令。</p>
<p>如果指定了某个继续运行程序的命令（目前包括 <a class="reference internal" href="#pdbcommand-continue"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">continue</span></code></a>, <a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">step</span></code></a>, <a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">next</span></code></a>, <a class="reference internal" href="#pdbcommand-return"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">return</span></code></a>, <a class="reference internal" href="#pdbcommand-jump"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">jump</span></code></a>, <a class="reference internal" href="#pdbcommand-quit"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">quit</span></code></a> 及它们的缩写）将终止命令列表（就像该命令后紧跟着 end）。因为在任何时候继续运行下去（即使是简单的 next 或 step），都可能会遇到另一个断点，该断点可能具有自己的命令列表，这导致要执行的列表含糊不清。</p>
<p>如果在命令列表中使用 <code class="docutils literal notranslate"><span class="pre">silent</span></code> 命令，那么在断点处停下时就不会打印常规信息。 这正是要打印特定消息然后继续运行的断点所想要的。 如果没有其他命令来打印任何消息，则你将不会看到已到达断点的迹象。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-step">
<span class="sig-name descname"><span class="pre">s(tep)</span></span></dt>
<dd><p>运行当前行，在第一个可以停止的位置（在被调用的函数内部或在当前函数的下一行）停下。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-next">
<span class="sig-name descname"><span class="pre">n(ext)</span></span></dt>
<dd><p>继续运行，直到运行到当前函数的下一行，或当前函数返回为止。（ <a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">next</span></code></a> 和 <a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">step</span></code></a> 之间的区别在于，<a class="reference internal" href="#pdbcommand-step"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">step</span></code></a> 进入被调用函数内部并停止，而 <a class="reference internal" href="#pdbcommand-next"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">next</span></code></a> （几乎）全速运行被调用函数，仅在当前函数的下一行停止。）</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-until">
<span class="sig-name descname"><span class="pre">unt(il)</span></span><span class="sig-prename descclassname"> <span class="pre">[lineno]</span></span></dt>
<dd><p>如果不带参数，则继续运行，直到行号比当前行大时停止。</p>
<p>如果带有 <em>lineno</em>，则继续执行直至行号大于或等于 <em>lineno</em>。 在这两种情况下，在当前帧返回时也将停止。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>允许明确给定行号。</p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-return">
<span class="sig-name descname"><span class="pre">r(eturn)</span></span></dt>
<dd><p>继续运行，直到当前函数返回。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-continue">
<span class="sig-name descname"><span class="pre">c(ont(inue))</span></span></dt>
<dd><p>继续运行，仅在遇到断点时停止。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-jump">
<span class="sig-name descname"><span class="pre">j(ump)</span></span><span class="sig-prename descclassname"> <span class="pre">lineno</span></span></dt>
<dd><p>设置即将运行的下一行。仅可用于堆栈最底部的帧。它可以往回跳来再次运行代码，也可以往前跳来跳过不想运行的代码。</p>
<p>需要注意的是，不是所有的跳转都是允许的 -- 例如，不能跳转到 <a class="reference internal" href="../reference/compound_stmts.xhtml#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环的中间或跳出 <a class="reference internal" href="../reference/compound_stmts.xhtml#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-list">
<span class="sig-name descname"><span class="pre">l(ist)</span></span><span class="sig-prename descclassname"> <span class="pre">[first[,</span> <span class="pre">last]]</span></span></dt>
<dd><p>列出当前文件的源代码。如果不带参数，则列出当前行周围的 11 行，或延续前一次列出。如果用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 作为参数，则列出当前行周围的 11 行。如果带有一个参数，则列出那一行周围的 11 行。如果带有两个参数，则列出所给的范围中的代码；如果第二个参数小于第一个参数，则将其解释为列出行数的计数。</p>
<p>当前帧中的当前行用 <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> 标记。如果正在调试异常，且最早抛出或传递该异常的行不是当前行，则那一行用 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 标记。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>增加了 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 标记。</p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-ll">
<span class="sig-name descname"><span class="pre">ll</span></span><span class="sig-prename descclassname"> <span class="pre">|</span> <span class="pre">longlist</span></span></dt>
<dd><p>列出当前函数或帧的所有源代码。相关行的标记与 <a class="reference internal" href="#pdbcommand-list"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">list</span></code></a> 相同。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-args">
<span class="sig-name descname"><span class="pre">a(rgs)</span></span></dt>
<dd><p>打印当前函数的参数及其当前的值。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-p">
<span class="sig-name descname"><span class="pre">p</span></span><span class="sig-prename descclassname"> <span class="pre">expression</span></span></dt>
<dd><p>在当前上下文中对 <em>expression</em> 求值并打印该值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">print()</span></code> 也可以使用，但它不是一个调试器命令 --- 它执行 Python <a class="reference internal" href="functions.xhtml#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 函数。</p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-pp">
<span class="sig-name descname"><span class="pre">pp</span></span><span class="sig-prename descclassname"> <span class="pre">expression</span></span></dt>
<dd><p>与 <a class="reference internal" href="#pdbcommand-p"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">p</span></code></a> 命令类似，但 <em>expression</em> 的值将使用 <a class="reference internal" href="pprint.xhtml#module-pprint" title="pprint: Data pretty printer."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pprint</span></code></a> 模块美观地打印。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-whatis">
<span class="sig-name descname"><span class="pre">whatis</span></span><span class="sig-prename descclassname"> <span class="pre">expression</span></span></dt>
<dd><p>打印 <em>expression</em> 的类型。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-prename descclassname"> <span class="pre">expression</span></span></dt>
<dd><p>尝试获取 <em>expression</em> 的源代码并显示它。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-prename descclassname"> <span class="pre">[expression]</span></span></dt>
<dd><p>如果 <em>expression</em> 的值发生变化则显示它的值，每次都会停止执行当前帧。</p>
<p>如果不带 <em>expression</em>，则列出当前帧的所有显示表达式。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>显示 <em>expression</em> 的值并与 <em>expression</em> 之前的求值结果进行比较，因此当结果可变时，显示可能无法体现变化。</p>
</div>
<p>示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nb">breakpoint</span><span class="p">()</span>
<span class="k">pass</span>
<span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</pre></div>
</div>
<p>显示将不会发现 <code class="docutils literal notranslate"><span class="pre">lst</span></code> 已被改变因为求值结果在执行比较之前已被 <code class="docutils literal notranslate"><span class="pre">lst.append(1)</span></code> 原地修改了:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="k">pass</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">display</span> <span class="n">lst</span>
<span class="n">display</span> <span class="n">lst</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">n</span>
<span class="o">&gt;</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">n</span>
<span class="o">&gt;</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以通过拷贝机制巧妙地实现此功能:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="k">pass</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">display</span> <span class="n">lst</span><span class="p">[:]</span>
<span class="n">display</span> <span class="n">lst</span><span class="p">[:]:</span> <span class="p">[]</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">n</span>
<span class="o">&gt;</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span> <span class="n">n</span>
<span class="o">&gt;</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">-&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="n">display</span> <span class="n">lst</span><span class="p">[:]:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">[</span><span class="n">old</span><span class="p">:</span> <span class="p">[]]</span>
<span class="p">(</span><span class="n">Pdb</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-undisplay">
<span class="sig-name descname"><span class="pre">undisplay</span></span><span class="sig-prename descclassname"> <span class="pre">[expression]</span></span></dt>
<dd><p>不再显示当前帧中的 <em>expression</em>。 如果不带 <em>expression</em>，则清除当前帧的所有显示表达式。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-interact">
<span class="sig-name descname"><span class="pre">interact</span></span></dt>
<dd><p>Start an interactive interpreter (using the <a class="reference internal" href="code.xhtml#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> module) whose global
namespace contains all the (global and local) names found in the current
scope.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="std pdbcommand" id="debugger-aliases">
<dt class="sig sig-object std" id="pdbcommand-alias">
<span class="sig-name descname"><span class="pre">alias</span></span><span class="sig-prename descclassname"> <span class="pre">[name</span> <span class="pre">[command]]</span></span></dt>
<dd><p>Create an alias called <em>name</em> that executes <em>command</em>.  The <em>command</em> must
<em>not</em> be enclosed in quotes.  Replaceable parameters can be indicated by
<code class="docutils literal notranslate"><span class="pre">%1</span></code>, <code class="docutils literal notranslate"><span class="pre">%2</span></code>, and so on, while <code class="docutils literal notranslate"><span class="pre">%*</span></code> is replaced by all the parameters.
If <em>command</em> is omitted, the current alias for <em>name</em> is shown. If no
arguments are given, all aliases are listed.</p>
<p>别名允许嵌套并可包含能在 pdb 提示符下合法输入的任何内容。 请注意内部 pdb 命令 <em>可以</em> 被别名所覆盖。 这样的命令将被隐藏直到别名被移除。 别名会递归地应用到命令行的第一个单词；行内的其他单词不会受影响。</p>
<p>作为示例，这里列出了两个有用的别名（特别适合放在 <code class="file docutils literal notranslate"><span class="pre">.pdbrc</span></code> 文件中）:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print instance variables (usage &quot;pi classInst&quot;)</span>
<span class="n">alias</span> <span class="n">pi</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="o">%</span><span class="mf">1.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;%1.</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="o">%</span><span class="mf">1.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="c1"># Print instance variables in self</span>
<span class="n">alias</span> <span class="n">ps</span> <span class="n">pi</span> <span class="bp">self</span>
</pre></div>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-unalias">
<span class="sig-name descname"><span class="pre">unalias</span></span><span class="sig-prename descclassname"> <span class="pre">name</span></span></dt>
<dd><p>删除指定的别名 <em>name</em>。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-0">
<span class="sig-name descname"><span class="pre">!</span></span><span class="sig-prename descclassname"> <span class="pre">statement</span></span></dt>
<dd><p>在当前栈帧的上下文中执行 (单行的) <em>statement</em>。 感叹号可以被省略，除非第一个语句的第一个单词与某个调试器命名重名，例如:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(Pdb) ! n=42
(Pdb)
</pre></div>
</div>
<p>要设置全局变量，你可以在同一行上在赋值命令前添加 <a class="reference internal" href="../reference/simple_stmts.xhtml#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> 语句，例如:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(Pdb) global list_options; list_options = [&#39;-l&#39;]
(Pdb)
</pre></div>
</div>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-prename descclassname"> <span class="pre">[args</span> <span class="pre">...]</span></span></dt>
<dt class="sig sig-object std" id="pdbcommand-restart">
<span class="sig-name descname"><span class="pre">restart</span></span><span class="sig-prename descclassname"> <span class="pre">[args</span> <span class="pre">...]</span></span></dt>
<dd><p>重启被调试的 Python 程序。 如果提供了 <em>args</em>，它会用 <a class="reference internal" href="shlex.xhtml#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> 来拆分且拆分结果将被用作新的 <a class="reference internal" href="sys.xhtml#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>。 历史、中断点、动作和调试器选项将被保留。 <a class="reference internal" href="#pdbcommand-restart"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">restart</span></code></a> 是 <a class="reference internal" href="#pdbcommand-run"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">run</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-quit">
<span class="sig-name descname"><span class="pre">q(uit)</span></span></dt>
<dd><p>退出调试器。 被执行的程序将被中止。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-prename descclassname"> <span class="pre">code</span></span></dt>
<dd><p>进入一个对 <em>code</em> 执行步进的递归调试器（该参数是在当前环境中执行的任意表达式或语句）。</p>
</dd></dl>

<dl class="std pdbcommand">
<dt class="sig sig-object std" id="pdbcommand-retval">
<span class="sig-name descname"><span class="pre">retval</span></span></dt>
<dd><p>打印当前函数最后一次返回的返回值。</p>
</dd></dl>

<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>一个帧是否会被认为源自特定模块是由帧全局变量 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 来决定的。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>