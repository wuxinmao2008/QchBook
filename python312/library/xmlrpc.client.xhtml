<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="xmlrpc.client --- XML-RPC 客户端访问" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/xmlrpc.client.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/xmlrpc/client.py[https://github.com/python/cpython/tree/3.12/Lib/xmlrpc/client.py] XML-RPC 是一种远程过程调用方法，它以使用 HTTP(S) 传递的 XML 作为载体。 通过它，客户端可以在远程服务器（服务器以 URI 指明）上调用带参数的方法并获取结构化的数据。 本模块支持编写 XM..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码: Lib/xmlrpc/client.py[https://github.com/python/cpython/tree/3.12/Lib/xmlrpc/client.py] XML-RPC 是一种远程过程调用方法，它以使用 HTTP(S) 传递的 XML 作为载体。 通过它，客户端可以在远程服务器（服务器以 URI 指明）上调用带参数的方法并获取结构化的数据。 本模块支持编写 XM..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>xmlrpc.client --- XML-RPC 客户端访问</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/library/xmlrpc.client.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="module-xmlrpc.client">
<span id="xmlrpc-client-xml-rpc-client-access"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code> --- XML-RPC 客户端访问</h1>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/xmlrpc/client.py">Lib/xmlrpc/client.py</a><span class="link-target"> [https://github.com/python/cpython/tree/3.12/Lib/xmlrpc/client.py]</span></p>
<hr class="docutils" />
<p>XML-RPC 是一种远程过程调用方法，它以使用 HTTP(S) 传递的 XML 作为载体。 通过它，客户端可以在远程服务器（服务器以 URI 指明）上调用带参数的方法并获取结构化的数据。 本模块支持编写 XML-RPC 客户端代码；它会处理在通用 Python 对象和 XML 之间进行在线翻译的所有细节。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> 模块对于恶意构建的数据是不安全的。 如果你需要解析不受信任或未经身份验证的数据，请参阅 <a class="reference internal" href="xml.xhtml#xml-vulnerabilities"><span class="std std-ref">XML 漏洞</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>对于 HTTPS URI，现在 <a class="reference internal" href="#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> 默认会执行所有必要的证书和主机名检查。</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.xhtml#availability"><span class="std std-ref">可用性</span></a>: 非 Emscripten，非 WASI。</p>
<p>此模块在 WebAssembly 平台 <code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> 和 <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code> 上不适用或不可用。 请参阅 <a class="reference internal" href="intro.xhtml#wasm-availability"><span class="std std-ref">WebAssembly 平台</span></a> 了解详情。</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="xmlrpc.client.ServerProxy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">ServerProxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transport</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_datetime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_builtin_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 实例是管理与远程 XML-RPC 服务器通信的对象。 要求的第一个参数为 URI (统一资源定位符)，通常就是服务器的 URL。 可选的第二个参数为传输工厂实例；在默认情况下对于 https: URL 是一个内部 <code class="xref py py-class docutils literal notranslate"><span class="pre">SafeTransport</span></code> 实例，在其他情况下则是一个内部 HTTP <code class="xref py py-class docutils literal notranslate"><span class="pre">Transport</span></code> 实例。 可选的第三个参数为编码格式，默认为 UTF-8。 可选的第四个参数为调试旗标。</p>
<p>下列形参控制所返回代理实例的使用。 如果 <em>allow_none</em> 为真值，则 Python 常量 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将被转写至 XML；默认行为是针对 <code class="docutils literal notranslate"><span class="pre">None</span></code> 引发 <a class="reference internal" href="exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 这是对 XML-RPC 规格的一个常用扩展，但并不被所有客户端和服务器所支持；请参阅 <a class="reference external" href="https://web.archive.org/web/20130120074804/http://ontosys.com/xml-rpc/extensions.php">http://ontosys.com/xml-rpc/extensions.php</a><span class="link-target"> [https://web.archive.org/web/20130120074804/http://ontosys.com/xml-rpc/extensions.php]</span> 了解详情。 <em>use_builtin_types</em> 旗标可被用来将日期/时间值表示为 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 对象而将二进制数据表示为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象；此旗标默认为假值。 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>, <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象可以被传给调用操作。 <em>headers</em> 形参为可选的随每次请求发送的 HTTP 标头序列，其形式为包含代表标头名称和值的二元组序列 (例如 <code class="docutils literal notranslate"><span class="pre">[('Header-Name',</span> <span class="pre">'value')]</span></code>)。 已淘汰的 <em>use_datetime</em> 旗标与 <em>use_builtin_types</em> 类似但它只针对日期/时间值。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>增加了 <em>use_builtin_types</em> 旗标。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了 <em>headers</em> 形参。</p>
<p>HTTP 和 HTTPS 传输均支持用于 HTTP 基本身份验证的 URL 语法扩展: <code class="docutils literal notranslate"><span class="pre">http://user:pass&#64;host:port/path</span></code>。 <code class="docutils literal notranslate"><span class="pre">user:pass</span></code> 部分将以 base64 编码为 HTTP 'Authorization' 标头，并在发起调用 XML-RPC 方法时作为连接过程的一部分发送给远程服务器。 你只需要在远程服务器要求基本身份验证账号和密码时使用此语法。 如果提供了 HTTPS URL，<em>context</em> 可以为 <a class="reference internal" href="ssl.xhtml#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 并配置有下层 HTTPS 连接的 SSL 设置。</p>
<p>返回的实例是一个代理对象，具有可被用来在远程服务器上发起相应 RPC 调用的方法。 如果远程服务器支持内省 API，则也可使用该代理对象在远程服务器上查询它所支持的方法（服务发现）并获取其他服务器相关的元数据</p>
<p>适用的类型（即可通过 XML 生成 marshall 对象），包括如下类型（除了已说明的例外，它们都会被反 marshall 为同样的 Python 类型）:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>XML-RPC类型</p></th>
<th class="head"><p>Python 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">boolean</span></code></p></td>
<td><p><a class="reference internal" href="functions.xhtml#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">i1</span></code>, <code class="docutils literal notranslate"><span class="pre">i2</span></code>,  <code class="docutils literal notranslate"><span class="pre">i4</span></code>, <code class="docutils literal notranslate"><span class="pre">i8</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">biginteger</span></code></p></td>
<td><p><a class="reference internal" href="functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的范围从 -2147483648 到 2147483647。值将获得 <code class="docutils literal notranslate"><span class="pre">&lt;int&gt;</span></code> 标志。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">double</span></code> 或 <code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p><a class="reference internal" href="functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>。值将获得 <code class="docutils literal notranslate"><span class="pre">&lt;double&gt;</span></code> 标志。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">array</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 包含整合元素。数组以 <a class="reference internal" href="stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code></a> 形式返回。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">struct</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。 键必须为字符串，值可以为任何适用的类型。 可以传入用户自定义类的对象；只有其 <a class="reference internal" href="stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性会被传输。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dateTime.iso8601</span></code></p></td>
<td><p><a class="reference internal" href="#xmlrpc.client.DateTime" title="xmlrpc.client.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> 或 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>。返回的类型取决于 <em>use_builtin_types</em> 和 <em>use_datetime</em> 标志的值。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">base64</span></code></p></td>
<td><p><a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a>, <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>。返回的类型取决于 <em>use_builtin_types</em> 标志的值。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nil</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> 常量。仅当 <em>allow_none</em> 为true时才允许传递。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bigdecimal</span></code></p></td>
<td><p><a class="reference internal" href="decimal.xhtml#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>.  仅返回类型。</p></td>
</tr>
</tbody>
</table>
<p>这是This is the full set of data types supported by XML-RPC 所支持数据类型的完整集合。 方法调用也可能引发一个特殊的 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 实例，用来提示 XML-RPC 服务器错误，或是用 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProtocolError</span></code></a> 来提示 HTTP/HTTPS 传输层中的错误。 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 和 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProtocolError</span></code></a> 都派生自名为 <code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code> 的基类。 请注意 xmlrpc client 模块目前不可 marshal 内置类型的子类的实例。</p>
<p>当传入字符串时，XML 中的特殊字符如 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 将被自动转义。 但是，调用方有责任确保字符串中没有 XML 中不允许的字符，例如 ASCII 值在 0 和 31 之间的控制字符（当然，制表、换行和回车除外）；不这样做将导致 XML-RPC 请求的 XML 格式不正确。 如果你必须通过 XML-RPC 传入任意字节数据，请使用 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类或者下文描述的 <a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 包装器类。</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code> 被保留作为 <a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 的别名用于向下兼容。 新的代码应当使用 <a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span>增加了 <em>context</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>增加了对带有前缀的类型标签的支持 (例如 <code class="docutils literal notranslate"><span class="pre">ex:nil</span></code>)。 增加了对反 marshall 被 Apache XML-RPC 实现用于表示数值的附加类型的支持: <code class="docutils literal notranslate"><span class="pre">i1</span></code>, <code class="docutils literal notranslate"><span class="pre">i2</span></code>, <code class="docutils literal notranslate"><span class="pre">i8</span></code>, <code class="docutils literal notranslate"><span class="pre">biginteger</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bigdecimal</span></code>。 请参阅 <a class="reference external" href="https://ws.apache.org/xmlrpc/types.html">https://ws.apache.org/xmlrpc/types.html</a> 了解详情。</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://tldp.org/HOWTO/XML-RPC-HOWTO/index.html">XML-RPC HOWTO</a><span class="link-target"> [https://tldp.org/HOWTO/XML-RPC-HOWTO/index.html]</span></dt><dd><p>以多种语言对 XML-RPC 操作和客户端软件进行了很好的说明。 包含 XML-RPC 客户端开发者所需知道的几乎任何事情。</p>
</dd>
<dt><a class="reference external" href="https://xmlrpc-c.sourceforge.net/introspection.html">XML-RPC Introspection</a><span class="link-target"> [https://xmlrpc-c.sourceforge.net/introspection.html]</span></dt><dd><p>描述了用于内省的 XML-RPC 协议扩展。</p>
</dd>
<dt><a class="reference external" href="http://xmlrpc.scripting.com/spec.html">XML-RPC Specification</a><span class="link-target"> [http://xmlrpc.scripting.com/spec.html]</span></dt><dd><p>官方规范说明。</p>
</dd>
</dl>
</div>
<section id="serverproxy-objects">
<span id="id1"></span><h2>ServerProxy 对象</h2>
<p><a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 实例有一个方法与 XML-RPC 服务器所接受的每个远程过程调用相对应。 调用该方法会执行一个 RPC，通过名称和参数签名来调度（例如同一个方法名可通过多个参数签名来重载）。 RPC 结束时返回一个值，它可以是适用类型的返回数据或是表示错误的 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fault</span></code></a> 或 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProtocolError</span></code></a> 对象。</p>
<p>支持 XML 内省 API 的服务器还支持一些以保留的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">system</span></code> 属性分组的通用方法:</p>
<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.ServerProxy.system.listMethods">
<span class="sig-prename descclassname"><span class="pre">ServerProxy.system.</span></span><span class="sig-name descname"><span class="pre">listMethods</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>此方法返回一个字符串列表，每个字符串都各自对应 XML-RPC 服务器所支持的（非系统）方法。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.ServerProxy.system.methodSignature">
<span class="sig-prename descclassname"><span class="pre">ServerProxy.system.</span></span><span class="sig-name descname"><span class="pre">methodSignature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此方法接受一个形参，即某个由 XML-RPC 服务器所实现的方法名称。 它返回一个由此方法可能的签名组成的数组。 一个签名就是一个类型数组。 这些类型中的第一个是方法的的返回类型，其余的均为形参。</p>
<p>由于允许多个签名（即重载），此方法是返回一个签名列表而非一个单例。</p>
<p>签名本身被限制为一个方法所期望的最高层级形参。 举例来说如果一个方法期望有一个结构体数组作为形参，并返回一个字符串，则其签名就是 &quot;string, array&quot;。 如果它期望有三个整数并返回一个字符串，则其签名是 &quot;string, int, int, int&quot;。</p>
<p>如果方法没有定义任何签名，则将返回一个非数组值。 在 Python 中这意味着返回值的类型为列表以外的类型。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.ServerProxy.system.methodHelp">
<span class="sig-prename descclassname"><span class="pre">ServerProxy.system.</span></span><span class="sig-name descname"><span class="pre">methodHelp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>此方法接受一个形参，即 XML-RPC 服务器所实现的某个方法的名称。 它返回描述相应方法用法的文档字符串。 如果没有可用的文档字符串，则返回空字符串。 文档字符串可以包含 HTML 标记。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版本发生变更: </span><a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 的实例支持 <a class="reference internal" href="../glossary.xhtml#term-context-manager"><span class="xref std std-term">context manager</span></a> 协议用于关闭下层传输。</p>
</div>
<p>以下是一个可运行的示例。 服务器端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">is_even</span><span class="p">,</span> <span class="s2">&quot;is_even&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>前述服务器的客户端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">with</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">proxy</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3 is even: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">is_even</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;100 is even: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">is_even</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span>
</pre></div>
</div>
</section>
<section id="datetime-objects">
<span id="id2"></span><h2>DateTime 对象</h2>
<dl class="py class">
<dt class="sig sig-object py" id="xmlrpc.client.DateTime">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">DateTime</span></span></dt>
<dd><p>该类的初始化可以使用距离 Unix 纪元的秒数、时间元组、ISO 8601 时间/日期字符串或 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 实例。 它具有下列方法，主要是为 marshall 和反 marshall 代码的内部使用提供支持:</p>
<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.DateTime.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>接受一个字符串作为实例的新时间值。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.DateTime.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将此 <a class="reference internal" href="#xmlrpc.client.DateTime" title="xmlrpc.client.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> 条目的 XML-RPC 编码格式写入到 <em>out</em> 流对象。</p>
</dd></dl>

<p>它还通过 <a class="reference internal" href="../reference/datamodel.xhtml#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">富比较</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 方法来支持特定的 Python 内置运算符。</p>
</dd></dl>

<p>以下是一个可运行的示例。 服务器端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">def</span> <span class="nf">today</span><span class="p">():</span>
    <span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">DateTime</span><span class="p">(</span><span class="n">today</span><span class="p">)</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">today</span><span class="p">,</span> <span class="s2">&quot;today&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>前述服务器的客户端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>

<span class="n">today</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="c1"># convert the ISO8601 string to a datetime object</span>
<span class="n">converted</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">today</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Today: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">converted</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.%m.%Y, %H:%M&quot;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="binary-objects">
<span id="id3"></span><h2>Binary 对象</h2>
<dl class="py class">
<dt class="sig sig-object py" id="xmlrpc.client.Binary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">Binary</span></span></dt>
<dd><p>该类的初始化可以使用字节数据（可包括 NUL）。 对 <a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 对象的初始访问是由一个属性来提供的:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.Binary.data">
<span class="sig-name descname"><span class="pre">data</span></span></dt>
<dd><p>被 <a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 实例封装的二进制数据。 该数据以 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象的形式提供。</p>
</dd></dl>

<p><a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 对象具有下列方法，支持这些方法主要是供 marshall 和反 marshall 代码在内部使用:</p>
<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.Binary.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>接受一个 base64 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象并将其解码为实例的新数据。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xmlrpc.client.Binary.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将此二进制条目的 XML-RPC base 64 编码格式写入到 <em>out</em> 流对象。</p>
<p>被编码数据将依据 <span class="target" id="index-2"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html#section-6.8"><strong>RFC 2045 第 6.8 节</strong></a><span class="link-target"> [https://datatracker.ietf.org/doc/html/rfc2045.html#section-6.8]</span> 每 76 个字符换行一次，这是撰写 XML-RPC 规范说明时 base64 规范的事实标准。</p>
</dd></dl>

<p>它还通过 <a class="reference internal" href="../reference/datamodel.xhtml#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 方法来支持特定的 Python 内置运算符。</p>
</dd></dl>

<p>该二进制对象的示例用法。 我们将通过 XMLRPC 来传输一张图片:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">def</span> <span class="nf">python_logo</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;python_logo.jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">Binary</span><span class="p">(</span><span class="n">handle</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">python_logo</span><span class="p">,</span> <span class="s1">&#39;python_logo&#39;</span><span class="p">)</span>

<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>客户端会获取图片并将其保存为一个文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;fetched_python_logo.jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
    <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">python_logo</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="fault-objects">
<span id="id4"></span><h2>Fault 对象</h2>
<dl class="py class">
<dt class="sig sig-object py" id="xmlrpc.client.Fault">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">Fault</span></span></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fault</span></code></a> 对象封装了 XML-RPC fault 标签的内容。 Fault 对象具有下列属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.Fault.faultCode">
<span class="sig-name descname"><span class="pre">faultCode</span></span></dt>
<dd><p>一个指明 fault 类型的整数。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.Fault.faultString">
<span class="sig-name descname"><span class="pre">faultString</span></span></dt>
<dd><p>一个包含与 fault 相关联的诊断消息的字符串。</p>
</dd></dl>

</dd></dl>

<p>在接下来的示例中我们将通过返回一个复数类型的值来故意引发一个 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a>。 服务器端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="c1"># A marshalling error is going to occur because we&#39;re returning a</span>
<span class="c1"># complex number</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>

<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>前述服务器的客户端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">proxy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">except</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">Fault</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A fault occurred&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fault code: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">faultCode</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fault string: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">faultString</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="protocolerror-objects">
<span id="protocol-error-objects"></span><h2>ProtocolError 对象</h2>
<dl class="py class">
<dt class="sig sig-object py" id="xmlrpc.client.ProtocolError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">ProtocolError</span></span></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProtocolError</span></code></a> 对象描述了下层传输层中的协议错误（例如当 URI 所指定的服务器不存在时的 404 'not found' 错误）。 它具有下列属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.ProtocolError.url">
<span class="sig-name descname"><span class="pre">url</span></span></dt>
<dd><p>触发错误的 URI 或 URL。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.ProtocolError.errcode">
<span class="sig-name descname"><span class="pre">errcode</span></span></dt>
<dd><p>错误代码。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.ProtocolError.errmsg">
<span class="sig-name descname"><span class="pre">errmsg</span></span></dt>
<dd><p>错误消息或诊断字符串。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xmlrpc.client.ProtocolError.headers">
<span class="sig-name descname"><span class="pre">headers</span></span></dt>
<dd><p>一个包含触发错误的 HTTP/HTTPS 请求的标头的字典。</p>
</dd></dl>

</dd></dl>

<p>在接下来的示例中我们将通过提供一个无效的 URI 来故意引发一个 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProtocolError</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="c1"># create a ServerProxy with a URI that doesn&#39;t respond to XMLRPC requests</span>
<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://google.com/&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">proxy</span><span class="o">.</span><span class="n">some_method</span><span class="p">()</span>
<span class="k">except</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ProtocolError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A protocol error occurred&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;URL: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HTTP/HTTPS headers: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error code: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">errcode</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error message: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="multicall-objects">
<h2>MultiCall 对象</h2>
<p><a class="reference internal" href="#xmlrpc.client.MultiCall" title="xmlrpc.client.MultiCall"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCall</span></code></a> 对象提供了一种将对远程服务器的多个调用封装为一个单独请求的方式 <a class="footnote-reference brackets" href="#id6" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="xmlrpc.client.MultiCall">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">MultiCall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">server</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>创建一个用于盒式方法调用的对象。 <em>server</em> 是调用的最终目标。 可以对结果对象发起调用，但它们将立即返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，并只在 <a class="reference internal" href="#xmlrpc.client.MultiCall" title="xmlrpc.client.MultiCall"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCall</span></code></a> 对象中存储调用名称和形参。 调用该对象本身会导致所有已存储的调用作为一个单独的 <code class="docutils literal notranslate"><span class="pre">system.multicall</span></code> 请求被发送。 此调用的结果是一个 <a class="reference internal" href="../glossary.xhtml#term-generator"><span class="xref std std-term">generator</span></a>；迭代这个生成器会产生各个结果。</p>
</dd></dl>

<p>以下是该类的用法示例。 服务器端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">//</span> <span class="n">y</span>

<span class="c1"># A simple server with simple arithmetic functions</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_multicall_functions</span><span class="p">()</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">subtract</span><span class="p">,</span> <span class="s1">&#39;subtract&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="s1">&#39;divide&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>前述服务器的客户端代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>
<span class="n">multicall</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">MultiCall</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">multicall</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;7+3=</span><span class="si">%d</span><span class="s2">, 7-3=</span><span class="si">%d</span><span class="s2">, 7*3=</span><span class="si">%d</span><span class="s2">, 7//3=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="convenience-functions">
<h2>便捷函数</h2>
<dl class="py function">
<dt class="sig sig-object py" id="xmlrpc.client.dumps">
<span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">methodname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">methodresponse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>请 <em>params</em> 转换为一个 XML-RPC 请求。 或者当 <em>methodresponse</em> 为真值时则转换为一个请求。 <em>params</em> 可以是一个参数元组或是一个 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 异常类的实例。 如果 <em>methodresponse</em> 为真值，只有单独的值可以被返回，这意味着 <em>params</em> 的长度必须为 1。 如果提供了 <em>encoding</em>，则在生成的 XML 会使用该编码格式；默认的编码格式为 UTF-8。 Python 的 <a class="reference internal" href="constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 值不可在标准 XML-RPC 中使用；要通过扩展来允许使用它，请为 <em>allow_none</em> 提供一个真值。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xmlrpc.client.loads">
<span class="sig-prename descclassname"><span class="pre">xmlrpc.client.</span></span><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_datetime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_builtin_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>将一个 XML-RPC 请求或响应转换为 Python 对象 <code class="docutils literal notranslate"><span class="pre">(params,</span> <span class="pre">methodname)</span></code>。 <em>params</em> 是一个参数元组；<em>methodname</em> 是一个字符串，或者如果数据包没有提供方法名则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果 XML-RPC 数据包是代表一个故障条件，则此函数将引发一个 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 异常。 <em>use_builtin_types</em> 旗标可被用于将日期/时间值表示为 <a class="reference internal" href="datetime.xhtml#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 对象并将二进制数据表示为 <a class="reference internal" href="stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 对象；此旗标默认为假值。</p>
<p>已过时的 <em>use_datetime</em> 旗标与 <em>use_builtin_types</em> 类似但只作用于日期/时间值。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>增加了 <em>use_builtin_types</em> 旗标。</p>
</div>
</dd></dl>

</section>
<section id="example-of-client-usage">
<span id="xmlrpc-client-example"></span><h2>客户端用法的示例</h2>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># simple test program (from the XML-RPC specification)</span>
<span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="kn">import</span> <span class="n">ServerProxy</span><span class="p">,</span> <span class="n">Error</span>

<span class="c1"># server = ServerProxy(&quot;http://localhost:8000&quot;) # local server</span>
<span class="k">with</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://betty.userland.com&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">proxy</span><span class="p">:</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">getStateName</span><span class="p">(</span><span class="mi">41</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">v</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>要通过 HTTP 代理访问一个 XML-RPC 服务器，你必须自行定义一个传输。 下面的例子演示了具体做法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">http.client</span>
<span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">class</span> <span class="nc">ProxiedTransport</span><span class="p">(</span><span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">Transport</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">set_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proxy</span> <span class="o">=</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proxy_headers</span> <span class="o">=</span> <span class="n">headers</span>

    <span class="k">def</span> <span class="nf">make_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy</span><span class="p">)</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">set_tunnel</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy_headers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span>
        <span class="k">return</span> <span class="n">connection</span>

<span class="n">transport</span> <span class="o">=</span> <span class="n">ProxiedTransport</span><span class="p">()</span>
<span class="n">transport</span><span class="o">.</span><span class="n">set_proxy</span><span class="p">(</span><span class="s1">&#39;proxy-server&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s1">&#39;http://betty.userland.com&#39;</span><span class="p">,</span> <span class="n">transport</span><span class="o">=</span><span class="n">transport</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">getStateName</span><span class="p">(</span><span class="mi">41</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="example-of-client-and-server-usage">
<h2>客户端与服务器用法的示例</h2>
<p>参见 <a class="reference internal" href="xmlrpc.server.xhtml#simplexmlrpcserver-example"><span class="std std-ref">SimpleXMLRPCServer 示例</span></a>。</p>
<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p>此做法被首次提及是在 <a class="reference external" href="https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader$1208?mode=topic">a discussion on xmlrpc.com</a><span class="link-target"> [https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader$1208?mode=topic]</span>。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>