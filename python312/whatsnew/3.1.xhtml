<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 3.1 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/3.1.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, Raymond Hettinger（译者：wh2099 at outlook dot com）,. 本文介绍了 Python 3.1 相比 3.0 的新特性。 Python 3.1 发布于 2009 年 6 月 27 日。 PEP 372: 有序字典: 常规的 Python 字典会以任意顺序迭代键/值对。 多年以来，有好几位作者编写了可以记住键的初始插入顺序的替代实现。 基于这些实现..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, Raymond Hettinger（译者：wh2099 at outlook dot com）,. 本文介绍了 Python 3.1 相比 3.0 的新特性。 Python 3.1 发布于 2009 年 6 月 27 日。 PEP 372: 有序字典: 常规的 Python 字典会以任意顺序迭代键/值对。 多年以来，有好几位作者编写了可以记住键的初始插入顺序的替代实现。 基于这些实现..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 3.1 有什么新变化</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/3.1.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-3-1">
<h1>Python 3.1 有什么新变化</h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Raymond Hettinger（译者：wh2099 at outlook dot com）</p>
</dd>
</dl>
<p>本文介绍了 Python 3.1 相比 3.0 的新特性。 Python 3.1 发布于 2009 年 6 月 27 日。</p>
<section id="pep-372-ordered-dictionaries">
<h2>PEP 372: 有序字典</h2>
<p>常规的 Python 字典会以任意顺序迭代键/值对。 多年以来，有好几位作者编写了可以记住键的初始插入顺序的替代实现。 基于这些实现的经验，现在引入了新的 <a class="reference internal" href="../library/collections.xhtml#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 类。</p>
<p>OrderedDict API 与常规字典基本相同，但将根据每个键首次插入的时间以有保证的顺序来迭代键和值。 如果一个新条目覆盖了现有的条目，则原始插入位置会保持不变。 删除条目并重新插入则会将其移至末尾。</p>
<p>标准库现在支持在某些模块中使用有序字典。 <a class="reference internal" href="../library/configparser.xhtml#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 模块会默认使用它们。 这使得配置文件将以其原始顺序被读取、修改和重新写入。 <a class="reference internal" href="../library/collections.xhtml#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 的 <em>_asdict()</em> 方法现在会返回一个值的出现顺序与下层的元组索引号相同的有序字典。 <a class="reference internal" href="../library/json.xhtml#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块已使用 <em>object_pairs_hook</em> 来构建以允许由解码器生成有序字典。 还添加了对第三方工具的支持如 <a class="reference external" href="https://pyyaml.org/">PyYAML</a><span class="link-target"> [https://pyyaml.org/]</span>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0372/"><strong>PEP 372</strong></a><span class="link-target"> [https://peps.python.org/pep-0372/]</span> - 有序字典</dt><dd><p>PEP 由 Armin Ronacher 和 Raymond Hettinger 撰写，由 Raymond Hettinger 实现。</p>
</dd>
</dl>
</div>
<p>因为一个有序字典记住它的顺序，他可以用于连接排序字典</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># regular unsorted dictionary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;banana&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;pear&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># dictionary sorted by key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">OrderedDict([(&#39;apple&#39;, 4), (&#39;banana&#39;, 3), (&#39;orange&#39;, 2), (&#39;pear&#39;, 1)])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># dictionary sorted by value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">OrderedDict([(&#39;pear&#39;, 1), (&#39;orange&#39;, 2), (&#39;banana&#39;, 3), (&#39;apple&#39;, 4)])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># dictionary sorted by length of the key string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
<span class="go">OrderedDict([(&#39;pear&#39;, 1), (&#39;apple&#39;, 4), (&#39;orange&#39;, 2), (&#39;banana&#39;, 3)])</span>
</pre></div>
</div>
<p>当条目删除时，新的排序字典会维护它的顺序。但如果有新的条目添加进来，键就被加入到末端，顺序就不再维护。</p>
</section>
<section id="pep-378-format-specifier-for-thousands-separator">
<h2>PEP 378: 千位分隔符的格式说明符</h2>
<p>内置的 <a class="reference internal" href="../library/functions.xhtml#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 函数和 <a class="reference internal" href="../library/stdtypes.xhtml#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 方法使用的迷你语言现在包括一种以千位分隔符格式化数字的简单、不可感知语言区域的方式。 这提供了更为人性化的程序输出，提升了外观专业程度与可读性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">1234567</span><span class="p">,</span> <span class="s1">&#39;,d&#39;</span><span class="p">)</span>
<span class="go">&#39;1,234,567&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mf">1234567.89</span><span class="p">,</span> <span class="s1">&#39;,.2f&#39;</span><span class="p">)</span>
<span class="go">&#39;1,234,567.89&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mf">12345.6</span> <span class="o">+</span> <span class="mf">8901234.12</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;,f&#39;</span><span class="p">)</span>
<span class="go">&#39;12,345.600000+8,901,234.120000j&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1234567.89&#39;</span><span class="p">),</span> <span class="s1">&#39;,f&#39;</span><span class="p">)</span>
<span class="go">&#39;1,234,567.89&#39;</span>
</pre></div>
</div>
<p>支持的类型有 <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="../library/functions.xhtml#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 和 <a class="reference internal" href="../library/decimal.xhtml#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>。</p>
<p>目前还在讨论要如何指定替代分隔符如点号、空格、撇号或下划线等。 可感知语言区域的应用程序应当使用现有的支持千位分隔符的 <em>n</em> 格式说明符。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0378/"><strong>PEP 378</strong></a><span class="link-target"> [https://peps.python.org/pep-0378/]</span> - 千位分隔符的格式说明符</dt><dd><p>PEP 由 Raymond Hettinger 撰写，并由 Eric Smith 和 Mark Dickinson 实现</p>
</dd>
</dl>
</div>
</section>
<section id="other-language-changes">
<h2>其他语言特性修改</h2>
<p>对Python 语言核心进行的小改动：</p>
<ul>
<li><p>包括 <code class="file docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件的目录和 zip 归档文件现在可通过将其名称传给解释器来直接执行。 这样的目录/zip 文件会自动作为 sys.path 的第一个条目插入。 （由 Andy Chu 提议并编写初始补丁；由 Phillip J. Eby 和 Nick Coghlan 改进补丁；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1739468">bpo-1739468</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1739468]</span>。）</p></li>
<li><p><a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 类型增加了一个 <code class="docutils literal notranslate"><span class="pre">bit_length</span></code> 方法用来返回以二进制代表其参数值所需的比特位数量:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>
<span class="go">&#39;0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">123</span><span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">124</span>
</pre></div>
</div>
<p>（由 Fredrik Johansson, Victor Stinner, Raymond Hettinger 和 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3439">bpo-3439</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3439]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/functions.xhtml#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 字符串中的字段现在可被自动编号:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Sir </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Gallahad&#39;</span><span class="p">,</span> <span class="s1">&#39;Camelot&#39;</span><span class="p">)</span>
<span class="go">&#39;Sir Gallahad of Camelot&#39;</span>
</pre></div>
</div>
<p>之前，字符串应当具有所需的编号字段例如: <code class="docutils literal notranslate"><span class="pre">'Sir</span> <span class="pre">{0}</span> <span class="pre">of</span> <span class="pre">{1}'</span></code>。</p>
<p>（由 Eric Smith在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5237">bpo-5237</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5237]</span> 中贡献）</p>
</li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">string.maketrans()</span></code> 函数已被弃用并由新的静态方法 <a class="reference internal" href="../library/stdtypes.xhtml#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.maketrans()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray.maketrans" title="bytearray.maketrans"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytearray.maketrans()</span></code></a> 所取代。 这项更改解决了对于 <a class="reference internal" href="../library/string.xhtml#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块所支持的类型的困惑。 现在，<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 分别拥有它们自己的具有适当类型的中间转译表的 <strong>maketrans</strong> 和 <strong>translate</strong> 方法。</p>
<p>（由Georg Brandl在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5675">bpo-5675</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5675]</span> 中贡献）</p>
</li>
<li><p>The syntax of the <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句的语法现在允许单个语句中存在多个上下文管理器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mylog.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;a.out&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="s1">&#39;&lt;critical&gt;&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p>有了这个新语法，<code class="xref py py-func docutils literal notranslate"><span class="pre">contextlib.nested()</span></code> 函数已不再必要因而现在已被弃用。</p>
<p>（由 Georg Brandl 和 Mattias Brändström 贡献; <a class="reference external" href="https://codereview.appspot.com/53094">appspot issue 53094</a><span class="link-target"> [https://codereview.appspot.com/53094]</span>。）</p>
</li>
<li><p>现在 <code class="docutils literal notranslate"><span class="pre">round(x,</span> <span class="pre">n)</span></code> 当 <em>x</em> 为整数时将返回整数。 之前是返回浮点数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mi">1123</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1100</span>
</pre></div>
</div>
<p>（由 Mark Dickinson在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4707">bpo-4707</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4707]</span> 贡献）</p>
</li>
<li><p>Python 现在使用 David Gay 的算法来查找不会改变实际值的最短浮点表示形式。 这应当有助于缓解某些对于二进制浮点数的困惑。</p>
<p>这项改进的优点对于 <code class="docutils literal notranslate"><span class="pre">1.1</span></code> 这样无法用二进制浮点精确表示的数来说是很明显的。 由于没有完全等价的表示，<code class="docutils literal notranslate"><span class="pre">float('1.1')</span></code> 这样的表达式会被求解为最接近的可表示值即十六进制的 <code class="docutils literal notranslate"><span class="pre">0x1.199999999999ap+0</span></code> 或十进制的 <code class="docutils literal notranslate"><span class="pre">1.100000000000000088817841970012523233890533447265625</span></code>。 这个最接近的值过去和现在仍然会在后续的浮点运算中被使用。</p>
<p>新的改变针对的是如何显示数字。 在之前，Python 使用了一种简单的方式。 <code class="docutils literal notranslate"><span class="pre">repr(1.1)</span></code> 的值会被计算为 <code class="docutils literal notranslate"><span class="pre">format(1.1,</span> <span class="pre">'.17g')</span></code> 并将被求解为 <code class="docutils literal notranslate"><span class="pre">'1.1000000000000001'</span></code>。 使用 17 个数位的优点是它将凭借 IEEE-754 标准来确保 <code class="docutils literal notranslate"><span class="pre">eval(repr(1.1))</span></code> 将恰好被舍入到其原始值。 缺点则是会让许多人感觉这样的输出令人困惑（将二进制浮点表示形式的内在局限性误认为是 Python 本身的问题）。</p>
<p>用于 <code class="docutils literal notranslate"><span class="pre">repr(1.1)</span></code> 的新算法更为智能并将返回 <code class="docutils literal notranslate"><span class="pre">'1.1'</span></code>。 在实际上，它会搜索所有等价的字符串表示形式（使用相同的下层浮点值进行排序）并返回其中最短的表示形式。</p>
<p>新算法倾向于尽可能放出更为清晰的表示形式，但它并不改变下层的值。 因此仍然会是 <code class="docutils literal notranslate"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span> <span class="pre">!=</span> <span class="pre">3.3</span></code> 虽然从表示形式上看情况不是这样。</p>
<p>这个新算法依赖于下层浮点实现的某些特性。 如果未找到所需的特性，则将继续使用旧算法。 此外，文本 pickle 协议也会通过使用旧算法来保证跨平台的可移植性。</p>
<p>（由 Eric Smith 和 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1580">bpo-1580</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1580]</span> 贡献）</p>
</li>
</ul>
</section>
<section id="new-improved-and-deprecated-modules">
<h2>新增，改进和弃用的模块</h2>
<ul>
<li><p>增加了一个 <a class="reference internal" href="../library/collections.xhtml#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 类以支持方便地统计一个序列或可迭代对象中的唯一条目数量。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Counter</span><span class="p">([</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">])</span>
<span class="go">Counter({&#39;blue&#39;: 3, &#39;red&#39;: 2, &#39;green&#39;: 1})</span>
</pre></div>
</div>
<p>（由 Raymond Hettinger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1696199">bpo-1696199</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1696199]</span> 中贡献。）</p>
</li>
<li><p>半圆了一个新模块 <a class="reference internal" href="../library/tkinter.ttk.xhtml#module-tkinter.ttk" title="tkinter.ttk: Tk themed widget set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter.ttk</span></code></a> 用于访问带主题的 Tk 部件集。 ttk 的基本设计思路，就是尽可能地把实现部件行为的代码与实现其外观的代码分离开来。</p>
<p>（由 Guilherme Polo 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2983">bpo-2983</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2983]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/gzip.xhtml#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a> 和 <a class="reference internal" href="../library/bz2.xhtml#bz2.BZ2File" title="bz2.BZ2File"><code class="xref py py-class docutils literal notranslate"><span class="pre">bz2.BZ2File</span></code></a> 类现在已支持上下文管理协议:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Automatically close file after writing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;xxx&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>（由 Antoine Pitrou 贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/decimal.xhtml#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块现在支持基于一个二进制 <a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 来创建 decimal 对象。 转换是准确的但有时也会令人吃惊:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.100000000000000088817841970012523233890533447265625&#39;)</span>
</pre></div>
</div>
<p>这个长长的 decimal 结果值显示了 <em>1.1</em> 所保存的实际二进制分数。 这个分数有许多位因为 <em>1.1</em> 无法用二进制来精确表示。</p>
<p>（由Raymond Hettinger 和 Mark Dickinson贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/itertools.xhtml#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模块增加了两个新函数。 <a class="reference internal" href="../library/itertools.xhtml#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.combinations_with_replacement()</span></code></a> 函数是生成组合数学结果包括排列与笛卡尔积的四个函数之一。 <a class="reference internal" href="../library/itertools.xhtml#itertools.compress" title="itertools.compress"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.compress()</span></code></a> 函数模仿了 APL 中的同名函数。 此外，现有的 <a class="reference internal" href="../library/itertools.xhtml#itertools.count" title="itertools.count"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.count()</span></code></a> 函数现在有一个可选的 <em>step</em> 参数并可接受任意类型的计数序列包括 <a class="reference internal" href="../library/fractions.xhtml#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 和 <a class="reference internal" href="../library/decimal.xhtml#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">q</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="s1">&#39;LOVE&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[&#39;LL&#39;, &#39;LO&#39;, &#39;LV&#39;, &#39;LE&#39;, &#39;OO&#39;, &#39;OV&#39;, &#39;OE&#39;, &#39;VV&#39;, &#39;VE&#39;, &#39;EE&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">compress</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">selectors</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">[2, 3, 5, 7]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">step</span><span class="o">=</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span>
<span class="go">[Fraction(1, 2), Fraction(2, 3), Fraction(5, 6), Fraction(1, 1)]</span>
</pre></div>
</div>
<p>（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/collections.xhtml#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 现在支持关键字参数 <em>rename</em>，它允许将无效的字段名自动转换为 _0, _1 等形式的位置名称。 这在字段名是由外部源如 CSV 标头、SQL 字段列表或用户输入创建的时候会很有用处:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">query</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="go">SELECT region, dept, count(*) FROM main GROUPBY region, dept</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">query_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">UserQuery</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;UserQuery&#39;</span><span class="p">,</span> <span class="n">query_fields</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">([</span><span class="n">UserQuery</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">])</span>
<span class="go">[UserQuery(region=&#39;South&#39;, dept=&#39;Shipping&#39;, _2=185),</span>
<span class="go"> UserQuery(region=&#39;North&#39;, dept=&#39;Accounting&#39;, _2=37),</span>
<span class="go"> UserQuery(region=&#39;West&#39;, dept=&#39;Sales&#39;, _2=419)]</span>
</pre></div>
</div>
<p>（由 Raymond Hettinger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1818">bpo-1818</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1818]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/re.xhtml#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a>, <a class="reference internal" href="../library/re.xhtml#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.subn()</span></code></a> 和 <a class="reference internal" href="../library/re.xhtml#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> 函数现在可接受一个 flags 形参。</p>
<p>（由 Gregory Smith 贡献）</p>
</li>
<li><p><a class="reference internal" href="../library/logging.xhtml#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 模块现在为不使用 logging 但是调用了使用它的库代码的应用程序实现了一个简单的 <a class="reference internal" href="../library/logging.handlers.xhtml#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.NullHandler</span></code></a> 类。 设置一个空处理器将会屏蔽诸如 &quot;找不到日志记录器 foo 的处理器&quot; 这样的虚假警告:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">NullHandler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>（由 Vinay Sajip 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4384">bpo-4384</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4384]</span> 中贡献。）</p>
</li>
<li><p>支持 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 命令行开关的 <a class="reference internal" href="../library/runpy.xhtml#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 模块现在也支持当提供包名称时通过查找并执行 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 子模块来执行包。</p>
<p>（由 Andi Vajda 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4195">bpo-4195</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4195]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/pdb.xhtml#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 模块现在可以访问并显示通过 <a class="reference internal" href="../library/zipimport.xhtml#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> (或其他符合规范的 <span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a><span class="link-target"> [https://peps.python.org/pep-0302/]</span> 加载器) 加载的源代码。</p>
<p>（由 Alexander Belopolsky 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4201">bpo-4201</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4201]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/functools.xhtml#functools.partial" title="functools.partial"><code class="xref py py-class docutils literal notranslate"><span class="pre">functools.partial</span></code></a> 对象现在可以被封存。</p></li>
</ul>
<blockquote>
<div><p>（由 Antoine Pitrou 和 Jesse Noller 提议，由 Jack Diederich 实现; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5228">bpo-5228</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5228]</span>。）</p>
</div></blockquote>
<ul>
<li><p>为符号增加 <a class="reference internal" href="../library/pydoc.xhtml#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 帮助主题以使得在交互环境下 <code class="docutils literal notranslate"><span class="pre">help('&#64;')</span></code> 能符合预期的效果。</p>
<p>（由 David Laban 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4739">bpo-4739</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4739]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/unittest.xhtml#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块现在支持跳过单个测试或测试类。 并且它还支持将一个测试标记为已预期会失败，即已经知道不可用，但不应在 TestResult 上被计为一次失败:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestGizmo</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_gizmo_on_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_gimzo_without_required_library</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>此外，还创建了一些针对异常的测试以便与使用 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句的上下文管理器一起工作:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_division_by_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">/</span> <span class="mi">0</span>
</pre></div>
</div>
<p>此外，还新增了一些断言方法包括 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual()</span></code></a>, <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictContainsSubset()</span></code>, <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a>, <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a>, <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a>, <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegexp()</span></code></a>, <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone()</span></code></a> 和 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone()</span></code></a>。</p>
<p>（由Benjamin Peterson 和 Antoine Pitrou 贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/io.xhtml#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块新增了三个常量用于 <a class="reference internal" href="../library/io.xhtml#io.IOBase.seek" title="io.IOBase.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a> 方法: <a class="reference internal" href="../library/os.xhtml#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-data docutils literal notranslate"><span class="pre">SEEK_SET</span></code></a>, <a class="reference internal" href="../library/os.xhtml#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-data docutils literal notranslate"><span class="pre">SEEK_CUR</span></code></a> 和 <a class="reference internal" href="../library/os.xhtml#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-data docutils literal notranslate"><span class="pre">SEEK_END</span></code></a>。</p></li>
<li><p><a class="reference internal" href="../library/sys.xhtml#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version_info</span></code></a> 元组现在是一个具名元组:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span>
<span class="go">sys.version_info(major=3, minor=1, micro=0, releaselevel=&#39;alpha&#39;, serial=2)</span>
</pre></div>
</div>
<p>（由 Ross Light 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4285">bpo-4285</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4285]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/nntplib.xhtml#module-nntplib" title="nntplib: NNTP protocol client (requires sockets).（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code></a> 和 <a class="reference internal" href="../library/imaplib.xhtml#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 模块现在支持 IPv6。</p>
<p>（由 Derek Morr 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1655">bpo-1655</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1655]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1664">bpo-1664</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1664]</span> 中贡献。）</p>
</li>
<li><p>当使用协议 2 或更低的版本时，<a class="reference internal" href="../library/pickle.xhtml#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模块已被调适以获得与 Python 2.x 更好的互操作性。 标准库的重组改变了对于许多对象的正式引用。 例如，Python 2 中的 <code class="docutils literal notranslate"><span class="pre">__builtin__.set</span></code> 在 Python 3 中称为 <code class="docutils literal notranslate"><span class="pre">builtins.set</span></code>。 这一改变使得在不同版本的 Python 之间共享数据的努力陷入混乱。 但是现在当选择协议 2 或更低的版本时，封存器将自动使用旧的 Python 2 名称进行加载和转储。 这样的重映射将默认启用但可以通过 <em>fix_imports</em> 选项来禁用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">b&#39;c__builtin__\nset\np0\n((lp1\nL1L\naL2L\naL3L\natp2\nRp3\n.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fix_imports</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">b&#39;cbuiltins\nset\np0\n((lp1\nL1L\naL2L\naL3L\natp2\nRp3\n.&#39;</span>
</pre></div>
</div>
<p>这项改变的一个不幸但无可避免的副作用是由 Python 3.1 所产生的协议 2 版本的 pickle 对象对于 Python 3.0 将不可读。 当在 Python 3.x 实现之间迁移数据时，应当使用最新的协议 3 版本的 pickle 协议，因为它不会试图与 Python 2.x 保持兼容。</p>
<p>（由 Alexandre Vassalotti 和 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6137">bpo-6137</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6137]</span> 中贡献。）</p>
</li>
<li><p>增加了一个新模块 <a class="reference internal" href="../library/importlib.xhtml#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a>。 它提供了针对 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句及其对应物 <a class="reference internal" href="../library/functions.xhtml#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数的完整、可移植的纯 Python 引用实现。 它代表了在记录和定义导入期间所发生的行动中实质性的一步。</p>
<p>（由 Brett Cannon 贡献。）</p>
</li>
</ul>
</section>
<section id="optimizations">
<h2>性能优化</h2>
<p>已增加的主要性能改善:</p>
<ul>
<li><p>新的 I/O 库（如 <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a><span class="link-target"> [https://peps.python.org/pep-3116/]</span> 所定义的）主要是用 Python 编写并很快被证明是 Python 3.0 中的一个问题瓶颈。 在 Python 3.1 中，I/O 库已完全用 C 重写并根据具体任务的不同有 2 到 20 倍的速度提升。 纯 Python 版本仍然可通过 <code class="docutils literal notranslate"><span class="pre">_pyio</span></code> 模块访问以用于实验性目的。</p>
<p>（由 Amaury Forgeot d'Arc 和 Antoine Pitrou 贡献。）</p>
</li>
<li><p>添加了一个启发式的工具以使仅包含不可追踪对象的元组和字典不会被垃圾回收器所追踪。 这可以减少收集数据的大小从而减少长时间运行的程序的垃圾收集开销，具体取决于它们对类型类型的使用方式。</p>
<p>（由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4688">bpo-4688</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4688]</span> 中贡献。）</p>
</li>
<li><p>通过在受支持的编译器（主要有: gcc, SunPro, icc）上启用名为 <code class="docutils literal notranslate"><span class="pre">--with-computed-gotos</span></code> 的配置选项，字节码求值循环会使用新的分派机制进行编译，根据系统、编译器和基准测试工具的不同，该机制可获得至多 20% 的速度提升。</p>
<p>（由 Antoine Pitrou 以及其他一些参与者在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4753">bpo-4753</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4753]</span> 中贡献。）</p>
</li>
<li><p>UTF-8, UTF-16 和 LATIN-1 的解码速度现已提升了二至四倍。</p>
<p>（由 Antoine Pitrou 和 Amaury Forgeot d'Arc 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4868">bpo-4868</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4868]</span> 中贡献。）</p>
</li>
<li><p><a class="reference internal" href="../library/json.xhtml#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块现在有了一个可显著提升其性能的 C 扩展。 此外，还对 API 进行了修改以使 json 只适用于 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，而不再适用于 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>。 这一修改使得该模块能与基于 Unicode 的 <a class="reference external" href="https://json.org/">JSON 规范</a><span class="link-target"> [https://json.org/]</span> 紧密匹配。</p>
<p>（由 Bob Ippolito 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4136">bpo-4136</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4136]</span> 中贡献。并由 Antoine Pitrou 和 Benjamin Peterson 转换为Py3.1）</p>
</li>
<li><p>解封操作现在将固定已封存对象的属性名称。 这可以节省内存并让封存对象变得更小。</p>
<p>（由 Jake McGuire 和 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5084">bpo-5084</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5084]</span> 中贡献。）</p>
</li>
</ul>
</section>
<section id="idle">
<h2>IDLE</h2>
<ul>
<li><p>IDLE 的格式菜单现在提供了一个从源文件中去除尾部空格的选项。</p>
<p>（由 Roger D. Serwy 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5150">bpo-5150</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5150]</span> 中贡献。）</p>
</li>
</ul>
</section>
<section id="build-and-c-api-changes">
<h2>构建和 C API 的改变</h2>
<p>针对 Python 构建过程和 C API 的改变包括:</p>
<ul>
<li><p>现在整数在内部是以 <code class="docutils literal notranslate"><span class="pre">2**15</span></code> 为基数或以 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 为基数来存储的，这个基数会在构建时被确定。 在之前版本中，它们总是以 <code class="docutils literal notranslate"><span class="pre">2**15</span></code> 为基数来存储。 在 64 位机器上使用 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 为基数可显著提升性能，但在 32 位机器上的基准测试结果则好坏参半。 因此，默认会在 64 位机器上使用 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 为基数而在 32 位机器上使用 <code class="docutils literal notranslate"><span class="pre">2**15</span></code> 为基数；在 Unix 上，有一个新的配置选项 <code class="docutils literal notranslate"><span class="pre">--enable-big-digits</span></code> 可被用于覆盖此默认值。</p>
<p>除了性能提升之外这项改变对于最终用户来说应当是不可见的，只有一个例外：出于测试和调试目的有一个新的提供相关内部格式信息的 <a class="reference internal" href="../library/sys.xhtml#sys.int_info" title="sys.int_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info</span></code></a>，它给出了每个数位对应的比特位数和用户存储每个数位的以字节数表示的 C 类型大小:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">int_info</span>
<span class="go">sys.int_info(bits_per_digit=30, sizeof_digit=4)</span>
</pre></div>
</div>
<p>（由 Mark Dickinson在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4258">bpo-4258</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4258]</span> 贡献）</p>
</li>
<li><p><a class="reference internal" href="../c-api/long.xhtml#c.PyLong_AsUnsignedLongLong" title="PyLong_AsUnsignedLongLong"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_AsUnsignedLongLong()</span></code></a> 函数现在将通过引发 <a class="reference internal" href="../library/exceptions.xhtml#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 而不是 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 来处理负的 <em>pylong</em>。</p>
<p>（由 Mark Dickinson 和 Lisandro Dalcrin 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5175">bpo-5175</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5175]</span> 中贡献。）</p>
</li>
<li><p>已弃用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Int()</span></code>。 请改用 <a class="reference internal" href="../c-api/number.xhtml#c.PyNumber_Long" title="PyNumber_Long"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Long()</span></code></a>。</p>
<p>（由 Mark Dickinson在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4910">bpo-4910</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4910]</span> 贡献）</p>
</li>
<li><p>新增了 <a class="reference internal" href="../c-api/conversion.xhtml#c.PyOS_string_to_double" title="PyOS_string_to_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_string_to_double()</span></code></a> 函数以取代已弃用的函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_ascii_strtod()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_ascii_atof()</span></code>。</p>
<p>（由 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5914">bpo-5914</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5914]</span> 贡献）</p>
</li>
<li><p>增加了 <a class="reference internal" href="../c-api/capsule.xhtml#c.PyCapsule" title="PyCapsule"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a> 作为 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyCObject</span></code> API 的替代。 主要区别在于新类型拥有一个定义良好的接口用来传递类型安全信息以及一个较低复杂度的签名用来调用析构器。 旧类型的 API 存在问题且现已被弃用。</p>
<p>（由 Larry Hastings 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5630">bpo-5630</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5630]</span> 中贡献。）</p>
</li>
</ul>
</section>
<section id="porting-to-python-3-1">
<h2>移植到 Python 3.1</h2>
<p>本节列出了先前描述的改变以及可能需要修改你的代码的其他问题修正:</p>
<ul>
<li><p>新的浮点字符串表示形式可能会破坏现有的 doctest。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">e</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Compute the base of natural logarithms.</span>

<span class="sd">    &gt;&gt;&gt; e()</span>
<span class="sd">    2.7182818284590451</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)))</span>

<span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>

<span class="o">**********************************************************************</span>
<span class="n">Failed</span> <span class="n">example</span><span class="p">:</span>
    <span class="n">e</span><span class="p">()</span>
<span class="n">Expected</span><span class="p">:</span>
    <span class="mf">2.7182818284590451</span>
<span class="n">Got</span><span class="p">:</span>
    <span class="mf">2.718281828459045</span>
<span class="o">**********************************************************************</span>
</pre></div>
</div>
</li>
<li><p>在 pickle 模块中用于协议 2 或更低版本的自动名称重映射会使得 Python 3.1 的 pickle 在 Python 3.0 中无法读取。 一种解决方案是使用协议 3。 另一种解决方案是将 <em>fix_imports</em> 选项设为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 请参阅上面的讨论来了解更多细节。</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>