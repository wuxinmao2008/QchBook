<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.1 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.1.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 概述: 本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Pytho..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, A.M. Kuchling,. 概述: 本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Pytho..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 2.1 有什么新变化</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.1.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-1">
<h1>Python 2.1 有什么新变化</h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2>概述</h2>
<p>本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Python 程序员提供新特性的简单概览。 请参阅 Python 2.1 文档，或特定的 PEP，获取针对你感兴趣的任何新特性的更多细节。</p>
<p>Python 开发团队的一个近期目标是加速新发行版的步调，使得每 6 到 9 个月就有一个新发行版。 2.1 是基于这个新步调推出的第一个发行版，第一个内测版将于一月发布，即 2.0 最终版发布 3 个月之后。</p>
<p>Python 2.1 的最终版本于2001年4月17日发布。</p>
</section>
<section id="pep-227-nested-scopes">
<h2>PEP 227: 嵌套的作用域</h2>
<p>Python 2.1 中的最大改变是 Python 的作用域规则。 在 Python 2.0 中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 例如，一个嵌套的递归函数将不起作用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 总是会引发 <a class="reference internal" href="../library/exceptions.xhtml#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常，因为名称 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的绑定既不在局部命名空间中也不在模块级命名空间中。 这在实践中不会有太大问题（你会经常这样递归地定义内部函数吗？），但是这也会让 <a class="reference internal" href="../reference/expressions.xhtml#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式的使用更为笨拙，这在实践中是有问题的。 在使用了 <a class="reference internal" href="../reference/expressions.xhtml#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 的代码中你经常能发现局部变量通过作为参数的默认值被拷贝。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。</p>
<p>Python 2.1 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 <code class="docutils literal notranslate"><span class="pre">name=name</span></code> 默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 <a class="reference internal" href="../reference/compound_stmts.xhtml#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.xhtml#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 或 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。</p>
<p>对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。</p>
<p>此项改变的一个附带影响是在特定条件下函数作用域内部 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句将不允许使用。 Python 参考手册已经写明 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 仅在模块最高层级上是可用的，但此前 CPython 解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 为此，如果一个函数包含带有自由变量的函数定义或 <a class="reference internal" href="../reference/expressions.xhtml#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式，编译器将通过引发 <a class="reference internal" href="../library/exceptions.xhtml#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常来提示。</p>
<p>为了使前面的解释更清楚，下面是一个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># The next line is a syntax error</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>包含 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句的第 4 行有语法错误，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会定义一个名为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的新局部变量，它的值应当被 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 所访问。</p>
<p>这应该不会是太大的限制，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。</p>
<p>由于兼容性问题，嵌套作用域被逐步引入；在 Python 2.1 中，它们默认未启用，但可以通过在模块中使用 future 语句来开启，如 <span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a><span class="link-target"> [https://peps.python.org/pep-0236/]</span> 所述。 （参见下一节对 <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a><span class="link-target"> [https://peps.python.org/pep-0236/]</span> 的进一步讨论。） 在 Python 2.2 中，嵌套作用域将成为默认设置，并且无法关闭，但用户将有整个 2.1 版本的生命周期来修复因引入嵌套作用域而导致的任何问题。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0227/"><strong>PEP 227</strong></a><span class="link-target"> [https://peps.python.org/pep-0227/]</span> - 静态嵌套作用域</dt><dd><p>由 Jeremy Hylton 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-236-future-directives">
<h2>PEP 236: __future__ 指令</h2>
<p>对嵌套作用域的反应引起了广泛关注，人们担心在 Python 2.1 版本发布时会破坏现有代码，强烈的反应促使 Python 开发者采取了更保守的策略。这个策略包括引入一种约定，在版本 N 中启用可选功能，该功能将在版本 N+1 中成为强制功能。</p>
<p>语法使用 <code class="docutils literal notranslate"><span class="pre">from...import</span></code> 语句，使用保留模块名 <a class="reference internal" href="../library/__future__.xhtml#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>。可以通过以下语句启用嵌套作用域:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">nested_scopes</span>
</pre></div>
</div>
<p>虽然它看起来像一个普通的 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句，但实际上并不是；关于此类 future 语句的位置有严格的规定。它们只能放在模块的顶部，必须位于任何 Python 代码或常规 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句之前。这是因为这样的语句会影响 Python 字节码编译器解析代码和生成字节码的方式，因此它们必须在任何会生成字节码的语句之前出现。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a><span class="link-target"> [https://peps.python.org/pep-0236/]</span> - 回到 <a class="reference internal" href="../library/__future__.xhtml#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a></dt><dd><p>由 Tim Peters 撰写，主要由 Jeremy Hylton 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-207-rich-comparisons">
<h2>PEP 207: 富比较</h2>
<p>在早期版本中，Python 对用户定义类和扩展类型的比较操作支持相当简单。类可以实现一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> 方法，该方法接收两个类实例，并且只能返回 0 表示相等，或 +1 或 -1 表示不相等；该方法不能引发异常或返回布尔值以外的任何内容。Numeric Python 的用户经常发现这种模型太弱且受限，因为在 Numeric Python 所用的数字运算程序中，能够对两个矩阵进行逐元素比较更为有用，返回一个包含每个元素比较结果的矩阵。如果两个矩阵的大小不同，则比较必须能够引发异常以表示错误。</p>
<p>在 Python 2.1 中增加了富比较操作以支持这一需求。 Python 类现在可以单独重载 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code> 和 <code class="docutils literal notranslate"><span class="pre">!=</span></code> 中的每个操作。 新的魔术方法名称如下：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>运算</p></th>
<th class="head"><p>方法名称</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.xhtml#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>（这些魔术方法是以对应的 Fortran 操作符命名的，如 <code class="docutils literal notranslate"><span class="pre">.LT.</span></code>、<code class="docutils literal notranslate"><span class="pre">.LE.</span></code> 等。 数值程序员几乎肯定对这些名称非常熟悉，并且会发现它们易于记忆。）</p>
<p>每个这样的魔术方法的形式都是 <code class="docutils literal notranslate"><span class="pre">method(self,</span> <span class="pre">other)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">self</span></code> 是操作符左侧的对象，而 <code class="docutils literal notranslate"><span class="pre">other</span></code> 是操作符右侧的对象。 例如，表达式 <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&lt;</span> <span class="pre">B</span></code> 会调用 <code class="docutils literal notranslate"><span class="pre">A.__lt__(B)</span></code>。</p>
<p>这些魔术方法可以返回任何类型的值：布尔值、矩阵、列表或任何其他 Python 对象。或者，如果比较是不可能的、不一致的或没有意义的，它们也可以引发异常。</p>
<p>内置的 <code class="docutils literal notranslate"><span class="pre">cmp(A,B)</span></code> 函数可以使用富比较机制，现在接受一个可选参数来指定要使用的比较操作；该参数可以是字符串 <code class="docutils literal notranslate"><span class="pre">&quot;&lt;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&lt;=&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&gt;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&gt;=&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;==&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;!=&quot;</span></code> 之一。 如果不带可选的第三个参数调用，<code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code> 函数将只返回 -1、0 或 +1，就像以前的 Python 版本一样；否则，它将调用适当的方法并可以返回任何 Python 对象。</p>
<p>对于 C 程序员来说，也有相应的变更；类型对象中有一个新的槽位 <code class="docutils literal notranslate"><span class="pre">tp_richcmp</span></code> 以及一个用于执行指定富比较的 API。 这里我不会涉及 C API 的具体内容，完整的相关函数列表请参阅 <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0207/"><strong>PEP 207</strong></a><span class="link-target"> [https://peps.python.org/pep-0207/]</span> 或 2.1 的 C API 文档。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0207/"><strong>PEP 207</strong></a><span class="link-target"> [https://peps.python.org/pep-0207/]</span> - 富比较</dt><dd><p>由 Guido van Rossum 编写，大量参考 David Ascher 的先期工作，并由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-230-warning-framework">
<h2>PEP 230: 警告框架</h2>
<p>在过去的 10 年中，Python 积累了一定数量的过时模块和功能。 由于无法确切知道某个功能被使用的程度：可能没有程序依赖该功能，也可能有很多程序依赖，因此很难确定何时可以安全地移除某个功能，为了以更结构化的方式移除旧功能，添加了一个警告框架。 当 Python 开发者想要废弃某个功能时，它会在下一个 Python 版本中首先触发一个警告。 然后，在随后的Python版本中可以移除该功能，这样用户将有一个完整的发布周期来删除对旧功能的使用。</p>
<p>Python 2.1 增加了警告框架以用于此方案。 它增加了一个 <a class="reference internal" href="../library/warnings.xhtml#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块，该模块提供了发出警告的函数，以及过滤掉不想显示的警告的功能。 第三方模块也可以使用这个框架来弃用它们不再希望支持的旧功能。</p>
<p>例如，在 Python 2.1 中，<code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块已被弃用，因此导入它会打印出一个警告:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regex</span>
<span class="go">__main__:1: DeprecationWarning: the regex module</span>
<span class="go">         is deprecated; please use the re module</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>警告可以通过调用 <a class="reference internal" href="../library/warnings.xhtml#warnings.warn" title="warnings.warn"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.warn()</span></code></a> 函数来发出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;feature X no longer supported&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个形参是警告消息；额外的可选形参可被用来指定一个专门的警告类别。</p>
<p>可以添加过滤器来禁用特定的警告；可以将某个正则表达式模式应用于消息或模块名称以抑制警告。 例如，你可能有一个使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块的程序但现在不想花时间将其转换为使用 <a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块。 可以通过以下调用来抑制警告消息</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="s1">&#39;.*regex module is deprecated&#39;</span><span class="p">,</span>
                        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这添加了一个过滤器，该过滤器仅适用于在 <a class="reference internal" href="../library/__main__.xhtml#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 模块中触发的 <a class="reference internal" href="../library/exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 类警告，并应用一个正则表达式来仅匹配有关 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块已被弃用的消息，这将导致忽略此类警告。警告还可以仅打印一次，每次执行违规代码时打印，或者转换为异常，从而导致程序停止（当然，除非以常规方式捕获这些异常）。</p>
<p>Python的C API也增加了用于发出警告的函数；详情请参阅PEP 230或Python的API文档。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0005/"><strong>PEP 5</strong></a><span class="link-target"> [https://peps.python.org/pep-0005/]</span> - 语言演化的准则</dt><dd><p>该文档由Paul Prescod撰写，旨在规定移除Python旧功能时应遵循的程序。尽管本文描述的政策尚未被正式采纳，但最终的政策可能不会与Prescod的提议有太大不同。</p>
</dd>
<dt><span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0230/"><strong>PEP 230</strong></a><span class="link-target"> [https://peps.python.org/pep-0230/]</span> - 警告框架</dt><dd><p>由 Guido van Rossum 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-229-new-build-system">
<h2>PEP 229: 新的构建系统</h2>
<p>在编译 Python 时，用户必须进入并编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件以启用各种附加模块；默认集相对较小，并且仅限于在大多数 Unix 平台上编译的模块。这意味着在具有更多功能的 Unix 平台上，特别是 Linux，Python 安装通常不包含所有可能有用的模块。</p>
<p>Python 2.0 添加了 Distutils，一组用于分发和安装扩展模块的模块。在 Python 2.1 中，Distutils 被用于编译大部分标准库扩展模块，自动检测当前机器上支持哪些模块。希望这将使 Python 的安装更加容易并具有更多功能。</p>
<p>不再需要编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件来启用模块，而是在 Python 源代码分发包的顶层目录运行一个 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本，该脚本在构建时尝试通过检查系统上的模块和头文件来发现可以启用那些模块。 如果某个模块已在 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 中配置，则 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本不会尝试编译该模块，并会遵从 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件中的内容。 这提供了一种方式来指定特定平台所需的任何奇怪的命令行标志或库。</p>
<p>在对构建机制的另一项重大更改中，Neil Schemenauer 对其进行了重组，现在 Python 使用单一的非递归 makefile，而不是在顶层目录和 <code class="file docutils literal notranslate"><span class="pre">Python/</span></code>、<code class="file docutils literal notranslate"><span class="pre">Parser/</span></code>、<code class="file docutils literal notranslate"><span class="pre">Objects/`和</span> <span class="pre">:file:`Modules/</span></code> 子目录中的多个 makefile。这使得构建 Python 更快，同时也使修改 Makefile 更加清晰和简单。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0229/"><strong>PEP 229</strong></a><span class="link-target"> [https://peps.python.org/pep-0229/]</span> - 使用 Distutils 来构建 Python</dt><dd><p>由 A.M. Kuchling 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-205-weak-references">
<h2>PEP 205: 弱引用</h2>
<p>弱引用，通过 <a class="reference internal" href="../library/weakref.xhtml#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块提供，是 Python 程序员工具箱中一种较小但有用的新数据类型。</p>
<p>存储对对象的引用（例如，在字典或列表中）会导致该对象永久存活。在某些特定情况下，这种行为是不希望的，最常见的是对象缓存，另一个是像树这样的数据结构中的循环引用。</p>
<p>例如，考虑一个记忆化函数，它通过将函数的参数及其结果存储在字典中来缓存另一个函数 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 的结果：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Cache the returned object</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p>这个版本适用于诸如整数之类的简单对象，但它有一个副作用；<code class="docutils literal notranslate"><span class="pre">_cache</span></code> 字典持有返回值的引用，因此这些值在 Python 进程退出并清理之前永远不会被释放。对于整数，这不是很明显，但如果 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> 返回一个对象或占用大量内存的数据结构，这可能会成为一个问题。</p>
<p>弱引用提供了一种实现缓存的方法，不会让对象在其生命周期结束后仍然存活。如果一个对象仅通过弱引用访问，该对象将被释放，并且弱引用将指示它所引用的对象不再存在。通过调用 <code class="docutils literal notranslate"><span class="pre">wr</span> <span class="pre">=</span> <span class="pre">weakref.ref(obj)</span></code> 来创建对对象 <em>obj</em> 的弱引用。通过调用弱引用，就像调用函数一样，可以返回被引用的对象：<code class="docutils literal notranslate"><span class="pre">wr()</span></code>。如果对象仍然存在，它将返回被引用的对象；如果对象不再存在，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>这使得可以编写一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">memoize()</span></code> 函数，其缓存不会使对象保持存活状态，因为缓存中存储的是弱引用：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]()</span>
        <span class="c1"># If weak reference object still exists,</span>
        <span class="c1"># return it</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">obj</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Cache a weak reference</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/weakref.xhtml#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块还允许创建代理对象，代理对象的行为类似于弱引用--仅被代理对象引用的对象会被解分配，但只要对象仍然存在，代理就会透明地将所有操作转发给对象，而不需要显式调用来检索对象。  如果对象已被解分配，尝试使用代理将引发:exc:<cite>!weakref.ReferenceError</cite> 异常：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># Equivalent to obj.attr</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span> <span class="c1"># Equivalent to obj.meth()</span>
<span class="k">del</span> <span class="n">obj</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># raises weakref.ReferenceError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0205/"><strong>PEP 205</strong></a><span class="link-target"> [https://peps.python.org/pep-0205/]</span> - 弱引用</dt><dd><p>由 Fred L. Drake, Jr 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-232-function-attributes">
<h2>PEP 232: 函数属性</h2>
<p>在 Python 2.1 中，函数现在可以附加任意信息。人们经常使用文档字符串来保存有关函数和方法的信息，因为 <a class="reference internal" href="../reference/datamodel.xhtml#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> 属性是唯一可以将任何信息附加到函数上的方式。例如，在 Zope 网络应用服务器中，函数通过拥有文档字符串来标记为公共访问安全，在 John Aycock 的 SPARK 解析框架中，文档字符串包含要解析的 BNF 语法的部分。这种过载是不幸的，因为文档字符串实际上是用来保存函数文档的；例如，这意味着你不能正确地为 Zope 中预期用于私有用途的函数编写文档。</p>
<p>现在可以使用常规的 Python 语法在函数上设置和检索任意属性：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>

<span class="n">f</span><span class="o">.</span><span class="n">publish</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">secure</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="s2">&quot;A ::= B (C D)*&quot;</span>
</pre></div>
</div>
<p>包含属性的字典可以作为函数的 <a class="reference internal" href="../library/stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 访问。 与类实例的 <a class="reference internal" href="../library/stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性不同，在函数中，您实际上可以为 <a class="reference internal" href="../library/stdtypes.xhtml#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 分配一个新的字典，尽管新值仅限于普通的 Python 字典；您 <em>不能</em> 狡猾地将其设置为 <code class="xref py py-class docutils literal notranslate"><span class="pre">UserDict</span></code> 实例，或任何其他行为类似映射的随机对象。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0232/"><strong>PEP 232</strong></a><span class="link-target"> [https://peps.python.org/pep-0232/]</span> - 函数属性</dt><dd><p>由 Barry Warsaw 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-235-importing-modules-on-case-insensitive-platforms">
<h2>PEP 235: 在大小写不敏感的平台上导入模块</h2>
<p>一些操作系统的文件系统是区分大小写的，MacOS 和 Windows 是主要的例子；在这些系统上，无法区分文件名 <code class="docutils literal notranslate"><span class="pre">FILE.PY</span></code> 和 <code class="docutils literal notranslate"><span class="pre">file.py</span></code>，尽管它们确实以原始大小写存储文件名（它们也是区分大小写的）</p>
<p>在 Python 2.1 中，<a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句可以在不区分大小写的平台上模拟大小写敏感性。  现在，Python 默认搜索第一个大小写敏感匹配的文件，如果找不到这样的文件，就会引发 <a class="reference internal" href="../library/exceptions.xhtml#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>，因此 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">file</span></code> 不会导入名为 <code class="docutils literal notranslate"><span class="pre">FILE.PY</span></code> 的模块。 在启动 Python 解释器之前，可以通过设置 <span class="target" id="index-47"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONCASEOK</span></code></a> 环境变量来请求大小写不敏感匹配。</p>
</section>
<section id="pep-217-interactive-display-hook">
<h2>PEP 217: 交互模式显示钩子</h2>
<p>在交互模式下使用 Python 解释器时，命令的输出是通过内置的 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 函数显示的。在 Python 2.1 中，可以将变量 <a class="reference internal" href="../library/sys.xhtml#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.displayhook()</span></code></a> 设置为一个可调用对象，该对象将在代替 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 函数被调用。例如，你可以将其设置为一个特殊的美观打印函数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a recursive data structure</span>
<span class="gp">... </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="c1"># Show Python&#39;s default output</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use pprint.pprint() as the display function</span>
<span class="gp">... </span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">displayhook</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[1, 2, 3,  &lt;Recursion on list with id=135143996&gt;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0217/"><strong>PEP 217</strong></a><span class="link-target"> [https://peps.python.org/pep-0217/]</span> - 用于交互模式的显示钩子</dt><dd><p>由 Moshe Zadka 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-208-new-coercion-model">
<h2>PEP 208: 新的强制转换模型</h2>
<p>在 C 级别上的数值类型转换方法进行了重大修改。这只会影响编写 Python C 扩展的作者，使他们在编写支持数值运算的扩展类型时有更多的灵活性。</p>
<p>扩展类型现在可以在其 <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> 结构中设置类型标志 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code>，以表明它们支持新的强制模型。 在此类扩展类型中，数字槽函数不再假定它们将得到两个相同类型的参数；相反，它们可能会得到两个不同类型的参数，然后可以执行自己的内部强制。如果槽函数传递给它一个无法处理的类型，它可以通过返回一个指向 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code> 单一值的引用来表示失败。 然后将尝试其他类型的数值函数，也许它们可以处理该操作；如果其他类型也返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，那么将引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。  用 Python 写的数值方法也可以返回 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>，导致解释器当作该方法不存在（也许会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，也许会尝试另一个对象的数值方法）。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0208/"><strong>PEP 208</strong></a><span class="link-target"> [https://peps.python.org/pep-0208/]</span> - 改写强制转换模型</dt><dd><p>由 Neil Schemenauer 编写和实现，基于 Marc-André Lemburg 的早期工作。阅读这部分内容可以了解数值运算在 C 级别上现在如何处理的细节。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-241-metadata-in-python-packages">
<h2>PEP 241: Python 包中的元数据</h2>
<p>Python 用户经常抱怨的一个问题是，没有一个包含所有 Python 模块的单一目录。  T. Middleton 位于``www.vex.net/parnassus/`` 的 Vaults of Parnassus（2009 年 2 月退役，可在 Internet Archive Wayback Machine&lt;<a class="reference external" href="https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/">https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/</a>&gt;`_ 上查阅&quot;）是最大的 Python 模块目录，但在 Vaults 注册软件是可选的，很多人都懒得去注册。</p>
<p>作为解决这个问题的第一步，使用 Distutils <strong class="command">sdist</strong> 命令打包的 Python 软件将包含一个名为 <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 的文件，其中包含有关包的信息，如名称、版本和作者（在目录编制术语中称为元数据）。<code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 文件可以包含的字段的完整列表见 <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a><span class="link-target"> [https://peps.python.org/pep-0241/]</span>。随着人们开始使用 Python 2.1 打包他们的软件，越来越多的包将包含元数据，从而使得构建自动化目录系统并进行实验成为可能。通过积累经验，也许有可能设计一个真正好的目录系统，然后在 Python 2.2 中支持它。例如，Distutils 的 <strong class="command">sdist</strong> 和 <strong class="command">bdist_*</strong> 命令可以支持一个 <code class="docutils literal notranslate"><span class="pre">upload</span></code> 选项，自动将你的包上传到目录服务器。</p>
<p>即使你不使用 Python 2.1，你也可以开始创建包含 <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 的包，因为 Distutils 的新版本将为早期 Python 版本的用户发布。Distutils 1.0.2 版本包含了 <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a><span class="link-target"> [https://peps.python.org/pep-0241/]</span> 所描述的更改，以及各种错误修复和增强功能。可以从 Distutils SIG 获取该版本：<a class="reference external" href="https://www.python.org/community/sigs/current/distutils-sig/">https://www.python.org/community/sigs/current/distutils-sig/</a> 。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a><span class="link-target"> [https://peps.python.org/pep-0241/]</span> - 针对 Python 软件包的元数据</dt><dd><p>由 A.M. Kuchling 撰写并实现。</p>
</dd>
<dt><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0243/"><strong>PEP 243</strong></a><span class="link-target"> [https://peps.python.org/pep-0243/]</span> - 模块仓库上传机制</dt><dd><p>由 Sean Reifschneider 撰写，这个 PEP 草案描述了用于将 Python 软件包上传到一个中心服务器的建议机制。</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2>新增和改进的模块</h2>
<ul>
<li><p>Ka-Ping Yee 贡献了两个新模块：<code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect.py</span></code>，用于获取有关正在运行的 Python 代码的信息，以及 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc.py</span></code>，用于交互式地将文档字符串转换为 HTML 或文本。此外，作为一个额外的功能，<code class="file docutils literal notranslate"><span class="pre">Tools/scripts/pydoc</span></code> 现在会自动安装，并使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc.py</span></code> 来显示给定 Python 模块、包或类名的文档。例如，<code class="docutils literal notranslate"><span class="pre">pydoc</span> <span class="pre">xml.dom</span></code> 会显示如下内容：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="n">Library</span> <span class="n">Documentation</span><span class="p">:</span> <span class="n">package</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="ow">in</span> <span class="n">xml</span>

<span class="n">NAME</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="o">-</span> <span class="n">W3C</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">Python</span><span class="o">.</span>

<span class="n">FILE</span>
    <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python2</span><span class="mf">.1</span><span class="o">/</span><span class="n">xml</span><span class="o">/</span><span class="n">dom</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">pyc</span>

<span class="n">DESCRIPTION</span>
    <span class="n">The</span> <span class="n">Python</span> <span class="n">mapping</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">documented</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="n">Python</span> <span class="n">Library</span> <span class="n">Reference</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">section</span> <span class="n">on</span> <span class="n">the</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="n">package</span><span class="o">.</span>

    <span class="n">This</span> <span class="n">package</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">following</span> <span class="n">modules</span><span class="p">:</span>
      <span class="o">...</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">pydoc</span></code> 还包括一个基于 Tk 的交互式帮助浏览器。<code class="file docutils literal notranslate"><span class="pre">pydoc</span></code> 很快会让人上瘾；试试看！</p>
</li>
<li><p>两个不同的单元测试模块被添加到标准库中。<a class="reference internal" href="../library/doctest.xhtml#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块，由 Tim Peters 贡献，提供了一个基于运行嵌入在文档字符串中的示例并将结果与预期输出进行比较的测试框架。PyUnit，由 Steve Purcell 贡献，是一个受到 JUnit 启发的单元测试框架，而 JUnit 则是对 Kent Beck 的 Smalltalk 测试框架的改编。更多关于 PyUnit 的信息，请参阅 <a class="reference external" href="https://pyunit.sourceforge.net/">https://pyunit.sourceforge.net/</a> 。</p></li>
<li><p><a class="reference internal" href="../library/difflib.xhtml#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块包含一个类，即 <a class="reference internal" href="../library/difflib.xhtml#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>，用于比较两个序列，并计算将一个序列转换为另一个序列所需的变化。 例如，该模块可用于编写与 Unix <strong class="program">diff</strong> 程序类似的工具，事实上，示例程序 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ndiff.py</span></code> 演示了如何编写这样的脚本。</p></li>
<li><p><a class="reference internal" href="../library/curses.panel.xhtml#module-curses.panel" title="curses.panel: A panel stack extension that adds depth to  curses windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses.panel</span></code></a>，是 ncurses 和 SYSV curses 一部分的 panel 库的包装器，由 Thomas Gellekum 贡献。panel 库为窗口提供了深度特性。窗口可以在深度顺序中向上或向下移动，panel 库会计算出面板的重叠位置和哪些部分是可见的。</p></li>
<li><p>PyXML 包自 Python 2.0 以来经历了几次发布，Python 2.1 包含了更新版本的 <a class="reference internal" href="../library/xml.xhtml#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> 包。一些值得注意的更改包括支持 Expat 1.2 及更高版本，Expat 解析器能够处理 Python 支持的任何编码的文件，以及对 SAX、DOM 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">minidom</span></code> 模块的各种错误修复。</p></li>
<li><p>Ka-Ping Yee 还贡献了另一个用于处理未捕获异常的钩子。<a class="reference internal" href="../library/sys.xhtml#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.excepthook()</span></code></a> 可以设置为一个可调用对象。当异常未被任何 <a class="reference internal" href="../reference/compound_stmts.xhtml#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 块捕获时，异常将传递给 <a class="reference internal" href="../library/sys.xhtml#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.excepthook()</span></code></a>，它可以执行任何需要的操作。在第九届 Python 会议上，他演示了这个钩子的一个应用：打印扩展的回溯信息，不仅列出堆栈帧，还列出每个帧的函数参数和局部变量。</p></li>
<li><p>Various functions in the <a class="reference internal" href="../library/time.xhtml#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module, such as <a class="reference internal" href="../library/time.xhtml#time.asctime" title="time.asctime"><code class="xref py py-func docutils literal notranslate"><span class="pre">asctime()</span></code></a> and
<a class="reference internal" href="../library/time.xhtml#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code></a>, require a floating point argument containing the time in
seconds since the epoch.  The most common use of these functions is to work with
the current time, so the floating point argument has been made optional; when a
value isn't provided, the current time will be used.  For example, log file
entries usually need a string containing the current time; in Python 2.1,
<code class="docutils literal notranslate"><span class="pre">time.asctime()</span></code> can be used, instead of the lengthier
<code class="docutils literal notranslate"><span class="pre">time.asctime(time.localtime(time.time()))</span></code> that was previously required.</p>
<p>此更改由 Thomas Wouters 提出并实现。</p>
</li>
<li><p>The <a class="reference internal" href="../library/ftplib.xhtml#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> module now defaults to retrieving files in passive mode,
because passive mode is more likely to work from behind a firewall.  This
request came from the Debian bug tracking system, since other Debian packages
use <a class="reference internal" href="../library/ftplib.xhtml#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> to retrieve files and then don't work from behind a firewall.
It's deemed unlikely that this will cause problems for anyone, because Netscape
defaults to passive mode and few people complain, but if passive mode is
unsuitable for your application or network setup, call <code class="docutils literal notranslate"><span class="pre">set_pasv(0)</span></code> on
FTP objects to disable passive mode.</p></li>
<li><p>对原始套接字访问的支持已添加到 <a class="reference internal" href="../library/socket.xhtml#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块中，由 Grant Edwards 贡献。</p></li>
<li><p>The <a class="reference internal" href="../library/profile.xhtml#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> module now contains a simple interactive statistics browser
for displaying timing profiles for Python programs, invoked when the module is
run as a script.  Contributed by  Eric S. Raymond.</p></li>
<li><p>A new implementation-dependent function, <code class="docutils literal notranslate"><span class="pre">sys._getframe([depth])</span></code>, has
been added to return a given frame object from the current call stack.
<a class="reference internal" href="../library/sys.xhtml#sys._getframe" title="sys._getframe"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys._getframe()</span></code></a> returns the frame at the top of the call stack;  if the
optional integer argument <em>depth</em> is supplied, the function returns the frame
that is <em>depth</em> calls below the top of the stack.  For example,
<code class="docutils literal notranslate"><span class="pre">sys._getframe(1)</span></code> returns the caller's frame object.</p>
<p>这个函数仅存在于 CPython 中，不存在于 Jython 或 .NET 实现中。请将其用于调试，并避免将其放入生产代码中。</p>
</li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2>其他的改变和修正</h2>
<p>由于较短的发布周期，Python 2.1 中的较小更改相对较少。通过搜索 CVS 更改日志，发现应用了 117 个补丁并修复了 136 个错误；这两个数字都可能是低估的。一些较为显著的更改包括：</p>
<ul>
<li><p>A specialized object allocator is now optionally available, that should be
faster than the system <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and have less memory overhead.  The
allocator uses C's <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> function to get large pools of memory, and
then fulfills smaller memory requests from these pools.  It can be enabled by
providing the <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> option to the <strong class="program">configure</strong>
script; see <code class="file docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code> for the implementation details.</p>
<p>Authors of C extension modules should test their code with the object allocator
enabled, because some incorrect code may break, causing core dumps at runtime.
There are a bunch of memory allocation functions in Python's C API that have
previously been just aliases for the C library's <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>, meaning that if you accidentally called mismatched functions, the
error wouldn't be noticeable.  When the object allocator is enabled, these
functions aren't aliases of <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> any more, and
calling the wrong function to free memory will get you a core dump.  For
example, if memory was allocated using <a class="reference internal" href="../c-api/memory.xhtml#c.PyMem_New" title="PyMem_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyMem_New</span></code></a>, it has to be freed
using <a class="reference internal" href="../c-api/memory.xhtml#c.PyMem_Del" title="PyMem_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Del()</span></code></a>, not <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>.  A few modules included with Python
fell afoul of this and had to be fixed; doubtless there are more third-party
modules that will have the same problem.</p>
<p>对象分配器由 Vladimir Marangozov 贡献。</p>
</li>
<li><p>The speed of line-oriented file I/O has been improved because people often
complain about its lack of speed, and because it's often been used as a naïve
benchmark.  The <a class="reference internal" href="../library/readline.xhtml#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> method of file objects has therefore been
rewritten to be much faster.  The exact amount of the speedup will vary from
platform to platform depending on how slow the C library's <code class="xref c c-func docutils literal notranslate"><span class="pre">getc()</span></code> was, but
is around 66%, and potentially much faster on some particular operating systems.
Tim Peters did much of the benchmarking and coding for this change, motivated by
a discussion in comp.lang.python.</p>
<p>A new module and method for file objects was also added, contributed by Jeff
Epler. The new method, <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code>, is similar to the existing
<code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> built-in.  <code class="xref py py-func docutils literal notranslate"><span class="pre">xreadlines()</span></code> returns an opaque sequence object
that only supports being iterated over, reading a line on every iteration but
not reading the entire file into memory as the existing <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> method
does. You'd use it like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">xreadlines</span><span class="p">():</span>
    <span class="c1"># ... do something for each line ...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>有关行 I/O 更改的更详细讨论，请参阅 2001 年 1 月 1 日至 15 日的 python-dev 摘要：<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-January/">https://mail.python.org/pipermail/python-dev/2001-January/</a> 。</p>
</li>
<li><p>A new method, <a class="reference internal" href="../library/stdtypes.xhtml#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a>, was added to dictionaries to enable
destructively iterating through the contents of a dictionary; this can be faster
for large dictionaries because there's no need to construct a list containing
all the keys or values. <code class="docutils literal notranslate"><span class="pre">D.popitem()</span></code> removes a random <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pair
from the dictionary <code class="docutils literal notranslate"><span class="pre">D</span></code> and returns it as a 2-tuple.  This was implemented
mostly by Tim Peters and Guido van Rossum, after a suggestion and preliminary
patch by Moshe Zadka.</p></li>
<li><p>Modules can now control which names are imported when <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>
is used, by defining an <code class="docutils literal notranslate"><span class="pre">__all__</span></code> attribute containing a list of names that
will be imported.  One common complaint is that if the module imports other
modules such as <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> or <a class="reference internal" href="../library/string.xhtml#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> will add
them to the importing module's namespace.  To fix this, simply list the public
names in <code class="docutils literal notranslate"><span class="pre">__all__</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># List public names</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Database&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>此补丁的更严格版本最初由 Ben Wolfson 提出并实现，但在经过一些 python-dev 讨论后，最终版本被修改为较弱的版本并提交。</p>
</li>
<li><p>Applying <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> to strings previously used octal escapes for
non-printable characters; for example, a newline was <code class="docutils literal notranslate"><span class="pre">'\012'</span></code>.  This was a
vestigial trace of Python's C ancestry, but today octal is of very little
practical use.  Ka-Ping Yee suggested using hex escapes instead of octal ones,
and using the <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\t</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code> escapes for the appropriate characters,
and implemented this new formatting.</p></li>
<li><p>在编译时检测到的语法错误现在可以引发包含错误文件名和行号的异常，这是 Jeremy Hylton 进行的编译器重组的一个令人愉快的副作用。</p></li>
<li><p>C extensions which import other modules have been changed to use
<a class="reference internal" href="../c-api/import.xhtml#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>, which means that they will use any import hooks
that have been installed.  This is also encouraged for third-party extensions
that need to import some other module from C code.</p></li>
<li><p>由于 Fredrik Lundh 的努力，Unicode 字符数据库的大小又减少了 340K。</p></li>
<li><p>一些新移植版本被贡献：MacOS X（由 Steven Majewski 贡献），Cygwin（由 Jason Tishler 贡献），RISCOS（由 Dietmar Schwertberger 贡献），以及 Unixware 7（由 Billy G. Allie 贡献）。</p></li>
</ul>
<p>此外还有一份由次要的程序错误修复、次要的内存泄漏、文档字符串编辑和其他调整组成的常规清单，因过于冗长而不值得逐项列出；如果你想了解完整细节请参阅 CVS 日志。</p>
</section>
<section id="acknowledgements">
<h2>致谢</h2>
<p>作者感谢以下人员对本文的各种草案提出建议： Graeme Cross, David Goodger, Jay Graves, Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas Wouters.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>