<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.0 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.0.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling 和 Moshe Zadka,. 概述: A new release of Python, version 2.0, was released on October 16, 2000. This article covers the exciting new features in 2.0, highlights some other useful chan..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, A.M. Kuchling 和 Moshe Zadka,. 概述: A new release of Python, version 2.0, was released on October 16, 2000. This article covers the exciting new features in 2.0, highlights some other useful chan..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 2.0 有什么新变化</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.0.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-0">
<h1>Python 2.0 有什么新变化</h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling 和 Moshe Zadka</p>
</dd>
</dl>
<section id="introduction">
<h2>概述</h2>
<p>A new release of Python, version 2.0, was released on October 16, 2000. This
article covers the exciting new features in 2.0, highlights some other useful
changes, and points out a few incompatible changes that may require rewriting
code.</p>
<p>Python 的开发工作在版本发布之间绝不会完全停止，总是会有错误修复和改进被持续地提交。 2.0 中包含了大量的小问题修正、一些性能优化、额外的文档字符串和更完善的错误消息；要列出所有这些是不可能的，但它们确实带来了明显的变化。 如果你想查看完整清单可以参阅公开的 CVS 日志。 这些进展归功于为 PythonLabs 工作的五位开发者，他们现在可以付出时间修复问题并获得报酬，同时也归功于迁移到 SourceForge 后在沟通方面的改善。</p>
</section>
<section id="what-about-python-1-6">
<h2>Python 1.6 将会怎样？</h2>
<p>Python 1.6 可以被视为继续履行合同义务的 Python 发布版。 在核心开发团队于 2000 年 5 月离开 CNRI 之后，CNRI 要求创建一个 1.6 发布版，其中包含 CNRI 在 Python 项目上已完成的所有工作。 因此 Python 1.6 代表了截至 2000 年 5 月的 CVS 树的状态，其中最重要的新特性是 Unicode 支持。 当然，5 月之后开发工作仍在继续，因此 1.6 树接受了一些修正以确保它对 Python 2.0 向上兼容。 所以 1.6 仍是 Python 演化过程的组成部分，而不是一个旁支。</p>
<p>那么，你应该对 Python 1.6 保持更多关注吗？也许不必。 1.6final 和 2.0beta1 是在同一天（2000 年 9 月 5 日）发布的，计划在一个月左右的时间内完成 Python 2.0 正式版。 如果你有应用程序需要维护，那么迁移到 1.6 破坏兼容性，修复它们，然后在一个月内又迁移到 2.0 再进行新一轮的兼容性修复的做法似乎没有什么意义；你最好直接迁移到 2.0。 本文档中介绍的大多数真正值得关注的特性都只出现在 2.0 中，因为很多工作都是在 5 月到 9 月之间完成的。</p>
</section>
<section id="new-development-process">
<h2>新开发流程</h2>
<p>Python 2.0 中最重要的变化可能根本不是代码，而是 Python 的开发方式：在 2000 年 5 月，Python 开发者开始使用 SourceForge 提供的工具来存储源代码、跟踪错误报告以及管理补丁提交队列。 要报告 Python 2.0 的错误或提交补丁，请使用位于 <a class="reference external" href="https://sourceforge.net/projects/python/">https://sourceforge.net/projects/python/</a> 的 Python项目页上的错误跟踪和补丁管理器工具。</p>
<p>现在托管在SourceForge的最重要的服务是Python CVS树，这是一个包含Python源代码的版本控制库。以前，大约有7个左右的人可以写入CVS树，所有的补丁都必须由这个短名单上的一个人检查和签到。很明显，这并不是非常可扩展的。通过将CVS树转移到SourceForge，有可能向更多的人授予写访问权；截至2000年9月，有27人能够检查变化，增加了4倍。这使得大规模的改变成为可能，如果它们必须通过一小群核心开发者来过滤，就不会被尝试。例如，有一天Peter Schneider-Kamp想到了放弃K&amp;R C的兼容性，将Python的C源转换为ANSI C。在获得python-dev邮件列表的批准后，他发起了一连串的签到，持续了大约一周，其他开发人员加入了进来帮忙，工作就完成了。如果只有5个人可以接触到写作，那么这项任务可能会被视为 &quot;不错，但不值得花费时间和精力，而且它永远不会完成。</p>
<p>转向使用 SourceForge 的服务显著提高了开发速度。 补丁现在由原提交者以外的人提交、评论、修改，并在不同人员之间来回传递，直到补丁被认为值得检入。 程序错误在一个中心位置被跟踪，并可以分配给特定人员进行修复，我们还可以统计未解决程序错误的数量来衡量进度。 这并不是没有代价的：开发人员现在需要处理更多的电子邮件，关注更多的邮件列表，并且需要为新环境编写专门的工具。 例如，SourceForge 发送的默认补丁和错误通知电子邮件完全无用，所以 Ka-Ping Yee 编写了一个 HTML 屏幕抓取器以便发送更有用的信息。</p>
<p>添加代码的便利性引发了一些初期的成长痛苦，比如代码在准备好之前或未经开发者团队明确同意就被检入。 现在形成的审批流程有点类似于 Apache 团队所使用的流程。 开发者可以对补丁投票：+1、+0、-0 或 -1；+1 和 -1 表示接受或拒绝，而 +0 和 -0 则表示开发者对变更大多持无所谓的态度，但略有正面或负面的倾向。 与 Apache 模型最显著的变化是投票本质上是咨询性的，让拥有终身仁慈独裁者地位的 Guido van Rossum 了解总体意见。 他仍然可以忽略投票结果，并批准或拒绝变更，即使社区不同意他的决定。</p>
<p>实际产生补丁是添加新功能的最后一步，与之前指定一个好的设计相比，这通常比较容易。 对于新功能的讨论往往会变成冗长的邮件列表帖子，使讨论难以跟踪，并且没有人能够阅读每一条发给 python-dev 的帖子。 因此，建议了一个相对正式的流程来编写 Python 增强提案（PEP），该流程借鉴了互联网 RFC 流程。 PEP 是描述拟议新特性的草案文件，并不断修改，直到社区达成共识，接受或拒绝该提案。 引用自 <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a><span class="link-target"> [https://peps.python.org/pep-0001/]</span> 的介绍部分 &quot;PEP Purpose and Guidelines&quot;：</p>
<blockquote class="epigraph">
<div><p>PEP 是 Python Enhancement Proposal 的缩写。 一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python 新增特性。 PEP 应当提供对所提议特性的精确的技术规格和原理说明。</p>
<p>我们打算将 PEP 作为提出新特性建议、收集社区对特定问题意见以及为必须加入 Python 的设计决策编写文档的首选机制。 PEP 的作者有责任在社区内部建立共识，并应将对立的观点也记入文档。</p>
</div></blockquote>
<p>请阅读 <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a><span class="link-target"> [https://peps.python.org/pep-0001/]</span> 的其余部分以了解 PEP 编辑流程、风格和格式的详细信息。 PEP 保存在 SourceForge 的Python CVS 树中，尽管它们不是 Python 2.0 发行版的一部分，但也可以从 <a class="reference external" href="https://peps.python.org/">https://peps.python.org/</a> 以 HTML 形式获取。 截至 2000 年 9 月，共有 25 个 PEP，从 <span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0201/"><strong>PEP 201</strong></a><span class="link-target"> [https://peps.python.org/pep-0201/]</span> &quot;Lockstep Iteration&quot; 到PEP 225 &quot;Elementwise/Objectwise Operators&quot;。</p>
</section>
<section id="unicode">
<h2>Unicode</h2>
<p>Python 2.0 中最大的新特性是引入了一种新的基本数据类型：Unicode 字符串。 Unicode 使用 16 位二进制数表示字符，而不是 ASCII 所使用的 8 位，这意味着可以支持 65,536 个不同的字符。</p>
<p>Unicode 支持的最终接口是通过在 python-dev 邮件列表上无数次激烈的讨论达成的，主要由 Marc-André Lemburg 基于 Fredrik Lundh 的 Unicode 字符串类型实现来完成。 详细的接口说明被写成了 <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0100/"><strong>PEP 100</strong></a><span class="link-target"> [https://peps.python.org/pep-0100/]</span> &quot;Python Unicode Integration&quot;。 这篇文章只简单地涵盖关于 Unicode 接口的最重要信息。</p>
<p>在 Python 源代码中，Unicode 字符串被写成 <code class="docutils literal notranslate"><span class="pre">u&quot;string&quot;</span></code>。 任意的 Unicode 字符可以使用新的转义序列 <code class="samp docutils literal notranslate"><span class="pre">\u</span><em><span class="pre">HHHH</span></em></code> 来表示，其中 <em>HHHH</em> 是一个从 0000 到 FFFF 的 4 位十六进制数字。 现有的 <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">HH</span></em></code> 转义序列也可以使用，而八进制转义序列可以用于最多到 U+01FF 码位的字符，即表示为 <code class="docutils literal notranslate"><span class="pre">\777</span></code>。</p>
<p>Unicode 字符串和常规字符串一样，是一种不可变的序列类型。 它们可以被索引和切片，但不能原地修改。 Unicode 字符串有一个 <code class="docutils literal notranslate"><span class="pre">encode(</span> <span class="pre">[encoding]</span> <span class="pre">)</span></code> 方法，该方法返回一个以所需编码格式表示的 8 位字符串。 编码格式通过字符串命名，如 <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>、<code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>、<code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code> 等等。 为实现和注册新的编码格式定义了一个编解码器 API，这些编码格式随后可在整个 Python 程序中使用。 如果未指定编码格式，默认编码格式通常是 7 位 ASCII，不过这可以通过在自定义版本的 <code class="file docutils literal notranslate"><span class="pre">site.py</span></code> 模块中调用 <code class="docutils literal notranslate"><span class="pre">sys.setdefaultencoding(encoding)</span></code> 函数来更改。</p>
<p>将 8 比特位和 Unicode 的字符串结合使用时将总是会使用默认 ASCII 编码格式强制转换到 Unicode；<code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">+</span> <span class="pre">u'bc'</span></code> 的结果将为 <code class="docutils literal notranslate"><span class="pre">u'abc'</span></code>。</p>
<p>新增了一批内置函数，现有的内置函数也被修改为支持 Unicode：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unichr(ch)</span></code> 将返回长度为 1 个字符的 Unicode 字符串，其中包含字符 <em>ch</em>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ord(u)</span></code>，其中 <em>u</em> 是长度为 1 个字符的常规或 Unicode 字符串，将以整数形式返回该字符的码位值。</p></li>
<li><p>函数 <code class="docutils literal notranslate"><span class="pre">unicode(string</span> <span class="pre">[,</span> <span class="pre">encoding]</span> <span class="pre">[,</span> <span class="pre">errors]</span> <span class="pre">)</span></code> 从 8 位字符串创建一个 Unicode 字符串。 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> 是一个指定使用编码格式的字符串。<code class="docutils literal notranslate"><span class="pre">errors</span></code> 参数指定如何处理当前编码格式中无效的字符；传入 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 作为参数值会在有任何编码错误时引发异常，而 <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 会静默忽略错误，<code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 则在出现问题时使用 U+FFFD 即官方的替换字符。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句，以及各种内置函数如 <code class="docutils literal notranslate"><span class="pre">eval()</span></code>，<code class="docutils literal notranslate"><span class="pre">getattr()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> 也会接受 Unicode 字符串和普通字符串。 （修复过程中可能会遗漏一些内置函数；如果你发现一个接受字符串但完全不接受 Unicode 字符串的内置函数，请报告此错误。）</p></li>
</ul>
<p>一个新的模块 <a class="reference internal" href="../library/unicodedata.xhtml#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 提供了对 Unicode 字符属性的接口。 例如，<code class="docutils literal notranslate"><span class="pre">unicodedata.category(u'A')</span></code> 返回 2 个字符的字符串 'Lu'，其中 'L' 表示这是一个字母，'u' 表示这是一个大写字母。 <code class="docutils literal notranslate"><span class="pre">unicodedata.bidirectional(u'\u0660')</span></code> 返回 'AN'，表示 U+0660 是一个阿拉伯数字。</p>
<p><a class="reference internal" href="../library/codecs.xhtml#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块包含查找现有编码格式和注册新编码格式的函数。 除非你想实现一个新的编码格式，否则你最常使用的是 <code class="docutils literal notranslate"><span class="pre">codecs.lookup(encoding)</span></code> 函数，它返回一个 4 元素的元组: <code class="docutils literal notranslate"><span class="pre">(encode_func,</span> <span class="pre">decode_func,</span> <span class="pre">stream_reader,</span> <span class="pre">stream_writer)</span></code>。</p>
<ul class="simple">
<li><p><em>encode_func</em> 是一个接受 Unicode 字符串的函数，并返回一个 2 元组 <code class="docutils literal notranslate"><span class="pre">(string,</span> <span class="pre">length)</span></code>。 <em>string</em> 是一个包含部分（可能是全部） Unicode 字符串转换为指定编码的 8 位字符串，<em>length</em> 告诉你转换了多少 Unicode 字符串。</p></li>
<li><p><em>decode_func</em> 与 <em>encode_func</em> 相反，它接受一个 8 位字符串并返回一个 2 元组 <code class="docutils literal notranslate"><span class="pre">(ustring,</span> <span class="pre">length)</span></code>，其中 <em>ustring</em> 是转换得到的 Unicode 字符串，<em>length</em> 是一个整数，表示消耗了多少 8 位字符串。</p></li>
<li><p><em>stream_reader</em> 是一个支持从流中解码输入的类。 <em>stream_reader(file_obj)</em> 返回一个支持 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>，<code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> 方法的对象。 这些方法都会从指定编码转换并返回 Unicode 字符串。</p></li>
<li><p><em>stream_writer</em> 同样是一个支持将输出编码到流中的类。 <em>stream_writer(file_obj)</em> 返回一个支持 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">writelines()</span></code> 方法的对象。 这些方法期望接收 Unicode 字符串，并在输出时将使用指定的编码格式来转换它们。</p></li>
</ul>
<p>例如，以下的代码将 Unicode 字符串写入一个 UTF-8 编码的文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">codecs</span>

<span class="n">unistr</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u0660\u2000</span><span class="s1">ab ...&#39;</span>

<span class="p">(</span><span class="n">UTF8_encode</span><span class="p">,</span> <span class="n">UTF8_decode</span><span class="p">,</span>
 <span class="n">UTF8_streamreader</span><span class="p">,</span> <span class="n">UTF8_streamwriter</span><span class="p">)</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">UTF8_streamwriter</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="n">unistr</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>以下的代码则可以从文件中读取 UTF-8 输入:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="o">=</span> <span class="n">UTF8_streamreader</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="nb">input</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>支持 Unicode 的正则表达式可以通过 <a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块使用，该模块有一个新的底层实现称为 SRE，由 Secret Labs AB 的 Fredrik Lundh 编写。</p>
<p>添加了一个 <code class="docutils literal notranslate"><span class="pre">-U</span></code> 命令行选项，使 Python 编译器将所有字符串字面量解释为 Unicode 字符串字面量。 这用于测试和为你的 Python 代码提供未来保障，因为未来某个版本的 Python 可能会取消对 8 位字符串的支持，只提供 Unicode 字符串。</p>
</section>
<section id="list-comprehensions">
<h2>列表推导式</h2>
<p>列表是 Python 中的一种主力数据类型，许多程序在某个时候都会处理列表。 对列表的两种常见操作是遍历它们，并筛选出符合某个条件的元素，或对每个元素应用某个函数。 例如，给定一个字符串列表，你可能想要提取出所有包含特定子字符串的字符串，或去掉每行的尾随空白。</p>
<p>现有的 <a class="reference internal" href="../library/functions.xhtml#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> 和 <a class="reference internal" href="../library/functions.xhtml#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> 函数可以用于此目的，但它们需要一个函数作为参数之一。 如果有一个现有的内置函数可以直接传递，这是很好的，但如果没有，你必须创建一个小函数来完成所需的工作。 而 Python 的作用域规则会使结果变得丑陋，特别是如果这个小函数需要额外的信息。 以上一段中的第一个例子为例，找到列表中所有包含给定子字符串的字符串。 你可以写如下代码来实现:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given the list L, make a list of all strings</span>
<span class="c1"># containing the substring S.</span>
<span class="n">sublist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="o">=</span><span class="n">S</span><span class="p">:</span>
                     <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>由于 Python 的作用域规则，将会使用默认参数以使由 <a class="reference internal" href="../reference/expressions.xhtml#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式创建的匿名函数知道正在搜索哪个子字符串。 列表推导能使这个过程更简洁:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sublist</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span> <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
<p>列表推导式的形式如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">expression</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sequence1</span>
             <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span> <span class="o">...</span>
             <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span>
             <span class="k">if</span> <span class="n">condition</span> <span class="p">]</span>
</pre></div>
</div>
<p><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>...:keyword:<cite>!in</cite> 子句包含要迭代的序列。 这些序列不必具有相同的长度，因为它们 <em>不是</em> 并行迭代的，而是从左到右依次迭代；这一点将在以下段落中更清楚地解释。 生成列表的元素将是 <em>表达式</em> 的连续值。 最后的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 子句是可选的；如果存在，只有当 <em>condition</em> 为真时，<em>表达式</em> 才会被求值并添加到结果中。</p>
<p>为了使语义更为清晰，列表推导相当于以下 Python 代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">sequence1</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span><span class="p">:</span>
    <span class="o">...</span>
        <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span><span class="p">:</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                  <span class="c1"># Append the value of</span>
                  <span class="c1"># the expression to the</span>
                  <span class="c1"># resulting list.</span>
</pre></div>
</div>
<p>这意味着当有多个 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>...:keyword:<cite>!in</cite> 子句时，生成的列表将等于所有序列长的的乘积。 如果你有两个长度为 3 的列表，输出列表将有 9 个元素:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>为了避免在 Python 的语法中引入歧义，如果 <em>表达式</em> 创建的是一个元组，它必须用括号括起来。 下面的第一个列表推导式有语法错误，而第二个则是正确的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Syntax error</span>
<span class="p">[</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="c1"># Correct</span>
<span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
</pre></div>
</div>
<p>列表推导的概念最初来自函数式编程语言 Haskell (<a class="reference external" href="https://www.haskell.org">https://www.haskell.org</a>)。 Greg Ewing 最有力地提出了将其添加到 Python 中的建议，并编写了最初的列表推导式补丁，然后在 python-dev 邮件列表上进行了看似无休止的讨论，并由 Skip Montanaro 保持更新。</p>
</section>
<section id="augmented-assignment">
<h2>增强赋值</h2>
<p>增强赋值运算符，另一个长期以来要求添加的功能，已经被加入到 Python 2.0 中。 增强赋值运算符包括 <code class="docutils literal notranslate"><span class="pre">+=</span></code>，<code class="docutils literal notranslate"><span class="pre">-=</span></code>，<code class="docutils literal notranslate"><span class="pre">*=</span></code> 等。例如，语句 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> 将变量 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的值增加 2，等同于稍长一些的 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code>。</p>
<p>支持的完整赋值运算符列表包括 <code class="docutils literal notranslate"><span class="pre">+=</span></code>，<code class="docutils literal notranslate"><span class="pre">-=</span></code>，<code class="docutils literal notranslate"><span class="pre">*=</span></code>，<code class="docutils literal notranslate"><span class="pre">/=</span></code>，<code class="docutils literal notranslate"><span class="pre">%=</span></code>，<code class="docutils literal notranslate"><span class="pre">**=</span></code>，<code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>，<code class="docutils literal notranslate"><span class="pre">|=</span></code>，<code class="docutils literal notranslate"><span class="pre">^=</span></code>，<code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>。 Python 类可以通过定义名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">__isub__()</span></code> 等方法来重载增强赋值运算符。 例如，以下的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> 类储存一个数字，并支持使用 += 来创建一个递增值的新实例。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Number</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">increment</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">n</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="nb">print</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code> 特殊方法使用增量值调用，并应返回一个具有适当修改值的新实例；这个返回值将作为左侧变量的新值被绑定。</p>
<p>增强赋值运算符最早在 C 编程语言中引入，大多数 C 派生语言，如 <strong class="program">awk</strong>，C++，Java 和 PHP 也支持它们。 增强赋值补丁由 Thomas Wouters 实现。</p>
</section>
<section id="string-methods">
<h2>字符串的方法</h2>
<p>直到现在，字符串操作功能都在 <a class="reference internal" href="../library/string.xhtml#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块中，它通常是用 C 编写的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> 模块的前端。 Unicode 的添加为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> 模块带来困难，因为所有函数都需要重写，以接受 8 位或 Unicode 字符串，对于像 <code class="xref py py-func docutils literal notranslate"><span class="pre">string.replace()</span></code> 这样的函数，它需要 3 个字符串参数，这意味着有 8 种可能的排列方式，相应的代码也会变得复杂。</p>
<p>相反，Python 2.0 将这个问题推给了字符串类型，使字符串操作功能通过 8 位字符串和 Unicode 字符串上的方法来实现。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;andrew&#39;</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">&#39;Andrew&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hostname&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">,</span> <span class="s1">&#39;linux&#39;</span><span class="p">)</span>
<span class="go">&#39;hlinuxtname&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;moshe&#39;</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>有一件事没有改变，即使是值得注意的愚人节玩笑，Python 字符串仍然是不可变的。 因此，字符串方法返回的是新的字符串，而不是修改他们操作的原字符串。</p>
<p>旧的 <a class="reference internal" href="../library/string.xhtml#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块仍然存在以保持向向兼容，但它主要作为新字符串方法的前端。</p>
<p>在 2.0 之前的版本中没有对应方法的两个方法是 <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code>，尽管它们在 JPython 中存在了相当长的时间。 <code class="docutils literal notranslate"><span class="pre">s.startswith(t)</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">s[:len(t)]</span> <span class="pre">==</span> <span class="pre">t</span></code>，而 <code class="docutils literal notranslate"><span class="pre">s.endswith(t)</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">s[-len(t):]</span> <span class="pre">==</span> <span class="pre">t</span></code>。</p>
<p>另一个值得特别提及的方法是 <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code>。 字符串的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> 方法接收一个参数，即字符串序列，并且等同于来自旧的 <a class="reference internal" href="../library/string.xhtml#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块的 <code class="xref py py-func docutils literal notranslate"><span class="pre">string.join()</span></code> 函数，但参数顺序相反。 换句话说，<code class="docutils literal notranslate"><span class="pre">s.join(seq)</span></code> 等同于旧的 <code class="docutils literal notranslate"><span class="pre">string.join(seq,</span> <span class="pre">s)</span></code>。</p>
</section>
<section id="garbage-collection-of-cycles">
<h2>循环的垃圾回收</h2>
<p>Python 的 C 实现使用引用技术来实现垃圾回收。 每个 Python 对象维护一个指向自身的引用数量，并在引用创建或销毁时调整该计数。 一旦引用计数达到零，对象就不再可访问，因为访问对象需要一个引用，然后如果计数为零，就不再存在任何引用。</p>
<p>引用计数有一些令人愉快的特性：它易于理解和实现，结果实现是可移植的，相当快，并且与其他实现自己内存处理方案的库良好互动。引用计数的主要问题是有时它无法识别对象不再可访问，从而导致内存泄露，这发生在存在引用循环时。</p>
<p>考虑最简单的循环，一个类实例引用自身:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">instance</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">instance</span><span class="o">.</span><span class="n">myself</span> <span class="o">=</span> <span class="n">instance</span>
</pre></div>
</div>
<p>在执行完上述两行代码后，<code class="docutils literal notranslate"><span class="pre">instance</span></code> 的引用计数是 2；一个引用来自名为 <code class="docutils literal notranslate"><span class="pre">'instance'</span></code> 的变量，另一个引用来自该实例的 <code class="docutils literal notranslate"><span class="pre">myself</span></code> 属性。</p>
<p>如果下一行代码是 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">instance</span></code>，会发生什么？ <code class="docutils literal notranslate"><span class="pre">instance</span></code> 的引用计数会减少 1，所以它的引用计数变为 1；<code class="docutils literal notranslate"><span class="pre">myself</span></code> 属性中的引用仍然存在。 然而，该实例不能再通过 Python 代码访问，并且它可以被删除。 如果多个对象相互引用，它们可以参与一个循环，导致所有对象都无法被垃圾回收，从而导致内存泄漏。</p>
<p>Python 2.0 通过周期性的执行一个循环检测算法来解决这个问题，该算法查找不可访问的循环并删除涉及的对象。 一个新的 <a class="reference internal" href="../library/gc.xhtml#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模块提供了执行垃圾回收、获取调试统计信息和调整回收器参数的功能。</p>
<p>运行循环检测算法需要一些时间，因此会带来一些额外的开销，希望在使用 2.0 版本的循环收集经验之后，Python 2.1 可以通过精细调整来尽量减少开销。 目前还不清楚性能损失有多大，因为对此进行精准测试很棘手，而且关键在于程序创建和销毁对象的频率。 如果你不能接受哪怕是微小的速度损失，或者怀疑循环收集存在问题，可以在编译 Python 时禁用循环检测，通过在运行 <strong class="program">configure</strong> 脚本时指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> 开关来实现。</p>
<p>有几个人解决了这个问题并为解决方案做出了贡献。循环检测方法的早期实现由 Toby Kelsey 编写。 当前的算法是在 Eric Tiedemann 访问 CNRI 期间提出的，Guido van Rossum 和 Neil Schemenauer 分别编写了两个不同的实现，后来由 Neil 将它们整合。 许多其他人也在过程中提出了建议；python-dev 邮件列表 2000 年 3 月的存档包含了大部分相关讨论，尤其是在标题为 “Reference cycle collection for Python” 和 “Finalization again” 的帖子中。</p>
</section>
<section id="other-core-changes">
<h2>其他核心变化</h2>
<p>Python 的语法和内置函数进行了各种小改动。 虽然这些改动都不是非常深远，但它们都是很方便的改进。</p>
<section id="minor-language-changes">
<h3>细微的语言特性修改</h3>
<p>一种新的语法是的使用元组和/或字典作为参数来调用函数更加方便。在 Python 1.5 及更早版本中，你会使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> 内置函数: <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args,</span> <span class="pre">kw)</span></code> 调用函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>，附带参数元组 <em>args</em> 和关键字参数字典 <em>kw</em>。 在 Python 2.0 中，<code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> 的使用方式是相同的。 但由于 Greg Ewing 的补丁，<code class="docutils literal notranslate"><span class="pre">f(*args,</span> <span class="pre">**kw)</span></code> 是一种更简洁明了的方式来实现相同的效果。 这种语法与定义函数的语法是对称的。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c1"># args is a tuple of positional args,</span>
    <span class="c1"># kw is a dictionary of keyword args</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">print</span></code> 语句现在可以通过在 <code class="docutils literal notranslate"><span class="pre">print</span></code> 后面加上 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">file</span></code> 来将其输出定向到文件型对象，这类似于 Unix shell 中的重定向操作符。 以前，你要么必须使用文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 方法，这缺乏 <code class="docutils literal notranslate"><span class="pre">print</span></code> 的方便和简单，要么你可以为 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 分配一个新值，然后恢复旧值。 为了将输出发送到标准错误，现在可以更简单地写成这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Warning: action field not supplied&quot;</span>
</pre></div>
</div>
<p>模块现在可以在导入时重命名，使用语法 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">module</span> <span class="pre">as</span> <span class="pre">name</span></code> 或 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">as</span> <span class="pre">othername</span></code>。这个补丁是由 Thomas Wouters 提交的。</p>
<p>当使用 <code class="docutils literal notranslate"><span class="pre">%</span></code> 操作符时有一种新的格式样式可用；'%r' 将插入其参数的 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 表示。 这也是为了对称性，这次是为了与现有的 %s 格式样式对称，后者插入其参数的 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 表示。例如，<code class="docutils literal notranslate"><span class="pre">'%r</span> <span class="pre">%s'</span> <span class="pre">%</span> <span class="pre">('abc',</span> <span class="pre">'abc')</span></code> 返回一个包含 <code class="docutils literal notranslate"><span class="pre">'abc'</span> <span class="pre">abc</span></code> 的字符串。</p>
<p>以前没有办法实现一个类来重载 Python 的内置 <a class="reference internal" href="../reference/expressions.xhtml#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 操作符并实现自定义版本。<code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">seq</span></code> 返回真如果 <em>obj</em> 存在于序列 <em>seq</em> 之中；Python 通过简单地尝试索引来计算这个结果，直到找到 <em>obj</em> 或遇到 <a class="reference internal" href="../library/exceptions.xhtml#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>。 Moshe Zadka 提供了一个补丁，增加了一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> 魔术方法，用于为 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> 提供自定义实现。 此外，用 C 编写的新内置对象可以通过序列协议中的新槽定义 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> 对它们的含义。</p>
<p>早期版本的 Python 使用递归算法来删除对象。深度嵌套的数据结构可能导致解释器填满 C 栈并崩溃。 Christian Tismer 重写了删除逻辑来解决这个问题。 相关地，比较递归对象时会导致无线递归并崩溃。Jeremy Hylton 重写了代码，使其不再崩溃，而是产生有用的结果。 例如，在以下代码之后:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>比较 <code class="docutils literal notranslate"><span class="pre">a==b</span></code> 将返回真值，因为这两个递归数据结构是同构的。 请参阅 python-dev 邮件列表 2000 年 4 月的存档中的 &quot;trashcan and PR#7&quot; 帖子，以了解导致此实现的讨论和一些相关的有用链接。 请注意，现在的比较操作也可以引发异常。 在早期版本的 Python 中，即使用户定义的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> 方法遇到错误，譬如 <code class="docutils literal notranslate"><span class="pre">cmp(a,b)</span></code> 的比较操作也总会产生一个答案，因为结果异常会被静默处理掉。</p>
<p>来自 ActiveState 的 Trent Mick 主要负责将 Python 移植到 Itanium 处理器上的 64 位 Windows 上。 （令人困惑的是，在 Win64 上，<code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> 类型仍然是 <code class="docutils literal notranslate"><span class="pre">'win32'</span></code> 的，因为为了便于移植，MS Visual C++ 在 Itanium 上将代码视为 32 位。） PythonWin 还支持 Windows CE；更多信息请参见 <a class="reference external" href="https://pythonce.sourceforge.net/">https://pythonce.sourceforge.net/</a> 的 Python CE 页面。</p>
<p>另一个新的平台是 Darwin/MacOS X；Python 2.0 中提供了初步支持。如果你指定 &quot;configure --with-dyld --with-suffix=.x&quot;，动态加载是可行的。 有关更多说明，请参阅 Python 源代码分发中的 README 文件。</p>
<p>已经尝试解决 Python 的一个问题，即当代码在局部变量赋值之前引用该变量时，会引发经常令人困惑的 <a class="reference internal" href="../library/exceptions.xhtml#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常。例如，以下代码在 1.5.2 和 2.0 中都会在 <code class="docutils literal notranslate"><span class="pre">print</span></code> 语句上引发异常；在 1.5.2 中，会引发 <a class="reference internal" href="../library/exceptions.xhtml#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常，而在 2.0 中，会引发一个新的 <a class="reference internal" href="../library/exceptions.xhtml#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> 异常。 <a class="reference internal" href="../library/exceptions.xhtml#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> 是 <a class="reference internal" href="../library/exceptions.xhtml#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 的子类，因此任何期望引发 <a class="reference internal" href="../library/exceptions.xhtml#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 的现有代码应该仍然可以正常工作。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;i=&quot;</span><span class="p">,</span><span class="n">i</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>新引入了两个异常 <a class="reference internal" href="../library/exceptions.xhtml#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> 和 <a class="reference internal" href="../library/exceptions.xhtml#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndentationError</span></code></a>。 它们均为 <a class="reference internal" href="../library/exceptions.xhtml#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 的子类，并会在发现 Python 代码缩进不正确时被引发。</p>
</section>
<section id="changes-to-built-in-functions">
<h3>对于内置函数的修改</h3>
<p>添加了一个新的内置函数 <code class="docutils literal notranslate"><span class="pre">zip(seq1,</span> <span class="pre">seq2,</span> <span class="pre">...)</span></code>。<a class="reference internal" href="../library/functions.xhtml#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 返回一个包含元组的列表，每个元组包含每个参数序列的第i个元素。<a class="reference internal" href="../library/functions.xhtml#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">map(None,</span> <span class="pre">seq1,</span> <span class="pre">seq2)</span></code> 的区别在于，如果序列长度不一致，<a class="reference internal" href="../library/functions.xhtml#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> 会用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 填充序列，而 <a class="reference internal" href="../library/functions.xhtml#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 会将返回的列表截短到最短的参数序列的长度。</p>
<p><a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> 函数现在在第一个参数是字符串时接受一个可选的“base”参数。<code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">10)</span></code> 返回 123，而 <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">16)</span></code> 返回 291。<code class="docutils literal notranslate"><span class="pre">int(123,</span> <span class="pre">16)</span></code> 会引发一个 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常，消息为 &quot;can't convert non-string with explicit base&quot;。</p>
<p>在 <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 模块中添加了一个新变量，用于保存更详细的版本信息。 <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> 是一个包含五个元素的元组 <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor,</span> <span class="pre">micro,</span> <span class="pre">level,</span> <span class="pre">serial)</span></code>。 例如，在假设的 2.0.1beta1 版本中，<code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> 将是 <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">'beta',</span> <span class="pre">1)</span></code>。 <em>level</em> 是一个字符串，如 <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;beta&quot;</span></code> 或代表最终发布版本的 <code class="docutils literal notranslate"><span class="pre">&quot;final&quot;</span></code>。</p>
<p>字典有一个特别的新方法 <code class="docutils literal notranslate"><span class="pre">setdefault(key,</span> <span class="pre">default)</span></code>，其行为与现有的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> 方法类似。 但是，如果键找不到，<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code> 既会像 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> 一样返回 <em>default</em> 的值，也会将其插入字典作为 <em>key</em> 的值。 因此，下面的代码行:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">dict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>可以简化为单个``return dict.setdefault(key, [])``语句。</p>
<p>解释器设置了一个最大递归深度，以便在填满 C 栈并导致核心储存或 GPF 之前捕获失控递归。以前这个限制是在编译 Python 时固定的，但在 2.0 中最大递归深度可以使用 <a class="reference internal" href="../library/sys.xhtml#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code></a> 和 <a class="reference internal" href="../library/sys.xhtml#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> 读取和修改。 默认值是 1000，可以通过运行一个新脚本 <code class="file docutils literal notranslate"><span class="pre">Misc/find_recursionlimit.py</span></code> 来找到给定平台的大致的最大值。</p>
</section>
</section>
<section id="porting-to-2-0">
<h2>移植 Python 2.0</h2>
<p>新的 Python 版本尽力与之前的版本兼容，而且兼容性记录相当不错。 然而，有些变化被认为足够有用，通常是因为他们修正了最终设计中的错误决定，因此有时无法避免打破向后兼容性。 本节列出了 Python 2.0 中可能导致旧 Python 代码中断的更改。</p>
<p>可能会导致最多代码中断的更改是对某些方法接受的参数进行了严格限制。一些方法会接受多个参数并将它们视为一个元组，特别是各种列表方法，如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>。在早期版本的Python中，如果 <code class="docutils literal notranslate"><span class="pre">L</span></code> 是一个列表，<code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">1,2</span> <span class="pre">)</span></code> 会将元组 <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> 附加到列表中。在Python 2.0中，这会引发一个 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常，消息为：“append requires exactly 1 argument; 2 given”。解决方法是简单地添加一组括号，将两个值作为一个元组传递：<code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">(1,2)</span> <span class="pre">)</span></code>。</p>
<p>这些方法的早期版本更加宽容，因为它们使用了 Python C 接口中的一个旧函数来解析它们的参数；2.0 版本将它们现代化，使用 <a class="reference internal" href="../c-api/arg.xhtml#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>，这是当前的参数解析函数，它提供了更有用的错误消息，并将多参数调用视为错误。如果你必须使用 2.0 但无法修复你的代码，可以编辑 <code class="file docutils literal notranslate"><span class="pre">Objects/listobject.c</span></code> 并定义预处理符号 <code class="docutils literal notranslate"><span class="pre">NO_STRICT_LIST_APPEND</span></code> 以保留旧的行为；但这并不推荐。</p>
<p><a class="reference internal" href="../library/socket.xhtml#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块中的某些函数仍然是宽容的。 例如，<code class="docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">('hostname',</span> <span class="pre">25)</span> <span class="pre">)</span></code> 是正确的形式，传递一个表示 IP 地址的元组，但 <code class="docutils literal notranslate"><span class="pre">socket.connect('hostname',</span> <span class="pre">25)</span></code> 也可以工作。 <a class="reference internal" href="../library/socket.xhtml#socket.socket.connect_ex" title="socket.socket.connect_ex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect_ex</span></code></a> 和 <a class="reference internal" href="../library/socket.xhtml#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.bind</span></code></a> 也是类似的宽松方式。 2.0alpha1 会更严格地检查这些函数，但是由于文档实际上使用了错误的多参数形式，许多人编写的代码在更严格的检查下会出错。 面对公众的反应 GvR 撤销了这些理性，因此对于 <a class="reference internal" href="../library/socket.xhtml#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块，文档已被修正，多参数形式只是被标记为已弃用；在未来的 Python 版本中它 <em>将会</em> 再次变得严格。</p>
<p>字符串字面量中的 <code class="docutils literal notranslate"><span class="pre">\x</span></code> 转义现在必须精确地使用2个十六进制数字。之前它会消耗 x 后面的所有十六进制数字，并取结果的最低8位，所以 <code class="docutils literal notranslate"><span class="pre">\x123456</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">\x56</span></code>。</p>
<p><a class="reference internal" href="../library/exceptions.xhtml#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 和 <a class="reference internal" href="../library/exceptions.xhtml#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常现在有了更友好的错误消息，其文本内容类似于 <code class="docutils literal notranslate"><span class="pre">'Spam'</span> <span class="pre">instance</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'eggs'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">'eggs'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></code>。 之前的错误消息只是缺少的属性名称，如 <code class="docutils literal notranslate"><span class="pre">eggs</span></code>，因此利用这一事实编写的代码在 2.0 中会中断。</p>
<p>在 Python 2.0 中，做了一些工作使得整数和长整数更加可互换。 在 1.5.2 中，为 Solaris 添加了大文件支持，允许读取大于 2 GiB 的文件；这使得文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> 方法返回长整数而不是常规整数。 一些代码会减去两个文件偏移量，并尝试使用结果来乘以一个序列或切片一个字符串，但这会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 在 2.0 中，长整数可以用于乘以或切片一个序列，并且会按直觉行为；例如，<code class="docutils literal notranslate"><span class="pre">3L</span> <span class="pre">*</span> <span class="pre">'abc'</span></code>' 生成 'abcabcabc'，<code class="docutils literal notranslate"><span class="pre">(0,1,2,3)[2L:4L]</span></code> 生成 (2,3)。 长整数也可以在以前只接受整数的各种上下文中使用，例如文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code> 方法，以及 <code class="docutils literal notranslate"><span class="pre">%</span></code> 操作符支持的格式（如 <code class="docutils literal notranslate"><span class="pre">%d</span></code>、<code class="docutils literal notranslate"><span class="pre">%i</span></code>、<code class="docutils literal notranslate"><span class="pre">%x</span></code> 等）。 例如，<code class="docutils literal notranslate"><span class="pre">&quot;%d&quot;</span> <span class="pre">%</span> <span class="pre">2L**64</span></code> 将生成字符串 <code class="docutils literal notranslate"><span class="pre">18446744073709551616</span></code>。</p>
<p>最微妙的长整数变化是，长整数的 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 表示不再有尾随的 'L' 字符，尽管 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 表示仍然包含它。许多人在打印长整数时不希望看到 'L' 字符，因为他们不得不专门去掉这个字符。在2.0中，这不再是一个问题，但那些使用 <code class="docutils literal notranslate"><span class="pre">str(longval)[:-1]</span></code> 并假设存在 'L' 的代码，现在将丢失最后一个数字。</p>
<p>对浮点数执行 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 现在会使用不同的格式化精度，而不是 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>。 <a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 使用 <code class="docutils literal notranslate"><span class="pre">%.17g</span></code> 格式字符串来调用 C 的 <code class="xref py py-func docutils literal notranslate"><span class="pre">sprintf()</span></code>，而 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 仍然使用 <code class="docutils literal notranslate"><span class="pre">%.12g</span></code>。其效果是，对于某些数字，<a class="reference internal" href="../library/functions.xhtml#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 可能比 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 显示更多的小数位。 例如，数字 8.1 无法精确地用二进制表示，所以 <code class="docutils literal notranslate"><span class="pre">repr(8.1)</span></code> 是 <code class="docutils literal notranslate"><span class="pre">'8.0999999999999996'</span></code>，而 str(8.1) 是 <code class="docutils literal notranslate"><span class="pre">'8.1'</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">-X</span></code> 命令行选项已被移除，该选项会将所有标准异常转换为字符串而不是类；现在标准异常将始终是类。包含标准异常的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">exceptions</span></code> 模块已从Python翻译为内置C模块，由Barry Warsaw和Fredrik Lundh编写。</p>
</section>
<section id="extending-embedding-changes">
<h2>扩展/嵌入更改</h2>
<p>有些更改是在底层进行的，仅对编写 C 扩展模块或在更大的应用中嵌入 Python 解释器的人有价值。 如果你不处理 Python 的 C API，可以安全地跳过这一节。</p>
<p>The version number of the Python C API was incremented, so C extensions compiled
for 1.5.2 must be recompiled in order to work with 2.0.  On Windows, it's not
possible for Python 2.0 to import a third party extension built for Python 1.5.x
due to how Windows DLLs work, so Python will raise an exception and the import
will fail.</p>
<p>使用 Jim Fulton 的 ExtensionClass 模块的用户将很高兴地发现，已经添加了钩子以支持 ExtensionClasses，因此现在支持 <a class="reference internal" href="../library/functions.xhtml#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="../library/functions.xhtml#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>。 这意味着你不再需要记住编写类似 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">type(obj)</span> <span class="pre">==</span> <span class="pre">myExtensionClass</span></code> 这样的代码，而可以使用更自然的 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(obj,</span> <span class="pre">myExtensionClass)</span></code>。</p>
<p><code class="file docutils literal notranslate"><span class="pre">Python/importdl.c</span></code> 文件，它充满了用于支持在许多不同平台上动态加载的 #ifdef，已被 Greg Stein 清理和重组。现在 <code class="file docutils literal notranslate"><span class="pre">importdl.c</span></code> 非常小，平台特定的代码已被移入一组特定的 <code class="file docutils literal notranslate"><span class="pre">Python/dynload_*.c</span></code> 文件中。 另一个清理工作是：Include/ 目录中有许多包含各种可移植性修改的 <code class="file docutils literal notranslate"><span class="pre">my*.h</span></code> 文件；它们已被合并到一个文件中，即 <code class="file docutils literal notranslate"><span class="pre">Include/pyport.h</span></code>。</p>
<p>Vladimir Marangozov 期待已久的 malloc 重组已经完成，使得Python解释器可以轻松使用自定义分配器，而不是C的标准 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>。 有关文档，请阅读 <code class="file docutils literal notranslate"><span class="pre">Include/pymem.h</span></code> 和 <code class="file docutils literal notranslate"><span class="pre">Include/objimpl.h</span></code> 中的注释。 有关界面敲定期间的详细讨论，请参阅 python.org 上的 'patches' 和 'python-dev' 列表的网络存档。</p>
<p>最新版本的 MacOS GUSI 开发环境支持 POSIX 线程。 因此，现在 Python 的 POSIX 线程支持在 Macintosh 上也可以使用。 还贡献了使用用户空间 GNU <code class="docutils literal notranslate"><span class="pre">pth</span></code> 库的线程支持。</p>
<p>Windows 上的线程支持也得到了增强。 Windows 支持的线程锁在发生争用时才使用内核对象；在常见的没有争用的情况下，他们使用简单得多的函数，这些函数快一个数量级。Python 1.5.2 在 NT 上的线程版本比无线程版本慢两倍；有了 2.0 的改进，差异仅为 10%。 这些改进由 Yakov Markovitch 提供。</p>
<p>Python 2.0 的源代码目前只用 ANSI C 原型，所以现在编译 Python 需要一个 ANSI C 的编译器，而不能通过仅使用支持 K&amp;R C 的编译器完成。</p>
<p>之前，Python 虚拟机在其字节码中使用 16 位数字，限制了源文件的大小。 特别是，这影响了 Python 源代码中字面量列表和字典的最大大小；偶尔会有人在生成 Python 代码时遇到这个限制。 Charles G. Waldman 的补丁将这个限制从 <code class="docutils literal notranslate"><span class="pre">2**16</span></code> 提高到 <code class="docutils literal notranslate"><span class="pre">2**32</span></code>。</p>
<p>添加了三个新的便捷函数，旨在模块初始化时将常量添加到模块的字典中: <a class="reference internal" href="../c-api/module.xhtml#c.PyModule_AddObject" title="PyModule_AddObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddObject()</span></code></a>、<a class="reference internal" href="../c-api/module.xhtml#c.PyModule_AddIntConstant" title="PyModule_AddIntConstant"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddIntConstant()</span></code></a> 和 <a class="reference internal" href="../c-api/module.xhtml#c.PyModule_AddStringConstant" title="PyModule_AddStringConstant"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddStringConstant()</span></code></a>。 每个函数都接收一个模块对象、一个以空字符结尾的包含要添加的名称的C字符串，以及一个第三个参数用于指定要赋值的值。 第三个参数分别是一个 Python 对象、一个 C 长整型或一个 C 字符串。</p>
<p>为 Unix 风格的信号处理程序添加了一个包装API。 <a class="reference internal" href="../c-api/sys.xhtml#c.PyOS_getsig" title="PyOS_getsig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_getsig()</span></code></a> 获取信号处理程序，<a class="reference internal" href="../c-api/sys.xhtml#c.PyOS_setsig" title="PyOS_setsig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_setsig()</span></code></a> 设置新的处理程序。</p>
</section>
<section id="distutils-making-modules-easy-to-install">
<h2>Distutils：使模块易于安装</h2>
<p>在 Python 2.0 之前，安装模块是一件繁琐的事情 —— 没有办法自动确定 Python 的安装位置，或者用于扩展模块的编译器选项。 软件作者不得不经历一套繁琐的程序来编辑 Makefile 和配置文件，这些只在 Unix 上真正有效，而 Windows 和 Mac OS 不受支持。 Python 用户面对不同扩展包之间大相径庭的安装说明，这使得管理 Python 成了一件麻烦事。</p>
<p>由 Greg Ward 领导的 SIG 创建了 <code class="docutils literal notranslate"><span class="pre">distutils</span></code>，一个使包安装更加容易的系统。它们构成了 distutils 包，这是 Python 标准库的新部分。 在最佳情况下，从源代码安装 Python 模块只需要以下几个步骤：首先解压缩 tarball 或 zip 归档文件，然后运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code>。 平台会自动检测，编译器会被识别，C 扩展模块会被编译，并且分发包会安装到适当的目录中。 可选的命令行参数提供了对安装过程的更多控制，distutils 包提供了许多地方来覆盖默认设置 —— 将构建与安装分开，在非默认目录中构建或安装，等等。</p>
<p>为了使用 Distutils，你需要编写一个 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本。 在简单场景下，当软件仅包含 .py 文件时，最小化的 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 可以只有几行代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">py_modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;module1&quot;</span><span class="p">,</span> <span class="s2">&quot;module2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>如果软件是由几个包组成的 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 文件也不会太过复杂:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">packages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;package&quot;</span><span class="p">,</span> <span class="s2">&quot;package.subpackage&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>最复杂的情况可能是 C 扩展；下面是一个来自 PyXML 包的示例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">expat_extension</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;xml.parsers.pyexpat&#39;</span><span class="p">,</span>
     <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;XML_NS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span>
     <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/expat/xmltok&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extensions/expat/xmlparse&#39;</span> <span class="p">],</span>
     <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/pyexpat.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmltok.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmlrole.c&#39;</span><span class="p">,</span> <span class="p">]</span>
       <span class="p">)</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;PyXML&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.5.4&quot;</span><span class="p">,</span>
       <span class="n">ext_modules</span> <span class="o">=</span><span class="p">[</span> <span class="n">expat_extension</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Distutils 还可以负责创建源代码和二进制分发包。运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">sdist</span></code> 的 &quot;sdist&quot; 命令构建一个源代码分发包，如 <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code>。添加新命令并不困难，已经有 &quot;bdist_rpm&quot; 和 &quot;bdist_wininst&quot; 命令，分别用于创建软件的 RPM 分发包和 Windows 安装程序。创建其他分发格式的命令，如 Debian 包和 Solaris <code class="file docutils literal notranslate"><span class="pre">.pkg</span></code> 文件，也在开发的不同阶段。</p>
<p>所有这些都记录在一个新手册中，<em>Distributing Python Modules</em>，它加入了Python文档的基本集合中。</p>
</section>
<section id="xml-modules">
<h2>XML 模块</h2>
<p>Python 1.5.2 包含了一个简单的 XML 解析器，以 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code> 模块的形式提供，由 Sjoerd Mullender 贡献。自1.5.2发布以来，处理 XML 的两种不同接口已经变得常见：SAX2（Simple API for XML 的第2版）提供了一个事件驱动的接口，与 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code> 有一些相似之处；而 DOM（Document Object Model）提供了一个基于树的接口，将 XML 文档转换为一个可遍历和修改的节点树。Python 2.0 包含了 SAX2 接口和简化的 DOM 接口，作为 <a class="reference internal" href="../library/xml.xhtml#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> 包的一部分。下面是这些新接口的简要概述；完整的详细信息请参阅 Python 文档或源代码。Python XML SIG 也在致力于改进文档。</p>
<section id="sax2-support">
<h3>SAX2 支持</h3>
<p>SAX 定义了一个事件驱动的接口来解析 XML。要使用 SAX，你必须编写一个 SAX 处理器类。处理器类继承自 SAX 提供的各种类，并覆盖各种方法，这些方法会在 XML 解析器遇到相应事件时被调用。例如，<a class="reference internal" href="../library/xml.sax.handler.xhtml#xml.sax.handler.ContentHandler.startElement" title="xml.sax.handler.ContentHandler.startElement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startElement()</span></code></a> 和 <a class="reference internal" href="../library/xml.sax.handler.xhtml#xml.sax.handler.ContentHandler.endElement" title="xml.sax.handler.ContentHandler.endElement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endElement()</span></code></a> 方法会在解析器遇到每个开始和结束标签时被调用，<a class="reference internal" href="../library/xml.sax.handler.xhtml#xml.sax.handler.ContentHandler.characters" title="xml.sax.handler.ContentHandler.characters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">characters()</span></code></a> 方法会在解析器遇到每个字符数据块时被调用，等等。</p>
<p>事件驱动方法的优点是整个文档不必同时驻留在内存中，这在处理非常大的文档时尤其重要。然而，如果你试图以某种复杂的方式修改文档结构，编写 SAX 处理程序类可能会变得非常复杂。</p>
<p>例如，这个小示例程序定义了一个处理器，它为每个开始和结束标签打印一条消息，然后使用它来解析文件 <code class="file docutils literal notranslate"><span class="pre">hamlet.xml</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml</span> <span class="kn">import</span> <span class="n">sax</span>

<span class="k">class</span> <span class="nc">SimpleHandler</span><span class="p">(</span><span class="n">sax</span><span class="o">.</span><span class="n">ContentHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">startElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Start of element:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">endElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;End of element:&#39;</span><span class="p">,</span> <span class="n">name</span>

<span class="c1"># Create a parser object</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">sax</span><span class="o">.</span><span class="n">make_parser</span><span class="p">()</span>

<span class="c1"># Tell it what handler to use</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">SimpleHandler</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">setContentHandler</span><span class="p">(</span> <span class="n">handler</span> <span class="p">)</span>

<span class="c1"># Parse a file!</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="s1">&#39;hamlet.xml&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<p>欲了解更多信息，请查阅 Python 文档，或 <a class="reference external" href="https://pyxml.sourceforge.net/topics/howto/xml-howto.html">https://pyxml.sourceforge.net/topics/howto/xml-howto.html</a> 上的 XML HOWTO。</p>
</section>
<section id="dom-support">
<h3>DOM 支持</h3>
<p>文档对象模型是一种基于树的表示法，用于表示 XML 文档。一个顶级 <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> 实例是树的根节点，并且有一个子节点，它是顶级 <code class="xref py py-class docutils literal notranslate"><span class="pre">Element`实例。这个</span> <span class="pre">:class:</span></code>!Element` 具有表示字符数据和任何子元素的子节点，这些子节点可以有进一步的子节点，依此类推。使用 DOM，你可以以任何方式遍历生成的树，访问元素和属性值，插入和删除节点，并将树转换回 XML。</p>
<p>DOM 在修改 XML 文档方面非常有用，因为你可以创建一个 DOM 树，通过添加新节点或重新排列子树来修改它，然后生成一个新的 XML 文档作为输出。你还可以手动构建一个 DOM 树并将其转换为 XML，这比简单地将``&lt;tag1&gt;``...``&lt;/tag1&gt;``写入文件更灵活。</p>
<p>Python 附带的 DOM 实现在 <a class="reference internal" href="../library/xml.dom.minidom.xhtml#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a> 模块中。它是一个轻量级的 Level 1 DOM 实现，支持 XML 命名空间。提供了 <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">parseString()</span></code> 便捷函数用于生成 DOM 树:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;hamlet.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">doc</span></code> 是一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> 实例。<code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>，和其他所有 DOM 类如:class:<cite>!Element</cite> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Text`一样，都是:class:</span></code>!Node` 基类的子类。因此，DOM 树中的所有节点都支持某些通用方法，例如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code> 方法，该方法返回一个包含节点及其子节点的 XML 表示的字符串。每个类也有自己的特定方法；例如，<code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> 实例有一个方法可以找到具有给定标签名的所有子元素。继续前面 2 行代码的例子：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">perslist</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span> <span class="s1">&#39;PERSONA&#39;</span> <span class="p">)</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
</pre></div>
</div>
<p>对于 <em>Hamlet</em> XML 文件，上面几行代码输出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">CLAUDIUS</span><span class="p">,</span> <span class="n">king</span> <span class="n">of</span> <span class="n">Denmark</span><span class="o">.</span> <span class="o">&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">HAMLET</span><span class="p">,</span> <span class="n">son</span> <span class="n">to</span> <span class="n">the</span> <span class="n">late</span><span class="p">,</span> <span class="ow">and</span> <span class="n">nephew</span> <span class="n">to</span> <span class="n">the</span> <span class="n">present</span> <span class="n">king</span><span class="o">.&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>文件的根元素可以通过 <code class="docutils literal notranslate"><span class="pre">doc.documentElement</span></code> 访问，并且可以通过删除、添加或一处节点来听松修改节点来轻松修改其子元素:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">documentElement</span>

<span class="c1"># Remove the first child</span>
<span class="n">root</span><span class="o">.</span><span class="n">removeChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Move the new first child to the end</span>
<span class="n">root</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Insert the new first child (originally,</span>
<span class="c1"># the third child) before the 20th child.</span>
<span class="n">root</span><span class="o">.</span><span class="n">insertBefore</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>再次，我建议你查阅 Python 文档，以获取不同 <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> 类及各种方法的完整列表。</p>
</section>
<section id="relationship-to-pyxml">
<h3>与 PyXML 的关系</h3>
<p>XML 特别兴趣小组已经致力于与 XML 相关的 Python 代码有一段时间了。 其代码分发包称为 PyXML，可以从 SIG 的网页 <a class="reference external" href="https://www.python.org/community/sigs/current/xml-sig">https://www.python.org/community/sigs/current/xml-sig</a> 获取。 PyXML 分发包也使用了 <code class="docutils literal notranslate"><span class="pre">xml</span></code> 作为包名。 如果你编写了使用 PyXML 的程序，可能会担心它与 Python 2.0 的 <a class="reference internal" href="../library/xml.xhtml#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> 包的兼容性。</p>
<p>答案是 Python 2.0 的 <a class="reference internal" href="../library/xml.xhtml#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> 包与 PyXML 不兼容，但可以通过安装最新版本的 PyXML 来使其兼容。 许多应用程序可以依赖 Python 2.0 中包含的 XML 支持，但更复杂的应用程序需要安装完整的 PyXML 包。 安装后，版本为 0.6.0 或更高的 PyXML 将替换随 Python 一起发布的 <a class="reference internal" href="../library/xml.xhtml#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> 包，并且将是标准包的严格超集，添加许多额外的功能。 PyXML 中的一些附加功能包括：</p>
<ul class="simple">
<li><p>4DOM，一个来自 FourThought, Inc. 的完整 DOM 实现。</p></li>
<li><p>xmlproc 验证解析器，由 Lars Marius Garshol 编写。</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">sgmlop</span></code> 解析器加速模块，由 Fredrik Lundh 编写。</p></li>
</ul>
</section>
</section>
<section id="module-changes">
<h2>模块更改</h2>
<p>Python 庞大的标准库进行了许多改进和错误修复；一些受影响的模块包括 <a class="reference internal" href="../library/readline.xhtml#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>、<a class="reference internal" href="../library/configparser.xhtml#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>、<a class="reference internal" href="../library/cgi.xhtml#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code></a>、<a class="reference internal" href="../library/calendar.xhtml#module-calendar" title="calendar: Functions for working with calendars, including some emulation of the Unix cal program."><code class="xref py py-mod docutils literal notranslate"><span class="pre">calendar</span></code></a>、<a class="reference internal" href="../library/posix.xhtml#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a>、<a class="reference internal" href="../library/readline.xhtml#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>、<a class="reference internal" href="../library/aifc.xhtml#module-aifc" title="aifc: Read and write audio files in AIFF or AIFC format.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code></a>、<a class="reference internal" href="../library/chunk.xhtml#module-chunk" title="chunk: Module to read IFF chunks.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">chunk</span></code></a>、<a class="reference internal" href="../library/wave.xhtml#module-wave" title="wave: Provide an interface to the WAV sound format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">wave</span></code></a>、<a class="reference internal" href="../library/random.xhtml#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>、<a class="reference internal" href="../library/shelve.xhtml#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> 和 <a class="reference internal" href="../library/nntplib.xhtml#module-nntplib" title="nntplib: NNTP protocol client (requires sockets).（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code></a>。 具体的逐个补丁详细信息，请参阅 CVS 日志。</p>
<p>Brian Gallew 贡献了 <a class="reference internal" href="../library/socket.xhtml#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块的 OpenSSL 支持。OpenSSL 是一个安全套接字层实现，用于加密通过套接字发送的数据。在编译 Python 时，你可以编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件以包含 SSL 支持，这会为 <a class="reference internal" href="../library/socket.xhtml#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块添加一个额外的函数：<code class="docutils literal notranslate"><span class="pre">socket.ssl(socket,</span> <span class="pre">keyfile,</span> <span class="pre">certfile)</span></code>，它接收一个套接字对象并返回一个 SSL 套接字。<a class="reference internal" href="../library/http.xhtml#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> 和 <a class="reference internal" href="../library/urllib.xhtml#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 模块也进行了更改，以支持``https://`` 的URL，但目前还没有人实现通过 SSL 的 FTP 或 SMTP。</p>
<p><a class="reference internal" href="../library/http.xhtml#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> 模块已由 Greg Stein 重写以支持 HTTP/1.1。</p>
<p>对 1.5 版本的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> 提供了向下兼容性，尽管使用 HTTP/1.1 特性如流水线将需要重写代码以使用不同的一组接口。</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 模块现在支持 Tcl/Tk 版本 8.1、8.2 或 8.3，并且不再支持旧的 7.x 版本。Tkinter 模块现在支持在 Tk 小部件中显示 Unicode 字符串。此外，Fredrik Lundh 贡献了一项优化，使得诸如 <code class="docutils literal notranslate"><span class="pre">create_line</span></code> 和 <code class="docutils literal notranslate"><span class="pre">create_polygon</span></code> 等操作速度更快，尤其是在使用大量坐标时。</p>
<p><a class="reference internal" href="../library/curses.xhtml#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> 模块在 Oliver Andrich 增强版本的基础上得到了极大的扩展，提供了许多来自 ncurses 和 SYSV curses 的附加功能，如颜色、替代字符集支持、手写板和鼠标支持等。 这意味着该模块不再兼容仅有 BSD curses 的操作系统，但目前似乎没有任何属于这一类别的操作系统正在维护中。</p>
<p>如前面讨论的 Python 2.0 对 Unicode 的支持所提到的，<a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块提供的正则表达式的底层实现已经更改。 SRE，一个新的正则表达式引擎，由 Ferdrik Lundh 编写，部分由惠普资助，支持匹配 8 位字符串和 Unicode 字符串。</p>
</section>
<section id="new-modules">
<h2>新增模块</h2>
<p>添加了许多新模块，我们将简单列出它们并附上简要概述；有关特定模块的详细信息，请查阅 2.0 文档。</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/atexit.xhtml#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 模块用于注册在 Python 解释器退出之前调用的函数。当前直接设置 <code class="docutils literal notranslate"><span class="pre">sys.exitfunc</span></code> 的代码应改为使用 <a class="reference internal" href="../library/atexit.xhtml#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 模块，导入 <a class="reference internal" href="../library/atexit.xhtml#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 并使用 <a class="reference internal" href="../library/atexit.xhtml#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">atexit.register()</span></code></a> 调用要在退出时调用的函数。 （由 Skip Montanaro 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/codecs.xhtml#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code>, <a class="reference internal" href="../library/unicodedata.xhtml#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>: 作为新的Unicode支持的一部分添加。</p></li>
<li><p><a class="reference internal" href="../library/filecmp.xhtml#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a> 模块取代了旧的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>, 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code> 模块，这些模块现在已经被废弃。（由 Gordon MacMillan 和 Moshe Zadka 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/gettext.xhtml#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a>: 这个模块通过提供 GNU gettext 消息目录库的接口，为 Python 程序提供国际化（I18N）和本地化（L10N）支持。 （由 Barry Warsaw 整合，来自 Martin von Löwis, Peter Funk 和 James Henstridge 的独立贡献。）</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code>: 支持 Linux 上的 <code class="file docutils literal notranslate"><span class="pre">/dev/audio</span></code> 设备，与现有的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sunaudiodev</span></code> 模块相对应。（由 Peter Bosch 贡献，Jeremy Hylton 提供修复。）</p></li>
<li><p><a class="reference internal" href="../library/mmap.xhtml#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmap</span></code></a>: 提供对内存映射文件的接口，支持 Windows 和 Unix。文件的内容可以直接映射到内存中，此时它表现得像一个可变字符串，因此可以读取和修改其内容。它们甚至可以传递给期望普通字符串的函数，例如 <a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块。（由 Sam Rushing 贡献，并由 A.M. Kuchling 提供一些扩展。）</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code>: Expat XML解析器的接口。 （由 Paul Prescod 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/urllib.robotparser.xhtml#module-urllib.robotparser" title="urllib.robotparser: Load a robots.txt file and answer questions about fetchability of other URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparser</span></code></a>: 解析 <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code> 文件，这个文件用于编写礼貌地避开网站某些区域的网络爬虫。 解析器接受 <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code> 文件的内容，从中构建一组规则，然后可以回答有关给定 URL 是否可以被抓取的问题。 （由 Skip Montanaro 贡献。）</p></li>
<li><p><a class="reference internal" href="../library/tabnanny.xhtml#module-tabnanny" title="tabnanny: Tool for detecting white space related problems in Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tabnanny</span></code></a>: 一个模块/脚本，用于检查 Python 源代码中不歧义的缩进。 （由 Tim Peters 贡献。）</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserString</span></code>: 一个基类，用于派生行为类似于字符串的对象。</p></li>
<li><p><a class="reference internal" href="../library/webbrowser.xhtml#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a> 模块提供了一种平台独立的方式来在特定 URL 上启动 web 浏览器。对于每个平台，模块会按特定顺序尝试各种浏览器。用户可以通过设置 <em>BROWSER</em> 环境变量来更改启动的浏览器。（最初的灵感来自 Eric S. Raymond 对 <a class="reference internal" href="../library/urllib.xhtml#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 的补丁，该补丁增加了类似的功能，但最终的模块来自 Fred Drake 最初实现的代码 <code class="file docutils literal notranslate"><span class="pre">Tools/idle/BrowserControl.py</span></code>，并由 Fred 适配到标准库中。）</p></li>
<li><p><a class="reference internal" href="../library/winreg.xhtml#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code></a> 模块：提供了一个用于访问 Windows 注册表的接口。<code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> 是对自 1995 年以来一直是 PythonWin 一部分的函数的改编，现在已被添加到核心分发版中，并增强了对 Unicode 的支持。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> 由 Bill Tutt 和 Mark Hammond 编写。</p></li>
<li><p><a class="reference internal" href="../library/zipfile.xhtml#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 模块：用于读取和写入 ZIP 格式的归档文件。 这些归档文件是由 DOS/Windows 上的 <strong class="program">PKZIP</strong> 或 Unix 上的 <strong class="program">zip</strong> 生成的，不要与 <strong class="program">gzip</strong> 格式文件（由 <a class="reference internal" href="../library/gzip.xhtml#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> 支持）混淆。 （由 James C. Ahlstrom 贡献。）</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil`模块：提供了一种比现有的</span> <span class="pre">:mod:</span></code>!ihooks` 模块更简单的方式来编写自定义导入钩子。（由 Greg Stein 实现，并在实现过程中在 python-dev 进行了大量讨论。）</p></li>
</ul>
</section>
<section id="idle-improvements">
<h2>IDLE 改进</h2>
<p>IDLE 是官方的 Python 跨平台 IDE，使用 Tkinter 编写。 Python 2.0 包括了 IDLE 0.6，它增加了许多新特性和改进。 部分新内容列表：</p>
<ul class="simple">
<li><p>界面改进和优化，特别是在语法高亮和自动缩进方面。</p></li>
<li><p>类浏览器现在将显示更多信息，例如一个模块中最高层级的函数。</p></li>
<li><p>制表符宽度现在是一个用户可设置的选项。在打开现有的 Python 文件时，IDLE 会自动检测缩进约定并进行适应。</p></li>
<li><p>现在支持在各种平台上调用浏览器，用于在浏览器中打开 Python 文档。</p></li>
<li><p>IDLE 现在有一个命令行，它与原版 Python 解释器大致相同。</p></li>
<li><p>在许多地方添加了调用提示。</p></li>
<li><p>IDLE 现在可以作为一个包被安装。</p></li>
<li><p>在编辑器窗口中，目前在底部位置增加了一个行/列显示栏。</p></li>
<li><p>三个新的键盘快捷键：检查模块 (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd></kbd>)，导入模块 (<kbd class="kbd docutils literal notranslate">F5</kbd>) 和执行脚本 (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd></kbd>)。</p></li>
</ul>
</section>
<section id="deleted-and-deprecated-modules">
<h2>删除和弃用的模块</h2>
<p>有几个模块因为已经过时，或者因为现在有更好的方法来实现相同的功能而被删除。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">stdwin</span></code> 模块已被移除；它是一个不再开发的跨平台窗口工具包。</p>
<p>许多模块已经移动到了 <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> 子目录: <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">dump</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">find</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">grep</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">packmail</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">poly</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">util</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">whatsound</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">zmod</span></code>。 如果你的代码依赖于已移动到 <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> 的模块，你可以简单地将该目录添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中来找回它们，但建议你更新任何使用这些模块的代码。</p>
</section>
<section id="acknowledgements">
<h2>致谢</h2>
<p>作者感谢以下人士对本文的各种草稿提出建议： David Bolen, Mark Hammond, Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil Schemenauer, and Russ Schmidt.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>