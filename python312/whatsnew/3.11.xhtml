<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 3.11 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/3.11.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="编者, Pablo Galindo Salgado,. 这篇文章介绍了 Python 3.11 相比 3.10 增加的新特性。 Python 3.11 发布于 2022 年 10 月 24 日。 要了解更详细的信息，可参阅 更新日志 。 摘要 -- 发布重点: Python 3.11 的速度比 Python 3.10 快 10-60%。在平均状况下，在标准基准测试（standard benc..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="编者, Pablo Galindo Salgado,. 这篇文章介绍了 Python 3.11 相比 3.10 增加的新特性。 Python 3.11 发布于 2022 年 10 月 24 日。 要了解更详细的信息，可参阅 更新日志 。 摘要 -- 发布重点: Python 3.11 的速度比 Python 3.10 快 10-60%。在平均状况下，在标准基准测试（standard benc..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 3.11 有什么新变化</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/3.11.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-3-11">
<h1>Python 3.11 有什么新变化</h1>
<dl class="field-list simple">
<dt class="field-odd">编者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pablo Galindo Salgado</p>
</dd>
</dl>
<p>这篇文章介绍了 Python 3.11 相比 3.10 增加的新特性。 Python 3.11 发布于 2022 年 10 月 24 日。 要了解更详细的信息，可参阅 <a class="reference internal" href="changelog.xhtml#changelog"><span class="std std-ref">更新日志</span></a>。</p>
<section id="summary-release-highlights">
<span id="whatsnew311-summary"></span><h2>摘要 -- 发布重点</h2>
<ul class="simple">
<li><p>Python 3.11 的速度比 Python 3.10 快 10-60%。在平均状况下，在标准基准测试（standard benchmark suite）中可见1.25倍的加速效果。更多细节请参见 <a class="reference internal" href="#whatsnew311-faster-cpython"><span class="std std-ref">更快的 CPython</span></a> 一节。</p></li>
</ul>
<p>新的语法特性：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#whatsnew311-pep654"><span class="std std-ref">PEP 654：异常组与 except*</span></a></p></li>
</ul>
<p>新的内置特性：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#whatsnew311-pep678"><span class="std std-ref">PEP 678：可用注释丰富异常</span></a></p></li>
</ul>
<p>新的标准库模块：</p>
<ul class="simple">
<li><p><span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0680/"><strong>PEP 680</strong></a><span class="link-target"> [https://peps.python.org/pep-0680/]</span>: <a class="reference internal" href="../library/tomllib.xhtml#module-tomllib" title="tomllib: Parse TOML files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tomllib</span></code></a> — 标准库中对解析 <a class="reference external" href="https://toml.io/">TOML</a><span class="link-target"> [https://toml.io/]</span> 的支持</p></li>
</ul>
<p>解释器的改进:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#whatsnew311-pep657"><span class="std std-ref">PEP 657：回溯信息中标注更详细的错误位置</span></a></p></li>
<li><p>新增 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-P"><code class="xref std std-option docutils literal notranslate"><span class="pre">-P</span></code></a> 命令行选项以及 <span class="target" id="index-85"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONSAFEPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONSAFEPATH</span></code></a> 环境变量来 <a class="reference internal" href="#whatsnew311-pythonsafepath"><span class="std std-ref">禁止自动将潜在的不安全路径前置</span></a> 到 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a></p></li>
</ul>
<p>新的类型标注特性：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#whatsnew311-pep646"><span class="std std-ref">PEP 646：可变参数泛型</span></a></p></li>
<li><p><a class="reference internal" href="#whatsnew311-pep655"><span class="std std-ref">PEP 655：将单个 TypedDict 项标记为必填或非必填项</span></a></p></li>
<li><p><a class="reference internal" href="#whatsnew311-pep673"><span class="std std-ref">PEP 673：Self 类型</span></a></p></li>
<li><p><a class="reference internal" href="#whatsnew311-pep675"><span class="std std-ref">PEP 675：任意字面值字符串类型</span></a></p></li>
<li><p><a class="reference internal" href="#whatsnew311-pep681"><span class="std std-ref">PEP 681：数据类变换</span></a></p></li>
</ul>
<p>重要的弃用、移除或限制：</p>
<ul class="simple">
<li><p><span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0594/"><strong>PEP 594</strong></a><span class="link-target"> [https://peps.python.org/pep-0594/]</span>: <a class="reference internal" href="#whatsnew311-pep594"><span class="std std-ref">许多旧标准库模块已被弃用</span></a>，并将在 Python 3.13 中移除</p></li>
<li><p><span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0624/"><strong>PEP 624</strong></a><span class="link-target"> [https://peps.python.org/pep-0624/]</span>: <a class="reference internal" href="#whatsnew311-pep624"><span class="std std-ref">Py_UNICODE 编码器 API 已被移除</span></a></p></li>
<li><p><span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0670/"><strong>PEP 670</strong></a><span class="link-target"> [https://peps.python.org/pep-0670/]</span>: <a class="reference internal" href="#whatsnew311-pep670"><span class="std std-ref">转换为静态内联函数的宏</span></a></p></li>
</ul>
</section>
<section id="new-features">
<span id="whatsnew311-features"></span><h2>新的特性</h2>
<section id="pep-657-fine-grained-error-locations-in-tracebacks">
<span id="whatsnew311-pep657"></span><h3>PEP 657：回溯信息中标注更详细的错误位置</h3>
<p>在打印回溯信息（traceback）时，解释器现在不仅会指出错误所在行，还会进一步指出引发错误的表达式在哪里。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;distance.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">11</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">manhattan_distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
          <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
  <span class="n">File</span> <span class="s2">&quot;distance.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">manhattan_distance</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">point_1</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">point_2</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">point_1</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point_2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                           <span class="o">^^^^^^^^^</span>
<span class="ne">AttributeError</span><span class="p">:</span> <span class="s1">&#39;NoneType&#39;</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;x&#39;</span>
</pre></div>
</div>
<p>先前版本的解释器只会指出该行存在错误，我们不清楚哪个对象是这里的 <code class="docutils literal notranslate"><span class="pre">None</span></code>。在深度嵌套的 <a class="reference internal" href="../library/stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 对象以及连用多个函数调用的场景下，这些增强的错误也会大有裨益：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;query.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">37</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">magic_arithmetic</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;query.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">18</span><span class="p">,</span> <span class="ow">in</span> <span class="n">magic_arithmetic</span>
    <span class="k">return</span> <span class="n">add_counts</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span>
           <span class="o">^^^^^^^^^^^^^</span>
  <span class="n">File</span> <span class="s2">&quot;query.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">24</span><span class="p">,</span> <span class="ow">in</span> <span class="n">add_counts</span>
    <span class="k">return</span> <span class="mi">25</span> <span class="o">+</span> <span class="n">query_user</span><span class="p">(</span><span class="n">user1</span><span class="p">)</span> <span class="o">+</span> <span class="n">query_user</span><span class="p">(</span><span class="n">user2</span><span class="p">)</span>
                <span class="o">^^^^^^^^^^^^^^^^^</span>
  <span class="n">File</span> <span class="s2">&quot;query.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">query_user</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">query_count</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">response</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">][</span><span class="s1">&#39;user&#39;</span><span class="p">],</span> <span class="n">retry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                               <span class="o">~~~~~~~~~~~~~~~~~~^^^^^</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="s1">&#39;NoneType&#39;</span> <span class="nb">object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">subscriptable</span>
</pre></div>
</div>
<p>在复杂的算数表达式中同样有用：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;calculation.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">54</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span>
              <span class="o">~~~~~~^~~</span>
<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">division</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p>此外，增强的回溯信息功能使用的信息通过通用 API 提供，该 API 可用于将 <a class="reference internal" href="../glossary.xhtml#term-bytecode"><span class="xref std std-term">bytecode</span></a> <a class="reference internal" href="../library/dis.xhtml#bytecodes"><span class="std std-ref">指令</span></a> 与源代码位置相关联。 可以使用以下方式获取此信息：</p>
<ul class="simple">
<li><p>Python 中的 <a class="reference internal" href="../reference/datamodel.xhtml#codeobject.co_positions" title="codeobject.co_positions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">codeobject.co_positions()</span></code></a> 方法。</p></li>
<li><p>C API 中的 <a class="reference internal" href="../c-api/code.xhtml#c.PyCode_Addr2Location" title="PyCode_Addr2Location"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_Addr2Location()</span></code></a> 函数。</p></li>
</ul>
<p>更多细节请参见 <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0657/"><strong>PEP 657</strong></a><span class="link-target"> [https://peps.python.org/pep-0657/]</span>。（由Pablo Galindo、Batuhan Taskaya 和 Ammar Askar 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43950">bpo-43950</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43950]</span> 中贡献）</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>该特性需要在 <a class="reference internal" href="../c-api/code.xhtml#codeobjects"><span class="std std-ref">代码对象</span></a> 中存储列位置，这可能会导致解释器内存占用和经过编译的 Python 文件的文件大小略有增加。 要避免存储额外的信息同时取消打印额外的回溯信息，请使用 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span> <span class="pre">no_debug_ranges</span></code></a> 命令行选项或 <span class="target" id="index-90"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONNODEBUGRANGES"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNODEBUGRANGES</span></code></a> 环境变量。</p>
</div>
</section>
<section id="pep-654-exception-groups-and-except">
<span id="whatsnew311-pep654"></span><h3>PEP 654：异常组与 <code class="docutils literal notranslate"><span class="pre">except*</span></code></h3>
<p><span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0654/"><strong>PEP 654</strong></a><span class="link-target"> [https://peps.python.org/pep-0654/]</span> 引入了若干语言特性，从而让程序能够同时引发和处理多个不相关的异常。内置类型 <a class="reference internal" href="../library/exceptions.xhtml#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 和 <a class="reference internal" href="../library/exceptions.xhtml#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> 使得将异常划分成组并一起引发成为可能，新添加的 <a class="reference internal" href="../reference/compound_stmts.xhtml#except-star"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except*</span></code></a> 是对 <a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 的泛化语法，这一语法能够匹配异常组的子组。</p>
<p>更多细节请参见 <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0654/"><strong>PEP 654</strong></a><span class="link-target"> [https://peps.python.org/pep-0654/]</span>。</p>
<p>（由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45292">bpo-45292</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45292]</span> 中贡献，PEP 由 Irit Katriel、Yury Selivanov 和 Guido van Rossum 编写）</p>
</section>
<section id="pep-678-exceptions-can-be-enriched-with-notes">
<span id="whatsnew311-pep678"></span><h3>PEP 678：可用注释丰富异常</h3>
<p><a class="reference internal" href="../library/exceptions.xhtml#BaseException.add_note" title="BaseException.add_note"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_note()</span></code></a> 方法已被添加到 <a class="reference internal" href="../library/exceptions.xhtml#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 中。如果存在引发异常时不可用的上下文信息，使用该方法可以手动附加这些信息来丰富异常。添加的备注会显示在默认的回溯信息中。</p>
<p>更多细节请参见 <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0678/"><strong>PEP 678</strong></a><span class="link-target"> [https://peps.python.org/pep-0678/]</span>。</p>
<p>（由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45607">bpo-45607</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45607]</span> 中贡献，PEP 由 Zac Hatfield-Dodds 编写）</p>
</section>
<section id="windows-py-exe-launcher-improvements">
<span id="whatsnew311-windows-launcher"></span><h3>Windows 下的 <code class="docutils literal notranslate"><span class="pre">py.exe</span></code> 启动器改进</h3>
<p>包括在 Python 3.11 中的 <a class="reference internal" href="../using/windows.xhtml#launcher"><span class="std std-ref">适用于Windows的Python启动器</span></a> 的副本已进行了重大更新。 现在它支持 <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0514/"><strong>PEP 514</strong></a><span class="link-target"> [https://peps.python.org/pep-0514/]</span> 所定义的 company/tag 语法即使用 <code class="samp docutils literal notranslate"><span class="pre">-V:</span><em><span class="pre">&lt;company&gt;</span></em><span class="pre">/</span><em><span class="pre">&lt;tag&gt;</span></em></code> 参数代替受限的 <code class="samp docutils literal notranslate"><span class="pre">-</span><em><span class="pre">&lt;major&gt;</span></em><span class="pre">.</span><em><span class="pre">&lt;minor&gt;</span></em></code>。 这允许启动托管在 <a class="reference external" href="https://www.python.org">python.org</a><span class="link-target"> [https://www.python.org]</span> 上的 <code class="docutils literal notranslate"><span class="pre">PythonCore</span></code> 以外的其他发行版。</p>
<p>当使用 <code class="docutils literal notranslate"><span class="pre">-V:</span></code> 选择器时，可以省略 company 或 tag，此时会搜索所有的安装。例如，<code class="docutils literal notranslate"><span class="pre">-V:OtherPython/</span></code> 会选择 <code class="docutils literal notranslate"><span class="pre">OtherPython</span></code> 所注册的“最佳”标签，而 <code class="docutils literal notranslate"><span class="pre">-V:3.11</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-V:/3.11</span></code> 则会选择标签为 <code class="docutils literal notranslate"><span class="pre">3.11</span></code> 的“最佳”发行版。</p>
<p>在使用旧式的 <code class="samp docutils literal notranslate"><span class="pre">-</span><em><span class="pre">&lt;major&gt;</span></em></code>、<code class="samp docutils literal notranslate"><span class="pre">-</span><em><span class="pre">&lt;major&gt;</span></em><span class="pre">.</span><em><span class="pre">&lt;minor&gt;</span></em></code>、<code class="samp docutils literal notranslate"><span class="pre">-</span><em><span class="pre">&lt;major&gt;</span></em><span class="pre">-</span><em><span class="pre">&lt;bitness&gt;</span></em></code> 或 <code class="samp docutils literal notranslate"><span class="pre">-</span><em><span class="pre">&lt;major&gt;</span></em><span class="pre">.</span><em><span class="pre">&lt;minor&gt;</span></em><span class="pre">-</span><em><span class="pre">&lt;bitness&gt;</span></em></code> 参数时，应保留过去版本的所有已有行为，并只选择从 <code class="docutils literal notranslate"><span class="pre">PythonCore</span></code> 发布的版本。 不过，<code class="docutils literal notranslate"><span class="pre">-64</span></code> 后缀现在表示“非 32 位”（不一定是 x86-64），因为有多种受支持的 64 位平台。 32 位运行时是通过检查运行时的标签是否有 <code class="docutils literal notranslate"><span class="pre">-32</span></code> 后缀来检测的。 自 Python 3.5 以来的所有版本都在其 32 位编译中包括了这个后缀。</p>
</section>
</section>
<section id="new-features-related-to-type-hints">
<span id="whatsnew311-typing-features"></span><span id="new-feat-related-type-hints-311"></span><h2>有关类型提示的新增特性</h2>
<p>本节介绍了涉及 <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span> 类型提示和 <a class="reference internal" href="../library/typing.xhtml#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块的主要更改。</p>
<section id="pep-646-variadic-generics">
<span id="whatsnew311-pep646"></span><h3>PEP 646：可变参数泛型</h3>
<p>之前的 <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/]</span> 引入了 <a class="reference internal" href="../library/typing.xhtml#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeVar</span></code></a>，其支持创建带单一类型参数的泛型。<span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a><span class="link-target"> [https://peps.python.org/pep-0646/]</span> 新引入了 <a class="reference internal" href="../library/typing.xhtml#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a>，其支持 <em>任意</em> 数量的类型的参数化。换言之，<a class="reference internal" href="../library/typing.xhtml#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a> 是 <em>可变参数（variadic）</em> 类型变量，支持 <em>可变参数</em> 泛型。</p>
<p>该泛型的引入让相当多的代码写法成为可能。特别是在诸如 NumPy 和 TensorFlow 这样的数值计算库中，这种泛型让类数组（array-like）结构类型可以用数组的 <em>形状（shape）</em> 来参数化。这样一来，静态类型检查器就能够在使用这些库的代码中捕获与形状有关的错误了。</p>
<p>更多细节请参见 <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a><span class="link-target"> [https://peps.python.org/pep-0646/]</span>。</p>
<p>（由 Matthew Rahtz 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43224">bpo-43224</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43224]</span> 中贡献，共同贡献的还有 Serhiy Storchaka 和 Jelle Zijlstra，PEP 由 Mark Mendoza、Matthew Rahtz、Pradeep Kumar Srinivasan 以及 Vincent Siles 编写）</p>
</section>
<section id="pep-655-marking-individual-typeddict-items-as-required-or-not-required">
<span id="whatsnew311-pep655"></span><h3>PEP 655：将单个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 项标记为必填或非必填项</h3>
<p><a class="reference internal" href="../library/typing.xhtml#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 和 <a class="reference internal" href="../library/typing.xhtml#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 提供了一种简单明了的方式来标记 <a class="reference internal" href="../library/typing.xhtml#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 中的单个项是否必须存在。而在之前的版本中，这只能通过使用继承来实现。</p>
<p>默认情况下，所有字段仍然是必填的，除非 <em>total</em> 参数设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，在这种情况下，默认情况下所有字段则是非必填的。例如，下面指定了一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code>，其中有一个必填的键和一个非必填的键：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
   <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
   <span class="n">year</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

<span class="n">m1</span><span class="p">:</span> <span class="n">Movie</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Black Panther&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">2018</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">m2</span><span class="p">:</span> <span class="n">Movie</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Star Wars&quot;</span><span class="p">}</span>  <span class="c1"># OK (year is not required)</span>
<span class="n">m3</span><span class="p">:</span> <span class="n">Movie</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="mi">2022</span><span class="p">}</span>  <span class="c1"># ERROR (missing required field title)</span>
</pre></div>
</div>
<p>而以下的定义和上述定义等价：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
   <span class="n">title</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
   <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>更多细节请参见 <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a><span class="link-target"> [https://peps.python.org/pep-0655/]</span>。</p>
<p>（由 David Foster 和 Jelle Zijlstra 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47087">bpo-47087</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47087]</span> 中贡献，PEP 由 David Foster 编写）</p>
</section>
<section id="pep-673-self-type">
<span id="whatsnew311-pep673"></span><h3>PEP 673：<code class="docutils literal notranslate"><span class="pre">Self</span></code> 类型</h3>
<p>新的 <a class="reference internal" href="../library/typing.xhtml#typing.Self" title="typing.Self"><code class="xref py py-data docutils literal notranslate"><span class="pre">Self</span></code></a> 注解提供了一种简单而又直观的方法来标注返回其类实例的方法。这一注解的行为与 <span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/#annotating-instance-and-class-methods"><strong>PEP 484</strong></a><span class="link-target"> [https://peps.python.org/pep-0484/#annotating-instance-and-class-methods]</span> 中指定的基于 <a class="reference internal" href="../library/typing.xhtml#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 的方法是一致的，但更简洁、更易于遵循。</p>
<p>常见的用法包括以 <a class="reference internal" href="../library/functions.xhtml#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 形式提供的替代构造函数，以及返回 <code class="docutils literal notranslate"><span class="pre">self</span></code> 的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLock</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="o">...</span>

<span class="k">class</span> <span class="nc">MyInt</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromhex</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>

    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/typing.xhtml#typing.Self" title="typing.Self"><code class="xref py py-data docutils literal notranslate"><span class="pre">Self</span></code></a> 也可以用来标注与其封闭类类型相同的方法参数或属性。</p>
<p>更多细节请参见 <span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a><span class="link-target"> [https://peps.python.org/pep-0673/]</span>。</p>
<p>（由 James Hilton-Balfe 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46534">bpo-46534</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46534]</span> 中贡献，PEP 由 Pradeep Kumar Srinivasan 和 James Hilton-Balfe 编写）</p>
</section>
<section id="pep-675-arbitrary-literal-string-type">
<span id="whatsnew311-pep675"></span><h3>PEP 675：任意字面值字符串类型</h3>
<p>新的 <a class="reference internal" href="../library/typing.xhtml#typing.LiteralString" title="typing.LiteralString"><code class="xref py py-data docutils literal notranslate"><span class="pre">LiteralString</span></code></a> 注解能用于注明函数参数可为任何字面值字符串类型。这允许函数接受任意字面值字符串类型，以及从其他字面值字符串创建的字符串。这样一来，类型检查器就可以强制对此敏感的函数（例如执行 SQL 语句或 shell 命令的函数）只以静态的实参来调用，从而提供对注入攻击的保护。</p>
<p>例如，SQL 查询函数可按照如下方式注解：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="n">sql</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">caller</span><span class="p">(</span>
    <span class="n">arbitrary_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">query_string</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">,</span>
    <span class="n">table_name</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM students&quot;</span><span class="p">)</span>       <span class="c1"># ok</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span>                   <span class="c1"># ok</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM &quot;</span> <span class="o">+</span> <span class="n">table_name</span><span class="p">)</span>  <span class="c1"># ok</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">)</span>               <span class="c1"># type checker error</span>
    <span class="n">run_query</span><span class="p">(</span>                                <span class="c1"># type checker error</span>
        <span class="sa">f</span><span class="s2">&quot;SELECT * FROM students WHERE name = </span><span class="si">{</span><span class="n">arbitrary_string</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a><span class="link-target"> [https://peps.python.org/pep-0675/]</span> 了解详情。</p>
<p>（由 Jelle Zijlstra 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47088">bpo-47088</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47088]</span> 中贡献，PEP 由 Pradeep Kumar Srinivasan 和 Graham Bleaney 编写）</p>
</section>
<section id="pep-681-data-class-transforms">
<span id="whatsnew311-pep681"></span><h3>PEP 681：数据类变换</h3>
<p><a class="reference internal" href="../library/typing.xhtml#typing.dataclass_transform" title="typing.dataclass_transform"><code class="xref py py-data docutils literal notranslate"><span class="pre">dataclass_transform</span></code></a> 可用于修饰类、元类或本身是装饰器的函数。使用 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass_Transform()</span></code> 就能让静态类型检查器知道被修饰的对象会在运行时执行对类的变换专业的“魔法”，从而让它具有类似 <a class="reference internal" href="../library/dataclasses.xhtml#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass</span></code></a> 的行为。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The create_model decorator is defined by a library.</span>
<span class="nd">@typing</span><span class="o">.</span><span class="n">dataclass_transform</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">create_model</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="o">...</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__eq__</span> <span class="o">=</span> <span class="o">...</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__ne__</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="c1"># The create_model decorator can now be used to create new model classes:</span>
<span class="nd">@create_model</span>
<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">CustomerModel</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">327</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Eric Idle&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>更多细节请参见 <span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a><span class="link-target"> [https://peps.python.org/pep-0681/]</span>。</p>
<p>（由 Jelle Zijlstra 在 <a class="reference external" href="https://github.com/python/cpython/issues/91860">gh-91860</a><span class="link-target"> [https://github.com/python/cpython/issues/91860]</span> 中贡献，PEP 由 Erik De Bonte 和 Eric Traut 编写）</p>
</section>
<section id="pep-563-may-not-be-the-future">
<span id="whatsnew311-pep563-deferred"></span><h3>未来版本可能不再实现 PEP 563</h3>
<p>原计划随 Python 3.10 发布的 <span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a><span class="link-target"> [https://peps.python.org/pep-0563/]</span> 延迟注解求值（<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 的 <a class="reference internal" href="../reference/simple_stmts.xhtml#future"><span class="std std-ref">future 语句</span></a>）已被无限期搁置。 更多信息请参见 <a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/message/VIZEBX5EYMSYIJNDBF6DMUMZOCWHARSO/">指导委员会（Steering Council）邮件列表中的讨论</a><span class="link-target"> [https://mail.python.org/archives/list/python-dev&#64;python.org/message/VIZEBX5EYMSYIJNDBF6DMUMZOCWHARSO/]</span> 。</p>
</section>
</section>
<section id="other-language-changes">
<span id="whatsnew311-other-lang-changes"></span><h2>其他语言特性修改</h2>
<ul class="simple">
<li><p>星号解包表达式现在可以在 <a class="reference internal" href="../reference/compound_stmts.xhtml#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 语句中使用。（更多细节请参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46725">bpo-46725</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46725]</span>）</p></li>
<li><p>现在，在 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-def"><span class="std std-ref">异步函数</span></a> 中的推导式内部允许使用异步 <a class="reference internal" href="../reference/expressions.xhtml#comprehensions"><span class="std std-ref">推导式</span></a>。此时，外部推导式隐式地变成了异步推导式。（由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33346">bpo-33346</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33346]</span> 中贡献）</p></li>
<li><p>在 <a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句和用于不支持 <a class="reference internal" href="../glossary.xhtml#term-context-manager"><span class="xref std std-term">context manager</span></a> 协议的对象 <a class="reference internal" href="../library/contextlib.xhtml#contextlib.ExitStack.enter_context" title="contextlib.ExitStack.enter_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contextlib.ExitStack.enter_context()</span></code></a> 中，以及 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 语句和用于不支持 <a class="reference internal" href="../glossary.xhtml#term-asynchronous-context-manager"><span class="xref std std-term">asynchronous context manager</span></a> 协议的对象的 <a class="reference internal" href="../library/contextlib.xhtml#contextlib.AsyncExitStack.enter_async_context" title="contextlib.AsyncExitStack.enter_async_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contextlib.AsyncExitStack.enter_async_context()</span></code></a> 中现在会引发 <a class="reference internal" href="../library/exceptions.xhtml#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 而不是 <a class="reference internal" href="../library/exceptions.xhtml#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=12022">bpo-12022</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=12022]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44471">bpo-44471</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44471]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/pickle.xhtml#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getstate__()</span></code></a>，它提供 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code> 方法的默认实现。 <a class="reference internal" href="../library/copy.xhtml#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> 并 <a class="reference internal" href="../library/pickle.xhtml#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 内置类型 <a class="reference internal" href="../library/stdtypes.xhtml#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="../library/collections.xhtml#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>, <a class="reference internal" href="../library/collections.xhtml#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>, <a class="reference internal" href="../library/weakref.xhtml#weakref.WeakSet" title="weakref.WeakSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.WeakSet</span></code></a> 和 <a class="reference internal" href="../library/datetime.xhtml#datetime.tzinfo" title="datetime.tzinfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.tzinfo</span></code></a> 的子类的实例现在将会拷贝并封存被实现为 <a class="reference internal" href="../glossary.xhtml#term-__slots__"><span class="xref std std-term">槽位</span></a> 的实例属性。 此项改变有一个意外的附带影响：它将扰乱少数不使用 <a class="reference internal" href="../library/pickle.xhtml#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getstate__()</span></code></a> 的现有 Python 项目。 请参阅 <a class="reference external" href="https://github.com/python/cpython/issues/70766">gh-70766</a><span class="link-target"> [https://github.com/python/cpython/issues/70766]</span> 上近期的评论了解有关此类代码所需处理的讨论。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=26579">bpo-26579</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=26579]</span> 中贡献。）</p></li>
</ul>
<ul class="simple" id="whatsnew311-pythonsafepath">
<li><p>增加了 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-P"><code class="xref std std-option docutils literal notranslate"><span class="pre">-P</span></code></a> 命令行选项和 <span class="target" id="index-105"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONSAFEPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONSAFEPATH</span></code></a> 环境变量，它们将禁用当运行脚本时将脚本目录，或者当使用 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 和 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 时将当前目前自动添加到 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>。 这可以确保只有标准库和已安装模块可通过 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 导入，而避免无意或恶意地使用本地（且通常为用户可写）的目录屏蔽此类模块。 （由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/57684">gh-57684</a><span class="link-target"> [https://github.com/python/cpython/issues/57684]</span> 中贡献。）</p></li>
<li><p>在 <a class="reference internal" href="../library/string.xhtml#formatspec"><span class="std std-ref">格式规格迷你语言</span></a> 中增加了一个 <code class="docutils literal notranslate"><span class="pre">&quot;z&quot;</span></code> 选项用来在舍入到格式精度后强制将负数转为正数。 请参阅 <span class="target" id="index-106"></span><a class="pep reference external" href="https://peps.python.org/pep-0682/"><strong>PEP 682</strong></a><span class="link-target"> [https://peps.python.org/pep-0682/]</span> 了解详情。 （由 John Belmonte 在 <a class="reference external" href="https://github.com/python/cpython/issues/90153">gh-90153</a><span class="link-target"> [https://github.com/python/cpython/issues/90153]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 不再接受字节串。对此的支持在 Python 3.2 和 3.6 之间中断过一段时间，但是直到 Python 3.10.0 发布时才被人发现。此外，由于 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 和 <a class="reference internal" href="../library/sys.xhtml#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 之间的交互，当同时存在 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 键时，恢复对此的支持会很困难。（由 Thomas Grainger 在 <a class="reference external" href="https://github.com/python/cpython/issues/91181">gh-91181</a><span class="link-target"> [https://github.com/python/cpython/issues/91181]</span> 中贡献）</p></li>
</ul>
</section>
<section id="other-cpython-implementation-changes">
<span id="whatsnew311-other-implementation-changes"></span><h2>其他 CPython 实现的改变</h2>
<ul class="simple">
<li><p>实现了用于 <a class="reference internal" href="../library/functions.xhtml#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> 和用于 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__bytes__" title="object.__bytes__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bytes__()</span></code></a> 特殊方法以支持 <a class="reference internal" href="../library/typing.xhtml#typing.SupportsComplex" title="typing.SupportsComplex"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.SupportsComplex</span></code></a> 和 <a class="reference internal" href="../library/typing.xhtml#typing.SupportsBytes" title="typing.SupportsBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.SupportsBytes</span></code></a> 协议。 （由 Mark Dickinson 和 Donghee Na 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=24234">bpo-24234</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=24234]</span> 中贡献。）</p></li>
<li><p>添加了新的内部哈希算法 <code class="docutils literal notranslate"><span class="pre">siphash13</span></code>。它与 <code class="docutils literal notranslate"><span class="pre">siphash24</span></code> 有类似的安全特性，但是对于长输入，它的速度略快。<a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和其他一些类型现在使用它作为 <a class="reference internal" href="../library/functions.xhtml#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 的默认算法。<span class="target" id="index-107"></span><a class="pep reference external" href="https://peps.python.org/pep-0552/"><strong>PEP 552</strong></a><span class="link-target"> [https://peps.python.org/pep-0552/]</span> <a class="reference internal" href="../reference/import.xhtml#pyc-invalidation"><span class="std std-ref">基于哈希的 .pyc 文件</span></a> 现在也使用 <code class="docutils literal notranslate"><span class="pre">siphash13</span></code>。（由 Inada Naoki 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=29410">bpo-29410</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=29410]</span>  中贡献）</p></li>
<li><p>当使用没有参数的 <a class="reference internal" href="../reference/simple_stmts.xhtml#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> 语句重新引发活动的异常时，被附加在此异常上的回溯现在始终为 <code class="docutils literal notranslate"><span class="pre">sys.exc_info()[1].__traceback__</span></code>。这意味着在当前 <a class="reference internal" href="../reference/compound_stmts.xhtml#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 子句中对回溯的修改将被反映到重新引发的异常。（由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711">bpo-45711</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711]</span> 中贡献）</p></li>
<li><p>解释器状态对已处理异常（又名 <code class="docutils literal notranslate"><span class="pre">exc_info</span></code> 或 <code class="docutils literal notranslate"><span class="pre">_PyErr_StackItem</span></code> ）的表示现在只有 <code class="docutils literal notranslate"><span class="pre">exc_value</span></code> 字段；<code class="docutils literal notranslate"><span class="pre">exc_type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exc_traceback</span></code> 已被移除，因为它们可以派生自 <code class="docutils literal notranslate"><span class="pre">exc_value</span></code> 。（由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711">bpo-45711</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711]</span> 中贡献）</p></li>
<li><p>WIndows 安装程序添加了一个新的 <a class="reference internal" href="../using/windows.xhtml#install-quiet-option"><span class="std std-ref">命令行选项</span></a> <code class="docutils literal notranslate"><span class="pre">AppendPath</span></code>。它的行为类似于 <code class="docutils literal notranslate"><span class="pre">PrependPath</span></code>，但是会追加安装和脚本目录而不是前加。（由 Bastian Neuburger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44934">bpo-44934</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44934]</span> 中贡献）</p></li>
<li><p>为了使用 <a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig.module_search_paths" title="PyConfig.module_search_paths"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths</span></code></a> 初始化 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>，<a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig.module_search_paths_set" title="PyConfig.module_search_paths_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths_set</span></code></a> 字段现在必须使用``1`` 作初始化，否则，该初始化行为会重新计算路径并替换任何加入到 <code class="docutils literal notranslate"><span class="pre">module_search_paths</span></code> 的值。</p></li>
<li><p><a class="reference internal" href="../using/cmdline.xhtml#cmdoption-help"><code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code></a> 选项的输出现在将适应于50行/80列。有关 <a class="reference internal" href="../using/cmdline.xhtml#using-on-envvars"><span class="std std-ref">Python environment variables</span></a>  和 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> 选项的信息可以分别使用 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-help-env"><code class="xref std std-option docutils literal notranslate"><span class="pre">--help-env</span></code></a> 和 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-help-xoptions"><code class="xref std std-option docutils literal notranslate"><span class="pre">--help-xoptions</span></code></a> 标志获得，并可以使用新的标志 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-help-all"><code class="xref std std-option docutils literal notranslate"><span class="pre">--help-all</span></code></a>。（由 Éric Araujo 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46142">bpo-46142</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46142]</span> 贡献。）</p></li>
<li><p>使用 2 (二进制), 4, 8 (八进制), 16 (十六进制) 或 32 以外的基数例如以 10 (十进制) 为基数在 <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 之间进行转换现在如果字符串表示形式中的位数超过特定限制则会引发 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 以避免因算法复杂度导致的拒绝服务攻击风险。 这是对于 <a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735">CVE-2020-10735</a><span class="link-target"> [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735]</span> 的一种缓解方案。 此限制可通过环境变量、命令行旗标或 <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> API 来配置或者禁用。 参见 <a class="reference internal" href="../library/stdtypes.xhtml#int-max-str-digits"><span class="std std-ref">整数字符串转换长度限制</span></a> 文档。 字符串形式的默认限制为 4300 位数字。</p></li>
</ul>
</section>
<section id="new-modules">
<span id="whatsnew311-new-modules"></span><h2>新增模块</h2>
<ul class="simple">
<li><p><a class="reference internal" href="../library/tomllib.xhtml#module-tomllib" title="tomllib: Parse TOML files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tomllib</span></code></a>: 用于解析 <a class="reference external" href="https://toml.io/">TOML</a><span class="link-target"> [https://toml.io/]</span>。 请参阅 <span class="target" id="index-108"></span><a class="pep reference external" href="https://peps.python.org/pep-0680/"><strong>PEP 680</strong></a><span class="link-target"> [https://peps.python.org/pep-0680/]</span> 了解详情。 （由 Taneli Hukkinen 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40059">bpo-40059</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40059]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/wsgiref.xhtml#module-wsgiref.types" title="wsgiref.types: WSGI types for static type checking"><code class="xref py py-mod docutils literal notranslate"><span class="pre">wsgiref.types</span></code></a>: 用于表态类型检查的 <span class="target" id="index-109"></span><a class="pep reference external" href="https://peps.python.org/pep-3333/"><strong>WSGI</strong></a><span class="link-target"> [https://peps.python.org/pep-3333/]</span> 专属类型。 （由 Sebastian Rittau 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42012">bpo-42012</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42012]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="improved-modules">
<span id="whatsnew311-improved-modules"></span><h2>改进的模块</h2>
<section id="asyncio">
<span id="whatsnew311-asyncio"></span><h3>asyncio</h3>
<ul class="simple">
<li><p>添加了 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">TaskGroup</span></code></a> 类，它是一个 <a class="reference internal" href="../reference/datamodel.xhtml#async-context-managers"><span class="std std-ref">异步上下文管理器</span></a>，可以持有一组任务，等待它们全部完成后才退出。 对于新代码，建议使用此类，而不是直接使用 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_task()</span></code></a> 和 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.gather" title="asyncio.gather"><code class="xref py py-func docutils literal notranslate"><span class="pre">gather()</span></code></a>。 （由 Yury Selivanov 等人在 <a class="reference external" href="https://github.com/python/cpython/issues/90908">gh-90908</a><span class="link-target"> [https://github.com/python/cpython/issues/90908]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.timeout" title="asyncio.timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">timeout()</span></code></a>，一个用于在异步操作上设置超时的异步上下文管理器。 对于新代码推荐用这个来代替直接使用 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for()</span></code></a>。 （由 Andrew Svetlov 在 <a class="reference external" href="https://github.com/python/cpython/issues/90927">gh-90927</a><span class="link-target"> [https://github.com/python/cpython/issues/90927]</span> 中贡献）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/asyncio-runner.xhtml#asyncio.Runner" title="asyncio.Runner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Runner</span></code></a> 类，该类对外公开了 <a class="reference internal" href="../library/asyncio-runner.xhtml#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 所使用的机制。 （由 Andrew Svetlov 在 <a class="reference external" href="https://github.com/python/cpython/issues/91218">gh-91218</a><span class="link-target"> [https://github.com/python/cpython/issues/91218]</span> 中贡献。）.)</p></li>
<li><p>为 asyncio 库中的同步化原语添加了 <a class="reference internal" href="../library/asyncio-sync.xhtml#asyncio.Barrier" title="asyncio.Barrier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Barrier</span></code></a> 类，以及相应的 <a class="reference internal" href="../library/asyncio-sync.xhtml#asyncio.BrokenBarrierError" title="asyncio.BrokenBarrierError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a> 异常。 （由 Yves Duprat 和 Andrew Svetlov 在 <a class="reference external" href="https://github.com/python/cpython/issues/87518">gh-87518</a><span class="link-target"> [https://github.com/python/cpython/issues/87518]</span> 中贡献。）</p></li>
<li><p>向 <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.loop.create_connection()</span></code></a> 添加了关键字参数 <em>all_errors</em> 以便可以将多个连接错误作为一个 <a class="reference internal" href="../library/exceptions.xhtml#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 来引发。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/asyncio-stream.xhtml#asyncio.StreamWriter.start_tls" title="asyncio.StreamWriter.start_tls"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.StreamWriter.start_tls()</span></code></a> 方法用于将现有的基于流的连接升级为 TLS。 （由 Ian Good 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=34975">bpo-34975</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=34975]</span> 中贡献。）</p></li>
<li><p>为事件循环添加了原始数据报套接字函数: <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.loop.sock_sendto" title="asyncio.loop.sock_sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sock_sendto()</span></code></a>, <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.loop.sock_recvfrom" title="asyncio.loop.sock_recvfrom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sock_recvfrom()</span></code></a> 和 <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.loop.sock_recvfrom_into" title="asyncio.loop.sock_recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sock_recvfrom_into()</span></code></a>。 这些函数在 <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 和 <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 中均有实现。 （由 Alex Grönholm 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46805">bpo-46805</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46805]</span> 中贡献。）.)</p></li>
<li><p>为 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 添加了 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.Task.cancelling" title="asyncio.Task.cancelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelling()</span></code></a> 和 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel()</span></code></a> 方法。 它们主要供内部使用，特别是 <a class="reference internal" href="../library/asyncio-task.xhtml#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">TaskGroup</span></code></a>。</p></li>
</ul>
</section>
<section id="contextlib">
<span id="whatsnew311-contextlib"></span><h3>contextlib</h3>
<ul class="simple">
<li><p>增加了非并行安全的 <a class="reference internal" href="../library/contextlib.xhtml#contextlib.chdir" title="contextlib.chdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">chdir()</span></code></a> 上下文管理器用来改变当前工作目录并在退出时恢复它。 是 <a class="reference internal" href="../library/os.xhtml#os.chdir" title="os.chdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">chdir()</span></code></a> 的简单包装器。 （由 Filipe Laíns 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=25625">bpo-25625</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=25625]</span> 中贡献）)</p></li>
</ul>
</section>
<section id="dataclasses">
<span id="whatsnew311-dataclasses"></span><h3>dataclasses</h3>
<ul class="simple">
<li><p>修改了字段默认的可变性检查，默认仅允许 <a class="reference internal" href="../glossary.xhtml#term-hashable"><span class="xref std std-term">hashable</span></a> 而非任何不为 <a class="reference internal" href="../library/stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 实例的对象。 （由 Eric V. Smith 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44674">bpo-44674</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44674]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="datetime">
<span id="whatsnew311-datetime"></span><h3>datetime</h3>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/datetime.xhtml#datetime.UTC" title="datetime.UTC"><code class="xref py py-const docutils literal notranslate"><span class="pre">datetime.UTC</span></code></a>，是 <a class="reference internal" href="../library/datetime.xhtml#datetime.timezone.utc" title="datetime.timezone.utc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">datetime.timezone.utc</span></code></a> 的便捷别名。 （由 Kabir Kwatra 在 <a class="reference external" href="https://github.com/python/cpython/issues/91973">gh-91973</a><span class="link-target"> [https://github.com/python/cpython/issues/91973]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/datetime.xhtml#datetime.date.fromisoformat" title="datetime.date.fromisoformat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.date.fromisoformat()</span></code></a>, <a class="reference internal" href="../library/datetime.xhtml#datetime.time.fromisoformat" title="datetime.time.fromisoformat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.time.fromisoformat()</span></code></a> 和 <a class="reference internal" href="../library/datetime.xhtml#datetime.datetime.fromisoformat" title="datetime.datetime.fromisoformat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.datetime.fromisoformat()</span></code></a> 现在可以被用来解析大多数 ISO 8601 格式（除了那些支持分数小时和分钟的格式）。 （由 Paul Ganssle 在 <a class="reference external" href="https://github.com/python/cpython/issues/80010">gh-80010</a><span class="link-target"> [https://github.com/python/cpython/issues/80010]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="enum">
<span id="whatsnew311-enum"></span><h3>enum</h3>
<ul class="simple">
<li><p>将 <code class="xref py py-class docutils literal notranslate"><span class="pre">EnumMeta</span></code> 重命名为 <a class="reference internal" href="../library/enum.xhtml#enum.EnumType" title="enum.EnumType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnumType</span></code></a> (<code class="xref py py-class docutils literal notranslate"><span class="pre">EnumMeta</span></code> 作为别名保留)。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/enum.xhtml#enum.StrEnum" title="enum.StrEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrEnum</span></code></a>，其成员可以（且必须）作为字符串使用。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/enum.xhtml#enum.ReprEnum" title="enum.ReprEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReprEnum</span></code></a>，它只是在为 <a class="reference internal" href="../reference/datamodel.xhtml#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 方法（供 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>, <a class="reference internal" href="../library/functions.xhtml#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 和 <a class="reference internal" href="../glossary.xhtml#term-f-string"><span class="xref std std-term">f-string</span></a> 使用）返回成员的字面值（而不是名称）时修改了它们的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a>。</p></li>
<li><p>修改了 <a class="reference internal" href="../library/enum.xhtml#enum.Enum.__format__" title="enum.Enum.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Enum.__format__()</span></code></a> (为 <a class="reference internal" href="../library/functions.xhtml#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 和 <a class="reference internal" href="../glossary.xhtml#term-f-string"><span class="xref std std-term">f-string</span></a> 的默认值) 以便始终产生于 <a class="reference internal" href="../library/enum.xhtml#enum.Enum.__str__" title="enum.Enum.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Enum.__str__()</span></code></a> 相同的结果：对于继承自 <a class="reference internal" href="../library/enum.xhtml#enum.ReprEnum" title="enum.ReprEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReprEnum</span></code></a> 的枚举它将成为其成员的值；对于所有其他枚举它将为枚举和成员名称 (例如 <code class="docutils literal notranslate"><span class="pre">Color.RED</span></code>)。</p></li>
<li><p>将新的 <em>boundary</em> 类形参连同其选项添加到 <a class="reference internal" href="../library/enum.xhtml#enum.Flag" title="enum.Flag"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flag</span></code></a> 枚举和 <a class="reference internal" href="../library/enum.xhtml#enum.FlagBoundary" title="enum.FlagBoundary"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlagBoundary</span></code></a> 枚举中，以控制超范围旗标值的处理方式。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/enum.xhtml#enum.verify" title="enum.verify"><code class="xref py py-func docutils literal notranslate"><span class="pre">verify()</span></code></a> 枚举装饰器和 <a class="reference internal" href="../library/enum.xhtml#enum.EnumCheck" title="enum.EnumCheck"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnumCheck</span></code></a> 枚举及其选项，以基于特定约束条件来检查枚举类。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/enum.xhtml#enum.member" title="enum.member"><code class="xref py py-func docutils literal notranslate"><span class="pre">member()</span></code></a> 和 <a class="reference internal" href="../library/enum.xhtml#enum.nonmember" title="enum.nonmember"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonmember()</span></code></a> 装饰器，用于确保被装饰的对象是/否会被转换为枚举成员。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/enum.xhtml#enum.property" title="enum.property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 装饰器，它类似于 <a class="reference internal" href="../library/functions.xhtml#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 但是专门针对枚举。 请使用它来代替 <a class="reference internal" href="../library/types.xhtml#types.DynamicClassAttribute" title="types.DynamicClassAttribute"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.DynamicClassAttribute()</span></code></a>。</p></li>
<li><p>增加了 <a class="reference internal" href="../library/enum.xhtml#enum.global_enum" title="enum.global_enum"><code class="xref py py-func docutils literal notranslate"><span class="pre">global_enum()</span></code></a> 枚举装饰器，它会调整 <a class="reference internal" href="../reference/datamodel.xhtml#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.xhtml#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 以将值显示为其模块的成员而不是枚举类的成员。 例如，<code class="docutils literal notranslate"><span class="pre">'re.ASCII'</span></code> 是 <a class="reference internal" href="../library/re.xhtml#re.RegexFlag" title="re.RegexFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.RegexFlag</span></code></a> 的 <a class="reference internal" href="../library/re.xhtml#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 成员而不是 <code class="docutils literal notranslate"><span class="pre">'RegexFlag.ASCII'</span></code>。</p></li>
<li><p>增强了 <a class="reference internal" href="../library/enum.xhtml#enum.Flag" title="enum.Flag"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flag</span></code></a> 以支持针对其成员的 <a class="reference internal" href="../library/functions.xhtml#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>，迭代和 <a class="reference internal" href="../reference/expressions.xhtml#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>/<a class="reference internal" href="../reference/expressions.xhtml#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>。 例如，现在可以使用下面的代码: <code class="docutils literal notranslate"><span class="pre">len(AFlag(3))</span> <span class="pre">==</span> <span class="pre">2</span> <span class="pre">and</span> <span class="pre">list(AFlag(3))</span> <span class="pre">==</span> <span class="pre">(AFlag.ONE,</span> <span class="pre">AFlag.TWO)</span></code></p></li>
<li><p>修改了 <a class="reference internal" href="../library/enum.xhtml#enum.Enum" title="enum.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> 和 <a class="reference internal" href="../library/enum.xhtml#enum.Flag" title="enum.Flag"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flag</span></code></a> 使得成员的定义是在 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> 被调用之前；<a class="reference internal" href="../library/functions.xhtml#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 现在将包括来自混入数据类型的方法等。</p></li>
<li><p>将 <a class="reference internal" href="../library/enum.xhtml#enum.Flag" title="enum.Flag"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flag</span></code></a> 修改为只考虑规范的基本值（即二的乘方）而复合值（如 <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">6</span></code>, <code class="docutils literal notranslate"><span class="pre">10</span></code> 等）则被视为别名；逆向旗标将被强制转换为对应的正向旗标。</p></li>
</ul>
</section>
<section id="fcntl">
<span id="whatsnew311-fcntl"></span><h3>fcntl</h3>
<ul class="simple">
<li><p>在 FreeBSD 上，<code class="xref py py-data docutils literal notranslate"><span class="pre">F_DUP2FD</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">F_DUP2FD_CLOEXEC</span></code> 旗标分别受到支持，前者等价于 <code class="docutils literal notranslate"><span class="pre">dup2</span></code> 用法而后者额外设置了 <code class="docutils literal notranslate"><span class="pre">FD_CLOEXEC</span></code> 旗标。</p></li>
</ul>
</section>
<section id="fractions">
<span id="whatsnew311-fractions"></span><h3>fractions</h3>
<ul class="simple">
<li><p>支持基于字符串执行 <span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-0515/"><strong>PEP 515</strong></a><span class="link-target"> [https://peps.python.org/pep-0515/]</span> 网络的 <a class="reference internal" href="../library/fractions.xhtml#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code></a> 初始化。 （由 Sergey B Kirpichev 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44258">bpo-44258</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44258]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/fractions.xhtml#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code></a> 现在实现了一个 <code class="docutils literal notranslate"><span class="pre">__int__</span></code> 方法，因而 <code class="docutils literal notranslate"><span class="pre">isinstance(some_fraction,</span> <span class="pre">typing.SupportsInt)</span></code> 检测将会通过。 （由 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44547">bpo-44547</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44547]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="functools">
<span id="whatsnew311-functools"></span><h3>functools</h3>
<ul>
<li><p><a class="reference internal" href="../library/functools.xhtml#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> 现在支持以 <a class="reference internal" href="../library/types.xhtml#types.UnionType" title="types.UnionType"><code class="xref py py-data docutils literal notranslate"><span class="pre">types.UnionType</span></code></a> 和 <a class="reference internal" href="../library/typing.xhtml#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Union</span></code></a> 作为 dispatch 参数的标注。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">singledispatch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@singledispatch</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Let me just say,&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@fun</span><span class="o">.</span><span class="n">register</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strength in numbers, eh?&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@fun</span><span class="o">.</span><span class="n">register</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enumerate this:&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>（由 Yurii Karabas 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46014">bpo-46014</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46014]</span> 中贡献。）</p>
</li>
</ul>
</section>
<section id="hashlib">
<span id="whatsnew311-hashlib"></span><h3>hashlib</h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/hashlib.xhtml#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">hashlib.blake2b()</span></code></a> 和 <a class="reference internal" href="../library/hashlib.xhtml#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">hashlib.blake2s()</span></code></a> 现在将优先使用 <a class="reference external" href="https://www.blake2.net/">libb2</a><span class="link-target"> [https://www.blake2.net/]</span> 而不是 Python 自带的副本。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47095">bpo-47095</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47095]</span> 中贡献。）</p></li>
<li><p>包含 SHA3 和 SHAKE 的内部 <code class="docutils literal notranslate"><span class="pre">_sha3</span></code> 模块现在会使用 <em>tiny_sha3</em> 而不是 <em>Keccak Code Package</em> 来减小代码和二进制文件的大小。 <a class="reference internal" href="../library/hashlib.xhtml#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块将首选来自 OpenSSL 的优化版 SHA3 和 SHAKE 实现。 这个改变将只影响不带 OpenSSL 支持的安装版。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47098">bpo-47098</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47098]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/hashlib.xhtml#hashlib.file_digest" title="hashlib.file_digest"><code class="xref py py-func docutils literal notranslate"><span class="pre">hashlib.file_digest()</span></code></a>，一个针对文件或文件型对象高效哈希运算的辅助函数。 （由 Christian Heimes 在 <a class="reference external" href="https://github.com/python/cpython/issues/89313">gh-89313</a><span class="link-target"> [https://github.com/python/cpython/issues/89313]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="whatsnew311-idle">
<span id="idle-and-idlelib"></span><h3>IDLE 与 idlelib</h3>
<ul class="simple">
<li><p>对 <code class="docutils literal notranslate"><span class="pre">.pyi</span></code> 文件应用语法高亮。 （由 Alex Waygood 和 Terry Jan Reedy 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45447">bpo-45447</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45447]</span> 中贡献。）</p></li>
<li><p>当附带输入和输出地保存 Shell 时将包括提示符。 （由 Terry Jan Reedy 在 <a class="reference external" href="https://github.com/python/cpython/issues/95191">gh-95191</a><span class="link-target"> [https://github.com/python/cpython/issues/95191]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="inspect">
<span id="whatsnew311-inspect"></span><h3>inspect</h3>
<ul>
<li><p>增加了 <a class="reference internal" href="../library/inspect.xhtml#inspect.getmembers_static" title="inspect.getmembers_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">getmembers_static()</span></code></a> 用于返回所有成员而不通过描述器协议触发动态查找。 （由 Weipeng Hong 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=30533">bpo-30533</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=30533]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/inspect.xhtml#inspect.ismethodwrapper" title="inspect.ismethodwrapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">ismethodwrapper()</span></code></a> 用于检查某个对象的类型是否为 <a class="reference internal" href="../library/types.xhtml#types.MethodWrapperType" title="types.MethodWrapperType"><code class="xref py py-class docutils literal notranslate"><span class="pre">MethodWrapperType</span></code></a>。 （由 Hakan Çelik 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=29418">bpo-29418</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=29418]</span> 中贡献。）</p></li>
<li><p>修改了 <a class="reference internal" href="../library/inspect.xhtml#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块中与帧相关的函数以返回新的 <a class="reference internal" href="../library/inspect.xhtml#inspect.FrameInfo" title="inspect.FrameInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">FrameInfo</span></code></a> 和 <a class="reference internal" href="../library/inspect.xhtml#inspect.Traceback" title="inspect.Traceback"><code class="xref py py-class docutils literal notranslate"><span class="pre">Traceback</span></code></a> 类实例（与之前的 <a class="reference internal" href="../glossary.xhtml#term-named-tuple"><span class="xref std std-term">named tuple</span></a> 风格的接口保持向下兼容），它们包括扩展的 <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0657/"><strong>PEP 657</strong></a><span class="link-target"> [https://peps.python.org/pep-0657/]</span> 位置信息（末尾行编号，列与结束列等）。 受影响的函数有:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/inspect.xhtml#inspect.getframeinfo" title="inspect.getframeinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getframeinfo()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/inspect.xhtml#inspect.getouterframes" title="inspect.getouterframes"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getouterframes()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/inspect.xhtml#inspect.getinnerframes" title="inspect.getinnerframes"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getinnerframes()</span></code></a>,</p></li>
<li><p><a class="reference internal" href="../library/inspect.xhtml#inspect.stack" title="inspect.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.stack()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/inspect.xhtml#inspect.trace" title="inspect.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.trace()</span></code></a></p></li>
</ul>
<p>（由 Pablo Galindo 在 <a class="reference external" href="https://github.com/python/cpython/issues/88116">gh-88116</a><span class="link-target"> [https://github.com/python/cpython/issues/88116]</span> 中贡献。）</p>
</li>
</ul>
</section>
<section id="locale">
<span id="whatsnew311-locale"></span><h3>locale</h3>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/locale.xhtml#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> 以获取当前语言区域编码格式。 它类似于 <code class="docutils literal notranslate"><span class="pre">locale.getpreferredencoding(False)</span></code> 但会忽略 <a class="reference internal" href="../library/os.xhtml#utf8-mode"><span class="std std-ref">Python UTF-8 模式</span></a>。</p></li>
</ul>
</section>
<section id="logging">
<span id="whatsnew311-logging"></span><h3>logging</h3>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/logging.xhtml#logging.getLevelNamesMapping" title="logging.getLevelNamesMapping"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLevelNamesMapping()</span></code></a> 以返回一个从日志记录级别名称 (例如 <code class="docutils literal notranslate"><span class="pre">'CRITICAL'</span></code>) 到其对应 <a class="reference internal" href="../library/logging.xhtml#levels"><span class="std std-ref">日志级别</span></a> 值 (例如默认值 <code class="docutils literal notranslate"><span class="pre">50</span></code>) 的映射。 （由 Andrei Kulakovin 在 <a class="reference external" href="https://github.com/python/cpython/issues/88024">gh-88024</a><span class="link-target"> [https://github.com/python/cpython/issues/88024]</span> 中贡献。）</p></li>
<li><p>向 <a class="reference internal" href="../library/logging.handlers.xhtml#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> 增加了 <a class="reference internal" href="../library/logging.handlers.xhtml#logging.handlers.SysLogHandler.createSocket" title="logging.handlers.SysLogHandler.createSocket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createSocket()</span></code></a> 方法以匹配 <a class="reference internal" href="../library/logging.handlers.xhtml#logging.handlers.SocketHandler.createSocket" title="logging.handlers.SocketHandler.createSocket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SocketHandler.createSocket()</span></code></a>。 它将在处理器初始化期间以及发出事件时被自动调用，如果没有已激活的套接字的话。 （由 Kirill Pinchuk 在 <a class="reference external" href="https://github.com/python/cpython/issues/88457">gh-88457</a><span class="link-target"> [https://github.com/python/cpython/issues/88457]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="math">
<span id="whatsnew311-math"></span><h3>math</h3>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/math.xhtml#math.exp2" title="math.exp2"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.exp2()</span></code></a>: 返回 2 的 x 次幂。 （由 Gideon Mitchell 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45917">bpo-45917</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45917]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/math.xhtml#math.cbrt" title="math.cbrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.cbrt()</span></code></a>: 返回 x 的立方根。 （由 Ajith Ramachandran 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44357">bpo-44357</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44357]</span> 中贡献。）</p></li>
<li><p>两个 <a class="reference internal" href="../library/math.xhtml#math.pow" title="math.pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.pow()</span></code></a> 边界情况的行为已改变，以便与 IEEE 754 规范保持一致。 <code class="docutils literal notranslate"><span class="pre">math.pow(0.0,</span> <span class="pre">-math.inf)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">math.pow(-0.0,</span> <span class="pre">-math.inf)</span></code> 等运算现在将返回 <code class="docutils literal notranslate"><span class="pre">inf</span></code>。 在此之前它们会引发 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 （由 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44339">bpo-44339</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44339]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/math.xhtml#math.nan" title="math.nan"><code class="xref py py-data docutils literal notranslate"><span class="pre">math.nan</span></code></a> 值将总是可用。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46917">bpo-46917</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46917]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="operator">
<span id="whatsnew311-operator"></span><h3>operator</h3>
<ul class="simple">
<li><p>增加了一个新函数 <code class="docutils literal notranslate"><span class="pre">operator.call</span></code>，使得 <code class="docutils literal notranslate"><span class="pre">operator.call(obj,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">==</span> <span class="pre">obj(*args,</span> <span class="pre">**kwargs)</span></code>。 （由 Antony Lee 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44019">bpo-44019</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44019]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="os">
<span id="whatsnew311-os"></span><h3>os</h3>
<ul class="simple">
<li><p>在 Windows 上，<a class="reference internal" href="../library/os.xhtml#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> 现在将使用 <code class="docutils literal notranslate"><span class="pre">BCryptGenRandom()</span></code>，而不是已被弃用的 <code class="docutils literal notranslate"><span class="pre">CryptGenRandom()</span></code>。 （由 Donghee Na 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44611">bpo-44611</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44611]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="pathlib">
<span id="whatsnew311-pathlib"></span><h3>pathlib</h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/pathlib.xhtml#pathlib.Path.glob" title="pathlib.Path.glob"><code class="xref py py-meth docutils literal notranslate"><span class="pre">glob()</span></code></a> 和 <a class="reference internal" href="../library/pathlib.xhtml#pathlib.Path.rglob" title="pathlib.Path.rglob"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rglob()</span></code></a> 在 <em>pattern</em> 以路径组件分隔符即 <a class="reference internal" href="../library/os.xhtml#os.sep" title="os.sep"><code class="xref py py-data docutils literal notranslate"><span class="pre">sep</span></code></a> 或 <a class="reference internal" href="../library/os.xhtml#os.altsep" title="os.altsep"><code class="xref py py-data docutils literal notranslate"><span class="pre">altsep</span></code></a> 结束时将只返回目录。 （由 Eisuke Kawasima 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=22276">bpo-22276</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=22276]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33392">bpo-33392</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33392]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="re">
<span id="whatsnew311-re"></span><h3>re</h3>
<ul class="simple">
<li><p>正则表达式现已支持原子化分组 (<code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code>) 和占有型数量限定符 (<code class="docutils literal notranslate"><span class="pre">*+</span></code>, <code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">?+</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}+</span></code>)。 （由 Jeffrey C. Jacobs 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=433030">bpo-433030</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=433030]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="shutil">
<span id="whatsnew311-shutil"></span><h3>shutil</h3>
<ul class="simple">
<li><p>在 <a class="reference internal" href="../library/shutil.xhtml#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.rmtree()</span></code></a> 中添加了可选形参 <em>dir_fd</em>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46245">bpo-46245</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46245]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="socket">
<span id="whatsnew311-socket"></span><h3>socket</h3>
<ul class="simple">
<li><p>为 NetBSD 添加了 CAN Socket 支持。 （由 Thomas Klausner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=30512">bpo-30512</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=30512]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/socket.xhtml#socket.create_connection" title="socket.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a> 具有一个在连接失败的情况下引发包含所有错误而的 <a class="reference internal" href="../library/exceptions.xhtml#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> 不是只引发最后的错误的选项。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=29980">bpo-29980</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=29980]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="sqlite3">
<span id="whatsnew311-sqlite3"></span><h3>sqlite3</h3>
<ul class="simple">
<li><p>你现在可以通过将 <a class="reference internal" href="../library/constants.xhtml#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 传给 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.set_authorizer" title="sqlite3.Connection.set_authorizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_authorizer()</span></code></a> 来禁用身份验证。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44491">bpo-44491</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44491]</span> 中贡献。）</p></li>
<li><p>排序名 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.create_collation" title="sqlite3.Connection.create_collation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_collation()</span></code></a> 现在可以包含任意 Unicode 字符。 带有无效字符的排序名现在将引发 <a class="reference internal" href="../library/exceptions.xhtml#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 而不是 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">sqlite3.ProgrammingError</span></code></a>。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44688">bpo-44688</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44688]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/sqlite3.xhtml#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 异常包括以 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Error.sqlite_errorcode" title="sqlite3.Error.sqlite_errorcode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sqlite_errorcode</span></code></a> 代表的 SQLite 扩展错误码和以 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Error.sqlite_errorname" title="sqlite3.Error.sqlite_errorname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sqlite_errorname</span></code></a> 代表的 SQLite 错误名。 （由 Aviv Palivoda, Daniel Shahaf 和 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16379">bpo-16379</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16379]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=24139">bpo-24139</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=24139]</span> 中贡献。）</p></li>
<li><p>向 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Connection</span></code></a> 添加了 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.setlimit" title="sqlite3.Connection.setlimit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setlimit()</span></code></a> 和 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.getlimit" title="sqlite3.Connection.getlimit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getlimit()</span></code></a> 用于在连接上设置和获取 SQLite 限制。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45243">bpo-45243</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45243]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/sqlite3.xhtml#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 会基于兼容底层 SQLite 库的默认线程模式来设置 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.threadsafety" title="sqlite3.threadsafety"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sqlite3.threadsafety</span></code></a>。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45613">bpo-45613</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45613]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/sqlite3.xhtml#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> C 回调会在启用了回调回溯的情况下使用不可引发的异常。 用户现在可以注册 <a class="reference internal" href="../library/sys.xhtml#sys.unraisablehook" title="sys.unraisablehook"><code class="xref py py-func docutils literal notranslate"><span class="pre">不可引发的钩子处理器</span></code></a> 来提升其调试体验。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45828">bpo-45828</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45828]</span> 中贡献。）</p></li>
<li><p>跨回滚的获取不会再引发 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.InterfaceError" title="sqlite3.InterfaceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterfaceError</span></code></a>。 而是改为由 SQLite 库来处理这类情况。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44092">bpo-44092</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44092]</span> 中贡献。）</p></li>
<li><p>向 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Connection</span></code></a> 添加了 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.serialize" title="sqlite3.Connection.serialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">serialize()</span></code></a> 和 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.deserialize" title="sqlite3.Connection.deserialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deserialize()</span></code></a> 用于序列化和反序列化数据库。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41930">bpo-41930</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41930]</span> 中贡献。）</p></li>
<li><p>向 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Connection</span></code></a> 添加了 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.create_window_function" title="sqlite3.Connection.create_window_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_window_function()</span></code></a> 用于创建聚合窗口函数。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=34916">bpo-34916</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=34916]</span> 中贡献。）</p></li>
<li><p>向 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Connection</span></code></a> 添加了 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Connection.blobopen" title="sqlite3.Connection.blobopen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">blobopen()</span></code></a>。 <a class="reference internal" href="../library/sqlite3.xhtml#sqlite3.Blob" title="sqlite3.Blob"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Blob</span></code></a> 允许对 blob 进行增量 I/O 操作。 （由 Aviv Palivoda 和 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=24905">bpo-24905</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=24905]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="string">
<span id="whatsnew311-string"></span><h3>string</h3>
<ul class="simple">
<li><p>向 <a class="reference internal" href="../library/string.xhtml#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> 添加了 <a class="reference internal" href="../library/string.xhtml#string.Template.get_identifiers" title="string.Template.get_identifiers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_identifiers()</span></code></a> 和 <a class="reference internal" href="../library/string.xhtml#string.Template.is_valid" title="string.Template.is_valid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_valid()</span></code></a>，它们分别返回全部的有效占位符，以及是否存在无效占位符。 （由 Ben Kehoe 在 <a class="reference external" href="https://github.com/python/cpython/issues/90465">gh-90465</a><span class="link-target"> [https://github.com/python/cpython/issues/90465]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="sys">
<span id="whatsnew311-sys"></span><h3>sys</h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/sys.xhtml#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">traceback</span></code> 字段现在是派生自 <code class="docutils literal notranslate"><span class="pre">value</span></code> (异常实例)，因此当一个异常在处理期间被修改时，其变化会在后续对 <code class="xref py py-func docutils literal notranslate"><span class="pre">exc_info()</span></code> 的调用结果中反映出来。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711">bpo-45711</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711]</span> 中贡献。）</p></li>
<li><p>增加了返回激活的异常实例的 <a class="reference internal" href="../library/sys.xhtml#sys.exception" title="sys.exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exception()</span></code></a> (等价于 <code class="docutils literal notranslate"><span class="pre">sys.exc_info()[1]</span></code>)。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46328">bpo-46328</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46328]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/sys.xhtml#sys.flags" title="sys.flags"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.flags.safe_path</span></code></a> 旗标。 （由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/57684">gh-57684</a><span class="link-target"> [https://github.com/python/cpython/issues/57684]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="sysconfig">
<span id="whatsnew311-sysconfig"></span><h3>sysconfig</h3>
<ul class="simple">
<li><p>增加了三个新的 <a class="reference internal" href="../library/sysconfig.xhtml#installation-paths"><span class="std std-ref">安装方案</span></a> (<em>posix_venv</em>, <em>nt_venv</em> and <em>venv</em>) 并将在 Python 创建新虚拟环境或从虚拟环境运行时使用。 前两个方案 (<em>posix_venv</em> 和 <em>nt_venv</em>) 是用于非 Windows 和 Windows 的 OS 专属方案，<em>venv</em> 实际上是根据 Python 运行所在的 OS 来确定的前两者之一。 这对于要修改 <a class="reference internal" href="../library/sysconfig.xhtml#sysconfig.get_preferred_scheme" title="sysconfig.get_preferred_scheme"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconfig.get_preferred_scheme()</span></code></a> 的下游分发者来说很有用处。 创建新虚拟环境的第三方代码应当使用新的 <em>venv</em> 安装方案来确定路径，就像 <a class="reference internal" href="../library/venv.xhtml#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 所做的那样。 （由 Miro Hrončok 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45413">bpo-45413</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45413]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="tempfile">
<span id="whatsnew311-tempfile"></span><h3>tempfile</h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/tempfile.xhtml#tempfile.SpooledTemporaryFile" title="tempfile.SpooledTemporaryFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpooledTemporaryFile</span></code></a> 对象现在完整实现了 <a class="reference internal" href="../library/io.xhtml#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 或 <a class="reference internal" href="../library/io.xhtml#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 的方法（取决于具体文件模式）。 这使它们能正确地配合接受文件型对象的 API 工作，如压缩文件的模块。 （由 Carey Metcalfe 在 <a class="reference external" href="https://github.com/python/cpython/issues/70363">gh-70363</a><span class="link-target"> [https://github.com/python/cpython/issues/70363]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="threading">
<span id="whatsnew311-threading"></span><h3>threading</h3>
<ul class="simple">
<li><p>在 Unix 上，如果 <code class="docutils literal notranslate"><span class="pre">sem_clockwait()</span></code> 函数存在于 C 库中 (即glibc 2.30 及更新的版本)，则 <a class="reference internal" href="../library/threading.xhtml#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.Lock.acquire()</span></code></a> 方法现在将使用单调时钟 (<a class="reference internal" href="../library/time.xhtml#time.CLOCK_MONOTONIC" title="time.CLOCK_MONOTONIC"><code class="xref py py-const docutils literal notranslate"><span class="pre">time.CLOCK_MONOTONIC</span></code></a>) 来计算超时，而不使用系统时钟 (<a class="reference internal" href="../library/time.xhtml#time.CLOCK_REALTIME" title="time.CLOCK_REALTIME"><code class="xref py py-const docutils literal notranslate"><span class="pre">time.CLOCK_REALTIME</span></code></a>)，以不受系统时钟修改的影响。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41710">bpo-41710</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41710]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="time">
<span id="whatsnew311-time"></span><h3>time</h3>
<ul class="simple">
<li><p>在 Unix 上，如果有可能，<a class="reference internal" href="../library/time.xhtml#time.sleep" title="time.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a> 现在将使用 <code class="docutils literal notranslate"><span class="pre">clock_nanosleep()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nanosleep()</span></code> 函数，其精度为 1 纳秒 (10<sup>-9</sup> 秒)，而不是使用精度为 1 微秒 (10<sup>-6</sup> 秒) 的 <code class="docutils literal notranslate"><span class="pre">select()</span></code>。 （由 Benjamin Szőke 和 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21302">bpo-21302</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21302]</span> 中贡献。）</p></li>
<li><p>在 Windows 8.1 或更新版本上，现在 <a class="reference internal" href="../library/time.xhtml#time.sleep" title="time.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.sleep()</span></code></a> 会使用一个基于 <a class="reference external" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/high-resolution-timers">高精度计时器</a><span class="link-target"> [https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/high-resolution-timers]</span> 的可等待计时器，其精度为 100 纳秒 (10<sup>-7</sup> 秒)。 在之前版本中，其精度为 1 毫秒 (10<sup>-3</sup> 秒)。 （由 Benjamin Szőke, Donghee Na, Eryk Sun 和 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21302">bpo-21302</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21302]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45429">bpo-45429</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45429]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="tkinter">
<span id="whatsnew311-tkinter"></span><h3>tkinter</h3>
<ul class="simple">
<li><p>增加了将 Tcl 库的准确版本号作为类似 <a class="reference internal" href="../library/sys.xhtml#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version_info</span></code></a> 的命名元组返回的方法 <code class="docutils literal notranslate"><span class="pre">info_patchlevel()</span></code>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://github.com/python/cpython/issues/91827">gh-91827</a><span class="link-target"> [https://github.com/python/cpython/issues/91827]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="traceback">
<span id="whatsnew311-traceback"></span><h3>回溯</h3>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/traceback.xhtml#traceback.StackSummary.format_frame_summary" title="traceback.StackSummary.format_frame_summary"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.StackSummary.format_frame_summary()</span></code></a> 以允许用户重载要在回溯中出现哪些帧，以及要如何格式化它们。 （由 Ammar Askar 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44569">bpo-44569</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44569]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/traceback.xhtml#traceback.TracebackException.print" title="traceback.TracebackException.print"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.TracebackException.print()</span></code></a>，该函数可将 <a class="reference internal" href="../library/traceback.xhtml#traceback.TracebackException" title="traceback.TracebackException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TracebackException</span></code></a> 实例格式化打印到一个文件。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33809">bpo-33809</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33809]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="typing">
<span id="whatsnew311-typing"></span><h3>typing</h3>
<p>主要的变化，请参阅 <a class="reference internal" href="#new-feat-related-type-hints-311"><span class="std std-ref">有关类型提示的新增特性</span></a>。</p>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/typing.xhtml#typing.assert_never" title="typing.assert_never"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.assert_never()</span></code></a> 和 <a class="reference internal" href="../library/typing.xhtml#typing.Never" title="typing.Never"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Never</span></code></a>。 <a class="reference internal" href="../library/typing.xhtml#typing.assert_never" title="typing.assert_never"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.assert_never()</span></code></a> 适用于要求类型检查器确认某一行代码是不可达的。 在运行时，它会引发 <a class="reference internal" href="../library/exceptions.xhtml#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>。 （由 Jelle Zijlstra 在 <a class="reference external" href="https://github.com/python/cpython/issues/90633">gh-90633</a><span class="link-target"> [https://github.com/python/cpython/issues/90633]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/typing.xhtml#typing.reveal_type" title="typing.reveal_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.reveal_type()</span></code></a>。 它适用于让类型检查器推理出给定表达式的类型。 在运行时它会打印所接收的值的类型。 （由 Jelle Zijlstra 在 <a class="reference external" href="https://github.com/python/cpython/issues/90572">gh-90572</a><span class="link-target"> [https://github.com/python/cpython/issues/90572]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/typing.xhtml#typing.assert_type" title="typing.assert_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.assert_type()</span></code></a>。 它适用于让类型检查器确认推理出的给定表达式的类型与给定的类型相匹配。 在运行时它将简单地返回所接收的值。 （由 Jelle Zijlstra 在 <a class="reference external" href="https://github.com/python/cpython/issues/90638">gh-90638</a><span class="link-target"> [https://github.com/python/cpython/issues/90638]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/typing.xhtml#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> 类型可以是泛型。 （由 Samodya Abeysiriwardane 在 <a class="reference external" href="https://github.com/python/cpython/issues/89026">gh-89026</a><span class="link-target"> [https://github.com/python/cpython/issues/89026]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/typing.xhtml#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></a> 类型可以是泛型。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43923">bpo-43923</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43923]</span> 中贡献。）</p></li>
<li><p>允许 <a class="reference internal" href="../library/typing.xhtml#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Any</span></code></a> 子类化。 这适用于避免关联到高度动态类的类型检查器错误，例如 mock 类。 （由 Shantanu Jain 在 <a class="reference external" href="https://github.com/python/cpython/issues/91154">gh-91154</a><span class="link-target"> [https://github.com/python/cpython/issues/91154]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/typing.xhtml#typing.final" title="typing.final"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.final()</span></code></a> 装饰器可在被装饰的对象上设置 <code class="docutils literal notranslate"><span class="pre">__final__</span></code> 属性。 （由 Jelle Zijlstra 在 <a class="reference external" href="https://github.com/python/cpython/issues/90500">gh-90500</a><span class="link-target"> [https://github.com/python/cpython/issues/90500]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/typing.xhtml#typing.get_overloads" title="typing.get_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_overloads()</span></code></a> 函数可被用来内省一个函数的重载。 <a class="reference internal" href="../library/typing.xhtml#typing.clear_overloads" title="typing.clear_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.clear_overloads()</span></code></a> 可被用来清理一个函数所有的重载。 （由 Jelle Zijlstra 在 <a class="reference external" href="https://github.com/python/cpython/issues/89263">gh-89263</a><span class="link-target"> [https://github.com/python/cpython/issues/89263]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/typing.xhtml#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 子类的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法将被保留。 （由 Adrian Garcia Badarasco 在 <a class="reference external" href="https://github.com/python/cpython/issues/88970">gh-88970</a><span class="link-target"> [https://github.com/python/cpython/issues/88970]</span> 中贡献。）</p></li>
<li><p>空元组类型 (<code class="docutils literal notranslate"><span class="pre">Tuple[()]</span></code>) 的表示形式已被简化。 这将影响内省操作，例如 <code class="docutils literal notranslate"><span class="pre">get_args(Tuple[()])</span></code> 现在将被求值为 <code class="docutils literal notranslate"><span class="pre">()</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">((),)</span></code>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://github.com/python/cpython/issues/91137">gh-91137</a><span class="link-target"> [https://github.com/python/cpython/issues/91137]</span> 中贡献。）</p></li>
<li><p>通过移除私有 <code class="docutils literal notranslate"><span class="pre">typing._type_check</span></code> 函数的回调检查放松了类型标注的运行时要求。 （由 Gregory Beauregard 在 <a class="reference external" href="https://github.com/python/cpython/issues/90802">gh-90802</a><span class="link-target"> [https://github.com/python/cpython/issues/90802]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/typing.xhtml#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> 支持将字符串求值为 <a class="reference internal" href="../library/stdtypes.xhtml#types-genericalias"><span class="std std-ref">PEP 585 泛型别名</span></a> 中的前向引用。 （由 Niklas Rosenstein 在 <a class="reference external" href="https://github.com/python/cpython/issues/85542">gh-85542</a><span class="link-target"> [https://github.com/python/cpython/issues/85542]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/typing.xhtml#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> 将不再添加 <a class="reference internal" href="../library/typing.xhtml#typing.Optional" title="typing.Optional"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code></a> 到形参并以 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为默认值。 （由 Nikita Sobolev 在 <a class="reference external" href="https://github.com/python/cpython/issues/90353">gh-90353</a><span class="link-target"> [https://github.com/python/cpython/issues/90353]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/typing.xhtml#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> 支持与纯字符串化的 <a class="reference internal" href="../library/typing.xhtml#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 标注进行求值。 （由 Gregory Beauregard 在 <a class="reference external" href="https://github.com/python/cpython/issues/90711">gh-90711</a><span class="link-target"> [https://github.com/python/cpython/issues/90711]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/typing.xhtml#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.no_type_check()</span></code></a> 将不再修改外部类和函数。 现在它还会正确地将类方法标记为不进行类型检查。 （由 Nikita Sobolev 在 <a class="reference external" href="https://github.com/python/cpython/issues/90729">gh-90729</a><span class="link-target"> [https://github.com/python/cpython/issues/90729]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="unicodedata">
<span id="whatsnew311-unicodedata"></span><h3>unicodedata</h3>
<ul class="simple">
<li><p>Unicode 数据库已更新到 14.0.0 版。 （由 Benjamin Peterson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45190">bpo-45190</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45190]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="unittest">
<span id="whatsnew311-unittest"></span><h3>unittest</h3>
<ul class="simple">
<li><p>增加了 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类的 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.enterContext" title="unittest.TestCase.enterContext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enterContext()</span></code></a> 和 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.enterClassContext" title="unittest.TestCase.enterClassContext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enterClassContext()</span></code></a> 方法，<a class="reference internal" href="../library/unittest.xhtml#unittest.IsolatedAsyncioTestCase" title="unittest.IsolatedAsyncioTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsolatedAsyncioTestCase</span></code></a> 类的 <a class="reference internal" href="../library/unittest.xhtml#unittest.IsolatedAsyncioTestCase.enterAsyncContext" title="unittest.IsolatedAsyncioTestCase.enterAsyncContext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enterAsyncContext()</span></code></a> 方法和 <a class="reference internal" href="../library/unittest.xhtml#unittest.enterModuleContext" title="unittest.enterModuleContext"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.enterModuleContext()</span></code></a> 函数。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45046">bpo-45046</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45046]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="venv">
<span id="whatsnew311-venv"></span><h3>venv</h3>
<ul class="simple">
<li><p>当新的 Python 虚拟环境被创建时，将使用 <em>venv</em> <a class="reference internal" href="../library/sysconfig.xhtml#installation-paths"><span class="std std-ref">sysconfig 安装方案</span></a> 来确定环境内部的路径。 当 Python 在虚拟环境中运行时，同一个安装方案将被设为默认。 这意味着下游分发方可以修改默认的 sysconfig 安装方案而不会改变虚拟环境的行为。 同样会创建新的虚拟环境的第三方代码也应当这样做。 （由 Miro Hrončok 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45413">bpo-45413</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45413]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="warnings">
<span id="whatsnew311-warnings"></span><h3>warnings</h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/warnings.xhtml#warnings.catch_warnings" title="warnings.catch_warnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.catch_warnings()</span></code></a> 现在接受 <a class="reference internal" href="../library/warnings.xhtml#warnings.simplefilter" title="warnings.simplefilter"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.simplefilter()</span></code></a> 的参数，这提供了一种在局部忽略警告或将其转为错误的更精确方式。 （由 Zac Hatfield-Dodds 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47074">bpo-47074</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47074]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="zipfile">
<span id="whatsnew311-zipfile"></span><h3>zipfile</h3>
<ul class="simple">
<li><p>增加了为在 <a class="reference internal" href="../library/zipfile.xhtml#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 的目录和文件头中读取元数据指定成员名称编码格式的支持。 （由 Stephen J. Turnbull 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28080">bpo-28080</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28080]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../library/zipfile.xhtml#zipfile.ZipFile.mkdir" title="zipfile.ZipFile.mkdir"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ZipFile.mkdir()</span></code></a> 用于在 ZIP 归档中新建目录。 （由 Sam Ezeh 在 <a class="reference external" href="https://github.com/python/cpython/issues/49083">gh-49083</a><span class="link-target"> [https://github.com/python/cpython/issues/49083]</span> 中贡献。）</p></li>
<li><p>为 <a class="reference internal" href="../library/zipfile.xhtml#zipfile.Path" title="zipfile.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">zipfile.Path</span></code></a> 增加了 <a class="reference internal" href="../library/zipfile.xhtml#zipfile.Path.stem" title="zipfile.Path.stem"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stem</span></code></a>, <a class="reference internal" href="../library/zipfile.xhtml#zipfile.Path.suffix" title="zipfile.Path.suffix"><code class="xref py py-attr docutils literal notranslate"><span class="pre">suffix</span></code></a> 和 <a class="reference internal" href="../library/zipfile.xhtml#zipfile.Path.suffixes" title="zipfile.Path.suffixes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">suffixes</span></code></a>。 （由 Miguel Brito 在 <a class="reference external" href="https://github.com/python/cpython/issues/88261">gh-88261</a><span class="link-target"> [https://github.com/python/cpython/issues/88261]</span> 中贡献。）</p></li>
</ul>
</section>
</section>
<section id="optimizations">
<span id="whatsnew311-optimizations"></span><h2>性能优化</h2>
<p>本节列出的特定优化均不依赖于 <a class="reference internal" href="#whatsnew311-faster-cpython"><span class="std std-ref">更快的 CPython</span></a> 项目，后者将在其专属章节中列出。</p>
<ul class="simple">
<li><p>编译器现在将优化只包含格式代码 <code class="docutils literal notranslate"><span class="pre">%s</span></code>, <code class="docutils literal notranslate"><span class="pre">%r</span></code> 和 <code class="docutils literal notranslate"><span class="pre">%a</span></code> 的字符串字面值中的简单 <a class="reference internal" href="../library/stdtypes.xhtml#old-string-formatting"><span class="std std-ref">printf 风格 % 格式化</span></a> 并使其速度与对应的 <a class="reference internal" href="../glossary.xhtml#term-f-string"><span class="xref std std-term">f-string</span></a> 表达式一样快。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28307">bpo-28307</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28307]</span> 中贡献。）</p></li>
<li><p>整除运算 (<code class="docutils literal notranslate"><span class="pre">//</span></code>) 已进行了更好的编译器微调。 在 x86-64 上现在将 <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 除以小于 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 的值时能够提速 20%。 （由 Gregory P. Smith 和 Tim Peters 在 <a class="reference external" href="https://github.com/python/cpython/issues/90564">gh-90564</a><span class="link-target"> [https://github.com/python/cpython/issues/90564]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/functions.xhtml#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 现在对小于 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 的整数运算可提速将近 30%。 （由 Stefan Behnel 在 <a class="reference external" href="https://github.com/python/cpython/issues/68264">gh-68264</a><span class="link-target"> [https://github.com/python/cpython/issues/68264]</span> 中贡献。）</p></li>
<li><p>列表大小调整针对常见场景进行了优化，对于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">list.append()</span></code> 可提速 ≈15% 而对于简单的 <a class="reference internal" href="../glossary.xhtml#term-list-comprehension"><span class="xref std std-term">list comprehension</span></a> 可提速 20-30%。 （由 Dennis Sweeney 在 <a class="reference external" href="https://github.com/python/cpython/issues/91165">gh-91165</a><span class="link-target"> [https://github.com/python/cpython/issues/91165]</span> 中贡献。）</p></li>
<li><p>字典在所有键均为 Unicode 对象时将不保存哈希值，以缩减 <a class="reference internal" href="../library/stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的大小。 例如，<code class="docutils literal notranslate"><span class="pre">sys.getsizeof(dict.fromkeys(&quot;abcdefg&quot;))</span></code> 在 64 位平台上将从 352 字节缩减为 272 字节（减小 23%）。 （由 Inada Naoki 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46845">bpo-46845</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46845]</span> 中贡献。）</p></li>
<li><p>现在使用 <a class="reference internal" href="../library/asyncio-protocol.xhtml#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.DatagramProtocol</span></code></a> 通过 UDP 传输大文件时速度将有成数量级的提升，对于 ≈60 MiB 的文件将可提速 100 倍以上。 （由 msoxzw 在 <a class="reference external" href="https://github.com/python/cpython/issues/91487">gh-91487</a><span class="link-target"> [https://github.com/python/cpython/issues/91487]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/math.xhtml#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 中的函数 <a class="reference internal" href="../library/math.xhtml#math.comb" title="math.comb"><code class="xref py py-func docutils literal notranslate"><span class="pre">comb()</span></code></a> 和 <a class="reference internal" href="../library/math.xhtml#math.perm" title="math.perm"><code class="xref py py-func docutils literal notranslate"><span class="pre">perm()</span></code></a> 对于大参数可提速 ≈10 倍（对于越大的 <em>k</em> 值提速幅度越大）。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=37295">bpo-37295</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=37295]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/statistics.xhtml#module-statistics" title="statistics: Mathematical statistics functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">statistics</span></code></a> 中的函数 <a class="reference internal" href="../library/statistics.xhtml#statistics.mean" title="statistics.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="../library/statistics.xhtml#statistics.variance" title="statistics.variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">variance()</span></code></a> 和 <a class="reference internal" href="../library/statistics.xhtml#statistics.stdev" title="statistics.stdev"><code class="xref py py-func docutils literal notranslate"><span class="pre">stdev()</span></code></a> 将会直接消耗迭代器而不是先将它们转换为 <a class="reference internal" href="../library/stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>。 这将使速度翻倍并能节省大量内存。 （由 Raymond Hettinger 在 <a class="reference external" href="https://github.com/python/cpython/issues/90415">gh-90415</a><span class="link-target"> [https://github.com/python/cpython/issues/90415]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/unicodedata.xhtml#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a> 将在固定时间内正规化纯 ASCII 字符串。 （由 Donghee Na 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44987">bpo-44987</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44987]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="faster-cpython">
<span id="whatsnew311-faster-cpython"></span><h2>更快的 CPython</h2>
<p>平均而言 CPython 3.11 比 CPython 3.10 <a class="reference external" href="https://github.com/faster-cpython/ideas#published-results">快 25%</a><span class="link-target"> [https://github.com/faster-cpython/ideas#published-results]</span>，该数据是用 <a class="reference external" href="https://github.com/python/pyperformance">pyperformance</a><span class="link-target"> [https://github.com/python/pyperformance]</span> 基准测试套件测得的，基于 Ubuntu Linux 上的 GCC 编译版。 根据工作负载的不同，总的提速效果可达 10-60%。</p>
<p>本项目聚焦于 Python 的两个主要领域: <a class="reference internal" href="#whatsnew311-faster-startup"><span class="std std-ref">更快的启动</span></a> 和 <a class="reference internal" href="#whatsnew311-faster-runtime"><span class="std std-ref">更快的运行时</span></a>。 本项目未涉及的优化将在 <a class="reference internal" href="#whatsnew311-optimizations"><span class="std std-ref">性能优化</span></a> 中单独列出。</p>
<section id="faster-startup">
<span id="whatsnew311-faster-startup"></span><h3>更快的启动</h3>
<section id="frozen-imports-static-code-objects">
<span id="whatsnew311-faster-imports"></span><h4>冻结导入 / 静态代码对象</h4>
<p>Python 会将 <a class="reference internal" href="../glossary.xhtml#term-bytecode"><span class="xref std std-term">bytecode</span></a> 缓存到 <a class="reference internal" href="../tutorial/modules.xhtml#tut-pycache"><span class="std std-ref">__pycache__</span></a> 目录以加快模型加载的速度。</p>
<p>在 3.10 版本时，Python 模块执行类似于这样：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Read __pycache__ -&gt; Unmarshal -&gt; Heap allocated code object -&gt; Evaluate
</pre></div>
</div>
<p>在 Python 3.11 中，对 Python 启动具有关键影响的核心模块已被“冻结”。 这意味着它们的 <a class="reference internal" href="../c-api/code.xhtml#codeobjects"><span class="std std-ref">代码对象</span></a> (及字节码) 将由解释器静态地分配。 这使得模块执行过程的步骤减少为:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Statically allocated code object -&gt; Evaluate
</pre></div>
</div>
<p>现在 Python 3.11 解释器启动加快了 10-15%。 这对使用 Python 的短期运行程序具有显著的影响。</p>
<p>（由 Eric Snow, Guido van Rossum 和 Kumar Aditya 在许多问题事件中贡献。）</p>
</section>
</section>
<section id="faster-runtime">
<span id="whatsnew311-faster-runtime"></span><h3>更快的运行时</h3>
<section id="cheaper-lazy-python-frames">
<span id="whatsnew311-lazy-python-frames"></span><h4>开销更低、更为惰性的 Python 帧</h4>
<p>存放执行信息的 Python 帧会在 Python 调用一个 Python 函数时被自动创建。 下面是新帧的优化操作:</p>
<ul class="simple">
<li><p>优化改进了帧创建进程。</p></li>
<li><p>通过大量重用 C 栈上的帧空间来避免内存分配。</p></li>
<li><p>将内部帧结构优化为仅包含关键信息。 在此之前的帧保存有额外的调试和内存管理信息。</p></li>
</ul>
<p>现在旧式的 <a class="reference internal" href="../reference/datamodel.xhtml#frame-objects"><span class="std std-ref">帧对象</span></a> 仅在调试器或 Python 内省函数如 <a class="reference internal" href="../library/sys.xhtml#sys._getframe" title="sys._getframe"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys._getframe()</span></code></a> 和 <a class="reference internal" href="../library/inspect.xhtml#inspect.currentframe" title="inspect.currentframe"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.currentframe()</span></code></a> 发出请求时才会被创建。 对于大多数用户代码，将不会创建任何帧对象。 因此，几乎所有 Python 函数调用都有显著的提速。 我们在 pyperformance 中测得了 3-7% 的提速。</p>
<p>（由 Mark Shannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44590">bpo-44590</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44590]</span> 中贡献。）</p>
</section>
<section id="inlined-python-function-calls">
<span id="whatsnew311-inline-calls"></span><span id="inline-calls"></span><h4>内联的 Python 函数调用</h4>
<p>在 Python 函数调用期间，Python 将调用一个评测 C 函数来解读该函数的代码。 这会有效地将纯 Python 递归限制在 C 栈的安全范围以内。</p>
<p>在 3.11 中，当 CPython 检测到 Python 代码调用了另一个 Python 函数时，它会设置一个新帧，并“跳转”到新帧内部的新代码。 这可以避免全部调用 C 解析函数。</p>
<p>大多数 Python 函数调用现在将不消耗任何 C 栈空间，这提升了它们的速度。 在简单的递归函数如斐波那契或阶乘函数中，我们测得了 1.7x 的提速。 这还意味着递归函数能够递归得更深（如果用户通过 <a class="reference internal" href="../library/sys.xhtml#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> 提升了递归限制的话）。 我们在 pyperformance 中测得了 1-3% 的提升。</p>
<p>（由 Pablo Galindo 和 Mark Shannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45256">bpo-45256</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45256]</span> 中贡献。）</p>
</section>
<section id="pep-659-specializing-adaptive-interpreter">
<span id="whatsnew311-pep659"></span><h4>PEP 659：专门化自适应解释器</h4>
<p><span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0659/"><strong>PEP 659</strong></a><span class="link-target"> [https://peps.python.org/pep-0659/]</span> 是 Faster CPython 项目的关键部分之一。 基本理念在于虽然 Python 是一种动态语言，但大部分代码都存在对象和类型极少发生变化的区域。 这一理念被称为 <em>类型稳定性</em>。</p>
<p>在运行时，Python 将尝试在所执行的代码中寻找常见模式和类型稳定性。 然后 Python 将把当前的操作替换为更加专门化的操作。 这种专门化的操作使用仅对这些应用场景/类型来说可用的快速路径，它们的性能通常都会超过其泛用型的对应物。 这还带来了名为 <em>内联缓存</em> 的另一项理念，即 Python 会将高消耗的操作的结果直接缓存在 <a class="reference internal" href="../glossary.xhtml#term-bytecode"><span class="xref std std-term">bytecode</span></a> 中。</p>
<p>这个特化程序还会将特定的常见指令对合并为一条超级指令，减少执行期间的开销。</p>
<p>Python 将只特化（会被多次执行的）“热门”代码。 这可以防止 Python 在只执行一次的代码上浪费时间。 Python 还可以在代码过于动态或用法发生变化时取消特化。 特化会定期地尝试，而特化尝试的开销也不高，这使得特化能够适应新的环境改变。</p>
<p>（PEP 由 Mark Shannon 撰写，部分想法由 Stefan Brunthaler 提供。 请参阅 <span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0659/"><strong>PEP 659</strong></a><span class="link-target"> [https://peps.python.org/pep-0659/]</span> 了解详情。 由 Mark Shannon 和 Brandt Bucher 实现，并由 Irit Katriel 和 Dennis Sweeney 提供了额外的帮助。）</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>运算</p></th>
<th class="head"><p>形式</p></th>
<th class="head"><p>专门化</p></th>
<th class="head"><p>运行加速（最高）</p></th>
<th class="head"><p>贡献者</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>双目运算</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code></p>
</td>
<td><p>常见类型如 <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.xhtml#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的双目加法、乘法和减法将采用针对其下层类型专门定制的快速路径。</p></td>
<td><p>10%</p></td>
<td><p>Mark Shannon,
Donghee Na,
Brandt Bucher,
Dennis Sweeney</p></td>
</tr>
<tr class="row-odd"><td><p>下标</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i]</span></code></p></td>
<td><p>对容器类型如 <a class="reference internal" href="../library/stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的下标操作将直接索引下层数据结构。</p>
<p>对自定义 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 的下标操作也是采用类似于 <a class="reference internal" href="#inline-calls"><span class="std std-ref">内联的 Python 函数调用</span></a> 的内联方式。</p>
</td>
<td><p>10-25%</p></td>
<td><p>Irit Katriel,
Mark Shannon</p></td>
</tr>
<tr class="row-even"><td><p>存储下标操作</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">z</span></code></p></td>
<td><p>类似于上述的下标操作专门化。</p></td>
<td><p>10-25%</p></td>
<td><p>Dennis Sweeney</p></td>
</tr>
<tr class="row-odd"><td><p>调用</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f(arg)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">C(arg)</span></code></p>
</td>
<td><p>对常用内置 (C) 函数和类型如 <a class="reference internal" href="../library/functions.xhtml#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的调用将直接调用其下层 C 版本。 这将避免经历内部调用流程。</p></td>
<td><p>20%</p></td>
<td><p>Mark Shannon,
Ken Jin</p></td>
</tr>
<tr class="row-even"><td><p>加载全局变量</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">print</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
</td>
<td><p>对象在全局/内置命名空间中的索引会被缓存。 加载全局和内置变量将不需要命名空间查找过程。</p></td>
<td><p><a class="footnote-reference brackets" href="#load-global" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>Mark Shannon</p></td>
</tr>
<tr class="row-odd"><td><p>加载属性</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o.attr</span></code></p></td>
<td><p>类似于加载全局变量。 属性在类/对象命名空间中的索引会被缓存。 在大多数情况下，加载属性将不需要命名空间查找过程。</p></td>
<td><p><a class="footnote-reference brackets" href="#load-attr" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p>Mark Shannon</p></td>
</tr>
<tr class="row-even"><td><p>加载要调用的方法</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o.meth()</span></code></p></td>
<td><p>方法的实际地址会被缓存。 加载方法现在将不需要命名空间查找过程 -- 即使对于具有较长继承链的类来说也是如此。</p></td>
<td><p>10-20%</p></td>
<td><p>Ken Jin,
Mark Shannon</p></td>
</tr>
<tr class="row-odd"><td><p>存储属性</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o.attr</span> <span class="pre">=</span> <span class="pre">z</span></code></p></td>
<td><p>类似于加载属性的优化。</p></td>
<td><p>2% 的运行效率</p></td>
<td><p>Mark Shannon</p></td>
</tr>
<tr class="row-even"><td><p>解包序列</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*seq</span></code></p></td>
<td><p>针对常见容器如 <a class="reference internal" href="../library/stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.xhtml#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 进行了专门化。 避免内部调用流程。</p></td>
<td><p>8%</p></td>
<td><p>Brandt Bucher</p></td>
</tr>
</tbody>
</table>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="load-global" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>类似的优化自 Python 3.8 起即已存在。 3.11 针对更多形式进行了专门化并减少了部分开销。</p>
</aside>
<aside class="footnote brackets" id="load-attr" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>类似的优化自 Python 3.10 起即已存在。 3.11 针对更多形式进行了专门化。 此外，所有属性加载都应当通过 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45947">bpo-45947</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45947]</span> 获得了加速。</p>
</aside>
</aside>
</section>
</section>
<section id="misc">
<span id="whatsnew311-faster-cpython-misc"></span><h3>杂项</h3>
<ul class="simple">
<li><p>现在由于惰性创建的对象命名空间对象需要的内存将会减少。 它们的命名空间现在还将更自由地共享键。 （由 Mark Shannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45340">bpo-45340</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45340]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40116">bpo-40116</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40116]</span> 中贡献。）</p></li>
<li><p>实现了“零消耗”的异常，可在未引发任何异常时消除 <a class="reference internal" href="../reference/compound_stmts.xhtml#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句的开销。 （由 Mark Shannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40222">bpo-40222</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40222]</span> 中贡献。）</p></li>
<li><p>解释器中更为简洁的异常表示形式使得捕获异常所需的时间减少了大约 10%。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711">bpo-45711</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 的正则表达式匹配引擎已被部分重构，现在会在受支持的平台上使用已计算的 goto（或“线程式代码”）。 因此，Python 3.11 执行 <a class="reference external" href="https://pyperformance.readthedocs.io/benchmarks.html#regex-dna">pyperformance 正则表达式基准测试</a><span class="link-target"> [https://pyperformance.readthedocs.io/benchmarks.html#regex-dna]</span> 相比 Python 3.10 提速了 10%。 （由 Brandt Bucher 在 <a class="reference external" href="https://github.com/python/cpython/issues/91404">gh-91404</a><span class="link-target"> [https://github.com/python/cpython/issues/91404]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="faq">
<span id="whatsnew311-faster-cpython-faq"></span><h3>常见问题</h3>
<section id="how-should-i-write-my-code-to-utilize-these-speedups">
<span id="faster-cpython-faq-my-code"></span><h4>我要如何编写代码以便应用这些加速？</h4>
<p>请编写遵循常见最佳实践的具有 Python 风格的代码；你不需要修改你的代码。 CPython 加速计划会针对我们观察到的常见代码模式进行优化。</p>
</section>
<section id="will-cpython-3-11-use-more-memory">
<span id="faster-cpython-faq-memory"></span><h4>CPython 3.11 会使用更多内存吗？</h4>
<p>可能不会；我们预期内存占用的增加相比 3.10 不会超过 20%。 这是通过上文提及的帧对象和对象字典内存优化来平衡的。</p>
</section>
<section id="i-don-t-see-any-speedups-in-my-workload-why">
<span id="faster-cpython-ymmv"></span><h4>我没有发现我的运行负载有任何加速。 为什么？</h4>
<p>特定代码将不会有明显的收益。 如果你的代码大部时间消耗在 I/O 操作上，或者像 NumPy 那样大部分计算是在 C 扩展库中进行的就将如此。 目前这个项目将只针对纯 Python 的运行负载。</p>
<p>此外，pyperformance 分数是一个几何平均值。 即使在 pyperformance 基准测试内部，特定的基准测试也略有放缓，但其他的基准测试则有将近 2x 的加速！</p>
</section>
<section id="is-there-a-jit-compiler">
<span id="faster-cpython-jit"></span><h4>是否有 JIT 编译器？</h4>
<p>没有。 我们还在探索其他优化方式。</p>
</section>
</section>
<section id="about">
<span id="whatsnew311-faster-cpython-about"></span><h3>关于</h3>
<p>CPython 加速项目探索针对 <a class="reference internal" href="../glossary.xhtml#term-CPython"><span class="xref std std-term">CPython</span></a> 的优化。 项目主团队由 Microsoft 提供资助来支持全职工作。 Pablo Galindo Salgado 还由 Bloomberg LP 提供资助来兼职该项目。 此外，还有许多贡献者是来自社区的志愿者。</p>
</section>
</section>
<section id="cpython-bytecode-changes">
<span id="whatsnew311-bytecode-changes"></span><h2>CPython 字节码的改变</h2>
<p>字节码现在包含内联缓存条目，它采用新增的 <a class="reference internal" href="../library/dis.xhtml#opcode-CACHE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CACHE</span></code></a> 指令形式。 许多操作码都预期带有确切数量的缓存，并指示解释器在运行时跳过它们。 被填充的缓存看起来可以像是任意指令，因此在读取或修改包含加速的数据的原始自适应字节码时应当格外小心。</p>
<section id="new-opcodes">
<span id="whatsnew311-added-opcodes"></span><h3>新的操作码</h3>
<ul class="simple">
<li><p><code class="xref std std-opcode docutils literal notranslate"><span class="pre">ASYNC_GEN_WRAP</span></code>, <a class="reference internal" href="../library/dis.xhtml#opcode-RETURN_GENERATOR"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">RETURN_GENERATOR</span></code></a> 和 <a class="reference internal" href="../library/dis.xhtml#opcode-SEND"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">SEND</span></code></a>，用于生成器和协程。</p></li>
<li><p><a class="reference internal" href="../library/dis.xhtml#opcode-COPY_FREE_VARS"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">COPY_FREE_VARS</span></code></a>，这可以避免需要特别的调用方代码来关闭。</p></li>
<li><p><a class="reference internal" href="../library/dis.xhtml#opcode-JUMP_BACKWARD_NO_INTERRUPT"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">JUMP_BACKWARD_NO_INTERRUPT</span></code></a>，用于某些不希望处理中断的循环。</p></li>
<li><p><a class="reference internal" href="../library/dis.xhtml#opcode-MAKE_CELL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">MAKE_CELL</span></code></a>，用于创建 <a class="reference internal" href="../c-api/cell.xhtml#cell-objects"><span class="std std-ref">Cell 对象</span></a>。</p></li>
<li><p><a class="reference internal" href="../library/dis.xhtml#opcode-CHECK_EG_MATCH"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CHECK_EG_MATCH</span></code></a> 和 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">PREP_RERAISE_STAR</span></code>，用于处理在 <span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0654/"><strong>PEP 654</strong></a><span class="link-target"> [https://peps.python.org/pep-0654/]</span> 中增加的 <a class="reference internal" href="#whatsnew311-pep654"><span class="std std-ref">新异常组和 except*</span></a>。</p></li>
<li><p><a class="reference internal" href="../library/dis.xhtml#opcode-PUSH_EXC_INFO"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">PUSH_EXC_INFO</span></code></a>，用于异常处理器。</p></li>
<li><p><a class="reference internal" href="../library/dis.xhtml#opcode-RESUME"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">RESUME</span></code></a>，空操作，用于内部追踪、调试和优化检查。</p></li>
</ul>
</section>
<section id="replaced-opcodes">
<span id="whatsnew311-replaced-opcodes"></span><h3>被替换的操作码</h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>被替换的操作码</p></th>
<th class="head"><p>新增的操作码</p></th>
<th class="head"><p>备注</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BINARY_*</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">INPLACE_*</span></code></div>
</div>
</td>
<td><p><a class="reference internal" href="../library/dis.xhtml#opcode-BINARY_OP"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BINARY_OP</span></code></a></p></td>
<td><p>用单个操作码替换所有数值类双目/原地操作码</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_FUNCTION</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_FUNCTION_KW</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_METHOD</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="../library/dis.xhtml#opcode-CALL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL</span></code></a></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">KW_NAMES</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">PRECALL</span></code></div>
<div class="line"><a class="reference internal" href="../library/dis.xhtml#opcode-PUSH_NULL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">PUSH_NULL</span></code></a></div>
</div>
</td>
<td><p>对方法的参数变换与关键字参数的处理进行解偶；允许更好的调用特化</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">DUP_TOP</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">DUP_TOP_TWO</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">ROT_TWO</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">ROT_THREE</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">ROT_FOUR</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">ROT_N</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="../library/dis.xhtml#opcode-COPY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">COPY</span></code></a></div>
<div class="line"><a class="reference internal" href="../library/dis.xhtml#opcode-SWAP"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">SWAP</span></code></a></div>
</div>
</td>
<td><p>栈操纵指令</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">JUMP_IF_NOT_EXC_MATCH</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="../library/dis.xhtml#opcode-CHECK_EXC_MATCH"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CHECK_EXC_MATCH</span></code></a></div>
</div>
</td>
<td><p>现在会执行检查但不会跳转</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">JUMP_ABSOLUTE</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_JUMP_IF_FALSE</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_JUMP_IF_TRUE</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="../library/dis.xhtml#opcode-JUMP_BACKWARD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">JUMP_BACKWARD</span></code></a></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_JUMP_BACKWARD_IF_*</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_JUMP_FORWARD_IF_*</span></code></div>
</div>
</td>
<td><p>参见 <a class="footnote-reference brackets" href="#bytecode-jump" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>; 针对每个方向的 <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>, <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>, <code class="docutils literal notranslate"><span class="pre">NONE</span></code> 和 <code class="docutils literal notranslate"><span class="pre">NOT_NONE</span></code> 变种</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">SETUP_WITH</span></code></div>
<div class="line"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">SETUP_ASYNC_WITH</span></code></div>
</div>
</td>
<td><p><a class="reference internal" href="../library/dis.xhtml#opcode-BEFORE_WITH"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BEFORE_WITH</span></code></a></p></td>
<td><p><a class="reference internal" href="../reference/compound_stmts.xhtml#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 代码块设置</p></td>
</tr>
</tbody>
</table>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="bytecode-jump" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>所有跳转操作码现在都是相对的，包括现有的 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">JUMP_IF_TRUE_OR_POP</span></code> 和 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">JUMP_IF_FALSE_OR_POP</span></code>。 该参数现在是相对于当前指令的偏移量而不是绝对位置。</p>
</aside>
</aside>
</section>
<section id="changed-removed-opcodes">
<span id="whatsnew311-changed-removed-opcodes"></span><span id="whatsnew311-removed-opcodes"></span><span id="whatsnew311-changed-opcodes"></span><h3>修改/移除的操作码</h3>
<ul class="simple">
<li><p>修改 <a class="reference internal" href="../library/dis.xhtml#opcode-MATCH_CLASS"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">MATCH_CLASS</span></code></a> 和 <a class="reference internal" href="../library/dis.xhtml#opcode-MATCH_KEYS"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">MATCH_KEYS</span></code></a> 为不再推入额外的布尔值来指示成功/失败。 而是在失败时推入 <code class="docutils literal notranslate"><span class="pre">None</span></code> 来代替由被提取值组成的元组。</p></li>
<li><p>修改配合异常使用的操作码以反映它们现在是由栈上的一个条目而非三个条目代表 (参见 <a class="reference external" href="https://github.com/python/cpython/issues/89874">gh-89874</a><span class="link-target"> [https://github.com/python/cpython/issues/89874]</span>)。</p></li>
<li><p>移除了 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">COPY_DICT_WITHOUT_KEYS</span></code>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">GEN_START</span></code>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_BLOCK</span></code>, <code class="xref std std-opcode docutils literal notranslate"><span class="pre">SETUP_FINALLY</span></code> 和 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">YIELD_FROM</span></code>。</p></li>
</ul>
</section>
</section>
<section id="deprecated">
<span id="whatsnew311-python-api-deprecated"></span><span id="whatsnew311-deprecated"></span><h2>弃用</h2>
<p>本小节列出了已在 Python 3.11 中弃用的 Python API。</p>
<p>已弃用的 C API 将 <a class="reference internal" href="#whatsnew311-c-api-deprecated"><span class="std std-ref">单独列出</span></a>。</p>
<section id="language-builtins">
<span id="whatsnew311-deprecated-builtins"></span><span id="whatsnew311-deprecated-language"></span><h3>语言/内置对象</h3>
<ul class="simple">
<li><p>串连 <a class="reference internal" href="../library/functions.xhtml#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> 描述器（在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19072">bpo-19072</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19072]</span> 中引入）现已被弃用。 它不能再被用来包装其他描述器如 <a class="reference internal" href="../library/functions.xhtml#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a>。 该特性的核心设计存在缺陷并导致了许多下游问题。 要“穿过”一个 <a class="reference internal" href="../library/functions.xhtml#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>，请考虑使用在 Python 3.10 中添加的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性。 （由 Raymond Hettinger 在 <a class="reference external" href="https://github.com/python/cpython/issues/89519">gh-89519</a><span class="link-target"> [https://github.com/python/cpython/issues/89519]</span> 中贡献。）</p></li>
<li><p>数值大于 <code class="docutils literal notranslate"><span class="pre">0o377</span></code> (十进制的 255) 的八进制转义符会产生 <a class="reference internal" href="../library/exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。 在未来的 Python 版本中，这将引发 <a class="reference internal" href="../library/exceptions.xhtml#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 并最终改为 <a class="reference internal" href="../library/exceptions.xhtml#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://github.com/python/cpython/issues/81548">gh-81548</a><span class="link-target"> [https://github.com/python/cpython/issues/81548]</span> 中贡献。）</p></li>
<li><p>现在从 <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 至 <a class="reference internal" href="../reference/datamodel.xhtml#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> 的委托已被弃用。 当 <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> 实现了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code> 但未实现 <a class="reference internal" href="../reference/datamodel.xhtml#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.xhtml#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 时调用 <code class="docutils literal notranslate"><span class="pre">int(a)</span></code> 现在将引发 <a class="reference internal" href="../library/exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。 （由 Zackery Spytz 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44977">bpo-44977</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44977]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="modules">
<span id="whatsnew311-deprecated-modules"></span><h3>模块</h3>
<ul id="whatsnew311-pep594">
<li><p><span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0594/"><strong>PEP 594</strong></a><span class="link-target"> [https://peps.python.org/pep-0594/]</span> 使得以下模块被弃用并将在 Python 3.13 中被移除:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/aifc.xhtml#module-aifc" title="aifc: Read and write audio files in AIFF or AIFC format.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/chunk.xhtml#module-chunk" title="chunk: Module to read IFF chunks.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">chunk</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/msilib.xhtml#module-msilib" title="msilib: Creation of Microsoft Installer files, and CAB files.（已弃用） (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">msilib</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/pipes.xhtml#module-pipes" title="pipes: A Python interface to Unix shell pipelines.（已弃用） (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pipes</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/telnetlib.xhtml#module-telnetlib" title="telnetlib: Telnet client class.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">telnetlib</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/audioop.xhtml#module-audioop" title="audioop: Manipulate raw audio data.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/crypt.xhtml#module-crypt" title="crypt: The crypt() function used to check Unix passwords.（已弃用） (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">crypt</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/nis.xhtml#module-nis" title="nis: Interface to Sun's NIS (Yellow Pages) library.（已弃用） (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nis</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/sndhdr.xhtml#module-sndhdr" title="sndhdr: Determine type of a sound file.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sndhdr</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/uu.xhtml#module-uu" title="uu: Encode and decode files in uuencode format.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">uu</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/cgi.xhtml#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/imghdr.xhtml#module-imghdr" title="imghdr: Determine the type of image contained in a file or byte stream.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">imghdr</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/nntplib.xhtml#module-nntplib" title="nntplib: NNTP protocol client (requires sockets).（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/spwd.xhtml#module-spwd" title="spwd: The shadow password database (getspnam() and friends).（已弃用） (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spwd</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/xdrlib.xhtml#module-xdrlib" title="xdrlib: Encoders and decoders for the External Data Representation (XDR).（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xdrlib</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/cgitb.xhtml#module-cgitb" title="cgitb: Configurable traceback handler for CGI scripts.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgitb</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/mailcap.xhtml#module-mailcap" title="mailcap: Mailcap file handling.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mailcap</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/ossaudiodev.xhtml#module-ossaudiodev" title="ossaudiodev: Access to OSS-compatible audio devices.（已弃用） (Linux, FreeBSD)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ossaudiodev</span></code></a></p></td>
<td><p><a class="reference internal" href="../library/sunau.xhtml#module-sunau" title="sunau: Provide an interface to the Sun AU sound format.（已弃用）"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sunau</span></code></a></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>（由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47061">bpo-47061</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47061]</span> 以及 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/68966">gh-68966</a><span class="link-target"> [https://github.com/python/cpython/issues/68966]</span> 中贡献。）</p>
</li>
<li><p>至少从 Python 3.6 起 <code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">smtpd</span></code> 模块已被弃用。 它们的文档和弃用警告现在已更新为提示它们将在 Python 3.12 中被移除。 （由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47022">bpo-47022</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47022]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/2to3.xhtml#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a> 包和 <a class="reference internal" href="../library/2to3.xhtml#to3-reference"><span class="std std-ref">2to3</span></a> 工具现已被弃用并可能无法解析 Python 3.10 或更新版本。 参见引入新 PEG 解析器的 <span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0617/"><strong>PEP 617</strong></a><span class="link-target"> [https://peps.python.org/pep-0617/]</span> 了解详情。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40360">bpo-40360</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40360]</span> 中贡献。）</p></li>
<li><p>未写入文档的模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sre_compile</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">sre_constants</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sre_parse</span></code> 现已被弃用。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47152">bpo-47152</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47152]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="standard-library">
<span id="whatsnew311-deprecated-stdlib"></span><h3>标准库</h3>
<ul>
<li><p><a class="reference internal" href="../library/configparser.xhtml#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 的下列部分自 Python 3.2 起已被弃用。 现在它们的弃用警告已更新为提示它们将在 Python 3.12 中被移除:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">configparser.SafeConfigParser</span></code> 类</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">configparser.ParsingError.filename</span></code> 特征属性</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">configparser.RawConfigParser.readfp()</span></code> 方法</p></li>
</ul>
<p>（由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45173">bpo-45173</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45173]</span> 中贡献。）</p>
</li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">configparser.LegacyInterpolation</span></code> 自 Python 3.2 起已在文档字符串中被弃用，并未在 <a class="reference internal" href="../library/configparser.xhtml#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 文档中列出。 现在它将发出 <a class="reference internal" href="../library/exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 并将在 Python 3.13 中被移除。 请改用 <a class="reference internal" href="../library/configparser.xhtml#configparser.BasicInterpolation" title="configparser.BasicInterpolation"><code class="xref py py-class docutils literal notranslate"><span class="pre">configparser.BasicInterpolation</span></code></a> 或 <a class="reference internal" href="../library/configparser.xhtml#configparser.ExtendedInterpolation" title="configparser.ExtendedInterpolation"><code class="xref py py-class docutils literal notranslate"><span class="pre">configparser.ExtendedInterpolation</span></code></a>。 （由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46607">bpo-46607</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46607]</span> 中贡献。）</p></li>
<li><p>较旧的 <a class="reference internal" href="../library/importlib.resources.xhtml#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> 函数集合已被弃用而改用在 Python 3.9 中添加的替代物并将在未来的 Python 版本中被移除，因为它们不支持位于 package 子目录下的资源:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.contents" title="importlib.resources.contents"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.contents()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.is_resource" title="importlib.resources.is_resource"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.is_resource()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.open_binary" title="importlib.resources.open_binary"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.open_binary()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.open_text" title="importlib.resources.open_text"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.open_text()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.read_binary" title="importlib.resources.read_binary"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.read_binary()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.read_text" title="importlib.resources.read_text"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.read_text()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/importlib.resources.xhtml#importlib.resources.path" title="importlib.resources.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.path()</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="../library/locale.xhtml#locale.getdefaultlocale" title="locale.getdefaultlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getdefaultlocale()</span></code></a> 函数已被弃用并将在 Python 3.15 中移除。 请改用 <a class="reference internal" href="../library/locale.xhtml#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale()</span></code></a>, <a class="reference internal" href="../library/locale.xhtml#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getpreferredencoding(False)</span></code></a> 和 <a class="reference internal" href="../library/locale.xhtml#locale.getlocale" title="locale.getlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getlocale()</span></code></a> 函数。 （由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/90817">gh-90817</a><span class="link-target"> [https://github.com/python/cpython/issues/90817]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/locale.xhtml#locale.resetlocale" title="locale.resetlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.resetlocale()</span></code></a> 函数已被弃用并将在 Python 3.13 中移除。 请改用 <code class="docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_ALL,</span> <span class="pre">&quot;&quot;)</span></code>。 （由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/90817">gh-90817</a><span class="link-target"> [https://github.com/python/cpython/issues/90817]</span> 中贡献。）</p></li>
<li><p>现在对于 <a class="reference internal" href="../library/re.xhtml#re-syntax"><span class="std std-ref">正则表达式</span></a> 中的数字分组引用和分组名称将应用更严格的规则。 现在只有 ASCII 数字序列会被接受作为数字引用，而 <a class="reference internal" href="../library/stdtypes.xhtml#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 模式和替换字符串中的分组名称只能包含 ASCII 字母、数字和下划线。 目前对于违反这些规则的语法将会引发弃用警告。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://github.com/python/cpython/issues/91760">gh-91760</a><span class="link-target"> [https://github.com/python/cpython/issues/91760]</span> 中贡献。）</p></li>
<li><p>在 <a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块中，<code class="xref py py-func docutils literal notranslate"><span class="pre">re.template()</span></code> 函数和相应的 <code class="xref py py-const docutils literal notranslate"><span class="pre">re.TEMPLATE</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">re.T</span></code> 旗标已被弃用，因为它们未被写入文档并缺少明显的目的。 它们将在 Python 3.13 中移除。 （由 Serhiy Storchaka 和 Miro Hrončok 在 <a class="reference external" href="https://github.com/python/cpython/issues/92728">gh-92728</a><span class="link-target"> [https://github.com/python/cpython/issues/92728]</span> 由贡献。）</p></li>
<li><p><a class="reference internal" href="../library/turtle.xhtml#turtle.settiltangle" title="turtle.settiltangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">turtle.settiltangle()</span></code></a> 自 Python 3.1 起已被弃用；现在它会发出弃用警告并将在 Python 3.13 中移除。 请改用 <a class="reference internal" href="../library/turtle.xhtml#turtle.tiltangle" title="turtle.tiltangle"><code class="xref py py-func docutils literal notranslate"><span class="pre">turtle.tiltangle()</span></code></a> (该函数在此前被错误地标记为已弃用，现在它的文档字符串已被修正)。 （由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45837">bpo-45837</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45837]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/typing.xhtml#typing.Text" title="typing.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Text</span></code></a>，它的存在只是为了在 Python 2 和 Python 3 代码之间提供兼容性支持，现在已被弃用。 目前尚无移除它的计划，但推荐用户在任何可能的地方改用 <a class="reference internal" href="../library/stdtypes.xhtml#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。 （由 Alex Waygood 在 <a class="reference external" href="https://github.com/python/cpython/issues/92332">gh-92332</a><span class="link-target"> [https://github.com/python/cpython/issues/92332]</span> 中贡献。）</p></li>
<li><p>用于构造 <a class="reference internal" href="../library/typing.xhtml#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> 类型的关键字参数语法现在已被弃用。 将在 Python 3.13 中移除对它的支持。 （由 Jingchen Ye 在 <a class="reference external" href="https://github.com/python/cpython/issues/90224">gh-90224</a><span class="link-target"> [https://github.com/python/cpython/issues/90224]</span> 中贡献。）</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">webbrowser.MacOSX</span></code> 已被弃用并将在 Python 3.13 中移除。 它未经测试，未写入文档，也未被 <a class="reference internal" href="../library/webbrowser.xhtml#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a> 本身所使用。 （由 Donghee Na 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42255">bpo-42255</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42255]</span> 中贡献。）</p></li>
<li><p>从 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 和 <a class="reference internal" href="../library/unittest.xhtml#unittest.IsolatedAsyncioTestCase" title="unittest.IsolatedAsyncioTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsolatedAsyncioTestCase</span></code></a> 测试方法返回一个值（默认的 <code class="docutils literal notranslate"><span class="pre">None</span></code> 以外的值）的行为现在已被弃用。</p></li>
<li><p>已弃用下列未正式写入文档的 <a class="reference internal" href="../library/unittest.xhtml#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 函数，计划在 Python 3.13 中移除:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.findTestCases()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.makeSuite()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.getTestCaseNames()</span></code></p></li>
</ul>
<p>请改用 <a class="reference internal" href="../library/unittest.xhtml#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 方法:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unittest.TestLoader.loadTestsFromModule()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestLoader.loadTestsFromTestCase" title="unittest.TestLoader.loadTestsFromTestCase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unittest.TestLoader.loadTestsFromTestCase()</span></code></a></p></li>
<li><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unittest.TestLoader.getTestCaseNames()</span></code></a></p></li>
</ul>
<p>（由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5846">bpo-5846</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5846]</span> 中贡献。）</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">unittest.TestProgram.usageExit()</span></code> 被标记为已弃用，将在 3.13 中被移除。 （由 Carlos Damázio 在 <a class="reference external" href="https://github.com/python/cpython/issues/67048">gh-67048</a><span class="link-target"> [https://github.com/python/cpython/issues/67048]</span> 中贡献。）</p></li>
</ul>
</section>
</section>
<section id="pending-removal-in-python-3-12">
<span id="whatsnew311-python-api-pending-removal"></span><span id="whatsnew311-pending-removal"></span><h2>计划在 Python 3.12 中移除</h2>
<p>以下 Python API 已在之前的 Python 发布版中弃用，并将在 Python 3.12 中移除。</p>
<p>C API 的移除计划将 <a class="reference internal" href="#whatsnew311-c-api-pending-removal"><span class="std std-ref">单独列出</span></a>。</p>
<ul>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code> 模块</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> 模块</p></li>
<li><p><a class="reference internal" href="3.10.xhtml#distutils-deprecated"><span class="std std-ref">整个 distutils 包</span></a></p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">imp</span></code> 模块</p></li>
<li><p><a class="reference internal" href="../library/typing.xhtml#typing.IO" title="typing.IO"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.io</span></code></a> 命名空间</p></li>
<li><p><a class="reference internal" href="../library/typing.xhtml#typing.Pattern" title="typing.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.re</span></code></a> 命名空间</p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">cgi.log()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.find_loader()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.module_repr()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder.find_module()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.find_loader()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.find_module()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter.find_module()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinLoader.module_repr()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.FileFinder.find_loader()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.FileFinder.find_module()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.FrozenImporter.find_module()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.FrozenLoader.module_repr()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_module()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.WindowsRegistryFinder.find_module()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.set_loader_wrapper()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.set_package_wrapper()</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pkgutil.ImpImporter</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pkgutil.ImpLoader</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">pathlib.Path.link_to()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">sqlite3.enable_shared_cache()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">sqlite3.OptimizedUnicode()</span></code></p></li>
<li><p><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONTHREADDEBUG</span></code> 环境变量</p></li>
<li><p>The following deprecated aliases in <a class="reference internal" href="../library/unittest.xhtml#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 中的下列已弃用别名:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>已弃用的别名</p></th>
<th class="head"><p>方法名</p></th>
<th class="head"><p>弃用于</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">failUnless</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">failIf</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">failUnlessEqual</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">failIfEqual</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">failUnlessAlmostEqual</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">failIfAlmostEqual</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">failUnlessRaises</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">assert_</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assertEquals</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">assertNotEquals</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assertAlmostEquals</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">assertNotAlmostEquals</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code></p></td>
<td><p><a class="reference internal" href="../library/unittest.xhtml#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a></p></td>
<td><p>3.5</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
</ul>
</section>
<section id="removed">
<span id="whatsnew311-python-api-removed"></span><span id="whatsnew311-removed"></span><h2>移除</h2>
<p>本小节列出了已在 Python 3.11 中移除的 Python API。</p>
<p>已移除的 C API 将 <a class="reference internal" href="#whatsnew311-c-api-removed"><span class="std std-ref">单独列出</span></a>。</p>
<ul>
<li><p>移除了允许旧式基于生成器的协程兼容 <a class="reference internal" href="../reference/compound_stmts.xhtml#async"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span></code></a> / <a class="reference internal" href="../reference/expressions.xhtml#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 代码的 <code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;asyncio.coroutine()</span></code> <a class="reference internal" href="../glossary.xhtml#term-decorator"><span class="xref std std-term">decorator</span></a>。 该函数自 Python 3.8 起已被弃用并且原定在 Python 3.10 中移除。 请改用 <a class="reference internal" href="../reference/compound_stmts.xhtml#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>。 （由 Illia Volochii 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43216">bpo-43216</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43216]</span> 中贡献。）</p></li>
<li><p>移除了用于在调试模式下包装旧式基于生成器的协程对象的 <code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.coroutines.CoroWrapper</span></code>。 （由 Illia Volochii 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43216">bpo-43216</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43216]</span> 中贡献。）</p></li>
<li><p>出于显著的安全性考量，自 Python 3.9 起已被禁用的 <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.loop.create_datagram_endpoint()</span></code></a> 的 <em>reuse_address</em> 形参现在已彻底移除。 这是因为在 UDP 中套接字选项 <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> 的行为。 （由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45129">bpo-45129</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45129]</span> 中贡献。）</p></li>
<li><p>移除了自 Python 3.9 起已弃用的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">binhex</span></code> 模块。 并移除了相关联的同样已弃用的 <a class="reference internal" href="../library/binascii.xhtml#module-binascii" title="binascii: Tools for converting between binary and various ASCII-encoded binary representations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">binascii</span></code></a> 函数:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">binascii.a2b_hqx()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">binascii.b2a_hqx()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">binascii.rlecode_hqx()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">binascii.rldecode_hqx()</span></code></p></li>
</ul>
<p><a class="reference internal" href="../library/binascii.xhtml#binascii.crc_hqx" title="binascii.crc_hqx"><code class="xref py py-func docutils literal notranslate"><span class="pre">binascii.crc_hqx()</span></code></a> 函数仍然可用。</p>
<p>（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45085">bpo-45085</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45085]</span> 中贡献。）</p>
</li>
<li><p>移除了自 Python 3.9 起已弃用的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils</span></code> <code class="docutils literal notranslate"><span class="pre">bdist_msi</span></code> 命令。 请改用 <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> (wheel 包)。 （由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45124">bpo-45124</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45124]</span> 中贡献。）</p></li>
<li><p>移除了自 Python 3.9 起已弃用的 <a class="reference internal" href="../library/xml.dom.pulldom.xhtml#xml.dom.pulldom.DOMEventStream" title="xml.dom.pulldom.DOMEventStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">xml.dom.pulldom.DOMEventStream</span></code></a>, <a class="reference internal" href="../library/wsgiref.xhtml#wsgiref.util.FileWrapper" title="wsgiref.util.FileWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">wsgiref.util.FileWrapper</span></code></a> 和 <a class="reference internal" href="../library/fileinput.xhtml#fileinput.FileInput" title="fileinput.FileInput"><code class="xref py py-class docutils literal notranslate"><span class="pre">fileinput.FileInput</span></code></a> 的 <a class="reference internal" href="../reference/datamodel.xhtml#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法。 （由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45132">bpo-45132</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45132]</span> 中贡献。）</p></li>
<li><p>移除了已弃用的 <a class="reference internal" href="../library/gettext.xhtml#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a> 函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">lgettext()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">ldgettext()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">lngettext()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">ldngettext()</span></code>。 并移除了 <code class="xref py py-func docutils literal notranslate"><span class="pre">bind_textdomain_codeset()</span></code> 函数、<code class="xref py py-meth docutils literal notranslate"><span class="pre">NullTranslations.output_charset()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">NullTranslations.set_output_charset()</span></code> 方法，以及 <code class="xref py py-func docutils literal notranslate"><span class="pre">translation()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">install()</span></code> 的 <em>codeset</em> 形参 ，因为它们仅被用于 <code class="xref py py-func docutils literal notranslate"><span class="pre">l*gettext()</span></code> 函数。 （由 Donghee Na 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44235">bpo-44235</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44235]</span> 中贡献。）</p></li>
<li><p>已从 <a class="reference internal" href="../library/inspect.xhtml#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块中移除:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">getargspec()</span></code> 函数自 Python 3.0 起已被弃用；请改用 <a class="reference internal" href="../library/inspect.xhtml#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.signature()</span></code></a> 或 <a class="reference internal" href="../library/inspect.xhtml#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getfullargspec()</span></code></a>。</p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">formatargspec()</span></code> 函数自 Python 3.5 起已被弃用；请改用 <a class="reference internal" href="../library/inspect.xhtml#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.signature()</span></code></a> 函数或直接使用 <a class="reference internal" href="../library/inspect.xhtml#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Signature</span></code></a> 对象。</p></li>
<li><p>未写入文档的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.from_builtin()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.from_function()</span></code> 方法自 Python 3.5 起已被弃用；请改用 <a class="reference internal" href="../library/inspect.xhtml#inspect.Signature.from_callable" title="inspect.Signature.from_callable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.from_callable()</span></code></a> 方法。</p></li>
</ul>
<p>（由 Hugo van Kemenade 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45320">bpo-45320</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45320]</span> 中贡献。）</p>
</li>
<li><p>从 <a class="reference internal" href="../library/pathlib.xhtml#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.PurePath</span></code></a> 中移除了 <a class="reference internal" href="../reference/datamodel.xhtml#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> 方法，因为它从未被使用而是在之前版本中误添加的。 （由 Nikita Sobolev 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46483">bpo-46483</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46483]</span> 中贡献。）</p></li>
<li><p>移除了 <code class="xref py py-mod docutils literal notranslate"><span class="pre">smtpd</span></code> 模块中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">MailmanProxy</span></code> 类，因为它在没有外部 <code class="xref py py-mod docutils literal notranslate"><span class="pre">mailman</span></code> 包时是无法使用的。 （由 Donghee Na 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35800">bpo-35800</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35800]</span> 中贡献。）</p></li>
<li><p>移除了 <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.TkappType</span></code> 中已被弃用的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code> 方法。 （由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=38371">bpo-38371</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=38371]</span> 中贡献。）</p></li>
<li><p>从 <a class="reference internal" href="../library/unittest.xhtml#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 发现中移除了命名空间包支持。 它在 Python 3.4 中引入但自 Python 3.7 起已不可用。 （由 Inada Naoki 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=23882">bpo-23882</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=23882]</span> 中贡献。）</p></li>
<li><p>移除了未写入文档的私有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">float.__set_format__()</span></code> 方法，之前在 Python 3.7 中名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">float.__setformat__()</span></code>。 其文档字符串已写明：“你应该不需要使用此函数。 它的存在主要是用于 Python 的测试套件。” （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46852">bpo-46852</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46852]</span> 中贡献。）</p></li>
<li><p><code class="xref std std-option docutils literal notranslate"><span class="pre">--experimental-isolated-subinterpreters</span></code> 配置旗标（和相应的 <code class="xref c c-macro docutils literal notranslate"><span class="pre">EXPERIMENTAL_ISOLATED_SUBINTERPRETERS</span></code> 宏）已被移除。</p></li>
<li><p><a class="reference external" href="https://pypi.org/project/Pynche/">Pynche</a><span class="link-target"> [https://pypi.org/project/Pynche/]</span> --- The Pythonically Natural Color and Hue Editor --- 已被移出 <code class="docutils literal notranslate"><span class="pre">Tools/scripts</span></code> 并且脱离Python 源代码树转为 <a class="reference external" href="https://gitlab.com/warsaw/pynche/-/tree/main">独立开发</a><span class="link-target"> [https://gitlab.com/warsaw/pynche/-/tree/main]</span>。</p></li>
</ul>
</section>
<section id="porting-to-python-3-11">
<span id="whatsnew311-python-api-porting"></span><span id="whatsnew311-porting"></span><h2>移植到 Python 3.11</h2>
<p>本节列出了先前描述的更改以及 Python API 中可能需要修改你的 Python 代码的其他错误修正。</p>
<p>针对 C API 的移植说明将 <a class="reference internal" href="#whatsnew311-c-api-porting"><span class="std std-ref">单独列出</span></a>。</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/functions.xhtml#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, <a class="reference internal" href="../library/io.xhtml#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a>, <a class="reference internal" href="../library/codecs.xhtml#codecs.open" title="codecs.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.open()</span></code></a> 和 <a class="reference internal" href="../library/fileinput.xhtml#fileinput.FileInput" title="fileinput.FileInput"><code class="xref py py-class docutils literal notranslate"><span class="pre">fileinput.FileInput</span></code></a> 的文件模式中不再接受 <code class="docutils literal notranslate"><span class="pre">'U'</span></code> (&quot;通用换行符&quot;)。 在 Python 3 中，&quot;通用换行符&quot; 模式会在文件以文本模式打开时默认被使用，而 <code class="docutils literal notranslate"><span class="pre">'U'</span></code> 旗标自 Python 3.3 起已被弃用。 这些函数的 <a class="reference internal" href="../library/functions.xhtml#open-newline-parameter"><span class="std std-ref">newline 形参</span></a> 将控制如何使用通用换行符。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=37330">bpo-37330</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=37330]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/ast.xhtml#ast.AST" title="ast.AST"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.AST</span></code></a> 节点位置在提供给 <a class="reference internal" href="../library/functions.xhtml#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 和其他相关函数时会进行验证。 如果检测到无效位置， 将会引发 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 （由 Pablo Galindo 在 <a class="reference external" href="https://github.com/python/cpython/issues/93351">gh-93351</a><span class="link-target"> [https://github.com/python/cpython/issues/93351]</span> 中提供。）</p></li>
<li><p>继在 Python 3.8 中弃用后，已禁止向 <a class="reference internal" href="../library/asyncio-eventloop.xhtml#asyncio.loop.set_default_executor" title="asyncio.loop.set_default_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.loop.set_default_executor()</span></code></a> 传入非 <a class="reference internal" href="../library/concurrent.futures.xhtml#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a> 执行器。（由 Illia Volochii 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43234">bpo-43234</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43234]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/calendar.xhtml#module-calendar" title="calendar: Functions for working with calendars, including some emulation of the Unix cal program."><code class="xref py py-mod docutils literal notranslate"><span class="pre">calendar</span></code></a>: 在未指定语言区域的情况下，<a class="reference internal" href="../library/calendar.xhtml#calendar.LocaleTextCalendar" title="calendar.LocaleTextCalendar"><code class="xref py py-class docutils literal notranslate"><span class="pre">calendar.LocaleTextCalendar</span></code></a> 和 <a class="reference internal" href="../library/calendar.xhtml#calendar.LocaleHTMLCalendar" title="calendar.LocaleHTMLCalendar"><code class="xref py py-class docutils literal notranslate"><span class="pre">calendar.LocaleHTMLCalendar</span></code></a> 类现在会使用 <a class="reference internal" href="../library/locale.xhtml#locale.getlocale" title="locale.getlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getlocale()</span></code></a>，而不是使用 <a class="reference internal" href="../library/locale.xhtml#locale.getdefaultlocale" title="locale.getdefaultlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getdefaultlocale()</span></code></a>。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46659">bpo-46659</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46659]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../library/pdb.xhtml#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 模块会使用 <code class="docutils literal notranslate"><span class="pre">'UTF-8'</span></code> 编码来读取 <code class="file docutils literal notranslate"><span class="pre">.pdbrc</span></code> 配置文件。 （由 Srinivas Reddy Thatiparthy (శ్రీనివాస్ రెడ్డి తాటిపర్తి) 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41137">bpo-41137</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41137]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/random.xhtml#random.sample" title="random.sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.sample()</span></code></a> 的 <em>population</em> 形参必须是一个序列，不再支持将 <a class="reference internal" href="../library/stdtypes.xhtml#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 自动转换为 <a class="reference internal" href="../library/stdtypes.xhtml#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>。 此外，如果样本大小大于总体大小，将会引发 <a class="reference internal" href="../library/exceptions.xhtml#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 。 （由 Raymond Hettinger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40465">bpo-40465</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40465]</span> 中贡献。）</p></li>
<li><p>移除了 <a class="reference internal" href="../library/random.xhtml#random.shuffle" title="random.shuffle"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.shuffle()</span></code></a> 的 <em>random</em> 可选形参。 在之前版本中重排操作是使用任意随机函数；现在，将始终使用 <a class="reference internal" href="../library/random.xhtml#random.random" title="random.random"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.random()</span></code></a> (之前的默认值)。</p></li>
<li><p>在 <a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> <a class="reference internal" href="../library/re.xhtml#re-syntax"><span class="std std-ref">正则表达式语法</span></a> 中，全局内联旗标 (例如 <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>) 现在只能在正则表达式的开头使用。 自 Python 3.6 起在别处使用这些旗标的做法已被弃用。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47066">bpo-47066</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=47066]</span> 中贡献）。</p></li>
<li><p>在 <a class="reference internal" href="../library/re.xhtml#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块中，修复了几个长期存在的错误，在极少数情况下，这些错误可能会导致捕获分组得到错误的结果。 因此，这可能会改变这些情况下的捕获输出。 （由 Ma Lin 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35859">bpo-35859</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35859]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="build-changes">
<span id="whatsnew311-build-changes"></span><h2>构建的改变</h2>
<ul>
<li><p>CPython 现已具有 <span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0011/"><strong>PEP 11</strong></a><span class="link-target"> [https://peps.python.org/pep-0011/]</span> <span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0011/#tier-3"><strong>Tier 3 support</strong></a><span class="link-target"> [https://peps.python.org/pep-0011/#tier-3]</span> 以便交叉编译至 <a class="reference external" href="https://webassembly.org/">WebAssembly</a><span class="link-target"> [https://webassembly.org/]</span> 平台 <a class="reference external" href="https://emscripten.org/">Emscripten</a><span class="link-target"> [https://emscripten.org/]</span> (<code class="docutils literal notranslate"><span class="pre">wasm32-unknown-emscripten</span></code> 即浏览器版 Python) 和 <a class="reference external" href="https://wasi.dev/">WebAssembly System Interface (WASI)</a><span class="link-target"> [https://wasi.dev/]</span> (<code class="docutils literal notranslate"><span class="pre">wasm32-unknown-wasi</span></code>)。 此计划的灵感来自前人的工作如 <a class="reference external" href="https://pyodide.org/">Pyodide</a><span class="link-target"> [https://pyodide.org/]</span>。 这些平台提供了 POSIX API 的有限子集；与网络、进程、线程、信号、mmap 和用户/组相关的 Python 标准库特性和模块将不可用或无法正常工作。 （Emscripten 由 Christian Heimes 和 Ethan Smith 在 <a class="reference external" href="https://github.com/python/cpython/issues/84461">gh-84461</a><span class="link-target"> [https://github.com/python/cpython/issues/84461]</span> 中贡献，WASI 由 Christian Heimes 在 <a class="reference external" href="https://github.com/python/cpython/issues/90473">gh-90473</a><span class="link-target"> [https://github.com/python/cpython/issues/90473]</span> 中贡献；平台的推进在 <a class="reference external" href="https://github.com/python/cpython/issues/95085">gh-95085</a><span class="link-target"> [https://github.com/python/cpython/issues/95085]</span> 中追踪。）</p></li>
<li><p>构建 CPython 现在需要:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.cppreference.com/w/c/11">C11</a><span class="link-target"> [https://en.cppreference.com/w/c/11]</span> 编译器和标准库。 <a class="reference external" href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)#Optional_features">可选的 C11 特性</a><span class="link-target"> [https://en.wikipedia.org/wiki/C11_(C_standard_revision)#Optional_features]</span> 不是必须的。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46656">bpo-46656</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46656]</span>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45440">bpo-45440</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45440]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46640">bpo-46640</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46640]</span> 中贡献。）</p></li>
<li><p>对 <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a><span class="link-target"> [https://en.wikipedia.org/wiki/IEEE_754]</span> 浮点数的支持。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46917">bpo-46917</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46917]</span> 中贡献。）</p></li>
</ul>
</li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_NO_NAN</span></code> 宏已被移除。 由于 CPython 现在要求 IEEE 754 浮点数，NaN 值将始终可用。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46656">bpo-46656</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46656]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../library/tkinter.xhtml#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a> 包现在需要 <a class="reference external" href="https://www.tcl.tk">Tcl/Tk</a><span class="link-target"> [https://www.tcl.tk]</span> 8.5.12 或更新的版本。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46996">bpo-46996</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46996]</span> 中贡献。）</p></li>
<li><p>大多数标准库扩展模块的构建依赖、编译器旗标和链接器旗标现在将由 <strong class="program">configure</strong> 来检测。 libffi, libnsl, libsqlite3, zlib, bzip2, liblzma, libcrypt, Tcl/Tk 和 uuid 旗标将由 <a class="reference external" href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a><span class="link-target"> [https://www.freedesktop.org/wiki/Software/pkg-config/]</span> (如果可用) 来检测。 <a class="reference internal" href="../library/tkinter.xhtml#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a> 现在需要由 pkg-config 命令来检测 <a class="reference external" href="https://www.tcl.tk">Tcl/Tk</a><span class="link-target"> [https://www.tcl.tk]</span> 标头和库的开发设置。 （由 Christian Heimes 和 Erlend Egeberg Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45847">bpo-45847</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45847]</span>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45747">bpo-45747</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45747]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45763">bpo-45763</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45763]</span> 中贡献。）</p></li>
<li><p>libpython 不再与 libcrypt 链接。 （由 Mike Gilbert 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45433">bpo-45433</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45433]</span> 中贡献。）</p></li>
<li><p>现在 CPython 可以通过向 <a class="reference internal" href="../using/configure.xhtml#cmdoption-with-lto"><code class="xref std std-option docutils literal notranslate"><span class="pre">--with-lto</span></code></a> 传入 <code class="docutils literal notranslate"><span class="pre">thin</span></code>，即 <code class="docutils literal notranslate"><span class="pre">--with-lto=thin</span></code> 在编译时启用 <a class="reference external" href="https://clang.llvm.org/docs/ThinLTO.html">ThinLTO</a><span class="link-target"> [https://clang.llvm.org/docs/ThinLTO.html]</span> 选项。 （由 Donghee Na 和 Brett Holman 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44340">bpo-44340</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44340]</span> 中贡献。）</p></li>
<li><p>现在可以禁用对象结构体的自由列表。 新的 <strong class="program">configure</strong> 选项 <a class="reference internal" href="../using/configure.xhtml#cmdoption-without-freelists"><code class="xref std std-option docutils literal notranslate"><span class="pre">--without-freelists</span></code></a> 可用于禁用除空元组单例之外的所有自由列表。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45522">bpo-45522</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45522]</span> 中贡献。）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Modules/makesetup</span></code> 已获得改进并进行绑定。 扩展模块现在可以通过 <code class="docutils literal notranslate"><span class="pre">makesetup</span></code> 来构建。 除部分测试模块外所有模块都可以静态链接到主二进制文件或库中。 （由 Brett Cannon 和 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45548">bpo-45548</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45548]</span>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45570">bpo-45570</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45570]</span>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45571">bpo-45571</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45571]</span> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43974">bpo-43974</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43974]</span> 中贡献。）</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>使用环境变量 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">TCLTK_CFLAGS</span></code> 和 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">TCLTK_LIBS</span></code> 来手动指定 Tcl/Tk 头文件和库的位置。 <strong class="program">configure</strong> 选项 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-tcltk-includes</span></code> 和 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-tcltk-libs</span></code> 已被移除。</p>
<p>在 RHEL 7 和 CentOS 7 上开发包将不提供 <code class="docutils literal notranslate"><span class="pre">tcl.pc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tk.pc</span></code>；请使用 <code class="docutils literal notranslate"><span class="pre">TCLTK_LIBS=&quot;-ltk8.5</span> <span class="pre">-ltkstub8.5</span> <span class="pre">-ltcl8.5&quot;</span></code>。 <code class="docutils literal notranslate"><span class="pre">Misc/rhel7</span></code> 目录包含 <code class="docutils literal notranslate"><span class="pre">.pc</span></code> 文件以及如何使用 RHEL 7 和 CentOS 7 的 Tcl/Tk 和 OpenSSL 构建 Python 的说明。</p>
</div>
</li>
<li><p>CPython 现在将默认使用 30 比特位的数字来实现 Python <a class="reference internal" href="../library/functions.xhtml#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>。 之前版本中，在 <code class="docutils literal notranslate"><span class="pre">SIZEOF_VOID_P</span> <span class="pre">&gt;=</span> <span class="pre">8</span></code> 的平台上默认使用 30 比特位数字，否则使用 15 位数字。 仍然有可能通过配置脚本的 <a class="reference internal" href="../using/configure.xhtml#cmdoption-enable-big-digits"><code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-big-digits</span></code></a> 选项或 <code class="docutils literal notranslate"><span class="pre">PC/pyconfig.h</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">PYLONG_BITS_IN_DIGIT</span></code> 变量（适用于 Windows）显式地要求使用 15 比特位数字，但该选项可能会在未来某个时候被移除。 （由 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45569">bpo-45569</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45569]</span> 中贡献。）</p></li>
</ul>
</section>
<section id="c-api-changes">
<span id="whatsnew311-c-api"></span><h2>C API 的改变</h2>
<section id="whatsnew311-c-api-new-features">
<span id="id5"></span><h3>新的特性</h3>
<ul>
<li><p>新增了 <a class="reference internal" href="../c-api/type.xhtml#c.PyType_GetName" title="PyType_GetName"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetName()</span></code></a> 函数用来获取类型的简短名称。 （由 Hai Shi 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42035">bpo-42035</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42035]</span> 中贡献。）</p></li>
<li><p>新增了 <a class="reference internal" href="../c-api/type.xhtml#c.PyType_GetQualName" title="PyType_GetQualName"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetQualName()</span></code></a> 函数用来获取类型的限定名称。 （由 Hai Shi 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42035">bpo-42035</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=42035]</span> 中贡献。）</p></li>
<li><p>在受限的 C API 中新增了 <a class="reference internal" href="../c-api/init.xhtml#c.PyThreadState_EnterTracing" title="PyThreadState_EnterTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_EnterTracing()</span></code></a> 和 <a class="reference internal" href="../c-api/init.xhtml#c.PyThreadState_LeaveTracing" title="PyThreadState_LeaveTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_LeaveTracing()</span></code></a> 函数用来挂起和恢复追踪和性能分析。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43760">bpo-43760</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43760]</span> 中贡献。）</p></li>
<li><p>增加了 <a class="reference internal" href="../c-api/apiabiversion.xhtml#c.Py_Version" title="Py_Version"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_Version</span></code></a> 常量，其中的值与 <a class="reference internal" href="../c-api/apiabiversion.xhtml#c.PY_VERSION_HEX" title="PY_VERSION_HEX"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_VERSION_HEX</span></code></a> 相同。 （由 Gabriele N. Tornetta 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43931">bpo-43931</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43931]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 及其 API 现在是受限 API 和稳定 ABI 的组成部分:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyObject_CheckBuffer" title="PyObject_CheckBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CheckBuffer()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_GetPointer" title="PyBuffer_GetPointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_GetPointer()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_SizeFromFormat" title="PyBuffer_SizeFromFormat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_SizeFromFormat()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_ToContiguous" title="PyBuffer_ToContiguous"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_ToContiguous()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_FromContiguous" title="PyBuffer_FromContiguous"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FromContiguous()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyObject_CopyData" title="PyObject_CopyData"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CopyData()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_IsContiguous" title="PyBuffer_IsContiguous"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_IsContiguous()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_FillContiguousStrides" title="PyBuffer_FillContiguousStrides"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillContiguousStrides()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/buffer.xhtml#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/memoryview.xhtml#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMemoryView_FromBuffer()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/typeobj.xhtml#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_getbuffer</span></code></a> 和 <a class="reference internal" href="../c-api/typeobj.xhtml#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code></a> 类型槽位</p></li>
</ul>
<p>（由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45459">bpo-45459</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45459]</span> 中贡献。）</p>
</li>
<li><p>增加了 <a class="reference internal" href="../c-api/type.xhtml#c.PyType_GetModuleByDef" title="PyType_GetModuleByDef"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleByDef()</span></code></a> 函数，用于在无法直接获取信息的情况下 (通过 <a class="reference internal" href="../c-api/structures.xhtml#c.PyCMethod" title="PyCMethod"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code></a>) 获取方法定义所在的模块。 （由 Petr Viktorin 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46613">bpo-46613</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46613]</span> 中贡献。）</p></li>
<li><p>添加了用于打包和解包 C double (序列化和反序列化) 的新函数: <a class="reference internal" href="../c-api/float.xhtml#c.PyFloat_Pack2" title="PyFloat_Pack2"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_Pack2()</span></code></a>, <a class="reference internal" href="../c-api/float.xhtml#c.PyFloat_Pack4" title="PyFloat_Pack4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_Pack4()</span></code></a>, <a class="reference internal" href="../c-api/float.xhtml#c.PyFloat_Pack8" title="PyFloat_Pack8"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_Pack8()</span></code></a>, <a class="reference internal" href="../c-api/float.xhtml#c.PyFloat_Unpack2" title="PyFloat_Unpack2"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_Unpack2()</span></code></a>, <a class="reference internal" href="../c-api/float.xhtml#c.PyFloat_Unpack4" title="PyFloat_Unpack4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_Unpack4()</span></code></a> 和 <a class="reference internal" href="../c-api/float.xhtml#c.PyFloat_Unpack8" title="PyFloat_Unpack8"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_Unpack8()</span></code></a>。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46906">bpo-46906</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46906]</span> 中贡献。）</p></li>
<li><p>添加了用于获取帧对象属性的新函数: <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetBuiltins" title="PyFrame_GetBuiltins"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetBuiltins()</span></code></a>, <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetGenerator" title="PyFrame_GetGenerator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetGenerator()</span></code></a>, <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetGlobals" title="PyFrame_GetGlobals"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetGlobals()</span></code></a>, <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLasti" title="PyFrame_GetLasti"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLasti()</span></code></a>。</p></li>
<li><p>新增了两个用于获取和设置活动异常实例的函数: <a class="reference internal" href="../c-api/exceptions.xhtml#c.PyErr_GetHandledException" title="PyErr_GetHandledException"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_GetHandledException()</span></code></a> 和 <a class="reference internal" href="../c-api/exceptions.xhtml#c.PyErr_SetHandledException" title="PyErr_SetHandledException"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_SetHandledException()</span></code></a>。 这两个函数是 <a class="reference internal" href="../c-api/exceptions.xhtml#c.PyErr_SetExcInfo" title="PyErr_SetExcInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_SetExcInfo()</span></code></a> 和 <a class="reference internal" href="../c-api/exceptions.xhtml#c.PyErr_GetExcInfo" title="PyErr_GetExcInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_GetExcInfo()</span></code></a> 的替代品，后者使用传统的 3 元组表示异常。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46343">bpo-46343</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46343]</span> 中贡献。）</p></li>
<li><p>添加了 <a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig.safe_path" title="PyConfig.safe_path"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.safe_path</span></code></a> 成员。 （由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/57684">gh-57684</a><span class="link-target"> [https://github.com/python/cpython/issues/57684]</span> 中贡献。）.)</p></li>
</ul>
</section>
<section id="whatsnew311-c-api-porting">
<span id="id6"></span><h3>移植到 Python 3.11</h3>
<ul id="whatsnew311-pep670">
<li><p>部分宏已被转换为静态内联函数以避免 <a class="reference external" href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html">宏陷阱</a><span class="link-target"> [https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html]</span>。 这项改变对用户来说应该是基本无感的，因为替代函数会将其参数强制转换为预期的类型以避免静态类型检查导致的编译器警告。 但是，当受限 C API 被设为 &gt;=3.11 时，将不会执行这些强制转换，调用方将需要自行将参数强制转换为其预期的类型。 请参阅 <span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0670/"><strong>PEP 670</strong></a><span class="link-target"> [https://peps.python.org/pep-0670/]</span> 了解详情。 （由 Victor Stinner 和 Erlend E. Aasland 在 <a class="reference external" href="https://github.com/python/cpython/issues/89653">gh-89653</a><span class="link-target"> [https://github.com/python/cpython/issues/89653]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../c-api/exceptions.xhtml#c.PyErr_SetExcInfo" title="PyErr_SetExcInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_SetExcInfo()</span></code></a> 不再使用 <code class="docutils literal notranslate"><span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">traceback</span></code> 参数，解释器现在将从异常实例（ 即 <code class="docutils literal notranslate"><span class="pre">value</span></code> 参数）中获取这些值。 该函数仍会偷取对所有三个参数的引用。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711">bpo-45711</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../c-api/exceptions.xhtml#c.PyErr_GetExcInfo" title="PyErr_GetExcInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_GetExcInfo()</span></code></a> 现在将从异常实例（即 <code class="docutils literal notranslate"><span class="pre">value</span></code> 字段）获取结果的 <code class="docutils literal notranslate"><span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">traceback</span></code> 字段。 （由 Irit Katriel 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711">bpo-45711</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45711]</span> 中贡献。）</p></li>
<li><p><a class="reference internal" href="../c-api/import.xhtml#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a> 新增了 <code class="docutils literal notranslate"><span class="pre">is_package</span></code> 字段用来指明冻结模块是否为包。 之前，是将 <code class="docutils literal notranslate"><span class="pre">size</span></code> 字段设置负值作为指示符。  现在 <code class="docutils literal notranslate"><span class="pre">size</span></code> 将只使用非负值。 （由 Kumar Aditya 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46608">bpo-46608</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46608]</span> 中贡献。）</p></li>
<li><p>现在 <a class="reference internal" href="../c-api/init.xhtml#c._PyFrameEvalFunction" title="_PyFrameEvalFunction"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyFrameEvalFunction()</span></code></a> 接受 <code class="docutils literal notranslate"><span class="pre">_PyInterpreterFrame*</span></code> 作为其第二个形参，而不是 <code class="docutils literal notranslate"><span class="pre">PyFrameObject*</span></code>。 请参阅 <span class="target" id="index-120"></span><a class="pep reference external" href="https://peps.python.org/pep-0523/"><strong>PEP 523</strong></a><span class="link-target"> [https://peps.python.org/pep-0523/]</span> 了解如何使用此函数指针类型的更多细节。</p></li>
<li><p>现在 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_New()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_NewWithPosOnlyArgs()</span></code> 接受一个额外的 <code class="docutils literal notranslate"><span class="pre">exception_table</span></code> 参数。 如有可能，应当避免使用这些函数。 获取自定义的代码对象：使用编译器创建一个代码对象，然后使用 <code class="docutils literal notranslate"><span class="pre">replace</span></code> 方法得到修改后的版本。</p></li>
<li><p><a class="reference internal" href="../c-api/code.xhtml#c.PyCodeObject" title="PyCodeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCodeObject</span></code></a> 不再具有 <code class="docutils literal notranslate"><span class="pre">co_code</span></code>, <code class="docutils literal notranslate"><span class="pre">co_varnames</span></code>, <code class="docutils literal notranslate"><span class="pre">co_cellvars</span></code> 和 <code class="docutils literal notranslate"><span class="pre">co_freevars</span></code> 字段。 请分别改用 <a class="reference internal" href="../c-api/code.xhtml#c.PyCode_GetCode" title="PyCode_GetCode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_GetCode()</span></code></a>, <a class="reference internal" href="../c-api/code.xhtml#c.PyCode_GetVarnames" title="PyCode_GetVarnames"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_GetVarnames()</span></code></a>, <a class="reference internal" href="../c-api/code.xhtml#c.PyCode_GetCellvars" title="PyCode_GetCellvars"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_GetCellvars()</span></code></a> 和 <a class="reference internal" href="../c-api/code.xhtml#c.PyCode_GetFreevars" title="PyCode_GetFreevars"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_GetFreevars()</span></code></a> 通过 C API 来访问它们。 （由 Brandt Bucher 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46841">bpo-46841</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46841]</span> 以及 Ken Jin 在 <a class="reference external" href="https://github.com/python/cpython/issues/92154">gh-92154</a><span class="link-target"> [https://github.com/python/cpython/issues/92154]</span> 和 <a class="reference external" href="https://github.com/python/cpython/issues/94936">gh-94936</a><span class="link-target"> [https://github.com/python/cpython/issues/94936]</span> 中贡献。）</p></li>
<li><p>旧的垃圾桶宏 (<code class="docutils literal notranslate"><span class="pre">Py_TRASHCAN_SAFE_BEGIN</span></code>/<code class="docutils literal notranslate"><span class="pre">Py_TRASHCAN_SAFE_END</span></code>) 现在已被弃用。 它们应该由新的宏 <code class="docutils literal notranslate"><span class="pre">Py_TRASHCAN_BEGIN</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Py_TRASHCAN_END</span></code> 代替。</p>
<p>带有旧版宏的 tp_dealloc 函数，例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span>
<span class="n">mytype_dealloc</span><span class="p">(</span><span class="n">mytype</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">Py_TRASHCAN_SAFE_BEGIN</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="o">...</span>
    <span class="n">Py_TRASHCAN_SAFE_END</span>
<span class="p">}</span>
</pre></div>
</div>
<p>应当按照以下方式迁移到新版宏:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span>
<span class="n">mytype_dealloc</span><span class="p">(</span><span class="n">mytype</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">Py_TRASHCAN_BEGIN</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mytype_dealloc</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">Py_TRASHCAN_END</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意 <code class="docutils literal notranslate"><span class="pre">Py_TRASHCAN_BEGIN</span></code> 的第二个参数应该是它所属的取消分配函数。</p>
<p>要在同一代码库中支持旧版本的 Python，可以定义以下的宏并在整个代码中使用它们 (版权声明：这些宏是从 <code class="docutils literal notranslate"><span class="pre">mypy</span></code> 代码库中拷贝的):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &gt;= 0x03080000</span>
<span class="c1">#  define CPy_TRASHCAN_BEGIN(op, dealloc) Py_TRASHCAN_BEGIN(op, dealloc)</span>
<span class="c1">#  define CPy_TRASHCAN_END(op) Py_TRASHCAN_END</span>
<span class="c1">#else</span>
<span class="c1">#  define CPy_TRASHCAN_BEGIN(op, dealloc) Py_TRASHCAN_SAFE_BEGIN(op)</span>
<span class="c1">#  define CPy_TRASHCAN_END(op) Py_TRASHCAN_SAFE_END(op)</span>
<span class="c1">#endif</span>
</pre></div>
</div>
</li>
<li><p>现在如果一个类型定义了 <a class="reference internal" href="../c-api/typeobj.xhtml#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 旗标但没有遍历函数 (<a class="reference internal" href="../c-api/typeobj.xhtml#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_traverse</span></code></a>) 则 <a class="reference internal" href="../c-api/type.xhtml#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a> 函数将引发一个错误。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44263">bpo-44263</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44263]</span> 中贡献。）</p></li>
<li><p>带有 <a class="reference internal" href="../c-api/typeobj.xhtml#c.Py_TPFLAGS_IMMUTABLETYPE" title="Py_TPFLAGS_IMMUTABLETYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_IMMUTABLETYPE</span></code></a> 旗标的堆类型现在可以继承 <span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0590/"><strong>PEP 590</strong></a><span class="link-target"> [https://peps.python.org/pep-0590/]</span> vectorcall 协议。 在之前版本中，这只适用于 <a class="reference internal" href="../c-api/typeobj.xhtml#static-types"><span class="std std-ref">静态类型</span></a>。（由 Erlend E. Aasland 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43908">bpo-43908</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=43908]</span> 中贡献。）</p></li>
<li><p>由于 <a class="reference internal" href="../c-api/structures.xhtml#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_TYPE()</span></code></a> 已改为内联静态函数，因此 <code class="docutils literal notranslate"><span class="pre">Py_TYPE(obj)</span> <span class="pre">=</span> <span class="pre">new_type</span></code> 必须换成 <code class="docutils literal notranslate"><span class="pre">Py_SET_TYPE(obj,</span> <span class="pre">new_type)</span></code>: 参见 <a class="reference internal" href="../c-api/structures.xhtml#c.Py_SET_TYPE" title="Py_SET_TYPE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SET_TYPE()</span></code></a> 函数（自 Python 3.9 起可用）。 为保持向下兼容，可以使用这个宏:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &lt; 0x030900A4 &amp;&amp; !defined(Py_SET_TYPE)</span>
<span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">_Py_SET_TYPE</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">ob</span><span class="p">,</span> <span class="n">PyTypeObject</span> <span class="o">*</span><span class="nb">type</span><span class="p">)</span>
<span class="p">{</span> <span class="n">ob</span><span class="o">-&gt;</span><span class="n">ob_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">#define Py_SET_TYPE(ob, type) _Py_SET_TYPE((PyObject*)(ob), type)</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=39573">bpo-39573</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=39573]</span> 中贡献。）</p>
</li>
<li><p>由于 <a class="reference internal" href="../c-api/structures.xhtml#c.Py_SIZE" title="Py_SIZE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SIZE()</span></code></a> 已改为内联静态函数，因此 <code class="docutils literal notranslate"><span class="pre">Py_SIZE(obj)</span> <span class="pre">=</span> <span class="pre">new_size</span></code> 必须换成 <code class="docutils literal notranslate"><span class="pre">Py_SET_SIZE(obj,</span> <span class="pre">new_size)</span></code>: 参见 <a class="reference internal" href="../c-api/structures.xhtml#c.Py_SET_SIZE" title="Py_SET_SIZE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SET_SIZE()</span></code></a> 函数（自 Python 3.9 起可用）。 为保持向下兼容，可以使用这个宏:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &lt; 0x030900A4 &amp;&amp; !defined(Py_SET_SIZE)</span>
<span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">_Py_SET_SIZE</span><span class="p">(</span><span class="n">PyVarObject</span> <span class="o">*</span><span class="n">ob</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span> <span class="n">ob</span><span class="o">-&gt;</span><span class="n">ob_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">#define Py_SET_SIZE(ob, size) _Py_SET_SIZE((PyVarObject*)(ob), size)</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=39573">bpo-39573</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=39573]</span> 中贡献。）</p>
</li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">Py_LIMITED_API</span></code> 宏被设为 <code class="docutils literal notranslate"><span class="pre">0x030b0000</span></code> (Python 3.11) 或更高版本时，<code class="docutils literal notranslate"><span class="pre">&lt;Python.h&gt;</span></code> 将不再包含头文件 <code class="docutils literal notranslate"><span class="pre">&lt;stdlib.h&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;stdio.h&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;errno.h&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;string.h&gt;</span></code>。 C 扩展应在 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;Python.h&gt;</span></code> 之后显式地包括头文件。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45434">bpo-45434</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45434]</span> 中贡献。）</p></li>
<li><p>非受限 API 文件 <code class="docutils literal notranslate"><span class="pre">cellobject.h</span></code>, <code class="docutils literal notranslate"><span class="pre">classobject.h</span></code>, <code class="docutils literal notranslate"><span class="pre">code.h</span></code>, <code class="docutils literal notranslate"><span class="pre">context.h</span></code>, <code class="docutils literal notranslate"><span class="pre">funcobject.h</span></code>, <code class="docutils literal notranslate"><span class="pre">genobject.h</span></code> 和 <code class="docutils literal notranslate"><span class="pre">longintrepr.h</span></code> 已被移至 <code class="docutils literal notranslate"><span class="pre">Include/cpython</span></code> 目录。 此外，还移除了 <code class="docutils literal notranslate"><span class="pre">eval.h</span></code> 头文件。 这些文件不能被直接包括，因为它们已经被包括在 <code class="docutils literal notranslate"><span class="pre">Python.h</span></code> 中了：参见 <a class="reference internal" href="../c-api/intro.xhtml#api-includes"><span class="std std-ref">包括文件</span></a>。如果它们已被直接包括，请考虑改为包括 <code class="docutils literal notranslate"><span class="pre">Python.h</span></code>。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35134">bpo-35134</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35134]</span> 中贡献。）</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_CHECK_INTERNED()</span></code> 宏已被排除在受限 C API 之外。 它从未在那里被使用，因为它使用了受限 C API 中不可用的内部结构体。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46007">bpo-46007</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46007]</span> 中贡献。）</p></li>
<li><p>以下帧函数和类型现在可通过 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;Python.h&gt;</span></code> 直接使用，不再需要添加 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;frameobject.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_Check" title="PyFrame_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_Check()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetBack" title="PyFrame_GetBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetBack()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetBuiltins" title="PyFrame_GetBuiltins"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetBuiltins()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetGenerator" title="PyFrame_GetGenerator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetGenerator()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetGlobals" title="PyFrame_GetGlobals"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetGlobals()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLasti" title="PyFrame_GetLasti"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLasti()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLocals" title="PyFrame_GetLocals"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLocals()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_Type" title="PyFrame_Type"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFrame_Type</span></code></a></p></li>
</ul>
<p>（由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/93937">gh-93937</a><span class="link-target"> [https://github.com/python/cpython/issues/93937]</span> 中贡献。）</p>
</li>
</ul>
<ul id="pyframeobject-3-11-hiding">
<li><p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrameObject" title="PyFrameObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFrameObject</span></code></a> 结构体成员已从公有 C API 中被移除。</p>
<p>虽然文档指出 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrameObject" title="PyFrameObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFrameObject</span></code></a> 字段可能随时更改，但这些字段长期以来一直保持稳定，并在多个流行的扩展中使用。</p>
<p>在 Python 3.11 中，为了优化性能，对帧结构进行了重组。 一些字段被完全删除，因为它们属于旧实现的细节。</p>
<p><a class="reference internal" href="../c-api/frame.xhtml#c.PyFrameObject" title="PyFrameObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFrameObject</span></code></a> 字段:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f_back</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetBack" title="PyFrame_GetBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetBack()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_blockstack</span></code>: 已移除。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_builtins</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetBuiltins" title="PyFrame_GetBuiltins"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetBuiltins()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_code</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetCode" title="PyFrame_GetCode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetCode()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_gen</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetGenerator" title="PyFrame_GetGenerator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetGenerator()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_globals</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetGlobals" title="PyFrame_GetGlobals"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetGlobals()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_iblock</span></code>: 已移除。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_lasti</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLasti" title="PyFrame_GetLasti"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLasti()</span></code></a>。 使用 <code class="docutils literal notranslate"><span class="pre">f_lasti</span></code> 并带有 <code class="docutils literal notranslate"><span class="pre">PyCode_Addr2Line()</span></code> 的代码应当改用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLineNumber" title="PyFrame_GetLineNumber"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLineNumber()</span></code></a>；它可能会更快。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_lineno</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLineNumber" title="PyFrame_GetLineNumber"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLineNumber()</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_locals</span></code>: 使用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLocals" title="PyFrame_GetLocals"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLocals()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_stackdepth</span></code>: 已移除。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_state</span></code>: 无公共 API (重命名为 <code class="docutils literal notranslate"><span class="pre">f_frame.f_state</span></code>)。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_trace</span></code>: 无公共 API。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_trace_lines</span></code>: 使用 <code class="docutils literal notranslate"><span class="pre">PyObject_GetAttrString((PyObject*)frame,</span> <span class="pre">&quot;f_trace_lines&quot;)</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code>: 使用 <code class="docutils literal notranslate"><span class="pre">PyObject_GetAttrString((PyObject*)frame,</span> <span class="pre">&quot;f_trace_opcodes&quot;)</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_localsplus</span></code>: 无公共 API (重命名为 <code class="docutils literal notranslate"><span class="pre">f_frame.localsplus</span></code>)。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_valuestack</span></code>: 已移除。</p></li>
</ul>
<p>现在 Python 帧对象是惰性地创建的。 一个附带影响是 <a class="reference internal" href="../reference/datamodel.xhtml#frame.f_back" title="frame.f_back"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code></a> 成员不可被直接访问，因为现在它的值也是惰性地计算的。 必须改为调用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetBack" title="PyFrame_GetBack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetBack()</span></code></a> 函数。</p>
<p>直接访问 <a class="reference internal" href="../reference/datamodel.xhtml#frame.f_locals" title="frame.f_locals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code></a> 的调试器 <em>必须</em> 改为调用 <a class="reference internal" href="../c-api/frame.xhtml#c.PyFrame_GetLocals" title="PyFrame_GetLocals"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLocals()</span></code></a>。 它们不再需要调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_FastToLocalsWithError()</span></code> 或 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_LocalsToFast()</span></code>，实际上它们不应调用这些函数。 现在帧所需要的更新将由虚拟机来管理。</p>
<p>在 Python 3.8 及更旧版本上定义 <code class="docutils literal notranslate"><span class="pre">PyFrame_GetCode()</span></code> 的代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &lt; 0x030900B1</span>
<span class="n">static</span> <span class="n">inline</span> <span class="n">PyCodeObject</span><span class="o">*</span> <span class="n">PyFrame_GetCode</span><span class="p">(</span><span class="n">PyFrameObject</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_code</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_code</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>在 Python 3.8 及更旧版本上定义 <code class="docutils literal notranslate"><span class="pre">PyFrame_GetBack()</span></code> 的代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &lt; 0x030900B1</span>
<span class="n">static</span> <span class="n">inline</span> <span class="n">PyFrameObject</span><span class="o">*</span> <span class="n">PyFrame_GetBack</span><span class="p">(</span><span class="n">PyFrameObject</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_back</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_back</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>或者使用 <a class="reference external" href="https://github.com/python/pythoncapi-compat">pythoncapi_compat 项目</a><span class="link-target"> [https://github.com/python/pythoncapi-compat]</span> 在更旧版本的 Python 上获取这些函数。</p>
</li>
<li><p><a class="reference internal" href="../c-api/init.xhtml#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 结构体成员的变化:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frame</span></code>: 已被移除，请使用 <a class="reference internal" href="../c-api/init.xhtml#c.PyThreadState_GetFrame" title="PyThreadState_GetFrame"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetFrame()</span></code></a> (由 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40429">bpo-40429</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40429]</span> 添加到 Python 3.9 的函数)。 警告：该函数返回一个 <a class="reference internal" href="../glossary.xhtml#term-strong-reference"><span class="xref std std-term">strong reference</span></a>，需要调用 <a class="reference internal" href="../c-api/refcounting.xhtml#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_XDECREF()</span></code></a>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tracing</span></code>: 已被更改，请使用 <a class="reference internal" href="../c-api/init.xhtml#c.PyThreadState_EnterTracing" title="PyThreadState_EnterTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_EnterTracing()</span></code></a> 和 <a class="reference internal" href="../c-api/init.xhtml#c.PyThreadState_LeaveTracing" title="PyThreadState_LeaveTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_LeaveTracing()</span></code></a> (由:issue:<cite>43760</cite> 添加到 Python 3.11 的函数)。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">recursion_depth</span></code>: 已被移除，请使用 <code class="docutils literal notranslate"><span class="pre">(tstate-&gt;recursion_limit</span> <span class="pre">-</span> <span class="pre">tstate-&gt;recursion_remaining)</span></code> 代替。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stackcheck_counter</span></code>：已移除。</p></li>
</ul>
<p>在 Python 3.8 或更旧版本中定义 <code class="docutils literal notranslate"><span class="pre">PyThreadState_GetFrame()</span></code> 的代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &lt; 0x030900B1</span>
<span class="n">static</span> <span class="n">inline</span> <span class="n">PyFrameObject</span><span class="o">*</span> <span class="n">PyThreadState_GetFrame</span><span class="p">(</span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>在 Python 3.10 或更旧版本中定义 <code class="docutils literal notranslate"><span class="pre">PyThreadState_EnterTracing()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PyThreadState_LeaveTracing()</span></code> 的代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#if PY_VERSION_HEX &lt; 0x030B00A2</span>
<span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">PyThreadState_EnterTracing</span><span class="p">(</span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">tracing</span><span class="o">++</span><span class="p">;</span>
<span class="c1">#if PY_VERSION_HEX &gt;= 0x030A00A1</span>
    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">cframe</span><span class="o">-&gt;</span><span class="n">use_tracing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">#else</span>
    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">use_tracing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">#endif</span>
<span class="p">}</span>

<span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">PyThreadState_LeaveTracing</span><span class="p">(</span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">use_tracing</span> <span class="o">=</span> <span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="o">||</span> <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_profilefunc</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">);</span>
    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">tracing</span><span class="o">--</span><span class="p">;</span>
<span class="c1">#if PY_VERSION_HEX &gt;= 0x030A00A1</span>
    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">cframe</span><span class="o">-&gt;</span><span class="n">use_tracing</span> <span class="o">=</span> <span class="n">use_tracing</span><span class="p">;</span>
<span class="c1">#else</span>
    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">use_tracing</span> <span class="o">=</span> <span class="n">use_tracing</span><span class="p">;</span>
<span class="c1">#endif</span>
<span class="p">}</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>或者使用 <a class="reference external" href="https://github.com/python/pythoncapi-compat">pythoncapi-compat 项目</a><span class="link-target"> [https://github.com/python/pythoncapi-compat]</span> 在旧版的 Python 函数上获取这些函数。</p>
</li>
<li><p>推荐发行方使用优化的 Blake2 库 <a class="reference external" href="https://www.blake2.net/">libb2</a><span class="link-target"> [https://www.blake2.net/]</span> 来构建 Python。</p></li>
<li><p>现在初始化时 <a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig.module_search_paths_set" title="PyConfig.module_search_paths_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths_set</span></code></a> 字段必须设为 1 以使用 <a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig.module_search_paths" title="PyConfig.module_search_paths"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths</span></code></a> 来初始化 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>。 否则，初始化将重新计算路径并替换任何加入到 <code class="docutils literal notranslate"><span class="pre">module_search_paths</span></code> 的值。</p></li>
<li><p><a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a> 将不会再计算初始搜索路径，并且不会将任何值填充到 <a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig.module_search_paths" title="PyConfig.module_search_paths"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.module_search_paths</span></code></a>。 要计算默认路径再修改它们，请结束初始化并使用 <a class="reference internal" href="../c-api/sys.xhtml#c.PySys_GetObject" title="PySys_GetObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_GetObject()</span></code></a> 来将 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 提取为一个 Python 列表对象并直接修改它。</p></li>
</ul>
</section>
<section id="whatsnew311-c-api-deprecated">
<span id="id7"></span><h3>弃用</h3>
<ul>
<li><p>弃用以下配置 Python 初始化的函数:</p>
<ul class="simple">
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddWarnOptionUnicode()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddWarnOption()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddXOption()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_HasWarnOptions()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetPath()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPath()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetStandardStreamEncoding()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_SetProgramFullPath()</span></code></p></li>
</ul>
<p>改用新的 <a class="reference internal" href="../c-api/init_config.xhtml#init-config"><span class="std std-ref">Python 初始化配置</span></a> 的 <a class="reference internal" href="../c-api/init_config.xhtml#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a> API (<span class="target" id="index-122"></span><a class="pep reference external" href="https://peps.python.org/pep-0587/"><strong>PEP 587</strong></a><span class="link-target"> [https://peps.python.org/pep-0587/]</span>)。 （由 Victor Stinner 在 <a class="reference external" href="https://github.com/python/cpython/issues/88279">gh-88279</a><span class="link-target"> [https://github.com/python/cpython/issues/88279]</span> 中贡献。）</p>
</li>
<li><p>弃用 <a class="reference internal" href="../c-api/bytes.xhtml#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBytesObject</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">ob_shash</span></code> 成员。 改用 <a class="reference internal" href="../c-api/object.xhtml#c.PyObject_Hash" title="PyObject_Hash"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Hash()</span></code></a>。 （由 Inada Naoki 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46864">bpo-46864</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=46864]</span> 中贡献。）.)</p></li>
</ul>
</section>
<section id="whatsnew311-c-api-pending-removal">
<span id="id8"></span><h3>计划在 Python 3.12 中移除</h3>
<p>以下 C API 在早期 Python 发行版中已经弃用，将在 Python 3.12 中移除。</p>
<ul class="simple">
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AS_DATA()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AS_UNICODE()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicodeAndSize()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicode()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_DATA_SIZE()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_SIZE()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GetSize()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_IS_COMPACT()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_IS_READY()</span></code></p></li>
<li><p><a class="reference internal" href="../c-api/unicode.xhtml#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_WSTR_LENGTH()</span></code></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyUnicode_AsUnicode()</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyUnicode_WCHAR_KIND</span></code></p></li>
<li><p><a class="reference internal" href="../c-api/unicode.xhtml#c.PyUnicodeObject" title="PyUnicodeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyUnicodeObject</span></code></a></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_InternImmortal()</span></code></p></li>
</ul>
</section>
<section id="whatsnew311-c-api-removed">
<span id="id9"></span><h3>移除</h3>
<ul>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_BlockSetup()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_BlockPop()</span></code> 已被移除。 （由 Mark Shannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40222">bpo-40222</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40222]</span> 中贡献。）</p></li>
<li><p>移除了下列使用 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 变量的数学宏:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Py_ADJUST_ERANGE1()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_ADJUST_ERANGE2()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_OVERFLOWED()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_SET_ERANGE_IF_OVERFLOW()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_SET_ERRNO_ON_MATH_ERROR()</span></code></p></li>
</ul>
<p>（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45412">bpo-45412</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45412]</span> 中贡献。）</p>
</li>
<li><p>移除 <code class="docutils literal notranslate"><span class="pre">Py_UNICODE_COPY()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Py_UNICODE_FILL()</span></code> 宏，它们自 Python 3.3 起已被弃用。 改用 <code class="docutils literal notranslate"><span class="pre">PyUnicode_CopyCharacters()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> (<code class="docutils literal notranslate"><span class="pre">wchar_t*</span></code> 字符串) 和 <code class="docutils literal notranslate"><span class="pre">PyUnicode_Fill()</span></code> 函数。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41123">bpo-41123</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=41123]</span> 中贡献。）</p></li>
<li><p>移除 <code class="docutils literal notranslate"><span class="pre">pystrhex.h</span></code> 头文件。 它只包含私有函数。 C 扩展应当只包括主 <code class="docutils literal notranslate"><span class="pre">&lt;Python.h&gt;</span></code> 头文件。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45434">bpo-45434</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45434]</span> 中贡献。）</p></li>
<li><p>移除了 <code class="docutils literal notranslate"><span class="pre">Py_FORCE_DOUBLE()</span></code> 宏，它曾经由 <code class="docutils literal notranslate"><span class="pre">Py_IS_INFINITY()</span></code> 宏使用。（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45440">bpo-45440</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45440]</span> 贡献。）</p></li>
<li><p>以下项目在 <a class="reference internal" href="../c-api/stable.xhtml#c.Py_LIMITED_API" title="Py_LIMITED_API"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_LIMITED_API</span></code></a> 定义时不再可用：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../c-api/marshal.xhtml#c.PyMarshal_WriteLongToFile" title="PyMarshal_WriteLongToFile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMarshal_WriteLongToFile()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/marshal.xhtml#c.PyMarshal_WriteObjectToFile" title="PyMarshal_WriteObjectToFile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMarshal_WriteObjectToFile()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/marshal.xhtml#c.PyMarshal_ReadObjectFromString" title="PyMarshal_ReadObjectFromString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMarshal_ReadObjectFromString()</span></code></a></p></li>
<li><p><a class="reference internal" href="../c-api/marshal.xhtml#c.PyMarshal_WriteObjectToString" title="PyMarshal_WriteObjectToString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMarshal_WriteObjectToString()</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Py_MARSHAL_VERSION</span></code> 宏</p></li>
</ul>
<p>这些不是 <a class="reference internal" href="../c-api/stable.xhtml#limited-api-list"><span class="std std-ref">受限 API</span></a> 的组成部分。</p>
<p>（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45474">bpo-45474</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45474]</span> 中贡献。）</p>
</li>
<li><p>将 <a class="reference internal" href="../c-api/weakref.xhtml#c.PyWeakref_GET_OBJECT" title="PyWeakref_GET_OBJECT"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyWeakref_GET_OBJECT()</span></code></a> 排除在受限 C API 之外。 由于 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyWeakReference</span></code> 结构体在受限 C API 中被屏蔽因此它从未发挥作用。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35134">bpo-35134</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=35134]</span> 中贡献。）</p></li>
<li><p>移除了 <code class="docutils literal notranslate"><span class="pre">PyHeapType_GET_MEMBERS()</span></code> 宏。它错误地暴露在公开的 C API 中，且只能由 Python 在内部使用。请使用 <code class="docutils literal notranslate"><span class="pre">PyTypeObject.tp_members</span></code> 作为替代。（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40170">bpo-40170</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=40170]</span> 贡献。）</p></li>
<li><p>移除了 <code class="docutils literal notranslate"><span class="pre">HAVE_PY_SET_53BIT_PRECISION</span></code> 宏（移动到了内部 C API）。（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45412">bpo-45412</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=45412]</span> 贡献。）</p></li>
</ul>
<ul id="whatsnew311-pep624">
<li><p>移除了 <a class="reference internal" href="../c-api/unicode.xhtml#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 编码器 API，它们从 Python 3.3 起已经弃用，很少使用，而且相对于推荐的替代品来说，效率很低。</p>
<p>被移除的函数有:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_Encode()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeASCII()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeLatin1()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeUTF7()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeUTF8()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeUTF16()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeUTF32()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeUnicodeEscape()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeRawUnicodeEscape()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeCharmap()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_TranslateCharmap()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeDecimal()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">PyUnicode_TransformDecimalToASCII()</span></code></p></li>
</ul>
<p>请参阅 <span class="target" id="index-123"></span><a class="pep reference external" href="https://peps.python.org/pep-0624/"><strong>PEP 624</strong></a><span class="link-target"> [https://peps.python.org/pep-0624/]</span> 了解细节以及 <span class="target" id="index-124"></span><a class="pep reference external" href="https://peps.python.org/pep-0624/#alternative-apis"><strong>迁移指引</strong></a><span class="link-target"> [https://peps.python.org/pep-0624/#alternative-apis]</span>。 （由 Inada Naoki 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44029">bpo-44029</a><span class="link-target"> [https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=44029]</span> 中贡献。）</p>
</li>
</ul>
</section>
</section>
<section id="notable-changes-in-3-11-4">
<h2>3.11.4 中的重要变化</h2>
<section id="tarfile">
<h3>tarfile</h3>
<ul class="simple">
<li><p><a class="reference internal" href="../library/tarfile.xhtml#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 中的提取方法和 <a class="reference internal" href="../library/shutil.xhtml#shutil.unpack_archive" title="shutil.unpack_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.unpack_archive()</span></code></a> 都新增了 <em>filter</em> 参数以允许限制可能令人意外或危险的 tar 特性，例如在目标目录之外创建文件。 相关细节参见 <a class="reference internal" href="../library/tarfile.xhtml#tarfile-extraction-filter"><span class="std std-ref">解压缩过滤器</span></a>。 在 Python 3.12 中，不带 <em>filter</em> 参数的用法将显示 <a class="reference internal" href="../library/exceptions.xhtml#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。 在 Python 3.14 中，默认值将切换为 <code class="docutils literal notranslate"><span class="pre">'data'</span></code>。 （由 Petr Viktorin 在 <span class="target" id="index-125"></span><a class="pep reference external" href="https://peps.python.org/pep-0706/"><strong>PEP 706</strong></a><span class="link-target"> [https://peps.python.org/pep-0706/]</span> 中贡献。）</p></li>
</ul>
</section>
</section>
<section id="notable-changes-in-3-11-5">
<h2>3.11.5 中的重要变化</h2>
<section id="openssl">
<h3>OpenSSL</h3>
<ul class="simple">
<li><p>来自 python.org 的 Windows 版本和 macOS 安装程序现在使用 OpenSSL 3.0。</p></li>
</ul>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>