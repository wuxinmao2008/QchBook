<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="6. 模块" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/tutorial/modules.xhtml" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 脚本 。随着程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用同一个函数时，不用把函数定义复制到各个程序。 为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 脚本 。随着程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用同一个函数时，不用把函数定义复制到各个程序。 为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>6. 模块</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" />
    <link rel="canonical" href="https://docs.python.org/3/tutorial/modules.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="modules">
<span id="tut-modules"></span><h1><span class="section-number">6. </span>模块</h1>
<p>退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 <em>脚本</em> 。随着程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用同一个函数时，不用把函数定义复制到各个程序。</p>
<p>为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是 <em>模块</em> ；模块中的定义可以 <em>导入</em> 到其他模块或 <em>主</em> 模块（在顶层和计算器模式下，执行脚本中可访问的变量集）。</p>
<p>模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 <code class="file docutils literal notranslate"><span class="pre">.py</span></code> 。在模块内部，通过全局变量 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 可以获取模块名（即字符串）。例如，用文本编辑器在当前目录下创建 <code class="file docutils literal notranslate"><span class="pre">fibo.py</span></code> 文件，输入以下内容：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fibonacci numbers module</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>    <span class="c1"># write Fibonacci series up to n</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="nb">print</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>   <span class="c1"># return Fibonacci series up to n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>现在，进入 Python 解释器，用以下命令导入该模块：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
</pre></div>
</div>
<p>此操作不会直接把 <code class="docutils literal notranslate"><span class="pre">fibo</span></code> 中定义的函数名称添加到当前 <a class="reference internal" href="../glossary.xhtml#term-namespace"><span class="xref std std-term">namespace</span></a> 中（请参阅 <a class="reference internal" href="classes.xhtml#tut-scopes"><span class="std std-ref">Python 作用域和命名空间</span></a> 了解详情）；它只是将模块名称 <code class="docutils literal notranslate"><span class="pre">fibo</span></code> 添加到那里。 使用该模块名称你可以访问其中的函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">fib</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">fib2</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;fibo&#39;</span>
</pre></div>
</div>
<p>如果经常使用某个函数，可以把它赋值给局部变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">.</span><span class="n">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<section id="more-on-modules">
<span id="tut-moremodules"></span><h2><span class="section-number">6.1. </span>模块详解</h2>
<p>模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 <em>第一次</em> 遇到模块名时执行。<a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> (文件作为脚本运行时，也会执行这些语句。)</p>
<p>每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。 因此，模块作者可以在模块内使用全局变量而不必担心与用户的全局变量发生意外冲突。 另一方面，如果你知道要怎么做就可以通过与引用模块函数一样的标记法 <code class="docutils literal notranslate"><span class="pre">modname.itemname</span></code> 来访问一个模块的全局变量。</p>
<p>模块可以导入其他模块。 根据惯例可以将所有 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句都放在模块（或者也可以说是脚本）的开头但这并非强制要求。 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模块的全局命名空间。</p>
<p>还有一种 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句的变化形式可以将来自某个模块的名称直接导入到导入方模块的命名空间中。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="n">fib</span><span class="p">,</span> <span class="n">fib2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<p>这条语句不会将所导入的模块的名称引入到局部命名空间中（因此在本示例中，<code class="docutils literal notranslate"><span class="pre">fibo</span></code> 将是未定义的名称）。</p>
<p>还有一种变体可以导入模块内定义的所有名称：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<p>这种方式会导入所有不以下划线（<code class="docutils literal notranslate"><span class="pre">_</span></code>）开头的名称。大多数情况下，不要用这个功能，这种方式向解释器导入了一批未知的名称，可能会覆盖已经定义的名称。</p>
<p>注意，一般情况下，不建议从模块或包内导入 <code class="docutils literal notranslate"><span class="pre">*</span></code>，因为，这项操作经常让代码变得难以理解。不过，为了在交互式编译器中少打几个字，这么用也没问题。</p>
<p>模块名后使用 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 时，直接把 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 后的名称与导入模块绑定。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span> <span class="k">as</span> <span class="nn">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="n">fib</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<p>与 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">fibo</span></code> 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 <code class="docutils literal notranslate"><span class="pre">fib</span></code>。</p>
<p><a class="reference internal" href="../reference/simple_stmts.xhtml#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> 中也可以使用这种方式，效果类似：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="n">fib</span> <span class="k">as</span> <span class="n">fibonacci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="go">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为了保证运行效率，每次解释器会话只导入一次模块。如果更改了模块内容，必须重启解释器；仅交互测试一个模块时，也可以使用 <a class="reference internal" href="../library/importlib.xhtml#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a>，例如 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">importlib;</span> <span class="pre">importlib.reload(modulename)</span></code>。</p>
</div>
<section id="executing-modules-as-scripts">
<span id="tut-modulesasscripts"></span><h3><span class="section-number">6.1.1. </span>以脚本方式执行模块</h3>
<p>可以用以下方式运行 Python 模块：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">fibo</span><span class="o">.</span><span class="n">py</span> <span class="o">&lt;</span><span class="n">arguments</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>这项操作将执行模块里的代码，和导入模块一样，但会把 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 赋值为 <code class="docutils literal notranslate"><span class="pre">&quot;__main__&quot;</span></code>。 也就是把下列代码添加到模块末尾：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">fib</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>这个文件既能被用作脚本，又能被用作一个可供导入的模块，因为解析命令行参数的那两行代码只有在模块作为“main”文件执行时才会运行：</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>fibo.py<span class="w"> </span><span class="m">50</span>
<span class="go">0 1 1 2 3 5 8 13 21 34</span>
</pre></div>
</div>
<p>当这个模块被导入到其它模块时，那两行代码不运行：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这常用于为模块提供一个便捷的用户接口，或用于测试（把模块作为执行测试套件的脚本运行）。</p>
</section>
<section id="the-module-search-path">
<span id="tut-searchpath"></span><h3><span class="section-number">6.1.2. </span>模块搜索路径</h3>
<p id="index-0">当导入一个名为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">spam</span></code> 的模块时，解释器首先会搜索具有该名称的内置模块。 这些模块的名称在 <a class="reference internal" href="../library/sys.xhtml#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a> 中列出。 如果未找到，它将在变量 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 所给出的目录列表中搜索名为 <code class="file docutils literal notranslate"><span class="pre">spam.py</span></code> 的文件。 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 是从这些位置初始化的:</p>
<ul class="simple">
<li><p>被命令行直接运行的脚本所在的目录（或未指定文件时的当前目录）。</p></li>
<li><p><span class="target" id="index-14"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> （目录列表，与 shell 变量 <span class="target" id="index-15"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> 的语法一样）。</p></li>
<li><p>依赖于安装的默认值（按照惯例包括一个 <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> 目录，由 <a class="reference internal" href="../library/site.xhtml#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块处理）。</p></li>
</ul>
<p>更多细节请参阅 <a class="reference internal" href="../library/sys_path_init.xhtml#sys-path-init"><span class="std std-ref">sys.path 模块搜索路径的初始化</span></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在支持符号链接的文件系统中，“被命令行直接运行的脚本所在的目录”是符号链接最终指向的目录。换句话说，符号链接所在的目录并 <strong>没有</strong> 被添加至模块搜索路径。</p>
</div>
<p>初始化后，Python 程序可以更改 <a class="reference internal" href="../library/sys.xhtml#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>。脚本所在的目录先于标准库所在的路径被搜索。这意味着，脚本所在的目录如果有和标准库同名的文件，那么加载的是该目录里的，而不是标准库的。这一般是一个错误，除非这样的替换是你有意为之。详见 <a class="reference internal" href="#tut-standardmodules"><span class="std std-ref">标准模块</span></a>。</p>
</section>
<section id="compiled-python-files">
<span id="tut-pycache"></span><h3><span class="section-number">6.1.3. </span>“已编译的” Python 文件</h3>
<p>为了快速加载模块，Python 把模块的编译版本缓存在 <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> 目录中，文件名为 <code class="file docutils literal notranslate"><span class="pre">module.</span><em><span class="pre">version</span></em><span class="pre">.pyc</span></code>，version 对编译文件格式进行编码，一般是 Python 的版本号。例如，CPython 的 3.3 发行版中，spam.py 的编译版本缓存为 <code class="docutils literal notranslate"><span class="pre">__pycache__/spam.cpython-33.pyc</span></code>。这种命名惯例让不同 Python 版本编译的模块可以共存。</p>
<p>Python 对比编译版与源码的修改日期，查看编译版是否已过期，是否要重新编译。此进程完全是自动的。此外，编译模块与平台无关，因此，可在不同架构的系统之间共享相同的库。</p>
<p>Python 在两种情况下不检查缓存。一，从命令行直接载入的模块，每次都会重新编译，且不储存编译结果；二，没有源模块，就不会检查缓存。为了让一个库能以隐藏源代码的形式分发（通过将所有源代码变为编译后的版本），编译后的模块必须放在源目录而非缓存目录中，并且源目录绝不能包含同名的未编译的源模块。</p>
<p>给专业人士的一些小建议：</p>
<ul class="simple">
<li><p>在 Python 命令中使用 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 或 <a class="reference internal" href="../using/cmdline.xhtml#cmdoption-OO"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> 开关，可以减小编译模块的大小。<code class="docutils literal notranslate"><span class="pre">-O</span></code> 去除断言语句，<code class="docutils literal notranslate"><span class="pre">-OO</span></code> 去除断言语句和 __doc__ 字符串。有些程序可能依赖于这些内容，因此，没有十足的把握，不要使用这两个选项。“优化过的”模块带有 <code class="docutils literal notranslate"><span class="pre">opt-</span></code> 标签，并且文件通常会一小些。将来的发行版或许会改进优化的效果。</p></li>
<li><p>从 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件读取的程序不比从 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 读取的执行速度快，<code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件只是加载速度更快。</p></li>
<li><p><a class="reference internal" href="../library/compileall.xhtml#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> 模块可以为一个目录下的所有模块创建 .pyc 文件。</p></li>
<li><p>本过程的细节及决策流程图，详见 <span class="target" id="index-16"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a><span class="link-target"> [https://peps.python.org/pep-3147/]</span>。</p></li>
</ul>
</section>
</section>
<section id="standard-modules">
<span id="tut-standardmodules"></span><h2><span class="section-number">6.2. </span>标准模块</h2>
<p id="index-4">Python 自带一个标准模块的库，它在 Python 库参考（此处以下称为&quot;库参考&quot; ）里另外描述。  一些模块是内嵌到编译器里面的， 它们给一些虽并非语言核心但却内嵌的操作提供接口，要么是为了效率，要么是给操作系统基础操作例如系统调入提供接口。 这些模块集是一个配置选项， 并且还依赖于底层的操作系统。 例如，<a class="reference internal" href="../library/winreg.xhtml#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">winreg</span></code></a> 模块只在 Windows 系统上提供。一个特别值得注意的模块 <a class="reference internal" href="../library/sys.xhtml#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>，它被内嵌到每一个 Python 编译器中。<code class="docutils literal notranslate"><span class="pre">sys.ps1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys.ps2</span></code> 变量定义了一些字符，它们可以用作主提示符和辅助提示符:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps1</span>
<span class="go">&#39;&gt;&gt;&gt; &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps2</span>
<span class="go">&#39;... &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps1</span> <span class="o">=</span> <span class="s1">&#39;C&gt; &#39;</span>
<span class="go">C&gt; print(&#39;Yuck!&#39;)</span>
<span class="go">Yuck!</span>
<span class="go">C&gt;</span>
</pre></div>
</div>
<p>只有解释器用于交互模式时，才定义这两个变量。</p>
<p>变量 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 是字符串列表，用于确定解释器的模块搜索路径。该变量以环境变量 <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 提取的默认路径进行初始化，如未设置 <span class="target" id="index-18"></span><a class="reference internal" href="../using/cmdline.xhtml#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>，则使用内置的默认路径。可以用标准列表操作修改该变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/ufs/guido/lib/python&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="the-dir-function">
<span id="tut-dir"></span><h2><span class="section-number">6.3. </span><a class="reference internal" href="../library/functions.xhtml#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 函数</h2>
<p>内置函数 <a class="reference internal" href="../library/functions.xhtml#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 用于查找模块定义的名称。返回结果是经过排序的字符串列表：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span><span class="o">,</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">fibo</span><span class="p">)</span>
<span class="go">[&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>  
<span class="go">[&#39;__breakpointhook__&#39;, &#39;__displayhook__&#39;, &#39;__doc__&#39;, &#39;__excepthook__&#39;,</span>
<span class="go"> &#39;__interactivehook__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;,</span>
<span class="go"> &#39;__stderr__&#39;, &#39;__stdin__&#39;, &#39;__stdout__&#39;, &#39;__unraisablehook__&#39;,</span>
<span class="go"> &#39;_clear_type_cache&#39;, &#39;_current_frames&#39;, &#39;_debugmallocstats&#39;, &#39;_framework&#39;,</span>
<span class="go"> &#39;_getframe&#39;, &#39;_git&#39;, &#39;_home&#39;, &#39;_xoptions&#39;, &#39;abiflags&#39;, &#39;addaudithook&#39;,</span>
<span class="go"> &#39;api_version&#39;, &#39;argv&#39;, &#39;audit&#39;, &#39;base_exec_prefix&#39;, &#39;base_prefix&#39;,</span>
<span class="go"> &#39;breakpointhook&#39;, &#39;builtin_module_names&#39;, &#39;byteorder&#39;, &#39;call_tracing&#39;,</span>
<span class="go"> &#39;callstats&#39;, &#39;copyright&#39;, &#39;displayhook&#39;, &#39;dont_write_bytecode&#39;, &#39;exc_info&#39;,</span>
<span class="go"> &#39;excepthook&#39;, &#39;exec_prefix&#39;, &#39;executable&#39;, &#39;exit&#39;, &#39;flags&#39;, &#39;float_info&#39;,</span>
<span class="go"> &#39;float_repr_style&#39;, &#39;get_asyncgen_hooks&#39;, &#39;get_coroutine_origin_tracking_depth&#39;,</span>
<span class="go"> &#39;getallocatedblocks&#39;, &#39;getdefaultencoding&#39;, &#39;getdlopenflags&#39;,</span>
<span class="go"> &#39;getfilesystemencodeerrors&#39;, &#39;getfilesystemencoding&#39;, &#39;getprofile&#39;,</span>
<span class="go"> &#39;getrecursionlimit&#39;, &#39;getrefcount&#39;, &#39;getsizeof&#39;, &#39;getswitchinterval&#39;,</span>
<span class="go"> &#39;gettrace&#39;, &#39;hash_info&#39;, &#39;hexversion&#39;, &#39;implementation&#39;, &#39;int_info&#39;,</span>
<span class="go"> &#39;intern&#39;, &#39;is_finalizing&#39;, &#39;last_traceback&#39;, &#39;last_type&#39;, &#39;last_value&#39;,</span>
<span class="go"> &#39;maxsize&#39;, &#39;maxunicode&#39;, &#39;meta_path&#39;, &#39;modules&#39;, &#39;path&#39;, &#39;path_hooks&#39;,</span>
<span class="go"> &#39;path_importer_cache&#39;, &#39;platform&#39;, &#39;prefix&#39;, &#39;ps1&#39;, &#39;ps2&#39;, &#39;pycache_prefix&#39;,</span>
<span class="go"> &#39;set_asyncgen_hooks&#39;, &#39;set_coroutine_origin_tracking_depth&#39;, &#39;setdlopenflags&#39;,</span>
<span class="go"> &#39;setprofile&#39;, &#39;setrecursionlimit&#39;, &#39;setswitchinterval&#39;, &#39;settrace&#39;, &#39;stderr&#39;,</span>
<span class="go"> &#39;stdin&#39;, &#39;stdout&#39;, &#39;thread_info&#39;, &#39;unraisablehook&#39;, &#39;version&#39;, &#39;version_info&#39;,</span>
<span class="go"> &#39;warnoptions&#39;]</span>
</pre></div>
</div>
<p>没有参数时，<a class="reference internal" href="../library/functions.xhtml#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 列出当前已定义的名称：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">.</span><span class="n">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;a&#39;, &#39;fib&#39;, &#39;fibo&#39;, &#39;sys&#39;]</span>
</pre></div>
</div>
<p>注意它列出所有类型的名称：变量，模块，函数，……。</p>
<p id="index-7"><a class="reference internal" href="../library/functions.xhtml#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 不会列出内置函数和变量的名称。这些内容的定义在标准模块 <a class="reference internal" href="../library/builtins.xhtml#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 中：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">builtins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">builtins</span><span class="p">)</span>  
<span class="go">[&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;,</span>
<span class="go"> &#39;BlockingIOError&#39;, &#39;BrokenPipeError&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;,</span>
<span class="go"> &#39;ChildProcessError&#39;, &#39;ConnectionAbortedError&#39;, &#39;ConnectionError&#39;,</span>
<span class="go"> &#39;ConnectionRefusedError&#39;, &#39;ConnectionResetError&#39;, &#39;DeprecationWarning&#39;,</span>
<span class="go"> &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;,</span>
<span class="go"> &#39;FileExistsError&#39;, &#39;FileNotFoundError&#39;, &#39;FloatingPointError&#39;,</span>
<span class="go"> &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;,</span>
<span class="go"> &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;InterruptedError&#39;,</span>
<span class="go"> &#39;IsADirectoryError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;,</span>
<span class="go"> &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotADirectoryError&#39;, &#39;NotImplemented&#39;,</span>
<span class="go"> &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;,</span>
<span class="go"> &#39;PendingDeprecationWarning&#39;, &#39;PermissionError&#39;, &#39;ProcessLookupError&#39;,</span>
<span class="go"> &#39;ReferenceError&#39;, &#39;ResourceWarning&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;,</span>
<span class="go"> &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;,</span>
<span class="go"> &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;TimeoutError&#39;, &#39;True&#39;, &#39;TypeError&#39;,</span>
<span class="go"> &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;,</span>
<span class="go"> &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;,</span>
<span class="go"> &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;_&#39;, &#39;__build_class__&#39;,</span>
<span class="go"> &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;,</span>
<span class="go"> &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;,</span>
<span class="go"> &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;,</span>
<span class="go"> &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;exit&#39;,</span>
<span class="go"> &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;,</span>
<span class="go"> &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;,</span>
<span class="go"> &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;,</span>
<span class="go"> &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;,</span>
<span class="go"> &#39;quit&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;,</span>
<span class="go"> &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;,</span>
<span class="go"> &#39;zip&#39;]</span>
</pre></div>
</div>
</section>
<section id="packages">
<span id="tut-packages"></span><h2><span class="section-number">6.4. </span>包</h2>
<p>包是通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式。 例如，模块名 <code class="xref py py-mod docutils literal notranslate"><span class="pre">A.B</span></code> 表示名为 <code class="docutils literal notranslate"><span class="pre">A</span></code> 的包中名为 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的子模块。 就像使用模块可以让不同模块的作者不必担心彼此的全局变量名一样，使用带点号模块名也可以让 NumPy 或 Pillow 等多模块包的作者也不必担心彼此的模块名冲突。</p>
<p>假设要为统一处理声音文件与声音数据设计一个模块集（“包”）。声音文件的格式很多（通常以扩展名来识别，例如：<code class="file docutils literal notranslate"><span class="pre">.wav</span></code>，<code class="file docutils literal notranslate"><span class="pre">.aiff</span></code>，<code class="file docutils literal notranslate"><span class="pre">.au</span></code>），因此，为了不同文件格式之间的转换，需要创建和维护一个不断增长的模块集合。为了实现对声音数据的不同处理（例如，混声、添加回声、均衡器功能、创造人工立体声效果），还要编写无穷无尽的模块流。下面这个分级文件树展示了这个包的架构：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</pre></div>
</div>
<p>导入包时，Python 搜索 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 里的目录，查找包的子目录。</p>
<p>需要有 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件才能让 Python 将包含该文件的目录当作包来处理（除非使用 <a class="reference internal" href="../glossary.xhtml#term-namespace-package"><span class="xref std std-term">namespace package</span></a>，这是一个相对高级的特性）。 这可以防止重名的目录如 <code class="docutils literal notranslate"><span class="pre">string</span></code> 在无意中屏蔽后继出现在模块搜索路径中的有效模块。 在最简单的情况下，<code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 变量，这将在稍后详细描述。</p>
<p>还可以从包中导入单个模块，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sound.effects.echo</span>
</pre></div>
</div>
<p>这将加载子模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.effects.echo</span></code>。 它必须通过其全名来引用。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sound</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">echo</span><span class="o">.</span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>另一种导入子模块的方法是 ：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
</pre></div>
</div>
<p>这也会加载子模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">echo</span></code>，并使其不必加包前缀，因此可按如下方式使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">echo</span><span class="o">.</span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Import 语句的另一种变体是直接导入所需的函数或变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sound.effects.echo</span> <span class="kn">import</span> <span class="n">echofilter</span>
</pre></div>
</div>
<p>同样，这将加载子模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">echo</span></code>，但这使其函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">echofilter()</span></code> 直接可用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>注意，使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">item</span></code> 时，item 可以是包的子模块（或子包），也可以是包中定义的函数、类或变量等其他名称。<code class="docutils literal notranslate"><span class="pre">import</span></code> 语句首先测试包中是否定义了 item；如果未在包中定义，则假定 item 是模块，并尝试加载。如果找不到 item，则触发 <a class="reference internal" href="../library/exceptions.xhtml#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常。</p>
<p>相反，使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">item.subitem.subsubitem</span></code> 句法时，除最后一项外，每个 item 都必须是包；最后一项可以是模块或包，但不能是上一项中定义的类、函数或变量。</p>
<section id="importing-from-a-package">
<span id="tut-pkg-import-star"></span><h3><span class="section-number">6.4.1. </span>从包中导入 *</h3>
<p id="index-8">使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></code> 时会发生什么？你可能希望它会查找并导入包的所有子模块，但事实并非如此。因为这将花费很长的时间，并且可能会产生你不想要的副作用，如果这种副作用被你设计为只有在导入某个特定的子模块时才应该发生。</p>
<p>唯一的解决办法是提供包的显式索引。<a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句使用如下惯例：如果包的 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 代码定义了列表 <code class="docutils literal notranslate"><span class="pre">__all__</span></code>，运行 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">*</span></code> 时，它就是被导入的模块名列表。发布包的新版本时，包的作者应更新此列表。如果包的作者认为没有必要在包中执行导入 * 操作，也可以不提供此列表。例如，<code class="file docutils literal notranslate"><span class="pre">sound/effects/__init__.py</span></code> 文件可以包含以下代码：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;echo&quot;</span><span class="p">,</span> <span class="s2">&quot;surround&quot;</span><span class="p">,</span> <span class="s2">&quot;reverse&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>这意味着 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></code> 将导入 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.effects</span></code> 包的三个命名子模块。</p>
<p>请注意子模块可能会受到本地定义名称的影响。 例如，如果你在 <code class="file docutils literal notranslate"><span class="pre">sound/effects/__init__.py</span></code> 文件中添加了一个 <code class="docutils literal notranslate"><span class="pre">reverse</span></code> 函数，<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></code> 将只导入 <code class="docutils literal notranslate"><span class="pre">echo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">surround</span></code> 这两个子模块，但 <strong>不会</strong> 导入 <code class="docutils literal notranslate"><span class="pre">reverse</span></code> 子模块，因为它被本地定义的 <code class="docutils literal notranslate"><span class="pre">reverse</span></code> 函数所遮挡:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;echo&quot;</span><span class="p">,</span>      <span class="c1"># refers to the &#39;echo.py&#39; file</span>
    <span class="s2">&quot;surround&quot;</span><span class="p">,</span>  <span class="c1"># refers to the &#39;surround.py&#39; file</span>
    <span class="s2">&quot;reverse&quot;</span><span class="p">,</span>   <span class="c1"># !!! refers to the &#39;reverse&#39; function now !!!</span>
<span class="p">]</span>

<span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># &lt;-- this name shadows the &#39;reverse.py&#39; submodule</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c1">#     in the case of a &#39;from sound.effects import *&#39;</span>
</pre></div>
</div>
<p>如果没有定义 <code class="docutils literal notranslate"><span class="pre">__all__</span></code>，<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></code> 语句 <em>不会</em> 把包 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.effects</span></code> 中的所有子模块都导入到当前命名空间；它只是确保包 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.effects</span></code> 已被导入（可能还会运行 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 中的任何初始化代码），然后再导入包中定义的任何名称。 这包括由 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 定义的任何名称（以及显式加载的子模块）。 它还包括先前 <a class="reference internal" href="../reference/simple_stmts.xhtml#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句显式加载的包里的任何子模块。 请看以下代码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sound.effects.echo</span>
<span class="kn">import</span> <span class="nn">sound.effects.surround</span>
<span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>在本例中，<code class="xref py py-mod docutils literal notranslate"><span class="pre">echo</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">surround</span></code> 模块被导入到当前命名空间，因为在执行 <code class="docutils literal notranslate"><span class="pre">from...import</span></code> 语句时它们已在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.effects</span></code> 包中定义了。 （当定义了 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 时也是如此）。</p>
<p>虽然，可以把模块设计为用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code> 时只导出遵循指定模式的名称，但仍不提倡在生产代码中使用这种做法。</p>
<p>记住，使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">specific_submodule</span></code> 没有任何问题！ 实际上，除了导入模块使用不同包的同名子模块之外，这种方式是推荐用法。</p>
</section>
<section id="intra-package-references">
<span id="id2"></span><h3><span class="section-number">6.4.2. </span>相对导入</h3>
<p>当包由多个子包构成（如示例中的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound</span></code> 包）时，可以使用绝对导入来引用同级包的子模块。 例如，如果 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.filters.vocoder</span></code> 模块需要使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sound.effects</span></code> 包中的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">echo</span></code> 模块，它可以使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">echo</span></code>。</p>
<p>你还可以编写相对导入代码，即使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span></code> 形式的 import 语句。 这些导入使用前导点号来表示相对导入所涉及的当前包和上级包。 例如对于 <code class="xref py py-mod docutils literal notranslate"><span class="pre">surround</span></code> 模块，可以使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">echo</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">formats</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="kn">import</span> <span class="n">equalizer</span>
</pre></div>
</div>
<p>注意，相对导入基于当前模块名。因为主模块名永远是 <code class="docutils literal notranslate"><span class="pre">&quot;__main__&quot;</span></code> ，所以如果计划将一个模块用作 Python 应用程序的主模块，那么该模块内的导入语句必须始终使用绝对导入。</p>
</section>
<section id="packages-in-multiple-directories">
<h3><span class="section-number">6.4.3. </span>多目录中的包</h3>
<p>包还支持一个特殊属性 <a class="reference internal" href="../reference/import.xhtml#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 。在包的 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 中的代码被执行前，该属性被初始化为一个只含一项的列表，该项是一个字符串，是 __init__.py 所在目录的名称。可以修改此变量；这样做会改变在此包中搜索模块和子包的方式。</p>
<p>这个功能虽然不常用，但可用于扩展包中的模块集。</p>
<p class="rubric">备注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>实际上函数定义也是被执行的语句；模块级函数定义的执行会将函数名称添加到模块的全局命名空间。</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>